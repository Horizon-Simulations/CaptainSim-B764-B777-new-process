/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Bool"] = "bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["Enum"] = "enum";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["HPA"] = "hectopascals";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["LBS"] = "pounds";
    SimVarValueType["LLA"] = "latlonalt";
    SimVarValueType["Mach"] = "mach";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["MetersPerSecond"] = "meters per second";
    SimVarValueType["MetersPerSecondSquared"] = "meters per second squared";
    SimVarValueType["MillimetersWater"] = "millimeters of water";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["Number"] = "number";
    SimVarValueType["Percent"] = "percent";
    SimVarValueType["PercentOver100"] = "percent over 100";
    SimVarValueType["Pounds"] = "pounds";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["Rankine"] = "rankine";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["SlugsPerCubicFoot"] = "slug per cubic foot";
    SimVarValueType["String"] = "string";
    SimVarValueType["Volts"] = "Volts";
})(SimVarValueType || (SimVarValueType = {}));
const latlonaltRegEx = new RegExp(/latlonalt/i);
const latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
const pbhRegex = new RegExp(/pbh/i);
const pid_structRegex = new RegExp(/pid_struct/i);
const xyzRegex = new RegExp(/xyz/i);
const stringRegex = new RegExp(/string/i);
const boolRegex = new RegExp(/boolean|bool/i);
const numberRegex = new RegExp(/number/i);
const defaultSource = '';
SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
        if (simvar) {
            let output;
            const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (registeredID >= 0) {
                if (numberRegex.test(unit)) {
                    output = simvar.getValueReg(registeredID);
                }
                else if (stringRegex.test(unit)) {
                    output = simvar.getValueReg_String(registeredID);
                }
                else if (latlonaltRegEx.test(unit)) {
                    output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
                }
                else if (pbhRegex.test(unit)) {
                    output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
                }
                else if (pid_structRegex.test(unit)) {
                    output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
                }
                else if (xyzRegex.test(unit)) {
                    output = new XYZ(simvar.getValue_XYZ(name, dataSource));
                }
                else {
                    output = simvar.getValueReg(registeredID);
                }
            }
            return output;
        }
        else {
            console.warn('SimVar handler is not defined (' + name + ')');
        }
    }
    catch (error) {
        console.warn('ERROR ', error, ' GetSimVarValue ' + name + ' unit : ' + unit);
        return null;
    }
    return null;
};
SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == undefined) {
        console.warn(name + ' : Trying to set a null value');
        return Promise.resolve();
    }
    try {
        if (simvar) {
            const regID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (regID >= 0) {
                if (stringRegex.test(unit)) {
                    return Coherent.call('setValueReg_String', regID, value);
                }
                else if (boolRegex.test(unit)) {
                    return Coherent.call('setValueReg_Bool', regID, !!value);
                }
                else if (numberRegex.test(unit)) {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
                else if (latlonaltRegEx.test(unit)) {
                    return Coherent.call('setValue_LatLongAlt', name, value, dataSource);
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    return Coherent.call('setValue_LatLongAltPBH', name, value, dataSource);
                }
                else if (pbhRegex.test(unit)) {
                    return Coherent.call('setValue_PBH', name, value, dataSource);
                }
                else if (pid_structRegex.test(unit)) {
                    return Coherent.call('setValue_PID_STRUCT', name, value, dataSource);
                }
                else if (xyzRegex.test(unit)) {
                    return Coherent.call('setValue_XYZ', name, value, dataSource);
                }
                else {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
            }
        }
        else {
            console.warn('SimVar handler is not defined');
        }
    }
    catch (error) {
        console.warn('error SetSimVarValue ' + error);
    }
    return Promise.resolve();
};

/**
 * A utility class for working with common aeronautical constants and calculations.
 */
class AeroMath {
    // ---- Ideal gas law relationships for air ----
    /**
     * Gets the static pressure of air, in hectopascals, given temperature and density.
     * @param temperature The temperature, in degrees Celsius.
     * @param density The density, in kilograms per cubic meter.
     * @returns The static pressure of air, in hectopascals, with the specified temperature and density.
     */
    static pressureAir(temperature, density) {
        return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    /**
     * Gets the density of air, in kilograms per cubic meter, given static pressure and temperature.
     * @param pressure The static pressure, in hectopascals.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The density of air, in kilograms per cubic meter, with the specified static pressure and temperature.
     */
    static densityAir(pressure, temperature) {
        return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    /**
     * Gets the temperature of air, in degrees Celsius, given static pressure and density.
     * @param pressure The static pressure, in hectopascals.
     * @param density The density, in kilograms per cubic meter.
     * @returns The temperature of air, in degrees Celsius, with the specified static pressure and temperature.
     */
    static temperatureAir(pressure, density) {
        return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    // ---- Other properties of air ----.
    /**
     * Gets the speed of sound in air, in meters per second, for a given temperature.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The speed of sound in air, in meters per second, for the given temperature.
     */
    static soundSpeedAir(temperature) {
        // speed of sound = sqrt(gamma * R * T)
        // gamma = 1.4
        // R = specific gas constant of dry air
        return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    // ---- Pressure ratios ----
    /**
     * Gets the ratio of total pressure to static pressure for a given mach number in a subsonic compressible airflow.
     * @param mach The mach number.
     * @returns The ratio of total pressure to static pressure for the specific mach number.
     */
    static totalPressureRatioAir(mach) {
        return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    // ---- Temperature ratios ----
    /**
     * Gets the ratio of total air temperature to static air temperature for a given mach number.
     * @param mach The mach number.
     * @param recovery The recovery factor. This is a value in the range `[0, 1]` representing the fraction of the
     * kinetic energy of the airflow that is converted to heat. Defaults to 1.
     * @returns The ratio of total air temperature to static air temperature for the specified mach number.
     */
    static totalTemperatureRatioAir(mach, recovery = 1) {
        return 1 + 0.2 * recovery * mach * mach;
    }
    // ---- ISA modeling ----
    /**
     * Gets the ISA temperature, in degrees Celsius, at a given pressure altitude. The supported pressure altitude range
     * is from -610 to 80000 meters above MSL. This method will return the temperature at -610 meters for all altitudes
     * below this range, and the temperature at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA temperature, in degrees Celsius, for the specified pressure altitude.
     */
    static isaTemperature(altitude) {
        // We don't use lookup table for perf reasons.
        if (altitude < 11000) {
            return 15 + Math.max(altitude, -610) * -0.0065;
        }
        else if (altitude < 20000) {
            return -56.5;
        }
        else if (altitude < 32000) {
            return -56.5 + (altitude - 20000) * 0.001;
        }
        else if (altitude < 47000) {
            return -44.5 + (altitude - 32000) * 0.0028;
        }
        else if (altitude < 51000) {
            return -2.5;
        }
        else if (altitude < 71000) {
            return -2.5 + (altitude - 51000) * -0.0028;
        }
        else {
            return -58.5 + (Math.min(altitude, 80000) - 71000) * -0.002;
        }
    }
    /**
     * Gets the ISA pressure, in hectopascals, at a given pressure altitude. The supported pressure altitude range is
     * from -610 to 80000 meters above MSL. This method will return the pressure at -610 meters for all altitudes below
     * this range, and the pressure at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA pressure, in hectopascals, for the specified pressure altitude.
     */
    static isaPressure(altitude) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // P(h) = P(h0) * (1 + dT/dh / T(h0) * (h - h0)) ^ (-g / (R * dT/dh))
        // Temperature constant with altitude:
        // P(h) = P(h0) * e^(-g / (R * T) * (h - h0))
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (altitude < -610) {
            // Modeling stops at -610 meters, so return the pressure for -610 meters for any altitude below this.
            return 1088.707021458965;
        }
        else if (altitude <= 11000) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return 1013.25 * Math.pow(1 - 2.25577e-5 * altitude, 5.25580);
        }
        else if (altitude <= 20000) {
            // Tropopause
            // dT/dh = 0
            return 226.32547681422847 * Math.exp(-1.57686e-4 * (altitude - 11000));
        }
        else if (altitude <= 32000) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 54.7512459834976 * Math.pow(1 + 4.61574e-6 * (altitude - 20000), -34.1627);
        }
        else if (altitude <= 47000) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 8.68079131804552 * Math.pow(1 + 1.22458e-5 * (altitude - 32000), -12.2010);
        }
        else if (altitude <= 51000) {
            // Stratopause
            // dT/dh = 0
            return 1.1091650294132658 * Math.exp(-1.26225e-4 * (altitude - 47000));
        }
        else if (altitude <= 71000) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return 0.6694542213945832 * Math.pow(1 - 1.03455e-5 * (altitude - 51000), 12.2010);
        }
        else if (altitude <= 80000) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return 0.03956893750841349 * Math.pow(1 - 9.31749e-6 * (altitude - 71000), 17.0814);
        }
        else {
            // Modeling stops at 80000 meters, so return the pressure for 80000 meters for any altitude above this.
            return 0.008864013902895545;
        }
    }
    /**
     * Gets the pressure altitude, in meters above MSL, corresponding to a given ISA pressure. The supported pressure
     * altitude range is from -610 to 80000 meters above MSL. This method will return -610 meters for all pressures above
     * the pressure at -610 meters, and 80000 meters for all pressures below the pressure at 80000 meters.
     * @param pressure The ISA pressure for which to get the altitude, in hectopascals.
     * @returns The pressure altitude, in meters above MSL, corresponding to the specified ISA pressure.
     */
    static isaAltitude(pressure) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // h(P) = T(h0) / dT/dh * ((P / P(h0)) ^ (-(R * dT/dh) / g) - 1) + h0
        // Temperature constant with altitude:
        // h(P) = -(R * T) / g * ln(P / P(h0)) + h0
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (pressure > 1088.707021458965) {
            // Modeling stops at -610 meters, so return -610 meters for any pressure above the pressure at this altitude.
            return -610;
        }
        else if (pressure > 226.32547681422847) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return -44330.76067152236 * (Math.pow(pressure / 1013.25, 0.1902659918566155) - 1);
        }
        else if (pressure > 54.7512459834976) {
            // Tropopause
            // dT/dh = 0
            return -6341.717083317479 * Math.log(pressure / 226.32547681422847) + 11000;
        }
        else if (pressure > 8.68079131804552) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 216649.984617851092 * (Math.pow(pressure / 54.7512459834976, -0.02927169105486393) - 1) + 20000;
        }
        else if (pressure > 1.1091650294132658) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 81660.6509987098 * (Math.pow(pressure / 8.68079131804552, -0.08196049504139005) - 1) + 32000;
        }
        else if (pressure > 0.6694542213945832) {
            // Stratopause
            // dT/dh = 0
            return -7922.360863537334 * Math.log(pressure / 1.1091650294132658) + 47000;
        }
        else if (pressure > 0.03956893750841349) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return -96660.38374172345 * (Math.pow(pressure / 0.6694542213945832, 0.08196049504139005) - 1) + 51000;
        }
        else if (pressure > 0.008864013902895545) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return -107325.0414006347 * (Math.pow(pressure / 0.03956893750841349, 0.05854321074385004) - 1) + 71000;
        }
        else {
            // Modeling stops at 80000 meters, so return 80000 meters for any pressure below the pressure at this altitude.
            return 80000;
        }
    }
    /**
     * Gets the ISA density, in kilograms per cubic meter, at a given pressure altitude. The supported pressure altitude
     * range is from -610 to 80000 meters above MSL. This method will return the density at -610 meters for all altitudes
     * below this range, and the density at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The ISA density, in kilograms per cubic meter, for the specified pressure altitude.
     */
    static isaDensity(altitude, deltaIsa = 0) {
        return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the speed of sound, in meters per second, at a given pressure altitude under ISA conditions.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The speed of sound, in meters per second, at the specified pressure altitude under ISA conditions.
     */
    static soundSpeedIsa(altitude, deltaIsa = 0) {
        return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the offset to apply to pressure altitude, in meters, to obtain indicated altitude for a given barometric setting.
     * @param baro The barometic setting for which to get the offset, in hectopascals.
     * @returns The offset to apply to pressure altitude, in meters, to obtain indicated altitude for the specified barometric setting.
     */
    static baroPressureAltitudeOffset(baro) {
        return 44307.694 * (Math.pow(baro / 1013.25, 0.190284) - 1);
    }
    // ---- Speed conversions ----
    // The following section contains methods for converting between different speeds: CAS, TAS, and mach.
    // All conversions are based on the following:
    // Constants:
    // gamma (adiabatic index of air) = 1.4
    // pressure_sea_level_isa = 1013.25 hPa
    // sound_speed_sea_level_isa = 340.2964 m/s
    // Relationship between mach and impact pressure (only valid for subsonic flow):
    // mach = sqrt(5 * ((impact_pressure / static_pressure + 1) ^ ((gamma - 1) / gamma)) - 1)
    // impact_pressure = static_pressure * ((1 + 0.2 * mach ^ 2) ^ (gamma / (gamma - 1)) - 1)
    // Relationship between mach and airspeed:
    // mach = airspeed / sound_speed
    // airspeed = mach * sound_speed
    /**
     * Converts true airspeed (TAS) to mach number.
     * @param tas The true airspeed to convert, in the same units as `soundSpeed`.
     * @param soundSpeed The speed of sound, in the same units as `tas`.
     * @returns The mach number equivalent of the specified true airspeed.
     */
    static tasToMach(tas, soundSpeed) {
        return tas / soundSpeed;
    }
    /**
     * Converts true airspeed (TAS) to mach number under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The mach number equivalent of the specified true airspeed at the specified pressure altitude under ISA
     * conditions.
     */
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
        return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts mach number to true airspeed (TAS).
     * @param mach The mach number to convert.
     * @param soundSpeed The speed of sound.
     * @returns The true airspeed equivalent of the specified mach number, in the same units as `soundSpeed`.
     */
    static machToTas(mach, soundSpeed) {
        return mach * soundSpeed;
    }
    /**
     * Converts mach number to true airspeed (TAS), in meters per second, under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified mach number at the specified
     * pressure altitude under ISA conditions.
     */
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
        return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number. The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified static pressure.
     */
    static casToMach(cas, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate mach from CAS by
        // calculating the impact pressure using sea level ISA conditions, then using that impact pressure to calculate
        // mach using ambient static pressure.
        const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
        const impactPressure = 1013.25 * (Math.pow(1 + (0.2 * mach0 * mach0), 3.5) - 1);
        return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified pressure altitude under
     * ISA conditions.
     */
    static casToMachIsa(cas, altitude) {
        return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number at the specified
     * static pressure.
     */
    static machToCas(mach, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate CAS from mach by
        // calculating the impact pressure using ambient static pressure, then using that impact pressure to calculate
        // CAS using sea level ISA conditions.
        const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number  at the specified
     * pressure altitude under ISA conditions.
     */
    static machToCasIsa(mach, altitude) {
        return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS).
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * ambient pressure and temperature.
     */
    static casToTas(cas, pressure, temperature) {
        return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS) under ISA conditions.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
        return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS).
     * @param tas The true airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * ambient pressure and temperature.
     */
    static tasToCas(tas, pressure, temperature) {
        return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS) under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
        return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    // ---- Lift and drag equations ----
    // force_coefficient = force / (dynamic_pressure * area)
    // dynamic_pressure = 0.5 * density * speed ^ 2
    /**
     * Calculates a fluid flow force coefficient given a force and flow parameters.
     * @param force The flow force, in newtons.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force coefficient given the specified force and flow parameters.
     */
    static flowCoefFromForce(force, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return force / (dynamicPressure * area);
    }
    /**
     * Calculates a fluid flow force given a coefficient and flow parameters.
     * @param coef The flow force coefficient.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force given the specified coefficient and flow parameters.
     */
    static flowForceFromCoef(coef, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return coef * dynamicPressure * area;
    }
}
/** The ideal gas constant, in units of joules per mole per kelvin. */
AeroMath.R = 8.314462618153;
/** The specific gas constant of dry air, in units of joules per kilogram per kelvin. */
AeroMath.R_AIR = 287.057;
/** Approximate value of the adiabatic index of air near room temperature. */
AeroMath.GAMMA_AIR = 1.4;
/** The speed of sound in air at sea level under ISA conditions, in meters per second. */
AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
AeroMath.lift = AeroMath.flowForceFromCoef;
AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
AeroMath.drag = AeroMath.flowForceFromCoef;

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.canConvert(value.unit)) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number' && (!unit || this.unit.canConvert(unit))) {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    abs(out) {
        if (out) {
            return out.set(Math.abs(this.number), this.unit);
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        if (isNaN(converted) && this.isNaN()) {
            return true;
        }
        const diff = this.number - converted;
        return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, out);
        }
        else {
            return this.source.add(arg1, out);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, out);
        }
        else {
            return this.source.subtract(arg1, out);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor, out) {
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs(out) {
        return this.source.abs(out);
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family, numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i++].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i++].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.family = family;
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
/**
 * Predefined unit families.
 */
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["Distance"] = "distance";
    UnitFamily["Angle"] = "angle";
    UnitFamily["Duration"] = "duration";
    UnitFamily["Weight"] = "weight";
    UnitFamily["Mass"] = "weight";
    UnitFamily["Volume"] = "volume";
    UnitFamily["Pressure"] = "pressure";
    UnitFamily["Temperature"] = "temperature";
    UnitFamily["TemperatureDelta"] = "temperature_delta";
    UnitFamily["Speed"] = "speed";
    UnitFamily["Acceleration"] = "acceleration";
    UnitFamily["WeightFlux"] = "weight_flux";
    UnitFamily["MassFlux"] = "weight_flux";
    UnitFamily["VolumeFlux"] = "volume_flux";
    UnitFamily["Density"] = "density";
    UnitFamily["Force"] = "force";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.Distance, 'meter', 1);
UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, 'foot', 0.3048);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, 'kilometer', 1000);
/** Statute mile. */
UnitType.MILE = new SimpleUnit(UnitFamily.Distance, 'mile', 1609.34);
/** Nautical mile. */
UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, 'nautical mile', 1852);
/** Great-arc radian. The average radius of Earth. */
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, 'great arc radian', 6378100);
/** 9.80665 meters, for internal use. */
UnitType.G_METER = new SimpleUnit(UnitFamily.Distance, '9.80665 meter', 9.80665);
UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.Weight, 'pound', 0.453592);
UnitType.SLUG = new SimpleUnit(UnitFamily.Weight, 'slug', 14.59390);
UnitType.TON = new SimpleUnit(UnitFamily.Weight, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, 'tonne', 1000);
/** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, 'liter', 0.80283679);
/** Weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'gallon', 3.0390664);
/** Weight equivalent of one imperial gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'imperial gallon', 3.6497683);
UnitType.LITER = new SimpleUnit(UnitFamily.Volume, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, 'gallon', 3.78541);
/** Hectopascal. */
UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, 'hectopascal', 1);
/** Atmosphere. */
UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, 'atmosphere', 1013.25);
/** Inch of mercury. */
UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, 'inch of mercury', 33.8639);
/** Millimeter of mercury. */
UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, 'millimeter of mercury', 1.33322);
/** Pound per square inch. */
UnitType.PSI = new SimpleUnit(UnitFamily.Pressure, 'pound per square inch', 68.9476);
UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, 'kelvin', 1, 0);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, '° Fahrenheit', 5 / 9, 459.67);
UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, '° Rankine', 5 / 9, 0);
/** Change in degrees Celsius. */
UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Celsius', 1);
/** Change in degrees Fahrenheit. */
UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Fahrenheit', 5 / 9);
UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], 'knot');
/** Kilometer per hour. */
UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
/** Miles per hour. */
UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
/** Meter per minute. */
UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
/** Meter per second. */
UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
/** Foot per minute. */
UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
/** Foot per second. */
UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
/** Meter per minute per second. */
UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
/** Meter per second per second. */
UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Foot per minute per second. */
UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
/** Foot per second per second. */
UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
/** Knot per second. */
UnitType.KNOT_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.NMILE], [UnitType.HOUR, UnitType.SECOND]);
/** Average gravitational acceleration on Earth at sea level. */
UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);
/** Kilogram per hour. */
UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
/** Pound per hour. */
UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
/** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one imperial gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
/** Density in slugs per cubic foot */
UnitType.SLUG_PER_FT3 = new CompoundUnit(UnitFamily.Density, [UnitType.SLUG], [UnitType.FOOT, UnitType.FOOT, UnitType.FOOT]);
/** Density in kilograms per cubic meter */
UnitType.KG_PER_M3 = new CompoundUnit(UnitFamily.Density, [UnitType.KILOGRAM], [UnitType.METER, UnitType.METER, UnitType.METER]);
/** Newton. */
UnitType.NEWTON = new CompoundUnit(UnitFamily.Force, [UnitType.KILOGRAM, UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Pound (force). */
UnitType.POUND_FORCE = new CompoundUnit(UnitFamily.Force, [UnitType.POUND, UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    publish(topic, data, sync = false, isCached = true) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync, isCached);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.resolvedSimVars = new Map();
        this.indexedSimVars = new Map();
        this.subscribed = new Set();
        for (const [topic, entry] of simVarMap) {
            if (entry.indexed) {
                this.indexedSimVars.set(topic, {
                    name: entry.name,
                    type: entry.type,
                    map: entry.map,
                    indexes: entry.indexed === true ? undefined : new Set(entry.indexed),
                    defaultIndex: entry.defaultIndex,
                });
            }
            else {
                this.resolvedSimVars.set(topic, Object.assign({}, entry));
            }
        }
        const handleSubscribedTopic = (topic) => {
            if (this.resolvedSimVars.has(topic)) {
                // If topic matches an already resolved topic -> start publishing.
                this.onTopicSubscribed(topic);
            }
            else {
                // Check if topic matches indexed topic.
                this.tryMatchIndexedSubscribedTopic(topic);
            }
        };
        // Iterate over each subscribed topic on the bus to see if it matches any of our topics. If so, start publishing.
        this.bus.forEachSubscribedTopic(handleSubscribedTopic);
        // Listen to first-time topic subscriptions. If any of them match our topics, start publishing.
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(handleSubscribedTopic);
    }
    /**
     * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
     * publishing the indexed topic.
     * @param topic The subscribed topic to check.
     */
    tryMatchIndexedSubscribedTopic(topic) {
        var _a;
        if (this.indexedSimVars.size === 0) {
            return;
        }
        let entry = this.indexedSimVars.get(topic);
        if (entry) {
            // The subscribed topic matches an unsuffixed topic -> check if the unsuffixed topic should be published and if
            // so, resolve the default index.
            if (entry.defaultIndex !== null) {
                const resolved = this.resolveIndexedSimVar(topic, entry, (_a = entry.defaultIndex) !== null && _a !== void 0 ? _a : 1);
                if (resolved !== undefined) {
                    this.onTopicSubscribed(resolved);
                }
            }
            return;
        }
        if (!SimVarPublisher.INDEXED_REGEX.test(topic)) { // Don't generate an array if we don't have to.
            return;
        }
        const match = topic.match(SimVarPublisher.INDEXED_REGEX);
        const [, matchedTopic, index] = match;
        entry = this.indexedSimVars.get(matchedTopic);
        if (entry) {
            const resolved = this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index));
            if (resolved !== undefined) {
                this.onTopicSubscribed(resolved);
            }
        }
    }
    /**
     * Attempts to resolve an indexed topic with an index, generating a version of the topic which is mapped to an
     * indexed simvar. The resolved indexed topic can then be published.
     * @param topic The topic to resolve.
     * @param entry The entry of the topic to resolve.
     * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
     * a suffix) and will be mapped the index-1 version of its simvar.
     * @returns The resolved indexed topic, or `undefined` if the topic could not be resolved with the specified index.
     */
    resolveIndexedSimVar(topic, entry, index) {
        index !== null && index !== void 0 ? index : (index = 1);
        const resolvedTopic = `${topic}_${index}`;
        if (this.resolvedSimVars.has(resolvedTopic)) {
            return resolvedTopic;
        }
        const defaultIndex = entry.defaultIndex === undefined ? 1 : entry.defaultIndex;
        // Ensure that the index we are trying to resolve is a valid index for the topic.
        if (entry.indexes !== undefined && !entry.indexes.has(index)) {
            return undefined;
        }
        this.resolvedSimVars.set(resolvedTopic, {
            name: entry.name.replace('#index#', `${index !== null && index !== void 0 ? index : 1}`),
            type: entry.type,
            map: entry.map,
            unsuffixedTopic: defaultIndex === index ? topic : undefined
        });
        return resolvedTopic;
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry !== undefined) {
            const value = this.getValueFromEntry(entry);
            this.publish(topic, value);
            // Check if we need to publish the same value to the unsuffixed version of the topic.
            if (entry.unsuffixedTopic) {
                this.publish(entry.unsuffixedTopic, value);
            }
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return this.getValueFromEntry(entry);
    }
    /**
     * Gets the current value for a resolved topic entry.
     * @param entry An entry for a resolved topic.
     * @returns The current value for the specified entry.
     */
    getValueFromEntry(entry) {
        return entry.map === undefined
            ? this.getSimVarValue(entry)
            : entry.map(this.getSimVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getSimVarValue(entry) {
        const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}
SimVarPublisher.INDEXED_REGEX = /(.*)_(0|[1-9]\d*)$/;
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class GameVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
        // Start polling all simvars for which there are existing subscriptions.
        for (const topic of this.simvars.keys()) {
            if (bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((topic) => {
            if (this.simvars.has(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const value = this.getValue(topic);
        if (value !== undefined) {
            this.publish(topic, value);
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.simvars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return entry.map === undefined
            ? this.getGameVarValue(entry)
            : entry.map(this.getGameVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getGameVarValue(entry) {
        const svValue = SimVar.GetGameVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for air data computer information.
 */
class AdcPublisher extends SimVarPublisher {
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['ias', { name: 'AIRSPEED INDICATED:#index#', type: SimVarValueType.Knots, indexed: true }],
            ['tas', { name: 'AIRSPEED TRUE:#index#', type: SimVarValueType.Knots, indexed: true }],
            [
                'mach_to_kias_factor',
                {
                    name: 'AIRSPEED INDICATED:#index#',
                    type: SimVarValueType.Knots,
                    map: (kias) => {
                        const factor = kias < 1 || this.mach === 0 ? AeroMath.machToCas(1, this.pressure) : kias / this.mach;
                        return isFinite(factor) ? factor : 1;
                    },
                    indexed: true
                }
            ],
            ['indicated_alt', { name: 'INDICATED ALTITUDE:#index#', type: SimVarValueType.Feet, indexed: true }],
            ['altimeter_baro_setting_inhg', { name: 'KOHLSMAN SETTING HG:#index#', type: SimVarValueType.InHG, indexed: true }],
            ['altimeter_baro_setting_mb', { name: 'KOHLSMAN SETTING MB:#index#', type: SimVarValueType.MB, indexed: true }],
            ['altimeter_baro_preselect_raw', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, indexed: true }],
            ['altimeter_baro_preselect_inhg', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => UnitType.HPA.convertTo(raw / 16, UnitType.IN_HG), indexed: true }],
            ['altimeter_baro_preselect_mb', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => raw / 16, indexed: true }],
            ['altimeter_baro_is_std', { name: 'L:XMLVAR_Baro#index#_ForcedToSTD', type: SimVarValueType.Bool, indexed: true }],
            ['radio_alt', { name: 'RADIO HEIGHT', type: SimVarValueType.Feet }],
            ['pressure_alt', { name: 'PRESSURE ALTITUDE', type: SimVarValueType.Feet }],
            ['vertical_speed', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
            ['ambient_density', { name: 'AMBIENT DENSITY', type: SimVarValueType.SlugsPerCubicFoot }],
            ['ambient_temp_c', { name: 'AMBIENT TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_pressure_inhg', { name: 'AMBIENT PRESSURE', type: SimVarValueType.InHG }],
            ['isa_temp_c', { name: 'STANDARD ATM TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ram_air_temp_c', { name: 'TOTAL AIR TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
            ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
            ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
            ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }],
            ['stall_aoa', { name: 'STALL ALPHA', type: SimVarValueType.Degree }],
            ['zero_lift_aoa', { name: 'ZERO LIFT ALPHA', type: SimVarValueType.Degree }],
            ['mach_number', { name: 'AIRSPEED MACH', type: SimVarValueType.Mach }],
        ]);
        super(simvars, bus, pacer);
        this.mach = 0;
        this.pressure = 1013.25;
        (_a = this.needUpdateMachToKiasData) !== null && _a !== void 0 ? _a : (this.needUpdateMachToKiasData = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('mach_to_kias_factor')) {
            this.needUpdateMachToKiasData = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        const isSlewing = SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
        if (!isSlewing) {
            if (this.needUpdateMachToKiasData) {
                this.mach = SimVar.GetSimVarValue('AIRSPEED MACH', SimVarValueType.Number);
                this.pressure = SimVar.GetSimVarValue('AMBIENT PRESSURE', SimVarValueType.HPA);
            }
            super.onUpdate();
        }
    }
}

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags, valuesToSet, mask) {
        return (flags & ~mask) | (valuesToSet & mask);
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values.
 *
 * When a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time
 * elapsed since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The
 * calculation of the weighting is such that the weight of each raw value in the sequence decays exponentially with the
 * "age" (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to
 * the sequence) of the value.
 */
class ExpSmoother {
    /**
     * Creates a new instance of ExpSmoother.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.dtThreshold = dtThreshold;
        this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or null if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        let next;
        if (this.tau > 0 && this.lastValue !== null) {
            const factor = this.calculateFactor(dt);
            next = ExpSmoother.smooth(raw, this.lastValue, factor);
        }
        else {
            next = raw;
        }
        this.lastValue = next;
        return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
        if (dt > this.dtThreshold) {
            return 0;
        }
        else {
            return Math.exp(-dt / this.tau);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        return this.lastValue = (value !== null && value !== void 0 ? value : null);
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

/**
 * A calculator for lookahead values based on past trends. The calculator accepts a series of input values separated
 * by discrete time intervals, computes a rate of change at each time step, and uses this rate of change to predict
 * what the input value will be at some arbitrary length of time in the future assuming the rate of change remains
 * constant.
 */
class Lookahead {
    /**
     * Constructor.
     * @param lookahead This calculator's lookahead time.
     * @param valueSmoothingTau The smoothing time constant to apply to the calculator's input values before rate of
     * change is computed. A value of `0` is equivalent to no smoothing. Defaults to `0`.
     * @param trendSmoothingTau The smoothing time constant to apply to the calculator's computed trend values. A value
     * of `0` is equivalent to no smoothing. Defaults to `0`.
     */
    constructor(lookahead, valueSmoothingTau = 0, trendSmoothingTau = 0) {
        this.lookahead = lookahead;
        this.lastSmoothedValue = null;
        this.lastTrendValue = 0;
        this.lastLookaheadValue = null;
        this.lastSmoothedLookaheadValue = null;
        this.valueSmoother = new ExpSmoother(valueSmoothingTau);
        this.trendSmoother = new ExpSmoother(trendSmoothingTau);
    }
    /**
     * Gets this calculator's last computed lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param smoothed Whether to retrieve the lookahead value computed using the last smoothed input value instead of
     * the raw input value as the present (`t = 0`) value. Defaults to `false`.
     * @returns This calculator's last computed lookahead value.
     */
    last(smoothed = false) {
        return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Gets this calculator's last computed trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @returns This calculator's last computed trend value.
     */
    lastTrend() {
        return this.lastTrendValue;
    }
    /**
     * Adds a new input value and gets the next lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @param smoothed Whether to return the lookahead value computed using the smoothed input value instead of the raw
     * input value as the present (`t = 0`) value. Note that this argument does not determine whether smoothing is
     * applied for the purposes of calculating rate of change (smoothing is always applied for this purpose if a positive
     * time constant is defined). Defaults to `false`.
     * @returns The next lookahead value.
     */
    next(value, dt, smoothed = false) {
        const oldSmoothedValue = this.lastSmoothedValue;
        let trend;
        if (dt < 0) {
            return this.reset(value);
        }
        else if (dt > 0) {
            this.lastSmoothedValue = this.valueSmoother.next(value, dt);
            if (oldSmoothedValue === null) {
                this.trendSmoother.reset();
                trend = 0;
            }
            else {
                trend = this.trendSmoother.next((this.lastSmoothedValue - oldSmoothedValue) / dt * this.lookahead, dt);
            }
        }
        else {
            trend = this.lastTrendValue;
            this.lastSmoothedValue = this.valueSmoother.next(value, dt);
        }
        this.lastTrendValue = trend;
        this.lastLookaheadValue = value + trend;
        this.lastSmoothedLookaheadValue = this.lastSmoothedValue + trend;
        return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Adds a new input value and gets the next trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @returns The next trend value.
     */
    nextTrend(value, dt) {
        this.next(value, dt);
        return this.lastTrendValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        this.lastSmoothedValue = this.valueSmoother.reset(value);
        this.trendSmoother.reset();
        this.lastTrendValue = 0;
        this.lastLookaheadValue = this.lastSmoothedValue;
        this.lastSmoothedLookaheadValue = this.lastSmoothedValue;
        return this.lastLookaheadValue;
    }
}

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value, precision = 1) {
        return Math.round(value / precision) * precision;
    }
    /**
     * Ceils a number.
     * @param value The number to ceil.
     * @param precision The precision with which to ceil. Defaults to `1`.
     * @returns The ceiled number.
     */
    static ceil(value, precision = 1) {
        return Math.ceil(value / precision) * precision;
    }
    /**
     * Floors a number.
     * @param value The number to floor.
     * @param precision The precision with which to floor. Defaults to `1`.
     * @returns The floored number.
     */
    static floor(value, precision = 1) {
        return Math.floor(value / precision) * precision;
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start, end, directional = true) {
        const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
        return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 360)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in degrees.
     * @param end The ending angle, in degrees.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in degrees, in the range `[0, 360)`.
     */
    static diffAngleDeg(start, end, directional = true) {
        const diff = ((end - start) % 360 + 360) % 360;
        return directional ? diff : Math.min(diff, 360 - diff);
    }
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        if (x0 !== x1 && y0 !== y1) {
            const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
            return fraction * (y1 - y0) + y0;
        }
        else {
            return y0;
        }
    }
    /**
     * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
     * lengths, then only the components shared by all vectors are interpolated in the result.
     * @param out The object to which to write the result.
     * @param x The key of the vector to interpolate.
     * @param x0 The key of the first known vector.
     * @param x1 The key of the second known vector.
     * @param y0 The first known vector.
     * @param y1 The second known vector.
     * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
     * Defaults to false.
     * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
     * Defaults to false.
     * @returns The interpolated vector corresponding to the specified key.
     */
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        const length = Math.min(y0.length, y1.length, out.length);
        for (let i = 0; i < length; i++) {
            out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
        }
        return out;
    }
}
/** Twice the value of pi. */
MathUtils.TWO_PI = Math.PI * 2;
/** Half the value of pi. */
MathUtils.HALF_PI = Math.PI / 2;
/** Square root of 3. */
MathUtils.SQRT3 = Math.sqrt(3);
/** Square root of 1/3. */
MathUtils.SQRT1_3 = 1 / Math.sqrt(3);

/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
class HandlerSubscription {
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler, initialNotifyFunc, onDestroy) {
        this.handler = handler;
        this.initialNotifyFunc = initialNotifyFunc;
        this.onDestroy = onDestroy;
        this._isAlive = true;
        this._isPaused = false;
        this.canInitialNotify = initialNotifyFunc !== undefined;
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify() {
        if (!this._isAlive) {
            throw new Error('HandlerSubscription: cannot notify a dead Subscription.');
        }
        this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot pause a dead Subscription.');
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot resume a dead Subscription.');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        if (initialNotify) {
            this.initialNotify();
        }
        return this;
    }
    /** @inheritdoc */
    destroy() {
        if (!this._isAlive) {
            return;
        }
        this._isAlive = false;
        this.onDestroy && this.onDestroy(this);
    }
}

/**
 * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
 * to change the state of the output subscribable.
 */
class SubscribablePipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let onDestroy;
        if (typeof arg4 === 'function') {
            handler = (fromVal) => {
                to.set(arg3(fromVal, to.get()));
            };
            onDestroy = arg4;
        }
        else {
            handler = (fromVal) => {
                to.set(fromVal);
            };
            onDestroy = arg3;
        }
        super(handler, (sub) => { sub.handler(from.get()); }, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribable {
    constructor() {
        this.isSubscribable = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this subscribable.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.notifySubscription(this.singletonSub);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribable: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        this.notifySubscription(sub);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribable: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
/**
 * An implementation of {@link MappedSubscribable}.
 */
class MappedSubscribableClass extends AbstractSubscribable {
    /**
     * Constructor.
     * @param input This subscribable's input.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     */
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
        super();
        this.input = input;
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.input.get()));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.input.get());
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSub = this.input.sub(inputValue => {
            this.updateValue(inputValue);
        }, true);
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     * @param inputValue The input value.
     */
    updateValue(inputValue) {
        const value = this.mapFunc(inputValue, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot pause a dead subscribable');
        }
        if (this._isPaused) {
            return this;
        }
        this.inputSub.pause();
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot resume a dead subscribable');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        this.inputSub.resume(true);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        this.inputSub.destroy();
    }
}

/**
 * A subscribable subject whose value can be freely manipulated.
 */
class Subject extends AbstractSubscribable {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        super();
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.isMutableSubscribable = true;
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /** @inheritdoc */
    notifySub(sub) {
        sub(this.value);
    }
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value) {
        let changed = false;
        for (const prop in value) {
            changed = value[prop] !== this.value[prop];
            if (changed) {
                break;
            }
        }
        Object.assign(this.value, value);
        changed && this.notify();
    }
    /** @inheritdoc */
    notify() {
        super.notify();
    }
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get() {
        return this.value;
    }
}

/**
 * Utility methods for working with Subscribables.
 */
class SubscribableUtils {
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isSubscribable === true;
    }
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isMutableSubscribable === true;
    }
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable(value, excludeSubscribables) {
        if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
            return value;
        }
        else {
            return Subject.create(value);
        }
    }
}
/**
 * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
 * `NaN`.
 * @param a The first number to compare.
 * @param b The second number to compare.
 * @returns Whether the two numbers are strictly equal or both `NaN`.
 */
SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || (isNaN(a) && isNaN(b));

/**
 * Utility class for generating common functions for mapping subscribables.
 */
class SubscribableMapFunctions {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity() {
        return (input) => input;
    }
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not() {
        return (input) => !input;
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise.
     */
    static or() {
        return (input) => input.length > 0 && input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if no tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if no tuple member is `true` or there are no
     * tuple members, and to `false` otherwise.
     */
    static nor() {
        return (input) => !input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static and() {
        return (input) => input.length > 0 && !input.includes(false);
    }
    /**
     * Generates a function which maps an input boolean tuple to `false` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static nand() {
        return (input) => input.length < 1 || input.includes(false);
    }
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate() {
        return (input) => -input;
    }
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs() {
        return Math.abs;
    }
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision(precision) {
        return SubscribableUtils.isSubscribable(precision)
            ? (input) => {
                const precisionVal = precision.get();
                return Math.round(input / precisionVal) * precisionVal;
            }
            : (input) => {
                return Math.round(input / precision) * precision;
            };
    }
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy(threshold) {
        return SubscribableUtils.isSubscribable(threshold)
            ? (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal
            : (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise.
     * @param freq The maximum frequency at which to map the input to itself, in hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    static atFrequency(freq, timeFunc = Date.now) {
        let t0;
        let timeRemaining = 0;
        if (SubscribableUtils.isSubscribable(freq)) {
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    const period = 1000 / freq.get();
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
        else {
            const period = 1000 / freq;
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
    }
}

/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
class MappedSubject extends AbstractSubscribable {
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
        super();
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        this.inputs = inputs;
        this.inputValues = inputs.map(input => input.get());
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.inputValues, undefined));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.inputValues, undefined);
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSubs = this.inputs.map((input, index) => input.sub(inputValue => {
            this.inputValues[index] = inputValue;
            this.updateValue();
        }));
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(...args) {
        let mapFunc, equalityFunc, mutateFunc, initialVal;
        if (typeof args[0] === 'function') {
            // Mapping function was supplied.
            mapFunc = args.shift();
            if (typeof args[0] === 'function') {
                equalityFunc = args.shift();
            }
            else {
                equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
            }
            if (typeof args[0] === 'function') {
                mutateFunc = args.shift();
                initialVal = args.shift();
            }
        }
        else {
            mapFunc = MappedSubject.IDENTITY_MAP;
            equalityFunc = MappedSubject.NEVER_EQUALS;
        }
        return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     */
    updateValue() {
        const value = this.mapFunc(this.inputValues, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot pause a dead subject');
        }
        if (this._isPaused) {
            return this;
        }
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].pause();
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot resume a dead subject');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputValues[i] = this.inputs[i].get();
            this.inputSubs[i].resume();
        }
        this.updateValue();
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].destroy();
        }
    }
}
MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
MappedSubject.NEVER_EQUALS = () => false;

/**
 * A Subject which provides a {@link NumberUnitInterface} value.
 */
class NumberUnitSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Returns a number {@link Subscribable} of this `NumberUnit` converted according to a unit or unit `Subscribable`
     *
     * @param unit the unit to subscribe to
     *
     * @returns a `MappedSubscribable<number>`
     */
    asUnit(unit) {
        return MappedSubject.create(([numberUnit, toUnit]) => numberUnit.asUnit(toUnit), this, SubscribableUtils.toSubscribable(unit, true));
    }
}

/**
 * 2D vector mathematical operations.
 */
class Vec2Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y) {
        const vec = new Float64Array(2);
        if (x !== undefined && y !== undefined) {
            vec[0] = x;
            vec[1] = y;
        }
        return vec;
    }
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Gets the determinant of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The determinant of the vectors.
     */
    static det(v1, v2) {
        return v1[0] * v2[1] - v1[1] * v2[0];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
    /**
     * Checks if a point is within a polygon.
     * @param polygon The polygon to check against.
     * @param point The point to test.
     * @returns True if the point is within or on the polygon, false otherwise.
     * @throws An error if first and last points in a polygon are not the same.
     */
    static pointWithinPolygon(polygon, point) {
        //Adapted from https://github.com/rowanwins/point-in-polygon-hao
        let k = 0;
        let f = 0;
        let u1 = 0;
        let v1 = 0;
        let u2 = 0;
        let v2 = 0;
        let currentP = null;
        let nextP = null;
        const x = point[0];
        const y = point[1];
        const contourLen = polygon.length - 1;
        currentP = polygon[0];
        if (currentP[0] !== polygon[contourLen][0] &&
            currentP[1] !== polygon[contourLen][1]) {
            throw new Error('First and last coordinates in a ring must be the same');
        }
        u1 = currentP[0] - x;
        v1 = currentP[1] - y;
        for (let i = 0; i < polygon.length - 1; i++) {
            nextP = polygon[i + 1];
            v2 = nextP[1] - y;
            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {
                currentP = nextP;
                v1 = v2;
                u1 = currentP[0] - x;
                continue;
            }
            u2 = nextP[0] - point[0];
            if (v2 > 0 && v1 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f > 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 > 0 && v2 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f < 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v2 === 0 && v1 < 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 < 0) {
                f = u1 * v2 - u2 * v1;
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 === 0) {
                if (u2 <= 0 && u1 >= 0) {
                    return undefined;
                }
                else if (u1 <= 0 && u2 >= 0) {
                    return undefined;
                }
            }
            currentP = nextP;
            v1 = v2;
            u1 = u2;
        }
        if (k % 2 === 0) {
            return false;
        }
        return true;
    }
}
/**
 * 3D vector mathematical operations.
 */
class Vec3Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y, z) {
        const vec = new Float64Array(3);
        if (x !== undefined && y !== undefined && z !== undefined) {
            vec[0] = x;
            vec[1] = y;
            vec[2] = z;
        }
        return vec;
    }
    /**
     * Gets the spherical angle theta (polar angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi (azimuthal angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x The new x-component.
     * @param y The new y-component.
     * @param z The new z-component.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r The new length (magnitude).
     * @param theta The new spherical angle theta (polar angle), in radians.
     * @param phi The new spherical angle phi (azimuthal angle), in radians.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = r * sinTheta * Math.cos(phi);
        vec[1] = r * sinTheta * Math.sin(phi);
        vec[2] = r * Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]) && isFinite(vec[2]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}
/**
 * N-dimensional vector mathematical operations.
 */
class VecNMath {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(length, ...components) {
        const vec = new Float64Array(length);
        for (let i = 0; i < length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec, ...components) {
        for (let i = 0; i < vec.length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec) {
        return Math.hypot(...vec);
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1, v2) {
        if (v1.length !== v2.length) {
            throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
        }
        let dot = 0;
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            dot += v1[i] * v2[i];
        }
        return dot;
    }
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            out[i] = v1[i] / mag;
        }
        return out;
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        if (vec1.length !== vec2.length) {
            return false;
        }
        for (let i = 0; i < vec1.length; i++) {
            if (vec1[i] !== vec2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        for (let i = 0; i < vec.length; i++) {
            if (!isFinite(vec[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from, to) {
        if (from.length !== to.length) {
            throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
        }
        to.set(from);
        return to;
    }
}

/**
 * A 2D affine transformation. By default, Transform2D objects are initially created as identity transformations.
 */
class Transform2D {
    constructor() {
        this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    /**
     * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
        let scaleX = arg1;
        if (arg1 instanceof Transform2D) {
            [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewX;
        array[2] = translateX;
        array[3] = skewY;
        array[4] = scaleY;
        array[5] = translateY;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[4] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y) {
        this.array[0] = x;
        this.array[4] = y;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param value The new x skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(value) {
        this.array[1] = value;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param value The new y skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[2] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y) {
        this.array[2] = x;
        this.array[5] = y;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_10 = array[3];
        const e_11 = array[4];
        const e_12 = array[5];
        const i_00 = e_11;
        const i_01 = -e_10;
        const i_10 = -e_01;
        const i_11 = e_00;
        const i_20 = e_01 * e_12 - e_02 * e_11;
        const i_21 = -(e_00 * e_12 - e_02 * e_10);
        const det = e_00 * i_00 + e_01 * i_01;
        return this.set(i_00 / det, i_10 / det, i_20 / det, i_01 / det, i_11 / det, i_21 / det);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform2D().set(this);
    }
    /**
     * Applies this transformation to a 2D vector.
     * @param vec A 2D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
        const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
        return Vec2Math.set(x, y, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y) {
        Transform2D.offsetOriginCache[0].toTranslation(-x, -y);
        Transform2D.offsetOriginCache[1] = this;
        Transform2D.offsetOriginCache[2].toTranslation(x, y);
        return Transform2D.concat(this, Transform2D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y) {
        return this.set(1, 0, x, 0, 1, y);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, originX, originY) {
        this.set(x, 0, 0, 0, y, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, originX, originY) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toReflection(theta, originX, originY) {
        const sin = Math.sin(2 * theta);
        const cos = Math.cos(2 * theta);
        this.set(cos, sin, 0, sin, -cos, 0);
        if (originX !== undefined && originY !== undefined) {
            this.offsetOrigin(originX, originY);
        }
        return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, order = 'after') {
        if (order === 'before') {
            Transform2D.addCache[0].toTranslation(x, y);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            Transform2D.addCache[1].toTranslation(x, y);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, arg3, arg4, arg5) {
        let originX, originY, order;
        if (typeof arg3 === 'number') {
            originX = arg3;
            originY = arg4;
            order = arg5;
        }
        else {
            order = arg3;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toScale(x, y) : Transform2D.addCache[0].toScale(x, y, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toScale(x, y) : Transform2D.addCache[1].toScale(x, y, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, arg2, arg3, arg4) {
        let originX, originY, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            order = arg4;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toRotation(theta) : Transform2D.addCache[0].toRotation(theta, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toRotation(theta) : Transform2D.addCache[1].toRotation(theta, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addReflection(theta, arg2, arg3, arg4) {
        let originX, originY, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            order = arg4;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform2D.addCache[0].toReflection(theta) : Transform2D.addCache[0].toReflection(theta, originX, originY);
            Transform2D.addCache[1].set(this);
        }
        else {
            Transform2D.addCache[0].set(this);
            originX === undefined ? Transform2D.addCache[1].toReflection(theta) : Transform2D.addCache[1].toReflection(theta, originX, originY);
        }
        return Transform2D.concat(this, Transform2D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform2D.concatCache[0];
        const newTransform = Transform2D.concatCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 2; j++) {
                    newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform2D.offsetOriginCache = [new Transform2D(), undefined, new Transform2D()];
Transform2D.addCache = [new Transform2D(), new Transform2D()];
Transform2D.concatCache = [new Transform2D(), new Transform2D()];

/**
 * A 3D affine transformation. By default, Transform3D objects are initially created as identity transformations.
 */
class Transform3D {
    constructor() {
        this.array = new Float64Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0
        ]);
    }
    /**
     * Gets the parameters of this transformation as a 12-tuple:
     * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
        return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
        let scaleX = arg1;
        if (arg1 instanceof Transform3D) {
            [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
        }
        const array = this.array;
        array[0] = scaleX;
        array[1] = skewXY;
        array[2] = skewXZ;
        array[3] = translateX;
        array[4] = skewYX;
        array[5] = scaleY;
        array[6] = skewYZ;
        array[7] = translateY;
        array[8] = skewZX;
        array[9] = skewZY;
        array[10] = scaleZ;
        array[11] = translateZ;
        return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
        this.array[0] = value;
        return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
        this.array[5] = value;
        return this;
    }
    /**
     * Sets the z scaling factor of this transformation.
     * @param value The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleZ(value) {
        this.array[10] = value;
        return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @param z The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y, z) {
        this.array[0] = x;
        this.array[5] = y;
        this.array[10] = z;
        return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param y The new x skew factor along the y axis.
     * @param z The new x skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(y, z) {
        this.array[1] = y;
        this.array[2] = z;
        return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param x The new y skew factor along the x axis.
     * @param z The new y skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(x, z) {
        this.array[4] = x;
        this.array[6] = z;
        return this;
    }
    /**
     * Sets the z skew factor of this transformation.
     * @param x The new z skew factor along the x axis.
     * @param y The new z skew factor along the y axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewZ(x, y) {
        this.array[8] = x;
        this.array[9] = y;
        return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
        this.array[3] = value;
        return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
        this.array[7] = value;
        return this;
    }
    /**
     * Sets the z translation of this transformation.
     * @param value The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateZ(value) {
        this.array[11] = value;
        return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @param z The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y, z) {
        this.array[3] = x;
        this.array[7] = y;
        this.array[11] = z;
        return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     * @throws Error if this transformation cannot be inverted.
     */
    invert() {
        const array = this.array;
        const e_00 = array[0];
        const e_01 = array[1];
        const e_02 = array[2];
        const e_03 = array[3];
        const e_10 = array[4];
        const e_11 = array[5];
        const e_12 = array[6];
        const e_13 = array[7];
        const e_20 = array[8];
        const e_21 = array[9];
        const e_22 = array[10];
        const e_23 = array[11];
        const c_00 = e_11 * e_22 - e_12 * e_21;
        const c_01 = e_12 * e_20 - e_10 * e_22;
        const c_02 = e_10 * e_21 - e_11 * e_20;
        const c_10 = e_02 * e_21 - e_01 * e_22;
        const c_11 = e_00 * e_22 - e_02 * e_20;
        const c_12 = e_01 * e_20 - e_00 * e_21;
        const c_20 = e_01 * e_12 - e_02 * e_11;
        const c_21 = e_02 * e_10 - e_00 * e_12;
        const c_22 = e_00 * e_11 - e_01 * e_10;
        const det = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
        if (det === 0) {
            throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
        }
        const i_00 = c_00 / det;
        const i_01 = c_10 / det;
        const i_02 = c_20 / det;
        const i_10 = c_01 / det;
        const i_11 = c_11 / det;
        const i_12 = c_21 / det;
        const i_20 = c_02 / det;
        const i_21 = c_12 / det;
        const i_22 = c_22 / det;
        const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
        const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
        const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
        return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new Transform3D().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const array = this.array;
        const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
        const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
        const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
        return Vec3Math.set(x, y, z, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @param z The z-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y, z) {
        Transform3D.offsetOriginCache[0].toTranslation(-x, -y, -z);
        Transform3D.offsetOriginCache[1] = this;
        Transform3D.offsetOriginCache[2].toTranslation(x, y, z);
        return Transform3D.concat(this, Transform3D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y, z) {
        return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, z, originX, originY, originZ) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationX(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationY(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationZ(theta, originX, originY, originZ) {
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        this.set(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
        const abs = Math.hypot(axisX, axisY, axisZ);
        const ux = axisX / abs;
        const uy = axisY / abs;
        const uz = axisZ / abs;
        const ux_uy = ux * uy;
        const ux_uz = ux * uz;
        const uy_uz = uy * uz;
        const sin = Math.sin(theta);
        const cos = Math.cos(theta);
        const cosCompl = 1 - cos;
        this.set(cos + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin, ux_uz * cosCompl * uy * sin, 0, ux_uy * cosCompl + uz * sin, cos + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin, 0, ux_uz * cosCompl - uy * sin, uy_uz * cosCompl + ux * sin, cos + uz * uz * cosCompl, 0);
        if (originX !== undefined && originY !== undefined && originZ !== undefined) {
            this.offsetOrigin(originX, originY, originZ);
        }
        return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, z, order = 'after') {
        if (order === 'before') {
            Transform3D.addCache[0].toTranslation(x, y, z);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            Transform3D.addCache[1].toTranslation(x, y, z);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, z, arg4, arg5, arg6, arg7) {
        let originX, originY, originZ, order;
        if (typeof arg4 === 'number') {
            originX = arg4;
            originY = arg5;
            originZ = arg6;
            order = arg7;
        }
        else {
            order = arg4;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toScale(x, y, z) : Transform3D.addCache[0].toScale(x, y, z, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toScale(x, y, z) : Transform3D.addCache[1].toScale(x, y, z, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationX(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationX(theta) : Transform3D.addCache[0].toRotationX(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationX(theta) : Transform3D.addCache[1].toRotationX(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationY(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationY(theta) : Transform3D.addCache[0].toRotationY(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationY(theta) : Transform3D.addCache[1].toRotationY(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationZ(theta, arg2, arg3, arg4, arg5) {
        let originX, originY, originZ, order;
        if (typeof arg2 === 'number') {
            originX = arg2;
            originY = arg3;
            originZ = arg4;
            order = arg5;
        }
        else {
            order = arg2;
        }
        if (order === 'before') {
            originX === undefined ? Transform3D.addCache[0].toRotationZ(theta) : Transform3D.addCache[0].toRotationZ(theta, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined ? Transform3D.addCache[1].toRotationZ(theta) : Transform3D.addCache[1].toRotationZ(theta, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, axisX, axisY, axisZ, arg5, arg6, arg7, arg8) {
        let originX, originY, originZ, order;
        if (typeof arg5 === 'number') {
            originX = arg5;
            originY = arg6;
            originZ = arg7;
            order = arg8;
        }
        else {
            order = arg5;
        }
        if (order === 'before') {
            originX === undefined
                ? Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ)
                : Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
            Transform3D.addCache[1].set(this);
        }
        else {
            Transform3D.addCache[0].set(this);
            originX === undefined
                ? Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ)
                : Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
        }
        return Transform3D.concat(this, Transform3D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
        if (transforms.length === 0) {
            return out.toIdentity();
        }
        if (transforms.length === 1) {
            return out.set(transforms[0]);
        }
        let index = 0;
        let next = transforms[index];
        const oldTransform = Transform3D.concatCache[0];
        const newTransform = Transform3D.concatCache[1].set(next);
        const oldArray = oldTransform.array;
        const newArray = newTransform.array;
        const end = transforms.length;
        while (++index < end) {
            next = transforms[index];
            const nextArray = next.array;
            oldTransform.set(newTransform);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 3; j++) {
                    newArray[j * 4 + i] =
                        oldArray[i] * nextArray[j * 4]
                            + oldArray[4 + i] * nextArray[j * 4 + 1]
                            + oldArray[8 + i] * nextArray[j * 4 + 2]
                            + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
                }
            }
        }
        return out.set(newTransform);
    }
}
Transform3D.offsetOriginCache = [new Transform3D(), undefined, new Transform3D()];
Transform3D.addCache = [new Transform3D(), new Transform3D()];
Transform3D.concatCache = [new Transform3D(), new Transform3D()];

/**
 * A perspective transformation.
 */
class TransformPerspective {
    constructor() {
        this.cameraPos = Vec3Math.create();
        this.surfacePos = Vec3Math.create(0, 0, 1);
        this.cameraPosTransform = new Transform3D();
        this.cameraRotationTransform = new Transform3D();
        this.cameraRotationInverseTransform = new Transform3D();
        this.allCameraTransforms = [this.cameraPosTransform, this.cameraRotationInverseTransform];
        this.fullTransform = new Transform3D();
    }
    /**
     * Gets the position of this transformation's camera, as `[x, y, z]` in world coordinates.
     * @returns The position of this transformation's camera, as `[x, y, z]` in world coordinates.
     */
    getCameraPosition() {
        return this.cameraPos;
    }
    /**
     * Gets the transformation representing the rotation of this transformation's camera.
     * @returns The transformation representing the rotation of this transformation's camera.
     */
    getCameraRotation() {
        return this.cameraRotationTransform;
    }
    /**
     * Gets the position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns The position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     */
    getSurfacePosition() {
        return this.cameraPos;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
        if (arg1 instanceof Float64Array) {
            this._setCameraPosition(arg1);
            this._setCameraRotation(arg2);
            this.setSurfacePosition(arg3);
            Transform3D.concat(this.fullTransform, this.allCameraTransforms);
            return this;
        }
        else {
            return this.set(arg1.getCameraPosition(), arg1.getCameraRotation(), arg1.getSurfacePosition());
        }
    }
    /**
     * Sets the position of this projection's camera. Does not update the full camera transformation.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     */
    _setCameraPosition(cameraPos) {
        Vec3Math.copy(cameraPos, this.cameraPos);
        this.cameraPosTransform.toTranslation(-cameraPos[0], -cameraPos[1], -cameraPos[2]);
    }
    /**
     * Sets the rotation of this projection's camera. Does not update the full camera transformation.
     * @param cameraRotation A transformation representing the rotation of the camera.
     */
    _setCameraRotation(cameraRotation) {
        this.cameraRotationTransform.set(cameraRotation);
        this.cameraRotationInverseTransform.set(cameraRotation).invert();
    }
    /**
     * Sets the position of this projection's camera.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     * @returns This transformation, after it has been changed.
     */
    setCameraPosition(cameraPos) {
        this._setCameraPosition(cameraPos);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
    }
    /**
     * Sets the rotation of this projection's camera.
     * @param cameraRotation A transformation representing the rotation of the camera.
     * @returns This transformation, after it has been changed.
     */
    setCameraRotation(cameraRotation) {
        this._setCameraRotation(cameraRotation);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
    }
    /**
     * Sets the position of this transformation's projection surface relative to the camera.
     * @param surfacePos The position of the projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns This transformation, after it has been changed.
     */
    setSurfacePosition(surfacePos) {
        Vec3Math.copy(surfacePos, this.surfacePos);
        return this;
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
        return new TransformPerspective().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector, in world coordinates.
     * @param out The 2D vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
        const transformedVec = this.fullTransform.apply(vec, TransformPerspective.vec3Cache[0]);
        if (Vec3Math.abs(transformedVec) < 1e-7) {
            return Vec2Math.set(0, 0, out);
        }
        if (transformedVec[2] < 0) {
            // vector is behind the camera.
            return Vec2Math.set(NaN, NaN, out);
        }
        const ratio = this.surfacePos[2] / transformedVec[2];
        return Vec2Math.set(transformedVec[0] * ratio + this.surfacePos[0], transformedVec[1] * ratio + this.surfacePos[1], out);
    }
}
TransformPerspective.vec3Cache = [Vec3Math.create()];

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0]) && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1]);
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a 3D vector to be observed.
 */
class Vec3Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
        let x, y, z;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
            z = arg3;
        }
        else {
            x = arg1[0];
            y = arg1[1];
            z = arg1[2];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(z, this.value[2]);
        if (!equals) {
            Vec3Math.set(x, y, z, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
class VecNSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static create(initialVal) {
        return new VecNSubject(initialVal);
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     * @deprecated Use `VecNSubject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new VecNSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, ...args) {
        let array;
        if (typeof arg1 === 'number') {
            array = args;
            args.unshift(arg1);
        }
        else {
            array = arg1;
        }
        if (array.length > this.value.length) {
            throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
        }
        let equals = true;
        const len = array.length;
        for (let i = 0; i < len; i++) {
            if (!SubscribableUtils.NUMERIC_NAN_EQUALITY(array[i], this.value[i])) {
                equals = false;
                break;
            }
        }
        if (!equals) {
            this.value.set(array);
            this.notify();
        }
    }
}

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint ot which to write the result.
     * @returns The antipode of this point.
     * @throws Error if argument `out` is undefined.
     */
    antipode(out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.antipode(out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /** @inheritdoc */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The antipode of this point.
     */
    antipode(out) {
        return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    /** @inheritdoc */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        if (other) {
            if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
                return true;
            }
            const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
            const distance = this.distance(other);
            return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /** @inheritdoc */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static equals(arg1, arg2, arg3, arg4, arg5) {
        if (arg1 instanceof Float64Array) {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else if (typeof arg1 === 'number') {
            return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distance(arg1, arg2, arg3, arg4) {
        if (arg1 instanceof Float64Array) {
            return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
        }
        else {
            let lat1, lon1, lat2, lon2;
            if (typeof arg1 === 'number') {
                lat1 = arg1;
                lon1 = arg2;
                lat2 = arg3;
                lon2 = arg4;
            }
            else {
                lat1 = arg1.lat;
                lon1 = arg1.lon;
                lat2 = arg2.lat;
                lon2 = arg2.lon;
            }
            lat1 *= Avionics.Utils.DEG2RAD;
            lon1 *= Avionics.Utils.DEG2RAD;
            lat2 *= Avionics.Utils.DEG2RAD;
            lon2 *= Avionics.Utils.DEG2RAD;
            // haversine formula
            const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
            const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
            const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distanceRhumb(arg1, arg2, arg3, arg4) {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === 'number') {
            lat1 = arg1 * Avionics.Utils.DEG2RAD;
            lon1 = arg2 * Avionics.Utils.DEG2RAD;
            lat2 = arg3 * Avionics.Utils.DEG2RAD;
            lon2 = arg4 * Avionics.Utils.DEG2RAD;
        }
        else if (arg1 instanceof Float64Array) {
            const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
            lat1 = point1.lat;
            lon1 = point1.lon;
            const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
            lat2 = point2.lat;
            lon2 = point2.lon;
        }
        else {
            lat1 = arg1.lat;
            lon1 = arg1.lon;
            lat2 = arg2.lat;
            lon2 = arg2.lon;
        }
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1, lon1, lat2, lon2) {
        return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this._sinRadius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return this._sinRadius * angle;
    }
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length) {
        return length / this._sinRadius;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        this._sinRadius = Math.sin(this._radius);
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse() {
        Vec3Math.multScalar(this._center, -1, this._center);
        this._radius = Math.PI - this._radius;
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
        return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Inverts a heading value by adding 180 and normalizing.
     * @param heading The heading to invert/reciprocate.
     * @returns The inverted/reciprocated heading.
     * */
    static reciprocateHeading(heading) {
        return NavMath.normalizeHeading(heading + 180);
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius, in meters.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param radius The airplane turn radius, in meters.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="@microsoft/msfs-types/coherent/facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/**
 * A Subject which provides a {@link GeoPointInterface} value.
 */
class GeoPointSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     */
    constructor(value, tolerance) {
        super();
        this.value = value;
        this.tolerance = tolerance;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     * @returns A GeoPointSubject.
     */
    static create(initialVal, tolerance) {
        return new GeoPointSubject(initialVal, tolerance);
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
}

/**
 * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
 * to define the type of projection to be implemented.
 */
class AbstractGeoProjection {
    constructor() {
        this.center = new GeoPoint(0, 0);
        this.centerTranslation = new Float64Array(2);
        this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE); // 1 pixel = 1 nautical mile
        this.preRotation = new Float64Array(3);
        this.translation = new Float64Array(2);
        this.postRotation = 0;
        this.rotationSin = 0;
        this.rotationCos = 1;
        this.reflectY = 1;
        this.preRotationForwardTransform = new Transform3D();
        this.preRotationReverseTransform = new Transform3D();
        this.rotationCache = [new Transform3D(), new Transform3D()];
    }
    /** @inheritdoc */
    getCenter() {
        return this.center.readonly;
    }
    /** @inheritdoc */
    getScaleFactor() {
        return this.scaleFactor;
    }
    /** @inheritdoc */
    getPreRotation() {
        return this.preRotation;
    }
    /** @inheritdoc */
    getTranslation() {
        return this.translation;
    }
    /** @inheritdoc */
    getPostRotation() {
        return this.postRotation;
    }
    /** @inheritdoc */
    getReflectY() {
        return this.reflectY === -1;
    }
    /** @inheritdoc */
    setCenter(point) {
        this.center.set(point);
        this.updateCenterTranslation();
        return this;
    }
    /** @inheritdoc */
    setScaleFactor(factor) {
        this.scaleFactor = factor;
        return this;
    }
    /** @inheritdoc */
    setPreRotation(vec) {
        this.preRotation.set(vec);
        this.updatePreRotationTransforms();
        this.updateCenterTranslation();
        return this;
    }
    /** @inheritdoc */
    setTranslation(vec) {
        this.translation.set(vec);
        return this;
    }
    /** @inheritdoc */
    setPostRotation(rotation) {
        this.postRotation = rotation;
        this.rotationCos = Math.cos(rotation);
        this.rotationSin = Math.sin(rotation);
        return this;
    }
    /** @inheritdoc */
    setReflectY(val) {
        this.reflectY = val ? -1 : 1;
        return this;
    }
    /** @inheritdoc */
    copyParametersFrom(other) {
        return this.setCenter(other.getCenter())
            .setPreRotation(other.getPreRotation())
            .setScaleFactor(other.getScaleFactor())
            .setTranslation(other.getTranslation())
            .setPostRotation(other.getPostRotation())
            .setReflectY(other.getReflectY());
    }
    /**
     * Updates the pre-rotation transformation matrices.
     */
    updatePreRotationTransforms() {
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        this.rotationCache[0].toRotationX(gamma);
        this.rotationCache[1].toRotationY(-phi);
        Transform3D.concat(this.preRotationForwardTransform, this.rotationCache);
        this.preRotationReverseTransform.set(this.preRotationForwardTransform);
        this.preRotationReverseTransform.invert();
    }
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    updateCenterTranslation() {
        const centerArray = AbstractGeoProjection.vec2Cache[0];
        centerArray[0] = this.center.lon;
        centerArray[1] = this.center.lat;
        this.preRotateForward(centerArray, centerArray);
        this.projectRaw(centerArray, this.centerTranslation);
    }
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateForward(vec, out) {
        const lambda = this.preRotation[0];
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        if (lambda === 0 && phi === 0 && gamma === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        if (phi === 0 && gamma === 0) {
            return Vec2Math.set(rotatedLon, lat, out);
        }
        const cartesianVec = GeoPoint.sphericalToCartesian(lat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
        const rotatedCartesianVec = this.preRotationForwardTransform.apply(cartesianVec, cartesianVec);
        const rotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);
        return Vec2Math.set(rotated.lon, rotated.lat, out);
    }
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateReverse(vec, out) {
        const lambda = this.preRotation[0];
        const phi = this.preRotation[1];
        const gamma = this.preRotation[2];
        if (lambda === 0 && phi === 0 && gamma === 0) {
            out.set(vec);
            return out;
        }
        const lat = vec[1];
        const lon = vec[0];
        let rotatedLat = lat;
        let rotatedLon = lon;
        if (phi !== 0 || gamma !== 0) {
            const rotatedCartesianVec = GeoPoint.sphericalToCartesian(rotatedLat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
            const cartesianVec = this.preRotationReverseTransform.apply(rotatedCartesianVec, rotatedCartesianVec);
            const unrotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);
            rotatedLat = unrotated.lat;
            rotatedLon = unrotated.lon;
        }
        rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180; // enforce [-180, 180)
        return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    /** @inheritdoc */
    project(point, out) {
        if (point instanceof Float64Array) {
            out.set(point);
        }
        else {
            out[0] = point.lon;
            out[1] = point.lat;
        }
        this.preRotateForward(out, out);
        this.projectRaw(out, out);
        // translate projected center point to origin
        out[0] -= this.centerTranslation[0];
        out[1] -= this.centerTranslation[1];
        // apply y-reflection
        out[1] *= this.reflectY;
        // apply scale factor
        out[0] *= this.scaleFactor;
        out[1] *= this.scaleFactor;
        // apply post-projection rotation
        const x = out[0];
        const y = out[1];
        out[0] = x * this.rotationCos - y * this.rotationSin;
        out[1] = x * this.rotationSin + y * this.rotationCos;
        // apply post-projection translation
        out[0] += this.translation[0];
        out[1] += this.translation[1];
        return out;
    }
    /** @inheritdoc */
    invert(vec, out) {
        const projected = AbstractGeoProjection.vec2Cache[0];
        projected.set(vec);
        // invert post-projection translation
        projected[0] -= this.translation[0];
        projected[1] -= this.translation[1];
        // invert post-projection rotation
        const x = projected[0];
        const y = projected[1];
        projected[0] = x * this.rotationCos + y * this.rotationSin;
        projected[1] = -x * this.rotationSin + y * this.rotationCos;
        // invert scale factor
        projected[0] /= this.scaleFactor;
        projected[1] /= this.scaleFactor;
        // invert y-reflection
        projected[1] *= this.reflectY;
        // translate projected center point to default projected position
        projected[0] += this.centerTranslation[0];
        projected[1] += this.centerTranslation[1];
        const inverted = this.invertRaw(projected, projected);
        this.preRotateReverse(inverted, inverted);
        if (out instanceof Float64Array) {
            out.set(inverted);
            return out;
        }
        else {
            return out.set(inverted[1], inverted[0]);
        }
    }
}
AbstractGeoProjection.vec2Cache = [new Float64Array(2)];
AbstractGeoProjection.vec3Cache = [new Float64Array(3)];
AbstractGeoProjection.geoPointCache = [new GeoPoint(0, 0)];
/**
 * A Mercator projection.
 */
class MercatorProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    projectRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.DEG2RAD;
        out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
        return out;
    }
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    invertRaw(vec, out) {
        out[0] = vec[0] * Avionics.Utils.RAD2DEG;
        out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
        return out;
    }
}

/**
 * Resamples projected great- and small-circle paths between defined endpoints into series of straight line segments and circular arcs.
 */
class GeoCircleResampler {
    /**
     * Constructor.
     * @param minDistance The minimum great-circle distance this resampler enforces between two adjacent resampled
     * points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance, in pixels, this resampler uses when deciding whether to discard
     * a resampled point during the simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by `2^[maxDepth] - 1`.
     */
    constructor(minDistance, dpTolerance, maxDepth) {
        this.minDistance = minDistance;
        this.dpTolerance = dpTolerance;
        this.maxDepth = maxDepth;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.startVector = {
            type: 'start',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            index: 0
        };
        this.lineVector = {
            type: 'line',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            index: 0
        };
        this.arcVector = {
            type: 'arc',
            point: new GeoPoint(0, 0),
            projected: new Float64Array(2),
            projectedArcCenter: new Float64Array(2),
            projectedArcRadius: 0,
            projectedArcStartAngle: 0,
            projectedArcEndAngle: 0,
            index: 0
        };
        this.state = {
            index: 0,
            prevX: 0,
            prevY: 0,
            vectorType: 'line',
            arcCenterX: 0,
            arcCenterY: 0,
            arcRadius: 0,
            isArcCounterClockwise: false
        };
        this.cosMinDistance = Math.cos(minDistance);
        this.dpTolSq = dpTolerance * dpTolerance;
    }
    /**
     * Resamples a projected great- or small-circle path.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     */
    resample(projection, circle, start, end, handler) {
        let startPoint, startVec, endPoint, endVec;
        if (start instanceof Float64Array) {
            startPoint = this.geoPointCache[0].setFromCartesian(start);
            startVec = start;
        }
        else {
            startPoint = start;
            startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
        }
        if (end instanceof Float64Array) {
            endPoint = this.geoPointCache[0].setFromCartesian(end);
            endVec = end;
        }
        else {
            endPoint = end;
            endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
        }
        const startLat = startPoint.lat;
        const startLon = startPoint.lon;
        const endLat = endPoint.lat;
        const endLon = endPoint.lon;
        const startProjected = projection.project(start, this.vec2Cache[0]);
        const endProjected = projection.project(end, this.vec2Cache[1]);
        const startX = startProjected[0];
        const startY = startProjected[1];
        const endX = endProjected[0];
        const endY = endProjected[1];
        this.startVector.point.set(startLat, startLon);
        Vec2Math.copy(startProjected, this.startVector.projected);
        handler(this.startVector);
        this.state.index = 1;
        this.state.prevX = startX;
        this.state.prevY = startY;
        this.state.vectorType = 'line';
        const state = this.resampleHelper(projection, circle, startLat, startLon, startVec[0], startVec[1], startVec[2], startX, startY, endLat, endLon, endVec[0], endVec[1], endVec[2], endX, endY, handler, 0, this.state);
        this.callHandler(handler, endLat, endLon, endX, endY, state);
    }
    /**
     * Resamples a projected great- or small-circle path. This method will recursively split the path into two halves
     * and resample the midpoint. Based on the projected position of the midpoint relative to those of the start and end
     * points, the projected path is modeled as either a straight line from the start to the end or a circular arc
     * connecting the start, end, and midpoints. Recursion continues as long as the maximum depth has not been reached
     * and at least one of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * If the path is modeled as a line: the distance from the projected midpoint to the model line is greater than
     * this resampler's Douglas-Peucker tolerance.
     * * If the path is modeled as an arc: the distance from the projected one-quarter or the three-quarter point along
     * the path to the model arc is greater than this resampler's Douglas-Peucker tolerance.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param lat1 The latitude of the start of the path, in degrees.
     * @param lon1 The longitude of the start of the path, in degrees.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path, in pixels.
     * @param projY1 The y-component of the projected location of the start of the path, in pixels.
     * @param lat2 The latitude of the end of the path, in degrees.
     * @param lon2 The longitude of the end of the path, in degrees.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path, in pixels.
     * @param projY2 The y-component of the projected location of the end of the path, in pixels.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param state The current state of the resampling algorithm.
     * @returns The index of the next resampled point.
     */
    resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, state) {
        if (depth >= this.maxDepth) {
            return state;
        }
        const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
        const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
        const angularWidth = circle.angleAlong(startVec, endVec, Math.PI);
        if (angularWidth <= GeoCircle.ANGULAR_TOLERANCE) {
            return state;
        }
        const midVec = circle.offsetAngleAlong(startVec, angularWidth / 2, this.vec3Cache[2]);
        const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
        const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
        const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
        const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
        const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
        const midProjected = projection.project(midPoint, this.vec2Cache[2]);
        const lat0 = midPoint.lat;
        const lon0 = midPoint.lon;
        const x0 = midVec[0];
        const y0 = midVec[1];
        const z0 = midVec[2];
        const projX0 = midProjected[0];
        const projY0 = midProjected[1];
        const A = projX2 - projX1;
        const B = projY2 - projY1;
        const C = projX1 * projX1 - projX2 * projX2 + projY1 * projY1 - projY2 * projY2;
        const D = projX0 - projX1;
        const E = projY0 - projY1;
        const F = projX1 * projX1 - projX0 * projX0 + projY1 * projY1 - projY0 * projY0;
        // Calculate the Douglas-Peucker metric
        const det = 2 * (A * E - B * D);
        const dpDisSq = (det * det / 4) / deltaProjectedDot;
        if (dpDisSq > this.dpTolSq) {
            // Attempt to model the projected path with an arc
            // Find the center of circle containing the arc passing through the projected start, end, and mid points.
            const arcCenterX = (B * F - C * E) / det;
            const arcCenterY = (C * D - A * F) / det;
            const arcRadius = Math.hypot(arcCenterX - projX1, arcCenterY - projY1);
            const startToEndVec = Vec3Math.set(A, B, 0, this.vec3Cache[3]);
            const centerToMidVec = Vec3Math.set(projX0 - arcCenterX, projY0 - arcCenterY, 0, this.vec3Cache[4]);
            const cross = Vec3Math.cross(startToEndVec, centerToMidVec, this.vec3Cache[4]);
            state.vectorType = 'arc';
            state.arcCenterX = arcCenterX;
            state.arcCenterY = arcCenterY;
            state.arcRadius = arcRadius;
            state.isArcCounterClockwise = cross[2] > 0;
        }
        else {
            state.vectorType = 'line';
        }
        const cosDistance = Vec3Math.dot(startVec, midVec);
        if (cosDistance > this.cosMinDistance) { // cosine of distance increases with decreasing distance
            // We are below the minimum distance required to continue resampling -> decide if we need to continue or if
            // the path can satisfactorily be modeled as either a straight line or a circular arc.
            if (state.vectorType === 'line') {
                // The path can be modeled as a line.
                return state;
            }
            // To find whether the path can be modeled as an arc, we need to project the one-quarter and three-quarter points
            // along the path and find the projected points' distances from the arc modeled above. If the distances are
            // within the D-P tolerance, then the path can be modeled as an arc.
            const query = circle.offsetAngleAlong(startVec, angularWidth / 4, this.geoPointCache[0]);
            const projectedQuery = projection.project(query, this.vec2Cache[0]);
            let distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
            if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
                circle.offsetAngleAlong(startVec, 3 * angularWidth / 4, query);
                projection.project(query, projectedQuery);
                distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
                if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
                    return state;
                }
            }
        }
        state = this.resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, state);
        this.callHandler(handler, lat0, lon0, projX0, projY0, state);
        state.index++;
        state.prevX = projX0;
        state.prevY = projY0;
        return this.resampleHelper(projection, circle, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, state);
    }
    /**
     * Calls a handler function for a resampled point.
     * @param handler The handler function to call.
     * @param lat The latitude of the resampled point, in degrees.
     * @param lon The longitude of the resampled point, in degrees.
     * @param projX The x-coordinate of the projected resampled point, in pixels.
     * @param projY The y-coordinate of the projected resampled point, in pixels.
     * @param state The current state of the resampling algorithm.
     */
    callHandler(handler, lat, lon, projX, projY, state) {
        let vector;
        if (state.vectorType === 'line') {
            vector = this.lineVector;
        }
        else {
            vector = this.arcVector;
            Vec2Math.set(state.arcCenterX, state.arcCenterY, vector.projectedArcCenter);
            vector.projectedArcRadius = state.arcRadius;
            vector.projectedArcStartAngle = Math.atan2(state.prevY - state.arcCenterY, state.prevX - state.arcCenterX);
            vector.projectedArcEndAngle = Math.atan2(projY - state.arcCenterY, projX - state.arcCenterX);
            if (vector.projectedArcEndAngle < vector.projectedArcStartAngle !== state.isArcCounterClockwise) {
                vector.projectedArcEndAngle += state.isArcCounterClockwise ? -MathUtils.TWO_PI : MathUtils.TWO_PI;
            }
        }
        vector.point.set(lat, lon);
        Vec2Math.set(projX, projY, vector.projected);
        vector.index = state.index;
        handler(vector);
    }
}

/**
 * A publisher for AHRS information.
 */
class AhrsPublisher extends SimVarPublisher {
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['pitch_deg', { name: 'ATTITUDE INDICATOR PITCH DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['roll_deg', { name: 'ATTITUDE INDICATOR BANK DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg_true', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, map: (heading) => MagVar.magneticToTrue(heading, this.magVar), indexed: true }],
            ['delta_heading_rate', { name: 'DELTA HEADING RATE:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
            ['actual_hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
            ['actual_hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
            ['actual_pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
            ['actual_roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
        ]);
        super(simvars, bus, pacer);
        this.magVar = 0;
        (_a = this.needUpdateMagVar) !== null && _a !== void 0 ? _a : (this.needUpdateMagVar = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('hdg_deg_true')) {
            this.needUpdateMagVar = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needUpdateMagVar) {
            this.magVar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        }
        super.onUpdate();
    }
}

/**
 * A publisher for events related to the sim's AI piloting feature.
 */
class AiPilotPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of AiPilotPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(new Map([
            ['ai_delegate_controls_active', { name: 'DELEGATE CONTROLS TO AI', type: SimVarValueType.Bool }],
            ['ai_auto_rudder_active', { name: 'AUTO COORDINATION', type: SimVarValueType.Bool }]
        ]), bus);
    }
}

/**
 * Ambient precipitation states.
 */
var AmbientPrecipState;
(function (AmbientPrecipState) {
    AmbientPrecipState[AmbientPrecipState["None"] = 2] = "None";
    AmbientPrecipState[AmbientPrecipState["Rain"] = 4] = "Rain";
    AmbientPrecipState[AmbientPrecipState["Snow"] = 8] = "Snow";
})(AmbientPrecipState || (AmbientPrecipState = {}));
/**
 * A publisher for ambient environment information.
 */
class AmbientPublisher extends SimVarPublisher {
    /**
     * Creates an AmbientPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['ambient_precip_state', { name: 'AMBIENT PRECIP STATE', type: SimVarValueType.Number }],
            ['ambient_precip_rate', { name: 'AMBIENT PRECIP RATE', type: SimVarValueType.MillimetersWater }],
            ['ambient_visibility', { name: 'AMBIENT VISIBILITY', type: SimVarValueType.Meters }],
            ['ambient_in_cloud', { name: 'AMBIENT IN CLOUD', type: SimVarValueType.Bool }],
            ['ambient_qnh_inhg', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.InHG }],
            ['ambient_qnh_mb', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.MB }],
        ]);
        super(simvars, bus, pacer);
    }
}

/**
 * A basic implementation of {@link Consumer}.
 */
class BasicConsumer {
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe, state = {}, currentHandler) {
        this.subscribe = subscribe;
        this.state = state;
        this.currentHandler = currentHandler;
        /** @inheritdoc */
        this.isConsumer = true;
        this.activeSubs = new Map();
    }
    /** @inheritdoc */
    handle(handler, paused = false) {
        let activeHandler;
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            activeHandler = (data) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.currentHandler(data, this.state, handler);
            };
        }
        else {
            activeHandler = handler;
        }
        let activeSubArray = this.activeSubs.get(handler);
        if (!activeSubArray) {
            activeSubArray = [];
            this.activeSubs.set(handler, activeSubArray);
        }
        const onDestroyed = (destroyed) => {
            const activeSubsArray = this.activeSubs.get(handler);
            if (activeSubsArray) {
                activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
                if (activeSubsArray.length === 0) {
                    this.activeSubs.delete(handler);
                }
            }
        };
        const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
        // Need to handle the case where the subscription is destroyed immediately
        if (sub.isAlive) {
            activeSubArray.push(sub);
        }
        else if (activeSubArray.length === 0) {
            this.activeSubs.delete(handler);
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        var _a;
        const activeSubArray = this.activeSubs.get(handler);
        if (activeSubArray) {
            (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
            if (activeSubArray.length === 0) {
                this.activeSubs.delete(handler);
            }
        }
    }
    /** @inheritdoc */
    atFrequency(frequency, immediateFirstPublish = true) {
        const initialState = {
            previousTime: Date.now(),
            firstRun: immediateFirstPublish
        };
        return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    getAtFrequencyHandler(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime || state.firstRun) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                if (state.firstRun) {
                    state.firstRun = false;
                }
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    withPrecision(precision) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    getWithPrecisionHandler(precision) {
        return (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
                state.hasLastValue = true;
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        };
    }
    /** @inheritdoc */
    whenChangedBy(amount) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    getWhenChangedByHandler(amount) {
        return (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (!state.hasLastValue || diff >= amount) {
                state.hasLastValue = true;
                state.lastValue = dataValue;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    whenChanged() {
        return new BasicConsumer(this.subscribe, { lastValue: '', hasLastValue: false }, this.getWhenChangedHandler());
    }
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    getWhenChangedHandler() {
        return (data, state, next) => {
            if (!state.hasLastValue || state.lastValue !== data) {
                state.hasLastValue = true;
                state.lastValue = data;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    onlyAfter(deltaTime) {
        return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    getOnlyAfterHandler(deltaTime) {
        return (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        };
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}
/**
 * A {@link Subscription} for a {@link BasicConsumer}.
 */
class ConsumerSubscription {
    /**
     * Constructor.
     * @param sub The event bus subscription backing this subscription.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(sub, onDestroy) {
        this.sub = sub;
        this.onDestroy = onDestroy;
    }
    /** @inheritdoc */
    get isAlive() {
        return this.sub.isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this.sub.isPaused;
    }
    /** @inheritdoc */
    get canInitialNotify() {
        return this.sub.canInitialNotify;
    }
    /** @inheritdoc */
    pause() {
        this.sub.pause();
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        this.sub.resume(initialNotify);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this.sub.destroy();
        this.onDestroy(this);
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new BasicConsumer((handler, paused) => {
            return this.bus.on(topic, handler, paused);
        });
    }
}

var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_yd_status', { name: 'AUTOPILOT YAW DAMPER', type: SimVarValueType.Bool }],
    ['ap_disengage_status', { name: 'AUTOPILOT DISENGAGED', type: SimVarValueType.Bool }],
    ['ap_heading_hold', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_hold', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_max_bank_id', { name: 'AUTOPILOT MAX BANK ID', type: SimVarValueType.Number }],
    ['ap_max_bank_value', { name: 'AUTOPILOT MAX BANK', type: SimVarValueType.Degree }],
    ['ap_wing_lvl_hold', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_hold', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['ap_toga_hold', { name: 'AUTOPILOT TAKEOFF POWER ACTIVE', type: SimVarValueType.Bool }],
    ['ap_heading_selected', { name: 'AUTOPILOT HEADING LOCK DIR:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_altitude_selected', { name: 'AUTOPILOT ALTITUDE LOCK VAR:#index#', type: SimVarValueType.Feet, indexed: true }],
    ['ap_pitch_selected', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }],
    ['ap_vs_selected', { name: 'AUTOPILOT VERTICAL HOLD VAR:#index#', type: SimVarValueType.FPM, indexed: true }],
    ['ap_fpa_selected', { name: 'L:WT_AP_FPA_Target:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_ias_selected', { name: 'AUTOPILOT AIRSPEED HOLD VAR:#index#', type: SimVarValueType.Knots, indexed: true }],
    ['ap_mach_selected', { name: 'AUTOPILOT MACH HOLD VAR:#index#', type: SimVarValueType.Number, indexed: true }],
    ['ap_selected_speed_is_mach', { name: 'AUTOPILOT MANAGED SPEED IN MACH', type: SimVarValueType.Bool }],
    ['ap_selected_speed_is_manual', { name: 'L:XMLVAR_SpeedIsManuallySet', type: SimVarValueType.Bool }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_is_active_1', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:1', type: SimVarValueType.Bool }],
    ['flight_director_is_active_2', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:2', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }]
]);
/**
 * Publishes autopilot data
 */
class AutopilotPublisher extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
        this.publish('ap_master_on', true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
        this.publish('ap_master_off', true);
    }
    /**
     * Publish a YD engage event
     */
    publishYdEngage() {
        this.publish('ap_yd_on', true);
    }
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage() {
        this.publish('ap_yd_off', true);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
        this.publish('ap_lock_set', lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
        this.publish('ap_lock_release', lock);
    }
}
/**
 * Manages an autopilot system
 */
class AutopilotInstrument {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
        this.bus = bus;
        // this.hEvents = this.bus.getSubscriber<HEvent>();
        this.publisher = new AutopilotPublisher(bus);
        this.simVarPublisher = new APSimVarPublisher(bus);
        this.simVarSubscriber = new EventSubscriber(bus);
    }
    /**
     * Initialize the instrument
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        // console.log('initting autopilot');
        this.simVarSubscriber.on('ap_master_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishMasterEngage();
            }
            else {
                this.publisher.publishMasterDisengage();
            }
        });
        this.simVarSubscriber.on('ap_yd_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishYdEngage();
            }
            else {
                this.publisher.publishYdDisengage();
            }
        });
        this.simVarSubscriber.on('ap_alt_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Alt);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Alt);
            }
        });
        this.simVarSubscriber.on('ap_pitch_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Pitch);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Pitch);
            }
        });
        this.simVarSubscriber.on('ap_heading_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Heading);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Heading);
            }
        });
        this.simVarSubscriber.on('ap_nav_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Nav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Nav);
            }
        });
        this.simVarSubscriber.on('ap_approach_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Approach);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Approach);
            }
        });
        this.simVarSubscriber.on('ap_backcourse_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Backcourse);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Backcourse);
            }
        });
        this.simVarSubscriber.on('ap_bank_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Bank);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Bank);
            }
        });
        this.simVarSubscriber.on('ap_wing_lvl_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.WingLevel);
            }
            else {
                this.publisher.publishLockRelease(APLockType.WingLevel);
            }
        });
        this.simVarSubscriber.on('ap_flc_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Flc);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Flc);
            }
        });
        this.simVarSubscriber.on('ap_vs_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Vs);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Vs);
            }
        });
        this.simVarSubscriber.on('ap_glideslope_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Glideslope);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Glideslope);
            }
        });
        this.simVarSubscriber.on('vnav_active').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.VNav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.VNav);
            }
        });
    }
    /** update our publishers */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/**
 * Utility functions for working with arrays.
 */
class ArrayUtils {
    /**
     * Creates a new array with initialized values.
     * @param length The length of the new array.
     * @param init A function which generates initial values for the new array at each index.
     * @returns A new array of the specified length with initialized values.
     */
    static create(length, init) {
        const newArray = [];
        for (let i = 0; i < length; i++) {
            newArray[i] = init(i);
        }
        return newArray;
    }
    /**
     * Gets the element at a specific index in an array.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array.
     * @throws RangeError if the index is out of bounds.
     */
    static at(array, index) {
        if (index < 0) {
            index += array.length;
        }
        if (index < 0 || index >= array.length) {
            throw new RangeError();
        }
        return array[index];
    }
    /**
     * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
     */
    static peekAt(array, index) {
        if (index < 0) {
            index += array.length;
        }
        return array[index];
    }
    /**
     * Gets the first element of an array.
     * @param array An array.
     * @returns The first element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static first(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[0];
    }
    /**
     * Gets the first element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The first element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekFirst(array) {
        return array[0];
    }
    /**
     * Gets the last element of an array.
     * @param array An array.
     * @returns The last element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static last(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[array.length - 1];
    }
    /**
     * Gets the last element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The last element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekLast(array) {
        return array[array.length - 1];
    }
    /**
     * Checks if a certain element is included in an array.
     * @param array An array.
     * @param searchElement The element to search for.
     * @param fromIndex The position in this array at which to begin searching for `searchElement`.
     * @returns Whether the search element is included in the specified array.
     */
    static includes(array, searchElement, fromIndex) {
        return array.includes(searchElement, fromIndex);
    }
    /**
     * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
     * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
     * @param a The first array.
     * @param b The second array.
     * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
     * to a function which uses the strict equality operator (`===`).
     * @returns Whether the two specified arrays are equal.
     */
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!equalsFunc(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
     * mapped elements to a maximum depth of one, leaving the original array intact.
     * @param array An array.
     * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
     * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
     * elements to a maximum depth of one.
     */
    static flatMap(array, map) {
        const out = [];
        for (let i = 0; i < array.length; i++) {
            const mapped = map(array[i], i, array);
            if (Array.isArray(mapped)) {
                for (let j = 0; j < mapped.length; j++) {
                    out[out.length] = mapped[j];
                }
            }
            else {
                out[out.length] = mapped;
            }
        }
        return out;
    }
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat(array, depth = 1) {
        const out = [];
        this.flatHelper(array, depth, 0, out);
        return out;
    }
    /**
     * Recursively flattens an array and writes the flattened sequence of elements into another array.
     * @param array The array to flatten.
     * @param maxDepth The maximum depth to which to flatten.
     * @param depth The current flattening depth.
     * @param out The array to which to write the flattened sequence of elements.
     */
    static flatHelper(array, maxDepth, depth, out) {
        for (let i = 0; i < array.length; i++) {
            const element = array[i];
            if (Array.isArray(element) && depth < maxDepth) {
                this.flatHelper(element, maxDepth, depth + 1, out);
            }
            else {
                out[out.length] = element;
            }
        }
    }
    /**
     * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
     * length and the same elements in the same order as the source array.
     * @param source The array to copy.
     * @param target The array to copy into. If not defined, a new array will be created.
     * @returns The target array, after the source array has been copied into it.
     */
    static shallowCopy(source, target = []) {
        target.length = source.length;
        for (let i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        return target;
    }
    /**
     * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
     * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
     * where `index` is the index at which the query element would be found if it were contained in the sorted array.
     * @param array An array.
     * @param element The element to search for.
     * @param comparator A function which determines the sorting order of elements in the array. The function should
     * return a negative number if the first element is to be sorted before the second, a positive number if the first
     * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
     * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
     * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
     * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
     * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
     * the query element would be found if it were contained in the sorted array, if no element in the array has a
     * sorting order equal to the query.
     */
    static binarySearch(array, element, comparator, first = true) {
        let min = 0;
        let max = array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = comparator(element, array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array) {
        return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
}
ArrayUtils.STRICT_EQUALS = (a, b) => a === b;

/** A collection of helper functions dealing with radios and frequencies. */
class RadioUtils {
    /**
     * Checks whether a frequency is a NAV frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a NAV frequency.
     */
    static isNavFrequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 108e3 || freqKhz > 117950) {
            return false;
        }
        return freqKhz % 50 === 0;
    }
    /**
     * Checks if frequency is a localizer frequency based on the number.
     * @param freq The frequency to check, in megahertz.
     * @returns True if frequency is between 108.1 and 111.95 MHz (inclusive) and the tenths place is odd.
     */
    static isLocalizerFrequency(freq) {
        return freq >= 108.1 && freq <= 111.95 && (Math.trunc(freq * 10) % 2 === 1);
    }
    /**
     * Checks whether a frequency is a 8.33 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 8.33 kHz-spacing COM frequency.
     */
    static isCom833Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136990) {
            return false;
        }
        return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    /**
     * Checks whether a frequency is a 25 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 25 kHz-spacing COM frequency.
     */
    static isCom25Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136975) {
            return false;
        }
        return freqKhz % 25 === 0;
    }
    /**
     * Checks whether a frequency is an ADF frequency.
     * @param freq The frequency to check, in kilohertz.
     * @returns Whether the specified frequency is an ADF frequency.
     */
    static isAdfFrequency(freq) {
        const freqHz = Math.round(freq * 1000);
        if (freqHz < 190e3 || freqHz > 1799500) {
            return false;
        }
        return freqHz % 500 === 0;
    }
}
RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];

/**
 * VOR signal to/from flags.
 */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));
/**
 * A publisher of NAV, COM, ADF radio and marker beacon tuning-related sim var events.
 */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of NavComSimVarPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ...NavComSimVarPublisher.createNavRadioDefinitions(),
            ...NavComSimVarPublisher.createComRadioDefinitions(),
            ...NavComSimVarPublisher.createAdfRadioDefinitions(),
            ...NavComSimVarPublisher.createMarkerBeaconDefinitions(),
            ...NavComSimVarPublisher.createGpsDefinitions()
        ]);
        super(simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions.
     * @returns An array of nav radio sim var event definitions.
     */
    static createNavRadioDefinitions() {
        return [
            ['nav_active_frequency', { name: 'NAV ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_standby_frequency', { name: 'NAV STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_signal', { name: 'NAV SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_sound', { name: 'NAV SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_ident', { name: 'NAV IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_volume', { name: 'NAV VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_obs', { name: 'NAV OBS:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_dme', { name: 'NAV HAS DME:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_nav', { name: 'NAV HAS NAV:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_cdi', { name: 'NAV CDI:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme', { name: 'NAV DME:#index#', type: SimVarValueType.NM, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial', { name: 'NAV RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial_error', { name: 'NAV RADIAL ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_to_from', { name: 'NAV TOFROM:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer', { name: 'NAV HAS LOCALIZER:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer_crs', { name: 'NAV LOCALIZER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_airport_ident', { name: 'NAV LOC AIRPORT IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_designator', { name: 'NAV LOC RUNWAY DESIGNATOR:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_number', { name: 'NAV LOC RUNWAY NUMBER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_glideslope', { name: 'NAV HAS GLIDE SLOPE:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_error', { name: 'NAV GLIDE SLOPE ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_raw_gs', { name: 'NAV RAW GLIDE SLOPE:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_lla', { name: 'NAV VOR LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme_lla', { name: 'NAV DME LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_lla', { name: 'NAV GS LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_magvar', { name: 'NAV MAGVAR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of com radio sim var event definitions.
     * @returns An array of com radio sim var event definitions.
     */
    static createComRadioDefinitions() {
        return [
            ['com_active_frequency', { name: 'COM ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_standby_frequency', { name: 'COM STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_name', { name: 'COM ACTIVE FREQ NAME:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_type', { name: 'COM ACTIVE FREQ TYPE:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_ident', { name: 'COM ACTIVE FREQ IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            // Note: 'COM RECEIVE' is whether the radio is receiving OR transmitting,
            // whereas 'COM RECEIVE EX1' is exclusively its receiving state.
            ['com_receive', { name: 'COM RECEIVE EX1:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_status', { name: 'COM STATUS:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_transmit', { name: 'COM TRANSMIT:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_spacing_mode', { name: 'COM SPACING MODE:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_volume', { name: 'COM VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3], defaultIndex: null }],
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions.
     * @returns An array of ADF radio sim var event definitions.
     */
    static createAdfRadioDefinitions() {
        return [
            ['adf_active_frequency', { name: 'ADF ACTIVE FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_standby_frequency', { name: 'ADF STANDBY FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_sound', { name: 'ADF SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['adf_volume', { name: 'ADF VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2], defaultIndex: null }],
            ['adf_ident', { name: 'ADF IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2], defaultIndex: null }],
            ['adf_signal', { name: 'ADF SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['adf_bearing', { name: 'ADF RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2], defaultIndex: null }],
            ['adf_lla', { name: 'ADF LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createMarkerBeaconDefinitions() {
        return [
            ['marker_beacon_hisense_on', { name: 'MARKER BEACON SENSITIVITY HIGH', type: SimVarValueType.Bool }],
            ['marker_beacon_sound', { name: 'MARKER SOUND', type: SimVarValueType.Bool }],
            ['marker_beacon_state', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
            ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createGpsDefinitions() {
        return [
            ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
            ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
            ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
            ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
            ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
            ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
            ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
        ];
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher of nav radio, ADF radio, GPS, and marker beacon-related sim var events.
 *
 * @deprecated Please use `NavComSimVarPublisher` instead.
 */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    static createNavRadioDefinitions(index) {
        return [
            [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
            [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
            [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
            [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
            [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
            [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`nav_radial_error_${index}`, { name: `NAV RADIAL ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
            [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
            [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
            [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
            [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
            [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    static createAdfRadioDefinitions(index) {
        return [
            [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
        ];
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));

/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 *
 * Requires that the topics defined in {@link NavComEvents} are published to the event bus.
 */
class APRadioNavInstrument {
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.navRadioData = ArrayUtils.create(5, index => {
            index = Math.max(1, index);
            return {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index, type: NavSourceType.Nav }),
                radialError: 0,
                magVar: 0
            };
        });
        this.currentCdiIndex = 1;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    init() {
        const navComSubscriber = this.bus.getSubscriber();
        for (let i = 1; i < 5; i++) {
            navComSubscriber.on(`nav_glideslope_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_gs_lla_${i}`).handle(this.setGlideslopePosition.bind(this, i));
            navComSubscriber.on(`nav_gs_error_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_raw_gs_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'gsAngle'));
            navComSubscriber.on(`nav_localizer_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_localizer_crs_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'course'));
            navComSubscriber.on(`nav_cdi_${i}`).whenChanged().handle(this.setCDIValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_has_nav_${i}`).whenChanged().handle(hasNav => !hasNav && this.setCDIValue(i, 'deviation', null));
            navComSubscriber.on(`nav_obs_${i}`).whenChanged().handle(this.setOBSValue.bind(this, i, 'heading'));
            navComSubscriber.on(`nav_lla_${i}`).handle(this.setNavPosition.bind(this, i));
            navComSubscriber.on(`nav_radial_error_${i}`).whenChanged().handle(this.setRadialError.bind(this, i));
            navComSubscriber.on(`nav_magvar_${i}`).whenChanged().handle(this.setMagVar.bind(this, i));
        }
        const navEvents = this.bus.getSubscriber();
        navEvents.on('cdi_select').handle(source => {
            const oldIndex = this.currentCdiIndex;
            this.currentCdiIndex = source.type === NavSourceType.Nav ? source.index : 0;
            if (oldIndex !== this.currentCdiIndex) {
                const data = this.navRadioData[this.currentCdiIndex];
                this.publisher.pub('nav_radio_active_gs_location', data.gsLocation);
                this.publisher.pub('nav_radio_active_nav_location', data.navLocation);
                this.publisher.pub('nav_radio_active_glideslope', data.glideslope);
                this.publisher.pub('nav_radio_active_localizer', data.localizer);
                this.publisher.pub('nav_radio_active_cdi_deviation', data.cdi);
                this.publisher.pub('nav_radio_active_obs_setting', data.obs);
                this.publisher.pub('nav_radio_active_radial_error', data.radialError);
                this.publisher.pub('nav_radio_active_magvar', data.magVar);
            }
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setGlideslopeValue(index, field, value) {
        this.navRadioData[index].glideslope[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_glideslope', this.navRadioData[index].glideslope);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_glideslope_1', this.navRadioData[index].glideslope);
                break;
            case 2:
                this.publisher.pub('nav_radio_glideslope_2', this.navRadioData[index].glideslope);
                break;
            case 3:
                this.publisher.pub('nav_radio_glideslope_3', this.navRadioData[index].glideslope);
                break;
            case 4:
                this.publisher.pub('nav_radio_glideslope_4', this.navRadioData[index].glideslope);
                break;
        }
    }
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setGlideslopePosition(index, lla) {
        this.navRadioData[index].gsLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_gs_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_gs_location_1', this.navRadioData[index].gsLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_gs_location_2', this.navRadioData[index].gsLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_gs_location_3', this.navRadioData[index].gsLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_gs_location_4', this.navRadioData[index].gsLocation);
                break;
        }
    }
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setNavPosition(index, lla) {
        this.navRadioData[index].navLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_nav_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_nav_location_1', this.navRadioData[index].navLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_nav_location_2', this.navRadioData[index].navLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_nav_location_3', this.navRadioData[index].navLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_nav_location_4', this.navRadioData[index].navLocation);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setLocalizerValue(index, field, value) {
        this.navRadioData[index].localizer[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_localizer', this.navRadioData[index].localizer);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_localizer_1', this.navRadioData[index].localizer);
                break;
            case 2:
                this.publisher.pub('nav_radio_localizer_2', this.navRadioData[index].localizer);
                break;
            case 3:
                this.publisher.pub('nav_radio_localizer_3', this.navRadioData[index].localizer);
                break;
            case 4:
                this.publisher.pub('nav_radio_localizer_4', this.navRadioData[index].localizer);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setCDIValue(index, field, value) {
        this.navRadioData[index].cdi[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_cdi_deviation', this.navRadioData[index].cdi);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_cdi_1', this.navRadioData[index].cdi);
                break;
            case 2:
                this.publisher.pub('nav_radio_cdi_2', this.navRadioData[index].cdi);
                break;
            case 3:
                this.publisher.pub('nav_radio_cdi_3', this.navRadioData[index].cdi);
                break;
            case 4:
                this.publisher.pub('nav_radio_cdi_4', this.navRadioData[index].cdi);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setOBSValue(index, field, value) {
        this.navRadioData[index].obs[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_obs_setting', this.navRadioData[index].obs);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_obs_1', this.navRadioData[index].obs);
                break;
            case 2:
                this.publisher.pub('nav_radio_obs_2', this.navRadioData[index].obs);
                break;
            case 3:
                this.publisher.pub('nav_radio_obs_3', this.navRadioData[index].obs);
                break;
            case 4:
                this.publisher.pub('nav_radio_obs_4', this.navRadioData[index].obs);
                break;
        }
    }
    /**
     * Sets the radial error of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param radialError The radial error to set.
     */
    setRadialError(index, radialError) {
        this.navRadioData[index].radialError = radialError;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_radial_error', radialError);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_radial_error_1', this.navRadioData[index].radialError);
                break;
            case 2:
                this.publisher.pub('nav_radio_radial_error_2', this.navRadioData[index].radialError);
                break;
            case 3:
                this.publisher.pub('nav_radio_radial_error_3', this.navRadioData[index].radialError);
                break;
            case 4:
                this.publisher.pub('nav_radio_radial_error_4', this.navRadioData[index].radialError);
                break;
        }
    }
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    setMagVar(index, magVar) {
        magVar = NavMath.normalizeHeading(-magVar + 180) % 360 - 180;
        this.navRadioData[index].magVar = magVar;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_magvar', magVar);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_magvar_1', this.navRadioData[index].magVar);
                break;
            case 2:
                this.publisher.pub('nav_radio_magvar_2', this.navRadioData[index].magVar);
                break;
            case 3:
                this.publisher.pub('nav_radio_magvar_3', this.navRadioData[index].magVar);
                break;
            case 4:
                this.publisher.pub('nav_radio_magvar_4', this.navRadioData[index].magVar);
                break;
        }
    }
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    createEmptyLocalizer(id) {
        return {
            isValid: false,
            course: 0,
            source: id
        };
    }
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    createEmptyGlideslope(id) {
        return {
            isValid: false,
            gsAngle: 0,
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    createEmptyCdi(id) {
        return {
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    createEmptyObs(id) {
        return {
            heading: 0,
            source: id
        };
    }
}

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to this backplane.
     * @param name A symbolic name for the publisher for reference.
     * @param publisher The publisher to add.
     * @param override Whether to override any existing publishers added to this backplane under the same name. If
     * `true`, any existing publisher with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new publisher will not be added if this backplane already has a publisher with the same
     * name or a publisher of the same type. Defaults to `false`.
     */
    addPublisher(name, publisher, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, publisher, this.publishers)) {
            this.publishers.set(name, publisher);
        }
    }
    /**
     * Add an instrument to this backplane.
     * @param name A symbolic name for the instrument for reference.
     * @param instrument The instrument to add.
     * @param override Whether to override any existing instruments added to this backplane under the same name. If
     * `true`, any existing instrument with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new instrument will not be added if this backplane already has an instrument with the same
     * name or an instrument of the same type. Defaults to `false`.
     */
    addInstrument(name, instrument, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, instrument, this.instruments)) {
            this.instruments.set(name, instrument);
        }
    }
    /**
     * Gets a publisher from this backplane.
     * @param name The name of the publisher to get.
     * @returns The publisher in this backplane with the specified name, or `undefined` if there is no such publisher.
     */
    getPublisher(name) {
        return this.publishers.get(name);
    }
    /**
     * Gets an instrument from this backplane.
     * @param name The name of the instrument to get.
     * @returns The instrument in this backplane with the specified name, or `undefined` if there is no such instrument.
     */
    getInstrument(name) {
        return this.instruments.get(name);
    }
    /**
     * Checks for duplicate publishers or instruments of the same name or type.
     * @param name the name of the publisher or instrument
     * @param objToCheck the object to check
     * @param map the map to check
     * @returns true if the object is already in the map
     */
    static checkAlreadyExists(name, objToCheck, map) {
        if (map.has(name)) {
            console.warn(`${name} already exists in backplane.`);
            return true;
        }
        // check if there already is a publisher with the same type
        for (const p of map.values()) {
            if (p.constructor === objToCheck.constructor) {
                console.warn(`${name} already exists in backplane.`);
                return true;
            }
        }
        return false;
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Brake information.
 */
class BrakeSimvarPublisher extends SimVarPublisher {
    /**
     * Create a BrakePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['brake_position_left', { name: 'BRAKE LEFT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_right', { name: 'BRAKE RIGHT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_left_raw', { name: 'BRAKE LEFT POSITION EX1', type: SimVarValueType.Percent }],
            ['brake_position_right_raw', { name: 'BRAKE RIGHT POSITION EX1', type: SimVarValueType.Percent }],
            ['left_wheel_rpm', { name: 'LEFT WHEEL RPM', type: SimVarValueType.RPM }],
            ['right_wheel_rpm', { name: 'RIGHT WHEEL RPM', type: SimVarValueType.RPM }],
            ['parking_brake_set', { name: 'BRAKE PARKING POSITION', type: SimVarValueType.Bool }],
            ['autobrake_switch_pos', { name: 'AUTO BRAKE SWITCH CB', type: SimVarValueType.Number }],
            ['autobrake_active', { name: 'AUTOBRAKES ACTIVE', type: SimVarValueType.Bool }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    /**
     * Creates a new instance of ClockPublisher.
     * @param bus The event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
        this.needPublishRealTime = false;
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['simTime', { name: 'E:ABSOLUTE TIME', type: SimVarValueType.Seconds, map: ClockPublisher.absoluteTimeToUNIXTime }],
            ['simRate', { name: 'E:SIMULATION RATE', type: SimVarValueType.Number }]
        ]), bus, pacer);
        if (this.bus.getTopicSubscriberCount('realTime') > 0) {
            this.needPublishRealTime = true;
        }
        else {
            const sub = this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
                if (topic === 'realTime') {
                    this.needPublishRealTime = true;
                    sub.destroy();
                }
            }, true);
            sub.resume();
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
        if (this.hiFreqInterval === undefined) {
            this.hiFreqInterval = setInterval(() => this.publish('simTimeHiFreq', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds'))), 0);
        }
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
        if (this.hiFreqInterval !== undefined) {
            clearInterval(this.hiFreqInterval);
            this.hiFreqInterval = undefined;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needPublishRealTime) {
            this.publish('realTime', Date.now());
        }
        this.simVarPublisher.onUpdate();
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}
/**
 * A clock which keeps track of real-world and sim time.
 */
class Clock {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
        this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
        this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
        this.publisher.onUpdate();
    }
}

/**
 * A publisher for control surfaces information.
 */
class ControlSurfacesPublisher extends SimVarPublisher {
    /**
     * Create an ControlSurfacesPublisher.
     * @param bus The EventBus to publish to.
     * @param gearCount The number of landing gear to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, gearCount, pacer) {
        const nonIndexedSimVars = [
            ['flaps_handle_index', { name: 'FLAPS HANDLE INDEX', type: SimVarValueType.Number }],
            ['flaps_left_angle', { name: 'TRAILING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_right_angle', { name: 'TRAILING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_left_percent', { name: 'TRAILING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['flaps_right_percent', { name: 'TRAILING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['slats_left_angle', { name: 'LEADING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['slats_right_angle', { name: 'LEADING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['slats_left_percent', { name: 'LEADING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['slats_right_percent', { name: 'LEADING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['spoilers_left_percent', { name: 'SPOILERS LEFT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_right_percent', { name: 'SPOILERS RIGHT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_without_spoilerons_left_percent', { name: 'SPOILERS WITHOUT SPOILERONS LEFT POSITION', type: SimVarValueType.Percent }],
            ['elevator_trim_angle', { name: 'ELEVATOR TRIM POSITION', type: SimVarValueType.Degree }],
            ['elevator_trim_pct', { name: 'ELEVATOR TRIM PCT', type: SimVarValueType.Percent }],
            ['elevator_trim_neutral_pct', { name: 'AIRCRAFT ELEVATOR TRIM NEUTRAL', type: SimVarValueType.Percent }],
            ['aileron_trim_angle', { name: 'AILERON TRIM', type: SimVarValueType.Degree }],
            ['aileron_trim_pct', { name: 'AILERON TRIM PCT', type: SimVarValueType.Percent }],
            ['rudder_trim_angle', { name: 'RUDDER TRIM', type: SimVarValueType.Degree }],
            ['rudder_trim_pct', { name: 'RUDDER TRIM PCT', type: SimVarValueType.Percent }],
            ['aileron_left_percent', { name: 'AILERON LEFT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['aileron_right_percent', { name: 'AILERON RIGHT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['elevator_percent', { name: 'ELEVATOR DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['rudder_percent', { name: 'RUDDER DEFLECTION PCT', type: SimVarValueType.Percent }]
        ];
        const gearIndexedSimVars = [
            ['gear_position', { name: 'GEAR POSITION', type: SimVarValueType.Number }],
            ['gear_is_on_ground', { name: 'GEAR IS ON GROUND', type: SimVarValueType.Bool }]
        ];
        const simvars = new Map(nonIndexedSimVars);
        // set un-indexed simvar topics to pull from index 0
        for (const [topic, simvar] of [...gearIndexedSimVars]) {
            simvars.set(`${topic}`, {
                name: `${simvar.name}:0`,
                type: simvar.type,
                map: simvar.map
            });
        }
        // add landing gear indexed simvar topics
        // HINT: for some reason index 0 is nose. not 1-based.
        gearCount = Math.max(gearCount, 1);
        for (let i = 0; i < gearCount; i++) {
            for (const [topic, simvar] of gearIndexedSimVars) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use generic listener event sync (default false).
     * If true, FlowEventSync will only work for gauges.
     * @param shouldResync Whether the eventbus should ask for a resync of all previously cached events (default true)
     */
    constructor(useAlternativeEventSync = false, shouldResync = true) {
        this._topicSubsMap = new Map();
        this._wildcardSubs = new Array();
        this._notifyDepthMap = new Map();
        this._wildcardNotifyDepth = 0;
        this._eventCache = new Map();
        this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
        this._busId = Math.floor(Math.random() * 2147483647);
        // fallback to flowevent when genericdatalistener not avail (su9)
        useAlternativeEventSync = (typeof RegisterGenericDataListener === 'undefined');
        const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        if (shouldResync === true) {
            this.syncEvent('event_bus', 'resync_request', false);
            this.on('event_bus', (data) => {
                if (data == 'resync_request') {
                    this.resyncEvents();
                }
            });
        }
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic, handler, paused = false) {
        let subs = this._topicSubsMap.get(topic);
        if (subs === undefined) {
            this._topicSubsMap.set(topic, subs = []);
            this.pub('event_bus_topic_first_sub', topic, false, false);
        }
        const initialNotifyFunc = (sub) => {
            const lastState = this._eventCache.get(topic);
            if (lastState !== undefined) {
                sub.handler(lastState.data);
            }
        };
        const onDestroyFunc = (sub) => {
            var _a;
            // If we are not in the middle of a notify operation, remove the subscription.
            // Otherwise, do nothing and let the post-notify clean-up code handle it.
            if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
                const subsToSplice = this._topicSubsMap.get(topic);
                if (subsToSplice) {
                    subsToSplice.splice(subsToSplice.indexOf(sub), 1);
                }
            }
        };
        const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
        subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic, handler) {
        const handlers = this._topicSubsMap.get(topic);
        const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler) {
        const sub = new HandlerSubscription(handler, undefined, this.onWildcardSubDestroyedFunc);
        this._wildcardSubs.push(sub);
        return sub;
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler) {
        const toDestroy = this._wildcardSubs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        var _a;
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const subs = this._topicSubsMap.get(topic);
        if (subs !== undefined) {
            let needCleanUpSubs = false;
            const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
            this._notifyDepthMap.set(topic, notifyDepth + 1);
            const len = subs.length;
            for (let i = 0; i < len; i++) {
                try {
                    const sub = subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(data);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            this._notifyDepthMap.set(topic, notifyDepth);
            if (needCleanUpSubs && notifyDepth === 0) {
                const filteredSubs = subs.filter(sub => sub.isAlive);
                this._topicSubsMap.set(topic, filteredSubs);
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        let needCleanUpSubs = false;
        this._wildcardNotifyDepth++;
        const wcLen = this._wildcardSubs.length;
        for (let i = 0; i < wcLen; i++) {
            const sub = this._wildcardSubs[i];
            if (sub.isAlive && !sub.isPaused) {
                sub.handler(topic, data);
            }
            needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        }
        this._wildcardNotifyDepth--;
        if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
            this._wildcardSubs = this._wildcardSubs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    onWildcardSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this._wildcardNotifyDepth === 0) {
            this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic) {
        var _a, _b;
        return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Executes a function once for each topic with at least one subscriber.
     * @param fn The function to execute.
     */
    forEachSubscribedTopic(fn) {
        this._topicSubsMap.forEach((subs, topic) => { subs.length > 0 && fn(topic, subs.length); });
    }
}
/**
 * An abstract class for bus sync implementations.
 */
class EventBusSyncBase {
    /**
     * Creates an instance of EventBusFlowEventSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.
     */
    constructor(recvEventCb, busId) {
        this.isPaused = false;
        this.lastEventSynced = -1;
        this.dataPackageQueue = [];
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.hookReceiveEvent();
        /** Sends the queued up data packages */
        const sendFn = () => {
            if (!this.isPaused && this.dataPackageQueue.length > 0) {
                // console.log(`Sending ${this.dataPackageQueue.length} packages`);
                const syncDataPackage = {
                    busId: this.busId,
                    packagedId: Math.floor(Math.random() * 1000000000),
                    data: this.dataPackageQueue
                };
                if (this.executeSync(syncDataPackage)) {
                    this.dataPackageQueue.length = 0;
                }
                else {
                    console.warn('Failed to send sync data package');
                }
            }
            requestAnimationFrame(sendFn);
        };
        requestAnimationFrame(sendFn);
    }
    /**
     * Processes events received and sends them onto the local bus.
     * @param syncData The data package to process.
     */
    processEventsReceived(syncData) {
        if (this.busId !== syncData.busId) {
            // HINT: coherent events are still received twice, so check for this
            if (this.lastEventSynced !== syncData.packagedId) {
                this.lastEventSynced = syncData.packagedId;
                syncData.data.forEach((data) => {
                    try {
                        this.recvEventCb(data.topic, data.data !== undefined ? data.data : undefined, false, data.isCached);
                    }
                    catch (e) {
                        console.error(e);
                        if (e instanceof Error) {
                            console.error(e.stack);
                        }
                    }
                });
            }
        }
    }
    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // stringify data
        const dataObj = data;
        // build a data package
        const dataPackage = {
            topic: topic,
            data: dataObj,
            isCached: isCached
        };
        // queue data package
        this.dataPackageQueue.push(dataPackage);
    }
}
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 * DON'T USE this, it has bad performance implications.
 * @deprecated
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
class EventBusCoherentSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // HINT: Stringifying the data again to circumvent the bad perf on Coherent interop
        try {
            this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, undefined, true);
        this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
            try {
                const evt = JSON.parse(e);
                this.processEventsReceived(evt);
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 */
class EventBusFlowEventSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // console.log('Sending sync package: ' + syncDataPackage.packagedId);
        try {
            LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        Coherent.on('OnInteractionEvent', (target, args) => {
            // identify if its a busevent
            if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
                return;
            }
            this.processEventsReceived(JSON.parse(args[2]));
        });
    }
}
EventBusFlowEventSync.EB_LISTENER_KEY = 'EB_EVENTS';
//// END GLOBALS DECLARATION
/**
 * A class that manages event bus synchronization via the Generic Data Listener.
 */
class EventBusListenerSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        try {
            this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        // pause the sync until the listener is ready
        this.isPaused = true;
        this.listener = RegisterGenericDataListener(() => {
            this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
                try {
                    this.processEventsReceived(data);
                }
                catch (error) {
                    console.error(error);
                }
            });
            this.isPaused = false;
        });
    }
}
EventBusListenerSync.EB_KEY = 'wt.eb.evt';
EventBusListenerSync.EB_LISTENER_KEY = 'JS_LISTENER_GENERICDATA';

/**
 * Captures the state of a value from a consumer.
 */
class ConsumerValue {
    /**
     * Creates an instance of a ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     */
    constructor(consumer, initialValue) {
        this.consumerHandler = (v) => { this.value = v; };
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialValue;
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused. While paused, this object's value will not update.
     */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Gets the current value.
     * @returns The current value.
     */
    get() {
        return this.value;
    }
    /**
     * Sets the consumer from which this object derives its value. If the consumer is null, this object's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This object, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this object. Once paused, this object's value will not be updated.
     * @returns This object, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this object. Once resumed, this object's value will be updated from consumed
     * events.
     * @returns This object, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /**
     * Destroys this object. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        this.isDestroyed = true;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * Creates a new ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     * @returns The created ConsumerValue.
     */
    static create(consumer, initialValue) {
        return new ConsumerValue(consumer, initialValue);
    }
}

/**
 * A publisher for publishing H:Events on the bus.
 */
class HEventPublisher extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
        // console.log(`dispaching hevent:  ${hEvent}`);
        this.publish('hEvent', hEvent, sync, false);
    }
}

/**
 * A subscribable subject which derives its value from an event consumer.
 */
class ConsumerSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
        super();
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.consumerHandler = this.onEventConsumed.bind(this);
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialVal;
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
        return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    onEventConsumed(value) {
        if (!this.equalityFunc(this.value, value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isDestroyed = true;
    }
}

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** The kind of data to return. */
var CompositeLogicXMLValueType;
(function (CompositeLogicXMLValueType) {
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Any"] = 0] = "Any";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["Number"] = 1] = "Number";
    CompositeLogicXMLValueType[CompositeLogicXMLValueType["String"] = 2] = "String";
})(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
/**
 *
 */
class CompositeLogicXMLHost {
    /**
     * Ctor
     * @param startPaused True to start paused.
     */
    constructor(startPaused = false) {
        this.anyHandlers = new Array();
        this.stringHandlers = new Array();
        this.numberHandlers = new Array();
        this.anyResultCache = new Array();
        this.stringResultCache = new Array();
        this.numberResultCache = new Array();
        this.context = new LogicXMLContext();
        this.isPaused = false;
        this.isPaused = startPaused;
    }
    /**
     * Set to pause the logic update loop.
     * @param isPaused True to pause, false to resume.
     */
    setIsPaused(isPaused) {
        this.isPaused = isPaused;
    }
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic, handler) {
        this.anyHandlers.push({ logic: logic, handler: handler });
        return logic.getValue(this.context);
    }
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @param smoothFactor An optional linear smoothing factor to apply to the value when updating.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic, handler, precision, smoothFactor) {
        this.numberHandlers.push({ logic: logic, handler: handler, precision: precision, smoothFactor: smoothFactor });
        return logic.getValueAsNumber(this.context);
    }
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic, handler) {
        this.stringHandlers.push({ logic: logic, handler: handler });
        return logic.getValueAsString(this.context);
    }
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec) {
        const func = new LogicXMLFunction();
        func.name = funcSpec.name;
        func.callback = funcSpec.logic;
        this.context.addFunction(func);
        return funcSpec.logic.getValue(this.context);
    }
    /**
     * Update every logic element and publish updates.
     * @param deltaTime The time since the last update, in ms.
     */
    update(deltaTime) {
        if (!this.isPaused) {
            for (let i = 0; i < this.anyHandlers.length; i++) {
                const newVal = this.anyHandlers[i].logic.getValue(this.context);
                if (newVal !== this.anyResultCache[i]) {
                    this.anyResultCache[i] = newVal;
                    this.anyHandlers[i].handler(newVal);
                }
            }
            for (let i = 0; i < this.stringHandlers.length; i++) {
                const newVal = this.stringHandlers[i].logic.getValueAsString(this.context);
                if (newVal !== this.stringResultCache[i]) {
                    this.stringResultCache[i] = newVal;
                    this.stringHandlers[i].handler(newVal);
                }
            }
            for (let i = 0; i < this.numberHandlers.length; i++) {
                let newVal = this.numberHandlers[i].logic.getValueAsNumber(this.context);
                let precision = this.numberHandlers[i].precision;
                if (precision !== undefined) {
                    precision = Math.pow(10, precision);
                    newVal = Math.round(newVal * precision) / precision;
                }
                if (this.numberHandlers[i].smoothFactor !== undefined && this.numberHandlers[i].smoothFactor !== 0) {
                    // A smoothFactor of 0 means no smoothing.  We don't trigger this update if the factor is
                    // undefined or 0, but typescript still thinks is could be undefined due to the array indexing.
                    // The 'or-0' here is just to get around that without having to do a temporary assignment.
                    newVal = Utils.SmoothLinear(this.numberResultCache[i], newVal, this.numberHandlers[i].smoothFactor || 0, deltaTime);
                }
                if (newVal !== this.numberResultCache[i]) {
                    this.numberResultCache[i] = newVal;
                    this.numberHandlers[i].handler(newVal);
                }
            }
            this.context.update();
        }
    }
}

/**
 * A utility class which provides the current game state.
 */
class GameStateProvider {
    /**
     * Constructor.
     */
    constructor() {
        this.gameState = Subject.create(undefined);
        window.document.addEventListener('OnVCockpitPanelAttributesChanged', this.onAttributesChanged.bind(this));
        this.onAttributesChanged();
    }
    /**
     * Responds to changes in document attributes.
     */
    onAttributesChanged() {
        var _a;
        if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute('gamestate')) {
            const attribute = window.parent.document.body.getAttribute('gamestate');
            if (attribute !== null) {
                const state = GameState[attribute];
                // The game state is set briefly to ingame after loading is finished before changing to briefing. In order to
                // not notify subscribers of this erroneous ingame state, we will debounce any state changes into ingame by two
                // frames.
                if (state === GameState.ingame && this.gameState.get() !== GameState.ingame) {
                    setTimeout(() => {
                        setTimeout(() => {
                            const newAttribute = window.parent.document.body.getAttribute('gamestate');
                            if (newAttribute !== null) {
                                this.gameState.set(GameState[newAttribute]);
                            }
                        });
                    });
                }
                else {
                    this.gameState.set(state);
                }
                return;
            }
        }
        this.gameState.set(undefined);
    }
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get() {
        var _a;
        return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : (GameStateProvider.INSTANCE = new GameStateProvider())).gameState;
    }
}

/**
 * A manager for key events. Allows key events to be triggered and intercepted, and also publishes intercepted key
 * events on the event bus.
 */
class KeyEventManager {
    /**
     * Constructor.
     * @param keyListener The Coherent key intercept view listener.
     * @param bus The event bus.
     */
    constructor(keyListener, bus) {
        this.keyListener = keyListener;
        this.bus = bus;
        Coherent.on('keyIntercepted', this.onKeyIntercepted.bind(this));
    }
    /**
     * Responds to key intercept events.
     * @param key The key that was intercepted.
     * @param value1 The second data value of the key event.
     * @param value0 The first data value of the key event.
     * @param value2 The third data value of the key event.
     */
    onKeyIntercepted(key, value1, value0, value2) {
        // Even though values are uint32, we will do what the sim does and pretend they're actually sint32
        if (value0 !== undefined && value0 >= 2147483648) {
            value0 -= 4294967296;
        }
        this.bus.pub('key_intercept', { key, value0, value1, value2 }, false, false);
    }
    /**
     * Triggers a key event.
     * @param key The key to trigger.
     * @param bypass Whether the event should bypass intercepts.
     * @param value0 The first data value of the key event. Defaults to `0`.
     * @param value1 The second data value of the key event. Defaults to `0`.
     * @param value2 The third data value of the key event. Defaults to `0`.
     * @returns A Promise which is fulfilled after the key event has been triggered.
     */
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
        return Coherent.call('TRIGGER_KEY_EVENT', key, bypass, value0, value1, value2);
    }
    /**
     * Enables interception for a key.
     * @param key The key to intercept.
     * @param passThrough Whether to pass the event through to the sim after it has been intercepted.
     */
    interceptKey(key, passThrough) {
        Coherent.call('INTERCEPT_KEY_EVENT', key, passThrough ? 0 : 1);
    }
    /**
     * Gets an instance of KeyEventManager. If an instance does not already exist, a new one will be created.
     * @param bus The event bus.
     * @returns A Promise which will be fulfilled with an instance of KeyEventManager.
     */
    static getManager(bus) {
        if (KeyEventManager.INSTANCE) {
            return Promise.resolve(KeyEventManager.INSTANCE);
        }
        if (!KeyEventManager.isCreatingInstance) {
            KeyEventManager.createInstance(bus);
        }
        return new Promise(resolve => {
            KeyEventManager.pendingPromiseResolves.push(resolve);
        });
    }
    /**
     * Creates an instance of KeyEventManager and fulfills all pending Promises to get the manager instance once
     * the instance is created.
     * @param bus The event bus.
     */
    static async createInstance(bus) {
        KeyEventManager.isCreatingInstance = true;
        KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
        KeyEventManager.isCreatingInstance = false;
        for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
            KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
        }
    }
    /**
     * Creates an instance of KeyEventManager.
     * @param bus The event bus.
     * @returns A Promise which is fulfilled with a new instance of KeyEventManager after it has been created.
     */
    static create(bus) {
        return new Promise((resolve, reject) => {
            const gameState = GameStateProvider.get();
            const sub = gameState.sub(state => {
                if (window['IsDestroying']) {
                    sub.destroy();
                    reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                    return;
                }
                if (state === GameState.briefing || state === GameState.ingame) {
                    sub.destroy();
                    const keyListener = RegisterViewListener('JS_LISTENER_KEYEVENT', () => {
                        if (window['IsDestroying']) {
                            reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                            return;
                        }
                        resolve(new KeyEventManager(keyListener, bus));
                    });
                }
            }, false, true);
            sub.resume(true);
        });
    }
}
KeyEventManager.isCreatingInstance = false;
KeyEventManager.pendingPromiseResolves = [];

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
/**
 * The class of airport facility.
 */
var AirportClass;
(function (AirportClass) {
    /** No other airport class could be identified. */
    AirportClass[AirportClass["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClass[AirportClass["HardSurface"] = 1] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClass[AirportClass["SoftSurface"] = 2] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClass[AirportClass["AllWater"] = 3] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClass[AirportClass["HeliportOnly"] = 4] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClass[AirportClass["Private"] = 5] = "Private";
})(AirportClass || (AirportClass = {}));
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
var AirportClassMask;
(function (AirportClassMask) {
    /** No other airport class could be identified. */
    AirportClassMask[AirportClassMask["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClassMask[AirportClassMask["HardSurface"] = 2] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClassMask[AirportClassMask["SoftSurface"] = 4] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClassMask[AirportClassMask["AllWater"] = 8] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClassMask[AirportClassMask["HeliportOnly"] = 16] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClassMask[AirportClassMask["Private"] = 32] = "Private";
})(AirportClassMask || (AirportClassMask = {}));
/**
 * An enumeration of possible intersection types.
 */
var IntersectionType;
(function (IntersectionType) {
    IntersectionType[IntersectionType["None"] = 0] = "None";
    IntersectionType[IntersectionType["Named"] = 1] = "Named";
    IntersectionType[IntersectionType["Unnamed"] = 2] = "Unnamed";
    IntersectionType[IntersectionType["Vor"] = 3] = "Vor";
    IntersectionType[IntersectionType["NDB"] = 4] = "NDB";
    IntersectionType[IntersectionType["Offroute"] = 5] = "Offroute";
    IntersectionType[IntersectionType["IAF"] = 6] = "IAF";
    IntersectionType[IntersectionType["FAF"] = 7] = "FAF";
    IntersectionType[IntersectionType["RNAV"] = 8] = "RNAV";
    IntersectionType[IntersectionType["VFR"] = 9] = "VFR";
})(IntersectionType || (IntersectionType = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a lateral and vertical discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
    /** A leg representing a lateral and vertical discontinuity in the flight plan that does not prevent sequencing. */
    LegType[LegType["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["All"] = 0] = "All";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
    FacilitySearchType[FacilitySearchType["Visual"] = 7] = "Visual";
    FacilitySearchType[FacilitySearchType["AllExceptVisual"] = 8] = "AllExceptVisual";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao) {
        return icao.substr(3, 4).trim();
    }
    /**
     * Checks whether an ICAO string defines a facility (optionally of a specific type).
     * @param icao An ICAO string.
     * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
     * the ICAO string defines any valid facility type.
     * @returns Whether the given ICAO string defines a facility of the specified type.
     */
    static isFacility(icao, type) {
        switch (icao[0]) {
            case 'A':
                return type === undefined || type === FacilityType.Airport;
            case 'W':
                return type === undefined || type === FacilityType.Intersection;
            case 'V':
                return type === undefined || type === FacilityType.VOR;
            case 'N':
                return type === undefined || type === FacilityType.NDB;
            case 'U':
                return type === undefined || type === FacilityType.USR;
            case 'R':
                return type === undefined || type === FacilityType.RWY;
            case 'S':
                return type === undefined || type === FacilityType.VIS;
            default:
                return false;
        }
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao) {
        return icao.substr(1, 2).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';
/**
 * Utility functions for working with facilities.
 */
class FacilityUtils {
    /**
     * Checks whether a facility is of a given type.
     * @param facility The facility to check.
     * @param type The facility type to check against.
     * @returns Whether the facility is of the specified type.
     */
    static isFacilityType(facility, type) {
        // Need to check for the intersection version of VOR/NDB facilities - these facilities have identical ICAOs
        // to their VOR/NDB counterparts, so we need to manually check the __Type property on the facility object.
        if (facility['__Type'] === 'JS_FacilityIntersection') {
            return type === FacilityType.Intersection;
        }
        return ICAO.isFacility(facility.icao, type);
    }
    /**
     * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
     * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
     * is returned.
     * @param facility A facility.
     * @returns The magnetic variation at the specified facility, in degrees.
     */
    static getMagVar(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            return -facility.magneticVariation; // VOR facility magvar is positive west instead of the standard positive east
        }
        else {
            return MagVar.get(facility.lat, facility.lon);
        }
    }
    /**
     * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees.
     * @param distance The distance, in nautical miles.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
     * facility.
     */
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
        return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    /**
     * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
     * @param reference1 The first reference facility.
     * @param radial1 The first magnetic radial, in degrees.
     * @param reference2 The second reference facility.
     * @param radial2 The second magnetic radial, in degrees.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
     * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
     */
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
        const magVar1 = FacilityUtils.getMagVar(reference1);
        const magVar2 = FacilityUtils.getMagVar(reference2);
        const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
        const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
        const radial1IncludesRef2 = radialCircle1.includes(reference2);
        const radial2IncludesRef1 = radialCircle2.includes(reference1);
        if (radial1IncludesRef2 && radial2IncludesRef1) {
            // Radials are parallel or antiparallel, and therefore do not have a unique intersection point.
            return out.set(NaN, NaN);
        }
        else if (radial1IncludesRef2) {
            // Reference 2 lies along the great circle of radial 1. The intersection point therefore is either reference 2
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
        }
        else if (radial2IncludesRef1) {
            // Reference 1 lies along the great circle of radial 2. The intersection point therefore is either reference 1
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
        }
        // Radials, unlike great circles, do not circumscribe the globe. Therefore, we choose the order of the intersection
        // operation carefully to ensure that the first solution (if it exists) is the "correct" intersection.
        const numIntersections = radialCircle1.encircles(reference2)
            ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache)
            : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
        if (numIntersections === 0) {
            return out.set(NaN, NaN);
        }
        return out.set(FacilityUtils.intersectionCache[0]);
    }
}
FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Utility functions for working with user facilities.
 */
class UserFacilityUtils {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
        const fac = {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat,
            lon,
            userFacilityType: UserFacilityType.LAT_LONG,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(lat, lon)
        };
        return fac;
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees, of the reference facility on which the new facility lies.
     * @param distance The distance, in nautical miles, from the reference facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_DISTANCE,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference.icao,
            reference1Radial: radial,
            reference1MagVar: FacilityUtils.getMagVar(reference),
            reference1Distance: distance
        };
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference1 The first reference facility.
     * @param radial1 The magnetic radial, in degrees, of the first reference facility on which the new facility lies.
     * @param reference2 The second reference facility.
     * @param radial2 The magnetic radial, in degrees, of the second reference facility on which the new facility lies.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility, or `undefined` if the specified radials do not intersect at a unique point.
     */
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
        if (isNaN(location.lat) || isNaN(location.lon)) {
            return undefined;
        }
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_RADIAL,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference1.icao,
            reference1Radial: radial1,
            reference1MagVar: FacilityUtils.getMagVar(reference1),
            reference2Icao: reference2.icao,
            reference2Radial: radial2,
            reference2MagVar: FacilityUtils.getMagVar(reference2)
        };
    }
}
UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];

var RunwaySurfaceCategory;
(function (RunwaySurfaceCategory) {
    RunwaySurfaceCategory[RunwaySurfaceCategory["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Water"] = 8] = "Water";
})(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator, lowerCase = false) {
        const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
        return lowerCase
            ? letter.toLowerCase()
            : letter;
    }
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            elevationEnd: 0,
            gradient: 0,
            latitude: 0,
            longitude: 0,
            length: 0,
            width: 0,
            startThresholdLength: 0,
            endThresholdLength: 0,
            surface: RunwaySurfaceType.Concrete,
            lighting: RunwayLightingType.Unknown
        };
    }
    /**
     * Utility method to return all of the one-way runways from a single airport facility
     * @param airport is the Airport Facility to evaluate
     * @returns all of the one-way runways in the airport facility, sorted.
     */
    static getOneWayRunwaysFromAirport(airport) {
        const runways = [];
        airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach(d => {
            runways.push(d[0]);
            runways.push(d[1]);
        });
        runways.sort(RunwayUtils.sortRunways);
        return runways;
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let endThresholdElevation = 0;
            let ilsFrequency;
            let startThresholdLength = 0, endThresholdLength = 0;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                endThresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
                startThresholdLength = runway.primaryThresholdLength;
                endThresholdLength = runway.secondaryThresholdLength;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                endThresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
                startThresholdLength = runway.secondaryThresholdLength;
                endThresholdLength = runway.primaryThresholdLength;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                elevationEnd: endThresholdElevation,
                gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency,
                length: runway.length,
                width: runway.width,
                startThresholdLength,
                endThresholdLength,
                surface: runway.surface,
                lighting: runway.lighting
            });
        }
        return splitRunways;
    }
    /**
     * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
     * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
     * then the name will be the designation of the primary runway only.
     * @param runway A paired runway.
     * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
     * @returns The name for the specified paired runway.
     */
    static getRunwayPairNameString(runway, padded = true) {
        const pad = padded ? 2 : 0;
        const dashIndex = runway.designation.search('-');
        const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
        const secondary = dashIndex < 0 ? '' : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
        return primary + secondary;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    /**
     * Gets the primary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The primary runway number for the specified runway.
     */
    static getRunwayNumberPrimary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return parseInt(runway.designation);
        }
        else {
            return parseInt(runway.designation.substring(0, dashIndex));
        }
    }
    /**
     * Gets the secondary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
     * runway.
     */
    static getRunwayNumberSecondary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return undefined;
        }
        else {
            return parseInt(runway.designation.substring(dashIndex + 1));
        }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg1, arg2) {
        let runway;
        if (typeof arg1 === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else if (typeof arg1 === 'number') {
            const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else {
            runway = arg1;
        }
        const runwayDesignation = runway.designation;
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            // Note: drop the leading zero in the runway designation for the search because some third-party sceneries
            // format the frequency names without the leading zero.
            const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ''));
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
        const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
        if (!matchedRunway) {
            return undefined;
        }
        return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
        let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        switch (runwayDesignator) {
            case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
                break;
            case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
                break;
            default:
                oppositeRunwayDesignator = runwayDesignator;
                break;
        }
        return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport, or the ICAO of the airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        const icao = typeof airport === 'string' ? airport : airport.icao;
        return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    /**
     * Gets the runway surface category from a runway or runway surface type.
     * @param runway A runway or runway surface type.
     * @returns The surface category of the specified runway or runway surface type.
     */
    static getSurfaceCategory(runway) {
        const surface = typeof runway === 'object' ? runway.surface : runway;
        if (this.SURFACES_HARD.includes(surface)) {
            return RunwaySurfaceCategory.Hard;
        }
        else if (this.SURFACES_SOFT.includes(surface)) {
            return RunwaySurfaceCategory.Soft;
        }
        else if (this.SURFACES_WATER.includes(surface)) {
            return RunwaySurfaceCategory.Water;
        }
        else {
            return RunwaySurfaceCategory.Unknown;
        }
    }
}
RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: '',
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 'L',
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 'R',
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 'C',
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 'W',
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 'A',
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 'B',
};
RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban,
];
RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
];
RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
];
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A utility class for working with approach procedures.
 */
class ApproachUtils {
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType(query) {
        const rnavTypeFlags = typeof query === 'number' ? query : query.rnavTypeFlags;
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param approach The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isRnpAr(approach) {
        return approach.approachType === ApproachType.APPROACH_TYPE_RNAV
            && approach.rnavTypeFlags === RnavTypeFlags.None
            && approach.runwayNumber !== 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getFrequencyFromAirport(facility, approach) {
        if (typeof approach === 'number') {
            approach = facility.approaches[approach];
        }
        if (approach) {
            switch (approach.approachType) {
                case ApproachType.APPROACH_TYPE_ILS:
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LDA:
                case ApproachType.APPROACH_TYPE_SDF:
                    return RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                    return RunwayUtils.getBcFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
            }
        }
        return undefined;
    }
    /**
     * Gets the reference facility for an approach. Only ILS, LOC (BC), LDA, SDF, VOR(DME), and NDB(DME) approaches can
     * have reference facilities.
     * @param approach The approach for which to get a reference facility.
     * @param facLoader The facility loader.
     * @returns A Promise which is fulfilled with the reference facility for the specified approach, or `undefined` if
     * one could not be found.
     */
    static async getReferenceFacility(approach, facLoader) {
        let facilityType;
        let isLoc = false;
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
                isLoc = true;
            // eslint-disable-next-line no-fallthrough
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                facilityType = FacilityType.VOR;
                break;
            case ApproachType.APPROACH_TYPE_NDB:
            case ApproachType.APPROACH_TYPE_NDBDME:
                facilityType = FacilityType.NDB;
                break;
            default:
                return undefined;
        }
        const finalLegs = approach.finalLegs;
        // Find the faf
        let fafLeg = undefined;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = finalLegs[i];
            if (BitFlags.isAll(leg.fixTypeFlags, FixTypeFlags.FAF)) {
                fafLeg = leg;
                break;
            }
        }
        if (!fafLeg) {
            return undefined;
        }
        if (!ICAO.isFacility(fafLeg.originIcao, facilityType)) {
            return undefined;
        }
        try {
            const facility = await facLoader.getFacility(facilityType, fafLeg.originIcao);
            if (isLoc && facility.type !== VorType.ILS) {
                return undefined;
            }
            else {
                return facility;
            }
        }
        catch (_a) {
            return undefined;
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
const airportIcaoRegionPattern = new RegExp(/^A../);
/**
 * A type map of facility type to facility search type.
 */
({
    /** Airport facility type. */
    [FacilityType.Airport]: FacilitySearchType.Airport,
    /** Intersection facility type. */
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    /** NDB facility type. */
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    /** VOR facility type. */
    [FacilityType.VOR]: FacilitySearchType.Vor,
    /** USR facility type. */
    [FacilityType.USR]: FacilitySearchType.User,
    /** Visual facility type. */
    [FacilityType.VIS]: FacilitySearchType.Visual
});
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => FacilityLoader.init(), 2000);
            }, true);
        }
        this.awaitInitialization().then(() => this.onInitialized());
    }
    /**
     * Initializes this facility loader.
     */
    static init() {
        FacilityLoader.isInitialized = true;
        for (const resolve of this.initPromiseResolveQueue) {
            resolve();
        }
        this.initPromiseResolveQueue.length = 0;
    }
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    awaitInitialization() {
        if (FacilityLoader.isInitialized) {
            return Promise.resolve();
        }
        else {
            return new Promise(resolve => {
                FacilityLoader.initPromiseResolveQueue.push(resolve);
            });
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        // Remove the region code from the icao
        if (type === FacilityType.Airport) {
            icao = icao.replace(airportIcaoRegionPattern, 'A  ');
        }
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const cachedFac = cache.get(icao);
        if (cachedFac !== undefined) {
            return Promise.resolve(cachedFac);
        }
        const currentTime = Date.now();
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            if (request !== undefined) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                Coherent.call(type, icao).then((isValid) => {
                    if (!isValid) {
                        rejection(`Facility ${icao} could not be found.`);
                        queue.delete(icao);
                    }
                });
            });
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            queue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startNearestSearchSession(type) {
        switch (type) {
            case FacilitySearchType.User:
            case FacilitySearchType.Visual:
                return this.startRepoNearestSearchSession(type);
            case FacilitySearchType.AllExceptVisual:
                return this.startCoherentNearestSearchSession(FacilitySearchType.All);
            default:
                return this.startCoherentNearestSearchSession(type);
        }
    }
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startCoherentNearestSearchSession(type) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestVorSearchSession(sessionId);
                break;
            case FacilitySearchType.Boundary:
                session = new NearestBoundarySearchSession(sessionId);
                break;
            default:
                session = new CoherentNearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    startRepoNearestSearchSession(type) {
        // Session ID doesn't really matter for these, so in order to not conflict with IDs from Coherent, we will set
        // them all to negative numbers
        const sessionId = FacilityLoader.repoSearchSessionId--;
        switch (type) {
            case FacilitySearchType.User:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            case FacilitySearchType.Visual:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            default:
                throw new Error();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        let results;
        if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
            const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
            results = await Coherent.call('SEARCH_BY_IDENT', ident, coherentFilter, maxItems);
        }
        else {
            results = [];
        }
        const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
        if (facRepositorySearchTypes) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, facRepositorySearchTypes);
        }
        return results;
    }
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
        const results = await this.searchByIdent(filter, ident, maxItems);
        if (!results) {
            return [];
        }
        const promises = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i];
            const facIdent = ICAO.getIdent(icao);
            if (facIdent === ident) {
                const facType = ICAO.getFacilityType(icao);
                promises.push(this.getFacility(facType, icao));
            }
        }
        const foundFacilities = await Promise.all(promises);
        if (foundFacilities.length > 1) {
            foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
            return foundFacilities;
        }
        else if (foundFacilities.length === 1) {
            return foundFacilities;
        }
        else {
            return [];
        }
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const isMismatch = facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W';
        const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
        const request = queue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, isMismatch);
            queue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session instanceof CoherentNearestSearchSession) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
};
FacilityLoader.repoSearchSessionId = -1;
FacilityLoader.isInitialized = false;
FacilityLoader.initPromiseResolveQueue = [];
/**
 * A session for searching for nearest facilities through Coherent.
 */
class CoherentNearestSearchSession {
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
        Coherent.call('SET_NEAREST_EXTENDED_AIRPORT_FILTERS', this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
}
/**
 * Default filters for the nearest airports search session.
 */
NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
};
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     * @param showTerminalWaypoints Whether or not to show terminal waypoints. Defaults to true.
     */
    setIntersectionFilter(typeMask, showTerminalWaypoints = true) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask, showTerminalWaypoints ? 1 : 0);
    }
}
/**
 * Default filters for the nearest intersections search session.
 */
NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
};
/**
 * A session for searching for nearest VORs.
 */
class NearestVorSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
        Coherent.call('SET_NEAREST_VOR_FILTER', this.sessionId, classMask, typeMask);
    }
}
/**
 * Default filters for the nearest VORs search session.
 */
NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
};
/**
 * A session for searching for nearest airspace boundaries.
 */
class NearestBoundarySearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask) {
        Coherent.call('SET_NEAREST_BOUNDARY_FILTER', this.sessionId, classMask);
    }
}
/**
 * A session for searching for nearest facilities that uses the facility repository.
 */
class NearestRepoFacilitySearchSession {
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo, sessionId) {
        this.repo = repo;
        this.sessionId = sessionId;
        this.filter = undefined;
        this.cachedResults = new Set();
        this.searchId = 0;
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
        const added = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i].icao;
            if (this.cachedResults.has(icao)) {
                this.cachedResults.delete(icao);
            }
            else {
                added.push(icao);
            }
        }
        const removed = Array.from(this.cachedResults);
        this.cachedResults.clear();
        for (let i = 0; i < results.length; i++) {
            this.cachedResults.add(results[i].icao);
        }
        return Promise.resolve({
            sessionId: this.sessionId,
            searchId: this.searchId++,
            added,
            removed
        });
    }
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter) {
        this.filter = filter;
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
class BinaryHeap {
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
        this.comparator = comparator;
        this.tree = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
        return this.tree.length;
    }
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
        return this.tree[0];
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
        if (this.tree.length === 0) {
            return undefined;
        }
        const min = this.tree[0];
        this.swap(0, this.tree.length - 1);
        this.tree.length--;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
        this.tree.push(element);
        this.heapifyUp(this.tree.length - 1);
        return this;
    }
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element) {
        if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
            return element;
        }
        return this.removeMinAndInsert(element);
    }
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element) {
        const min = this.tree[0];
        this.tree[0] = element;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
        this.tree.length = 0;
        return this;
    }
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyUp(index) {
        let parent = BinaryHeap.parent(index);
        while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
            this.swap(parent, index);
            index = parent;
            parent = BinaryHeap.parent(index);
        }
    }
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyDown(index) {
        const len = this.tree.length;
        while (index < len) {
            const left = BinaryHeap.left(index);
            const right = BinaryHeap.right(index);
            let needSwapFlags = 0;
            if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
                needSwapFlags |= 1;
            }
            if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
                needSwapFlags |= 2;
            }
            if (needSwapFlags === 3) {
                needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
            }
            if (needSwapFlags === 0) {
                break;
            }
            const swapChild = needSwapFlags === 1 ? left : right;
            this.swap(index, swapChild);
            index = swapChild;
        }
    }
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    swap(index1, index2) {
        const old1 = this.tree[index1];
        this.tree[index1] = this.tree[index2];
        this.tree[index2] = old1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    static left(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    static right(index) {
        return index * 2 + 2;
    }
}

/**
 * A sorted array.
 */
class SortedArray {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index.
     * @param index An index.
     * @returns The element at the specified index.
     * @throws RangeError if index is out of bounds.
     */
    get(index) {
        if (index < 0 || index >= this._array.length) {
            throw new RangeError();
        }
        return this._array[index];
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    peek(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array.
     * @returns The first element in this array.
     * @throws RangeError if this array is empty.
     */
    first() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[0];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    peekFirst() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array.
     * @returns The last element in this array.
     * @throws RangeError if this array is empty.
     */
    last() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[this._array.length - 1];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    peekLast() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Removes an element at a specific index from this array and returns it.
     * @param index The index of the element to remove.
     * @returns The removed element, or `undefined` if no element was removed.
     */
    removeAt(index) {
        if (index < 0 || index >= this._array.length) {
            return undefined;
        }
        return this._array.splice(index, 1)[0];
    }
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop() {
        return this._array.pop();
    }
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift() {
        return this._array.shift();
    }
    /**
     * Re-sorts this array using its sorting function.
     */
    resort() {
        this._array.sort(this.comparatorFunc);
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A linearly interpolated N-dimensional lookup table.
 */
class LerpLookupTable {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg) {
        this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
        if (typeof arg === 'number') {
            this._dimensionCount = isNaN(arg) ? 0 : Math.max(0, arg);
            return;
        }
        const leastDimension = arg.reduce((accum, current) => (current.length < accum.length) ? current : accum);
        this._dimensionCount = Math.max(0, leastDimension ? (leastDimension.length - 1) : 0);
        if (this._dimensionCount === 0) {
            return;
        }
        for (let i = 0; i < arg.length; i++) {
            this.insertBreakpoint(arg[i]);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
        return this._dimensionCount;
    }
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table');
        }
        if (breakpoint.length - 1 < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
        }
        this.insertBreakpointHelper(breakpoint, 0, this.table);
        return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
        const dimensionKey = breakpoint[dimension + 1];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        if (dimension === this._dimensionCount - 1) {
            let match = array.match(query);
            if (!match) {
                match = { key: dimensionKey, value: breakpoint[0] };
                array.insert(match);
            }
        }
        else {
            let next = array.match(query);
            if (!next) {
                array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
        }
    }
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot look up a key in a 0-dimensional table');
        }
        if (key.length < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
        }
        const value = this.lookupHelper(key, 0, this.table);
        if (value === undefined) {
            throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
        }
        return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray) {
        const dimensionKey = key[dimension];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        const index = lookupArray.matchIndex(query);
        let start;
        let end;
        if (index >= 0) {
            start = lookupArray.peek(index);
            end = start;
        }
        else {
            start = lookupArray.peek(-index - 2);
            end = lookupArray.peek(-index - 1);
            if (!start) {
                start = end;
            }
            if (!end) {
                end = start;
            }
        }
        if (!start || !end) {
            return undefined;
        }
        let startValue;
        let endValue;
        if (dimension === this.dimensionCount - 1) {
            startValue = start.value;
            endValue = end.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            startValue = this.lookupHelper(key, dimension + 1, start.array);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            endValue = this.lookupHelper(key, dimension + 1, end.array);
        }
        if (startValue === undefined || endValue === undefined) {
            return undefined;
        }
        if (startValue === endValue) {
            return startValue;
        }
        return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
}
LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
LerpLookupTable.tempBreakpoint = { key: 0 };

/**
 * A k-dimensional search tree.
 */
class KdTree {
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount, keyFunc) {
        this.keyFunc = keyFunc;
        this.elements = [];
        this.keys = [];
        this.nodes = [];
        this.minDepth = -1;
        this.maxDepth = -1;
        this.dimensionCount = Math.trunc(dimensionCount);
        if (this.dimensionCount < 2) {
            throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
        }
        this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
        this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
            return (a, b) => {
                const aKey = this.keys[a];
                const bKey = this.keys[b];
                for (let i = 0; i < this.dimensionCount; i++) {
                    const dimension = (i + index) % this.dimensionCount;
                    if (aKey[dimension] < bKey[dimension]) {
                        return -1;
                    }
                    else if (aKey[dimension] > bKey[dimension]) {
                        return 1;
                    }
                }
                return 0;
            };
        });
        this.keyCache = [
            new Float64Array(this.dimensionCount)
        ];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements in this tree. */
    get size() {
        return this.elements.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    searchKey(key, radius, arg3, out, filter) {
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(undefined, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(undefined, key, radius, arg3);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(element, radius, arg3, out, filter) {
        const key = this.keyFunc(element, this.keyCache[0]);
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(element, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(element, key, radius, arg3);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(element, key, radius, visitor) {
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            return visitor(elementInner, keyInner, distance, queryKey, queryElement);
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            return searchRadius + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
        if (maxResultCount <= 0) {
            out.length = 0;
            return out;
        }
        const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
                if (heap.size === maxResultCount) {
                    heap.insertAndRemoveMin(elementIndex);
                }
                else {
                    heap.insert(elementIndex);
                }
            }
            return true;
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            let maxDist = searchRadius;
            if (heap.size === maxResultCount) {
                maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
            }
            return maxDist + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
        out.length = heap.size;
        for (let i = out.length - 1; i >= 0; i--) {
            out[i] = this.elements[heap.removeMin()];
        }
        return out;
    }
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
        const elementIndex = this.nodes[nodeIndex];
        if (elementIndex === undefined) {
            return true;
        }
        const nodeKey = this.keys[elementIndex];
        const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
        if (distanceFromNode <= radius) {
            if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
                return false;
            }
        }
        const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        const lesserNodeIndex = KdTree.lesser(nodeIndex);
        const greaterNodeIndex = KdTree.greater(nodeIndex);
        if (this.nodes[lesserNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, -1)) {
            if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        if (this.nodes[greaterNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, 1)) {
            if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        const insertDepth = this.insertElementInTree(element) + 1;
        this.maxDepth = Math.max(this.maxDepth, insertDepth);
        if (insertDepth === this.minDepth + 1) {
            this.minDepth = KdTree.depth(this.nodes.indexOf(undefined, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
        }
        // Rebalance the tree if max depth is greater than twice the min depth.
        if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
            this.rebuild();
        }
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        for (const element of elements) {
            this.elements.push(element);
            this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
            const insertedIndex = this.elements.length - 1;
            for (let i = 0; i < this.dimensionCount; i++) {
                this.indexArrays[i].push(insertedIndex);
            }
        }
        this.rebuild();
    }
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    insertElementInTree(element) {
        const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
        let index = 0;
        let depth = 0;
        let elementIndex;
        while ((elementIndex = this.nodes[index]) !== undefined) {
            const pivotDimension = depth % this.dimensionCount;
            const keyToCompare = key[pivotDimension];
            if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
                index = KdTree.lesser(index);
            }
            else {
                index = KdTree.greater(index);
            }
            depth++;
        }
        this.elements.push(element);
        this.keys.push(key);
        const insertedIndex = this.elements.length - 1;
        this.nodes[index] = insertedIndex;
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].push(insertedIndex);
        }
        return depth;
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        if (!this.removeElementFromArrays(element)) {
            return false;
        }
        this.resetIndexArrays();
        this.rebuild();
        return true;
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        let removed = false;
        for (const element of elements) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
            this.rebuild();
        }
        return removed;
    }
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    removeElementFromArrays(element) {
        const index = this.elements.indexOf(element);
        if (index < 0) {
            return false;
        }
        const lastIndex = this.elements.length - 1;
        this.elements[index] = this.elements[lastIndex];
        this.keys[index] = this.keys[lastIndex];
        this.elements.length--;
        this.keys.length--;
        return true;
    }
    /**
     * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
     * number of elements in the tree.
     */
    resetIndexArrays() {
        for (let i = 0; i < this.dimensionCount; i++) {
            const array = this.indexArrays[i];
            array.length = this.elements.length;
            for (let j = 0; j < array.length; j++) {
                array[j] = j;
            }
        }
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        let removed = false;
        for (const element of toRemove) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
        }
        this.insertAll(toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        // clear the tree structure
        this.nodes.length = 0;
        if (this.size === 0) {
            return;
        }
        // sort index arrays
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].sort(this.indexSortFuncs[i]);
        }
        this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
        const log = Math.log2(this.elements.length + 1);
        this.minDepth = Math.floor(log) - 1;
        this.maxDepth = Math.ceil(log) - 1;
    }
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    buildSubTree(nodeIndex, pivotDimension, start, end) {
        const tempArray = this.indexArrays[this.dimensionCount];
        const sortedArray = this.indexArrays[0];
        const medianIndex = Math.trunc((start + end) / 2);
        const medianKeyIndex = sortedArray[medianIndex];
        // Insert median into its position in the tree
        this.nodes[nodeIndex] = medianKeyIndex;
        if (end - start === 1) {
            return;
        }
        if (end - start <= 3) {
            const lesserIndex = medianIndex - 1;
            const greaterIndex = medianIndex + 1;
            if (lesserIndex >= start) {
                this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
            }
            if (greaterIndex < end) {
                this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
            }
            return;
        }
        for (let i = start; i < end; i++) {
            tempArray[i] = sortedArray[i];
        }
        // Partition the index arrays not in the pivot dimension around the median key in the pivot dimension and at the
        // same time rotate the index arrays such that the index array sorted in the next pivot dimension is located at
        // index 0.
        for (let i = 1; i < this.dimensionCount; i++) {
            const targetArray = this.indexArrays[i - 1];
            const toPartitionArray = this.indexArrays[i];
            let lesserCount = 0;
            let greaterCount = 0;
            for (let j = start; j < end; j++) {
                const keyIndex = toPartitionArray[j];
                if (keyIndex === medianKeyIndex) {
                    targetArray[medianIndex] = keyIndex;
                }
                else {
                    const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
                    if (comparison <= 0) {
                        const index = start + (lesserCount++);
                        targetArray[index] = keyIndex;
                    }
                    else {
                        const index = medianIndex + 1 + (greaterCount++);
                        targetArray[index] = keyIndex;
                    }
                }
            }
        }
        // Copy the temporary array (now containing the sorted indexes in the pivot dimension) to the last index array.
        const newSortedArray = this.indexArrays[this.dimensionCount - 1];
        for (let i = start; i < end; i++) {
            newSortedArray[i] = tempArray[i];
        }
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
        this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.elements.length = 0;
        this.keys.length = 0;
        this.nodes.length = 0;
        for (let i = 0; i < this.indexArrays.length; i++) {
            this.indexArrays[i].length = 0;
        }
        this.minDepth = -1;
        this.maxDepth = -1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    static lesser(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    static greater(index) {
        return index * 2 + 2;
    }
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    static leastIndexAtDepth(depth) {
        return 1 << depth - 1;
    }
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    static depth(index) {
        return Math.trunc(Math.log2(index + 1));
    }
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    static distance(key1, key2, dimensionCount) {
        let sumSq = 0;
        for (let i = 0; i < dimensionCount; i++) {
            const diff = key1[i] - key2[i];
            sumSq += diff * diff;
        }
        return Math.sqrt(sumSq);
    }
}

/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
class GeoKdTree {
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc) {
        this.keyFunc = keyFunc;
        this.cartesianTree = new KdTree(3, (element, out) => {
            const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
            out[0] = vec[0];
            out[1] = vec[1];
            out[2] = vec[2];
            return out;
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
        let center, radius;
        let argA, argB, argC;
        if (typeof arg1 === 'number') {
            center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
            radius = arg3;
            argA = arg4;
            argB = arg5;
            argC = arg6;
        }
        else if (!(arg1 instanceof Float64Array)) {
            center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        else {
            center = arg1;
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
        if (typeof argA === 'number') {
            return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
        }
        else {
            this.doVisitorSearch(center, radiusCartesian, argA);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(center, radiusCartesian, visitor) {
        this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
            const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
            const greatCircleDist = GeoPoint.distance(vec, center);
            return visitor(element, vec, greatCircleDist, center);
        });
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
        const cartesianFilter = filter
            ? (element, key) => {
                const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
                const greatCircleDist = GeoPoint.distance(vec, center);
                return filter(element, vec, greatCircleDist, center);
            }
            : undefined;
        return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        this.cartesianTree.insert(element);
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        this.cartesianTree.insertAll(elements);
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        return this.cartesianTree.remove(element);
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        return this.cartesianTree.removeAll(elements);
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        this.cartesianTree.rebuild();
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.cartesianTree.clear();
    }
}
GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];

/**
 * Types of subscribable array change event.
 */
var SubscribableArrayEventType;
(function (SubscribableArrayEventType) {
    /** An element was added. */
    SubscribableArrayEventType["Added"] = "Added";
    /** An element was removed. */
    SubscribableArrayEventType["Removed"] = "Removed";
    /** The array was cleared. */
    SubscribableArrayEventType["Cleared"] = "Cleared";
})(SubscribableArrayEventType || (SubscribableArrayEventType = {}));

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class AbstractSubscribableArray {
    constructor() {
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this array.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
        const array = this.getArray();
        if (index > array.length - 1) {
            throw new Error('Index out of range');
        }
        return array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
        return this.getArray()[index];
    }
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    notify(index, type, modifiedItem) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(index, type, modifiedItem, this.getArray());
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(index, type, modifiedItem, this.getArray());
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const array = this.getArray();
        sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
}

/**
 * Types of facility repository sync events.
 */
var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType["Add"] = "Add";
    FacilityRepositorySyncType["Remove"] = "Remove";
    FacilityRepositorySyncType["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType["DumpResponse"] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRepository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.repos = new Map();
        this.trees = {
            [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
            [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        };
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        // Request a dump from any existing instances on other instruments to initialize the repository.
        this.pubSyncEvent({
            type: FacilityRepositorySyncType.DumpRequest, uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
        });
    }
    /**
     * Gets the number of facilities stored in this repository.
     * @param types The types of facilities to count. Defaults to all facility types.
     * @returns The number of facilities stored in this repository.
     */
    size(types) {
        var _a, _b;
        let size = 0;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                size += repo.size;
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
            }
        }
        return size;
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(type, lat, lon, radius, arg5, out, filter) {
        if (type !== FacilityType.USR && type !== FacilityType.VIS) {
            throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
        }
        if (typeof arg5 === 'number') {
            return this.trees[type].search(lat, lon, radius, arg5, out, filter);
        }
        else {
            this.trees[type].search(lat, lon, radius, arg5);
        }
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
        }
        this.addToRepo(fac);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    /**
     * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
     * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
     * replaced with the new one.
     * @param facs The facilities to add.
     */
    addMultiple(facs) {
        this.addMultipleToRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        if (!ICAO.isFacility(icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
        }
        this.removeFromRepo(icao);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    /**
     * Removes multiple facilities from this repository and all other repositories synced with this one.
     * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
     */
    removeMultiple(facs) {
        this.removeMultipleFromRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map(fac => typeof fac === 'object' ? fac.icao : fac) });
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                repo.forEach(fn);
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
            }
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === undefined) {
            this.repos.set(facilityType, repo = new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            if (existing === undefined) {
                this.trees[facilityType].insert(fac);
            }
            else {
                this.trees[facilityType].removeAndInsert([existing], [fac]);
            }
        }
        if (existing === undefined) {
            this.publisher.pub('facility_added', fac, false, false);
        }
        else {
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Adds multiple facilities to this repository.
     * @param facs The facilities to add.
     */
    addMultipleToRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const addedFacilities = [];
        const changedFacilitiesRemoved = [];
        const changedFacilitiesAdded = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const facilityType = ICAO.getFacilityType(fac.icao);
            let repo = this.repos.get(facilityType);
            if (repo === undefined) {
                this.repos.set(facilityType, repo = new Map());
            }
            const existing = repo.get(fac.icao);
            repo.set(fac.icao, fac);
            if (existing === undefined) {
                addedFacilities.push(fac);
            }
            else {
                changedFacilitiesRemoved.push(existing);
                changedFacilitiesAdded.push(fac);
            }
        }
        const addedUserFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (addedUserFacilities.length > 0) {
            const removedUserFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
            this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
        }
        const addedVisFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (addedVisFacilities.length > 0) {
            const removedVisFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
            this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
        }
        for (let i = 0; i < addedFacilities.length; i++) {
            const fac = addedFacilities[i];
            this.publisher.pub('facility_added', fac, false, false);
        }
        for (let i = 0; i < changedFacilitiesAdded.length; i++) {
            const fac = changedFacilitiesAdded[i];
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     */
    removeFromRepo(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        const facilityType = ICAO.getFacilityType(icao);
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === undefined) {
            return;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === undefined) {
            return;
        }
        repo.delete(icao);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            this.trees[facilityType].remove(facilityInRepo);
        }
        this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
        this.publisher.pub('facility_removed', facilityInRepo, false, false);
    }
    /**
     * Removes multiple facilities from this repository.
     * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
     */
    removeMultipleFromRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const removedFacilities = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const icao = typeof fac === 'string' ? fac : fac.icao;
            const repo = this.repos.get(ICAO.getFacilityType(icao));
            if (repo === undefined) {
                continue;
            }
            const facilityInRepo = repo.get(icao);
            if (facilityInRepo === undefined) {
                continue;
            }
            repo.delete(icao);
            removedFacilities.push(facilityInRepo);
        }
        const removedUserFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (removedUserFacilities.length > 0) {
            this.trees[FacilityType.USR].removeAll(removedUserFacilities);
        }
        const removedVisFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (removedVisFacilities.length > 0) {
            this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
        }
        for (let i = 0; i < removedFacilities.length; i++) {
            const removedFac = removedFacilities[i];
            this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
            this.publisher.pub('facility_removed', removedFac, false, false);
        }
    }
    /**
     * Publishes a facility added or removed sync event over the event bus.
     * @param data The event data.
     */
    pubSyncEvent(data) {
        this.ignoreSync = true;
        this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.DumpResponse:
                // Only accept responses to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    break;
                }
                else {
                    this.lastDumpRequestUid = undefined;
                }
            // eslint-disable-next-line no-fallthrough
            case FacilityRepositorySyncType.Add:
                if (data.facs.length === 1) {
                    this.addToRepo(data.facs[0]);
                }
                else {
                    this.addMultipleToRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.Remove:
                if (data.facs.length === 1) {
                    this.removeFromRepo(data.facs[0]);
                }
                else {
                    this.removeMultipleFromRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.DumpRequest:
                // Don't respond to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRepository.INSTANCE = new FacilityRepository(bus));
    }
}
FacilityRepository.SYNC_TOPIC = 'facilityrepo_sync';
FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
};

/**
 * A task queue backed by an array.
 */
class ArrayTaskQueue {
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks) {
        this.tasks = tasks;
        this.head = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    hasNext() {
        return this.head < this.tasks.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    next() {
        return this.tasks[this.head++];
    }
}

/**
 * A process which dispatches tasks in a task queue potentially over multiple frames.
 */
class ThrottledTaskQueueProcess {
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue, handler) {
        this.queue = queue;
        this.handler = handler;
        this._hasStarted = false;
        this._hasEnded = false;
        this._shouldAbort = false;
    }
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted() {
        return this._hasStarted;
    }
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded() {
        return this._hasEnded;
    }
    /**
     * Starts this process.
     */
    start() {
        this._hasStarted = true;
        this.processQueue(0);
    }
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    processQueue(elapsedFrameCount) {
        let dispatchCount = 0;
        const t0 = performance.now();
        while (!this._shouldAbort && this.queue.hasNext()) {
            if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
                const task = this.queue.next();
                task();
                dispatchCount++;
            }
            else {
                break;
            }
        }
        if (this._shouldAbort) {
            return;
        }
        if (!this.queue.hasNext()) {
            this.handler.onFinished(elapsedFrameCount);
            this._hasEnded = true;
        }
        else {
            this.handler.onPaused(elapsedFrameCount);
            requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
        }
    }
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort() {
        if (this._hasStarted && !this._hasEnded) {
            this.handler.onAborted();
            this._shouldAbort = true;
            this._hasEnded = true;
        }
    }
}

/**
 * A nearest search session for boundaries (airspaces) in the form of LodBoundary objects.
 */
class NearestLodBoundarySearchSession {
    /**
     * Constructor.
     * @param cache The boundary cache this search session uses.
     * @param session The nearest boundary facility search session this search session uses.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     */
    constructor(cache, session, frameBudget) {
        this.cache = cache;
        this.session = session;
        this.frameBudget = frameBudget;
    }
    /**
     * Searches for the nearest boundaries around a specified location.
     * @param lat The latitude of the search center, in degrees.
     * @param lon The longitude of the search center, in degrees.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items for which to search.
     * @returns The nearest search results.
     */
    async searchNearest(lat, lon, radius, maxItems) {
        const facilityResults = await this.session.searchNearest(lat, lon, radius, maxItems);
        const results = { added: [], removed: facilityResults.removed };
        const tasks = facilityResults.added.map((fac, index) => () => { results.added[index] = this.cache.get(fac); });
        await new Promise(resolve => {
            const taskQueue = new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget, resolve));
            taskQueue.start();
        });
        return results;
    }
    /**
     * Sets this session's boundary class filter. The new filter takes effect with the next search executed in this
     * session.
     * @param classMask A bitmask defining the boundary classes to include in the search (`0`: exclude, `1`: include).
     * The bit index for each boundary class is equal to the value of the corresponding `BoundaryType` enum.
     */
    setFilter(classMask) {
        this.session.setBoundaryFilter(classMask);
    }
}
/**
 * A throttled task queue handler for retrieving and creating new LodBoundary objects in response to a nearest search.
 */
class NearestLodBoundarySearchTaskQueueHandler {
    /**
     * Constructor.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     * @param resolve The Promise resolve function this handler will call when the task queue is finished.
     */
    constructor(frameBudget, resolve) {
        this.frameBudget = frameBudget;
        this.resolve = resolve;
    }
    /** @inheritdoc */
    onStarted() {
        // noop
    }
    /** @inheritdoc */
    canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
        return timeElapsed < this.frameBudget;
    }
    /** @inheritdoc */
    onPaused() {
        // noop
    }
    /** @inheritdoc */
    onFinished() {
        this.resolve();
    }
    /** @inheritdoc */
    onAborted() {
        // noop
    }
}

/**
 * The transition type to which a flight path vector belongs.
 */
var FlightPathVectorFlags;
(function (FlightPathVectorFlags) {
    FlightPathVectorFlags[FlightPathVectorFlags["None"] = 0] = "None";
    /** A turn to a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["TurnToCourse"] = 1] = "TurnToCourse";
    /** An arcing turn to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Arc"] = 2] = "Arc";
    /** A direct course to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Direct"] = 4] = "Direct";
    /** A path to intercept a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["InterceptCourse"] = 8] = "InterceptCourse";
    /** Inbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    /** Outbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    /** A direct hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    /** A teardrop hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    /** A parallel hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    /** A course reversal. */
    FlightPathVectorFlags[FlightPathVectorFlags["CourseReversal"] = 512] = "CourseReversal";
    /** A turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["LegToLegTurn"] = 1024] = "LegToLegTurn";
    /** An anticipated turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    /** A fallback path. */
    FlightPathVectorFlags[FlightPathVectorFlags["Fallback"] = 4096] = "Fallback";
})(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        // *********************************************************************************************************
        // ******** When adding new fields, they MUST be initialized, even if it just gets set to undefined ********
        // ******** This is so that it can be used with Object.keys()                                       ********
        // *********************************************************************************************************
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction. */
        this.originRunway = undefined;
        /** The ICAO for the facility associated with the departure procedure. */
        this.departureFacilityIcao = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The ICAO for the facility associated with the arrival procedure. */
        this.arrivalFacilityIcao = undefined;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The arrival runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.arrivalRunway = undefined;
        /** The ICAO for the facility associated with the approach procedure. */
        this.approachFacilityIcao = undefined;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /** The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
/**
 * Bitflags describing a leg definition.
 */
var LegDefinitionFlags;
(function (LegDefinitionFlags) {
    LegDefinitionFlags[LegDefinitionFlags["None"] = 0] = "None";
    LegDefinitionFlags[LegDefinitionFlags["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags[LegDefinitionFlags["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags[LegDefinitionFlags["Obs"] = 4] = "Obs";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
})(LegDefinitionFlags || (LegDefinitionFlags = {}));
/**
 * Vertical flight phase.
 */
var VerticalFlightPhase;
(function (VerticalFlightPhase) {
    VerticalFlightPhase["Climb"] = "Climb";
    VerticalFlightPhase["Descent"] = "Descent";
})(VerticalFlightPhase || (VerticalFlightPhase = {}));
var SpeedUnit;
(function (SpeedUnit) {
    SpeedUnit[SpeedUnit["IAS"] = 0] = "IAS";
    SpeedUnit[SpeedUnit["MACH"] = 1] = "MACH";
})(SpeedUnit || (SpeedUnit = {}));
/** Types of speed restrictions on legs. */
var SpeedRestrictionType;
(function (SpeedRestrictionType) {
    SpeedRestrictionType[SpeedRestrictionType["Unused"] = 0] = "Unused";
    SpeedRestrictionType[SpeedRestrictionType["At"] = 1] = "At";
    SpeedRestrictionType[SpeedRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType[SpeedRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType[SpeedRestrictionType["Between"] = 4] = "Between";
})(SpeedRestrictionType || (SpeedRestrictionType = {}));

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            flags: FlightPathVectorFlags.None,
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector, circle, start, end, flags) {
        vector.flags = flags;
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the direction of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The direction of the turn described by the flight path circle vector.
     */
    static getVectorTurnDirection(vector) {
        return vector.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
     */
    static getVectorTurnRadius(vector) {
        return Math.min(vector.radius, Math.PI - vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the true course for a flight plan leg.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
     * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
     * @returns The true course for the specified flight plan leg.
     */
    static getLegTrueCourse(leg, point, magVarFacility) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const magVar = magVarFacility
            ? -magVarFacility.magneticVariation // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.reverse();
        }
        return out;
    }
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle, out) {
        return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > MathUtils.HALF_PI
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Gets the great circle tangent to a given path at a given tangent point. The tangent circle will contain the
     * tangent point and have the same direction as the path at the tangent point.
     * @param point The tangent point. If the point does not lie on the path, it will be projected onto the path.
     * @param path The geo circle describing the path.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified path at the specified point.
     */
    static getGreatCircleTangentToPath(point, path, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(path.center, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Gets the great circle tangent to a given flight path vector at a given tangent point. The tangent circle will
     * contain the tangent point and have the same direction as the vector at the tangent point.
     * @param point The tangent point. If the point does not lie on the vector, it will be projected onto the vector.
     * @param vector The flight path vector.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified flight path vector at the specified point.
     */
    static getGreatCircleTangentToVector(point, vector, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const centerVec = Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[1]);
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(centerVec, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
        }
        const radius = turnDirection === 'left'
            ? turnRadius
            : Math.PI - turnRadius;
        const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
        const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
        return out.set(turnCenter, radius);
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
            return posAngularDistance >= Math.PI ? -Infinity : Infinity;
        }
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angularTolerance = circle.angularWidth(tolerance);
        if (typeof end !== 'number') {
            end = circle.angleAlong(start, end, Math.PI, angularTolerance);
        }
        if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const angle = circle.angleAlong(start, pos, Math.PI);
        if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
        return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static projectVelocityToCircle(speed, position, direction, projectTo) {
        if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return NaN;
        }
        if (speed === 0) {
            return 0;
        }
        if (!(position instanceof Float64Array)) {
            position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
        }
        const velocityPath = typeof direction === 'number'
            ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction)
            : direction.isGreatCircle()
                ? direction
                : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
        const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
        const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
        const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
        const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
        const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
        return speed * sinTheta * sign;
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress(legCalc) {
        var _a, _b, _c, _d, _e, _f;
        var _g, _h, _j, _k, _l, _m;
        const vectors = legCalc.ingressToEgress;
        let vectorIndex = 0;
        let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
        const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
        const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
        const firstEgressVector = legCalc.egress[0];
        const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
        if (lastIngressVector && ingressJoinVector) {
            // Check if the last ingress vector joins the base flight path before the end of a vector. If so, we need to
            // replace the base flight path vector the ingress joins with a shortened version starting where the ingress
            // ends.
            const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
            const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector
                ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon)
                : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
            const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
            const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
            if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
                // Ingress joins the base flight path before the end of the joined vector.
                if (ingressEndAlongVectorDistance > normalizedTolerance) {
                    // Ingress joins the base flight path after the start of the joined vector.
                    ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
                    FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : (vectors[_g] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
                }
                else {
                    // Ingress joins the base flight path at or before the start of the joined vector.
                    Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : (vectors[_h] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVector);
                }
            }
            flightPathVectorIndex++;
        }
        const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
        for (let i = flightPathVectorIndex; i < end; i++) {
            Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : (vectors[_j] = FlightPathUtils.createEmptyCircleVector()), legCalc.flightPath[i]);
            flightPathVectorIndex++;
        }
        if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
            if (firstEgressVector) {
                // Check if the first egress vector joins the base flight path in after the start of a vector. If so, we need
                // to replace the base flight path vector the egress joins with a shortened version starting where the egress
                // starts.
                const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
                const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
                const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
                const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
                if (egressStartAlongVectorDistance > normalizedTolerance) {
                    // Egress joins the base flight path after the start of the joined vector.
                    if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
                        // Egress joins the base flight path before the end of the joined vector.
                        egressJoinVectorCircle.closest(egressStart, egressStart);
                        FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : (vectors[_k] = FlightPathUtils.createEmptyCircleVector()), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                    }
                    else {
                        // Egress joins the base flight path at or after the end of the joined vector.
                        Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : (vectors[_l] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
                    }
                }
            }
            else {
                // There is no egress, but there is a base flight path vector flagged as the vector with which the egress
                // joins. This is technically an invalid state, but we can easily just treat this as a regular "no-egress"
                // case and copy the entire egress join vector into the resolved vectors array.
                Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : (vectors[_m] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
            }
        }
        vectors.length = vectorIndex;
        return legCalc;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
}
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg, flags) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        if (turnEndPoint.equals(start)) {
            return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle, flags = 0) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const intersectionIndex = (numIntersections === 1 || circle.encircles(start)) ? 0 : 1;
        const endVec = intersections[intersectionIndex];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
[
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
[new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths via a turn starting at the start
 * point followed by an angled intercept path which intercepts the final path before the end point.
 */
class InterceptGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
        }
        const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
        if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // initial and final paths are parallel
            return 0;
        }
        const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
        const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
        // The set of centers of great circles that intersect the end path at the desired intercept angle
        const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
        const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
        if (startTurnDirection === undefined) {
            // Calculate the intercept point if the intercept path were to pass through the start point.
            const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
            if (interceptCount === 0) {
                // No great-circle path passing through the start point can intercept the final path at the desired intercept angle.
                startTurnDirection = startPath.encircles(end) ? 'left' : 'right';
            }
            else {
                let intersectionIndex = 0;
                if (interceptCount > 1) {
                    // There are two great-circle paths passing through the start point that intercept the final path at the
                    // desired angle. One of them will be directed toward the end path and the other will be directed away from
                    // it. We want to choose the one directed toward it.
                    intersectionIndex = endPath.encircles(start) ? 0 : 1;
                }
                let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                // sin x ~= x for x near 0, so to check if the angle between the start path and intercept path is parallel or
                // antiparallel we just have to check the magnitude of their cross product instead of the arcsine of the
                // magnitude.
                if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                    // If start and intercept paths are parallel or antiparallel, it doesn't really matter which direction we
                    // turn, so we will just turn in the direction that aligns us with the end path.
                    cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                    if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                        // If start and end paths are antiparallel (they can't be parallel since we would have returned from the
                        // method by now), then we just arbitrarily choose to turn right.
                        startTurnDirection = 'right';
                    }
                    else {
                        startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                    }
                }
                else {
                    startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                }
            }
        }
        const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
        const endTurnRadiusRad = endTurnRadius === undefined ? undefined : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
        if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // If the desired intercept angle is 0 degrees, the only valid path is when the starting turn ends exactly on the
            // path to intercept and the end of the turn lies before the end point
            if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
                // starting turn is not tangent to path to intercept
                return 0;
            }
            const startTurnEnd = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd, end, Math.PI);
            if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                // the end of the starting turn lies after the end point.
                return 0;
            }
            return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        // Find the great-circle path that intersects the path to intercept at the desired intercept angle and is tangent
        // to the starting turn.
        // The set of centers of great circles that are tangent to the starting turn
        const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
        const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
        if (interceptPathCount === 0) {
            return 0;
        }
        const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
        let interceptCrossSign;
        if (startToEndPathAngleRad >= interceptAngleRad) {
            // The start turn is considered to overshoot if it crosses to the contralateral side of the final path before
            // joining the intercept path that requires the shortest turn to join. The contralateral side is defined as the
            // right side for left turns and the left side for right turns. If this occurs, we need to choose the second
            // intercept path (if it exists). This is because choosing the first intercept path would trigger a case below
            // that attempts to end the start turn early, which could produce a path that requires the plane to track toward
            // the final path at an angle greater than the intercept angle.
            const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
            const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
            interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
            interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === 'right') ? 1 : -1;
        }
        else {
            // If the start path intersects the final path at a shallower angle than the intercept path, then we always want
            // to choose the intercept path that requires the shortest turn to join. Even if the turn has overshot the final
            // path by the time it can join the chosen intercept path, we handle that case below by attempting to end the
            // start turn early. We are guaranteed that ending the start turn early will not result in a path that requires
            // the plane to track toward the final path at an angle greater than the intercept angle because if it did, that
            // would mean the start turn does not overshoot the final path and therefore we wouldn't have needed to end the
            // start turn early in the first place.
            interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
            interceptCrossSign = startTurnDirection === 'right' ? 1 : -1;
        }
        const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
        const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        // Required turn anticipation for the end turn to join the intercept and final paths.
        let minDInterceptEnd = 0;
        if (endTurnRadiusRad !== undefined) {
            const endTheta = Math.PI - interceptAngleRad;
            minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
            if (isNaN(minDInterceptEnd)) {
                // Turn radius is too large for the end turn to join the intercept and final paths
                return 0;
            }
        }
        const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
        if (interceptToEndOffset < minDInterceptEnd) {
            // The intercept path does not intercept the final path early enough to make the end turn before the end point
            return 0;
        }
        let vectorIndex = index;
        if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            // The start turn ends too late to make a turn to join the final path or the start turn overshoots the end path
            // before reaching the intercept course -> attempt to end the start turn early
            if (endTurnRadiusRad === undefined) {
                // We don't need to calculate a final turn, so attempt to end the start turn where it intersects the end path
                const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
                if (startTurnEndPathIntersectionCount === 0) {
                    return 0;
                }
                const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === 'right' ? 0 : 1];
                if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The start turn intercepts the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
            }
            else {
                // We need to calculate a final turn to join the end path. This final turn must be tangent to the starting turn
                // and the end path.
                const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the starting turn
                const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the end path
                const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === 'left' ? 1 : -1));
                const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
                if (endTurnCircleCount === 0) {
                    return 0;
                }
                const endTurnCenter = intersections[0];
                const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === 'left' ? 'right' : 'left', InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
                endTurnCircle.closest(startTurnCenter, startTurnEnd);
                const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The end turn joins the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
            }
        }
        else {
            if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
            }
            let interceptPathEnd = intercept;
            if (endTurnRadiusRad !== undefined) {
                interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
            }
            if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
            }
            if (endTurnRadius !== undefined) {
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
            }
        }
        return vectorIndex - index;
    }
}
InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
        this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
        }
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        // Calculate the relative directions of the start point, intersection point, and end point.
        const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
        // positive -> start point lies after the intersection (with respect to the direction of start path)
        const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        // positive -> end point lies after the intersection (with respect to the direction of end path)
        const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        // along-track distance from the intersection point to the start/end of the minimum-radius turn from start path to end path
        let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        if (isNaN(minD)) {
            // Turn radius is too large for any turn to join the start and end paths
            minD = Infinity;
        }
        const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
        const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
        const towardEndPointTurnDirection = startPath.encircles(end, false) ? 'left' : 'right';
        let needCalculateTwoTurnPath = false;
        let needCalculateOneTurnPath = false;
        if (isEndForwardOfIntersection) {
            if (desiredTurnDirection === undefined || desiredTurnDirection === towardEndPointTurnDirection) {
                const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
                const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
                if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
                    // The minimum turn radius is too large to intercept the final path before the end point
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
                else {
                    // Make a single constant-radius turn either starting at the start point, or ending at the end point,
                    // depending on which is closer to the intersection point.
                    const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
                    if (intersectionStartDistance <= intersectionEndDistance) {
                        // start turn at start point
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
                        if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
                        }
                    }
                    else {
                        // end turn at end point
                        let turnStart = start;
                        if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
                        }
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                    }
                }
            }
            else {
                if (pathDot >= 0) {
                    // The start and end paths intersect at an angle <= 90 degrees. This means that for a turn away from the end
                    // point, the total flight path distance is minimized when the turn joins the start and end paths directly.
                    if (intersectionStartOffset <= minD) {
                        // The start point lies at or before the required turn start point to minimize the flight path distance.
                        needCalculateOneTurnPath = true;
                    }
                    else {
                        needCalculateTwoTurnPath = !preferSingleTurn;
                        needCalculateOneTurnPath = preferSingleTurn;
                    }
                }
                else {
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
            }
        }
        else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
        }
        let needDirectFallback = false;
        if (needCalculateTwoTurnPath) {
            const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
            // Attempt to make a turn to intercept the end path at 45 degrees. At this point we are in fallback territory
            // so we won't honor the desired starting turn direction.
            const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, undefined, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
            if (numInterceptVectors === 0) {
                needDirectFallback = allowDirectFallback;
            }
            else {
                vectorIndex += numInterceptVectors;
                const lastVector = vectors[vectorIndex - 1];
                const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
                if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
                }
            }
        }
        else if (needCalculateOneTurnPath) {
            // Make a single constant-radius turn from the start path to join the end path. The turn must start after the
            // intersection of the start and end paths (the only case where the turn starts before the intersection is
            // handled above).
            if (minD > Math.PI / 2) {
                // No amount of anticipation can provide a turn which joins the start and end paths of the desired radius.
                needDirectFallback = allowDirectFallback;
            }
            else {
                const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
                const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
                const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
                const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
                if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
                }
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
                }
            }
        }
        if (needDirectFallback) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45; // degrees
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, undefined, flags);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, undefined, flags);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
class DirectToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
        let vectorIndex = index;
        if (typeof startPath === 'number') {
            startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
        }
        const endPos = DirectToPointBuilder.geoPointCache[0];
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            endPos.set(end);
            end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
        }
        else {
            endPos.setFromCartesian(end);
        }
        const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
        if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
            return vectorIndex - index;
        }
        else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
            return vectorIndex - index;
        }
        const startPathEncirclesTerminator = startPath.encircles(end);
        const startPathIncludesTerminator = startPath.includes(end);
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right');
        const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === 'left'
            ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2])
            : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
        const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
        // The angle between the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
        const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
        flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
        if (!GeoPoint.equals(turnEndVec, start)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
        }
        if (!GeoPoint.equals(turnEndVec, end)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, undefined, flags);
        }
        return vectorIndex - index;
    }
}
DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the magnetic variation, in degrees, to use when calculating a flight plan leg's course. If the leg defines
     * an origin or fix VOR facility, then the magnetic variation defined at the VOR is used. Otherwise the computed
     * magnetic variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The magnetic variation, in degrees, to use when calculating the specified flight plan leg's course.
     */
    getLegMagVar(leg, point) {
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR)) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR)) ? leg.fixIcao
                : undefined;
        const facility = facIcao !== undefined ? this.facilityCache.get(facIcao) : undefined;
        // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
        return facility === undefined ? MagVar.get(point) : -facility.magneticVariation;
    }
    /**
     * Gets the true course, in degrees, for a flight plan leg. If the leg defines an origin or fix VOR facility, then
     * the magnetic variation defined at the VOR is used to adjust magnetic course. Otherwise the computed magnetic
     * variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The true course, in degrees, for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    /** @inheritdoc */
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
        var _a, _b, _c;
        var _d;
        const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : (_d.calculated = {
            courseMagVar: 0,
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            distance: 0,
            distanceWithTransitions: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTransitions: 0,
            flightPath: [],
            ingress: [],
            ingressJoinIndex: -1,
            ingressToEgress: [],
            egressJoinIndex: -1,
            egress: [],
            endsInFallback: false
        });
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            state.isFallback = calcs.endsInFallback;
            return calcs;
        }
        try {
            this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
            this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
            resolveIngressToEgress && this.resolveIngressToEgress(calcs);
            calcs.endsInFallback = state.isFallback;
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
            vectors.length = 0;
            calcs.ingress.length = 0;
            calcs.ingressJoinIndex = 0;
            calcs.egress.length = 0;
            calcs.egressJoinIndex = -1;
            calcs.ingressToEgress.length = 0;
            calcs.endsInFallback = false;
            state.isFallback = false;
        }
        return calcs;
    }
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    resolveIngressToEgress(legCalc) {
        FlightPathUtils.resolveIngressToEgress(legCalc);
    }
}
/**
 * Calculates flight path vectors for legs with no path.
 */
class NoPathLegCalculator extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.courseMagVar = 0;
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.flightPath.length = 0;
        state.currentCourse = undefined;
        state.currentPosition = undefined;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            vectors.length = 0;
            state.isFallback = false;
            return;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            if (state.isFallback && state.currentCourse !== undefined) {
                vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
            }
            else {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            }
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            vectors.length = 0;
            return;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        let initialCourse;
        if (leg.course !== 0) {
            // If a course is defined on the leg, then honor it.
            initialCourse = leg.trueDegrees ? leg.course % 360 : MagVar.magneticToTrue(leg.course, startPoint);
        }
        else {
            if (state.currentCourse === undefined) {
                // If the current course from the previous leg is undefined, then attempt to select an initial course from
                // the definition of the previous leg, if one exists.
                const prevLeg = legs[calculateIndex - 1];
                switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) {
                    case LegType.CA:
                    case LegType.CF:
                    case LegType.CR:
                    case LegType.FA:
                    case LegType.FC:
                    case LegType.FD:
                    case LegType.FM:
                    case LegType.VA:
                    case LegType.VD:
                    case LegType.VM:
                    case LegType.VR:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.HA:
                        // If the previous leg defines a course, then use that course.
                        initialCourse = this.getLegTrueCourse(prevLeg.leg, startPoint);
                        break;
                    case LegType.IF:
                        // If the previous leg is an IF for a runway fix, then use runway heading as the initial course.
                        if (ICAO.isFacility(prevLeg.leg.fixIcao, FacilityType.RWY)) {
                            const runwayFix = this.facilityCache.get(prevLeg.leg.fixIcao);
                            if (runwayFix) {
                                initialCourse = runwayFix.runway.course;
                                break;
                            }
                        }
                    // eslint-disable-next-line no-fallthrough
                    default:
                        // If we can't select an initial course from the previous leg, then default to the course that puts us on a
                        // great-circle path from the start point to the terminator fix.
                        initialCourse = startPoint.bearingTo(terminatorPos);
                        // If the calculated course is NaN (only happens when the start and end points are coincident or antipodal),
                        // then just arbitrarily use true north.
                        if (isNaN(initialCourse)) {
                            initialCourse = 0;
                        }
                }
            }
            else {
                // If the current course from the previous leg is defined, use it.
                initialCourse = state.currentCourse;
            }
        }
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, startPoint, startPath, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), leg.turnDirection === LegTurnDirection.Left ? 'left' : leg.turnDirection === LegTurnDirection.Right ? 'right' : undefined);
        state.currentPosition.set(terminatorPos);
        if (vectorIndex > 0) {
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            vectors.length = vectorIndex;
            return;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec, FlightPathVectorFlags.Arc);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    /** @inheritdoc */
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, true);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.turnBuilder = new TurnToCourseBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
        this.interceptInfo = {
            circle: undefined,
            start: undefined,
            end: undefined
        };
        this.handleInvalidInterceptCache = {
            vec3: [new Float64Array(3), new Float64Array(3), new Float64Array(3)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)],
            intersection: [new Float64Array(3), new Float64Array(3)]
        };
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const interceptInfo = this.getInterceptPathInfo(legs, calculateIndex, state, this.interceptInfo);
        if (course === undefined || !interceptInfo.circle || !state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        const effectiveInterceptPathStartVec = interceptInfo.start
            ? GeoPoint.sphericalToCartesian(interceptInfo.start, this.vec3Cache[0])
            : interceptInfo.end
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.end, -Math.PI, this.vec3Cache[0], Math.PI)
                : undefined;
        const effectiveInterceptPathEndVec = interceptInfo.end
            ? GeoPoint.sphericalToCartesian(interceptInfo.end, this.vec3Cache[1])
            : interceptInfo.start
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.start, Math.PI, this.vec3Cache[1], Math.PI)
                : undefined;
        const effectiveInterceptPathAngularWidth = interceptInfo.start && interceptInfo.end
            ? interceptInfo.circle.angleAlong(interceptInfo.start, interceptInfo.end, Math.PI)
            : effectiveInterceptPathStartVec
                ? Math.PI
                : MathUtils.TWO_PI;
        const initialVec = state.currentPosition.toCartesian(this.vec3Cache[2]);
        const includeInitialTurn = this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1;
        const interceptPathStartVec = Vec3Math.copy(initialVec, this.vec3Cache[3]);
        let initialTurnVector = undefined;
        if (includeInitialTurn) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            initialTurnVector = vectors[vectorIndex - 1];
            GeoPoint.sphericalToCartesian(initialTurnVector.endLat, initialTurnVector.endLon, interceptPathStartVec);
        }
        const interceptPath = this.geoCircleCache[0].setAsGreatCircle(interceptPathStartVec, course);
        const startPath = this.geoCircleCache[1].set(interceptPath.center, interceptPath.radius);
        // If an initial turn exists, check if a fallback intercept is required because the end of the initial turn lies
        // past the path to intercept. If an initial turn does not exist, check if any fallback intercept is required.
        let fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, initialTurnVector !== undefined, false, this.vec3Cache[4]);
        if (initialTurnVector !== undefined) {
            if (fallbackInterceptVec === undefined) {
                // An initial turn exists and does not end past the path to intercept. Check if a fallback intercept is required
                // for another reason.
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, false, this.vec3Cache[4]);
            }
            else {
                // An initial turn exists and ends past the path to intercept. First check if the initial turn intersects the
                // path to intercept
                const turnCircle = FlightPathUtils.setGeoCircleFromVector(initialTurnVector, this.geoCircleCache[2]);
                const intersections = this.intersectionCache;
                const numIntersections = turnCircle.intersection(interceptInfo.circle, intersections);
                if (numIntersections > 1) {
                    // Order intersections such that the one closer to the turn end is at index 0.
                    if (interceptInfo.circle.radius > MathUtils.HALF_PI !== interceptInfo.circle.encircles(initialVec)) {
                        const temp = intersections[0];
                        intersections[0] = intersections[1];
                        intersections[1] = temp;
                    }
                }
                for (let i = 0; i < numIntersections; i++) {
                    const intersection = intersections[i];
                    if (FlightPathUtils.isPointAlongArc(turnCircle, initialVec, interceptPathStartVec, intersection)
                        && (!effectiveInterceptPathStartVec
                            || FlightPathUtils.isPointAlongArc(interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathAngularWidth, intersection))) {
                        // End the turn early at the intercept point
                        const distance = turnCircle.distanceAlong(initialVec, intersection, Math.PI);
                        if (distance > GeoCircle.ANGULAR_TOLERANCE) {
                            const intersectionPoint = this.geoPointCache[0].setFromCartesian(intersection);
                            initialTurnVector.distance = UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                            initialTurnVector.endLat = intersectionPoint.lat;
                            initialTurnVector.endLon = intersectionPoint.lon;
                            state.currentPosition.set(initialTurnVector.endLat, initialTurnVector.endLon);
                            state.currentCourse = FlightPathUtils.getVectorFinalCourse(initialTurnVector);
                        }
                        else {
                            vectorIndex--;
                        }
                        vectors.length = vectorIndex;
                        return;
                    }
                }
                // The initial turn does not intersect the path to intercept -> calculate a fallback intercept
                // without an initial turn (i.e. change the intercept path to start at the start of the leg).
                vectorIndex = 0;
                Vec3Math.copy(initialVec, interceptPathStartVec);
                interceptPath.setAsGreatCircle(interceptPathStartVec, course);
                startPath.setAsGreatCircle(interceptPathStartVec, startCourse);
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, true, this.vec3Cache[4]);
            }
        }
        if (fallbackInterceptVec === undefined) {
            vectorIndex += this.interceptBuilder.build(vectors, vectorIndex, interceptPathStartVec, course, interceptInfo.circle);
        }
        else {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, interceptPathStartVec, startPath, fallbackInterceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
    }
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    calculateFallbackIntercept(start, interceptPath, pathToInterceptCircle, pathToInterceptStart, pathToInterceptEnd, pathToInterceptAngularWidth, onlyHandleInitialPointPastIntercept, forceFallback, out) {
        if (pathToInterceptCircle.includes(start)) {
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, start)) {
                // Initial point already lies on the path to intercept.
                return forceFallback ? Vec3Math.copy(start, out) : undefined;
            }
        }
        // Determine if the starting position is "past" the path to intercept.
        let isInitialPosPastPath = false;
        const intersections = this.handleInvalidInterceptCache.intersection;
        const numIntersections = interceptPath.intersection(pathToInterceptCircle, intersections);
        let desiredIntersection;
        if (numIntersections === 2) {
            const nextIntersectionIndex = pathToInterceptCircle.encircles(start) ? 0 : 1;
            const prevIntersectionIndex = 1 - nextIntersectionIndex;
            const nextIntersection = intersections[nextIntersectionIndex];
            const prevIntersection = intersections[prevIntersectionIndex];
            // Define the desired intercept point as the one that requires the shortest distance traveled along the initial
            // path and path to intercept circle from the initial position to some point along the path to intercept. Then,
            // determine if the initial position lies before or after the desired intercept point, relative to the direction
            // of the initial path.
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI && pathToInterceptCircle.isGreatCircle()) {
                isInitialPosPastPath = interceptPath.angleAlong(start, nextIntersection, Math.PI) > MathUtils.HALF_PI + GeoCircle.ANGULAR_TOLERANCE;
            }
            else {
                const prevIntersectionInitialPathOffset = interceptPath.angleAlong(prevIntersection, start, Math.PI);
                const nextIntersectionInitialPathOffset = interceptPath.angleAlong(start, nextIntersection, Math.PI);
                const prevIntersectionInitialPathDistance = Math.min(prevIntersectionInitialPathOffset, MathUtils.TWO_PI - prevIntersectionInitialPathOffset);
                const nextIntersectionInitialPathDistance = Math.min(nextIntersectionInitialPathOffset, MathUtils.TWO_PI - nextIntersectionInitialPathOffset);
                let prevIntersectionInterceptPathDistance = 0;
                let nextIntersectionInterceptPathDistance = 0;
                if (pathToInterceptStart && pathToInterceptEnd) {
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, prevIntersection)) {
                        const prevIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptStart, Math.PI);
                        const prevIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptEnd, Math.PI);
                        prevIntersectionInterceptPathDistance = Math.min(prevIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathStartOffset, prevIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathEndOffset);
                    }
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, nextIntersection)) {
                        const nextIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptStart, Math.PI);
                        const nextIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptEnd, Math.PI);
                        nextIntersectionInterceptPathDistance = Math.min(nextIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathStartOffset, nextIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathEndOffset);
                    }
                }
                const prevIntersectionTotalDistance = prevIntersectionInitialPathDistance + prevIntersectionInterceptPathDistance;
                const nextIntersectionTotalDistance = nextIntersectionInitialPathDistance + nextIntersectionInterceptPathDistance;
                // Only consider the starting position past the path to intercept if the path to intercept has a defined start
                // and end (i.e. is not a DME circle) OR the distance to one of the two intercept points is greater than pi/2
                // great-arc radians.
                if ((pathToInterceptStart !== undefined && pathToInterceptEnd !== undefined)
                    || (prevIntersectionTotalDistance >= MathUtils.HALF_PI || nextIntersectionTotalDistance >= MathUtils.HALF_PI)) {
                    isInitialPosPastPath = prevIntersectionTotalDistance < nextIntersectionTotalDistance - GeoCircle.ANGULAR_TOLERANCE;
                }
            }
            desiredIntersection = isInitialPosPastPath ? prevIntersection : nextIntersection;
        }
        else if (numIntersections === 1) {
            const distanceToIntersection = interceptPath.angleAlong(start, intersections[0], Math.PI);
            isInitialPosPastPath = distanceToIntersection < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && distanceToIntersection > Math.PI + GeoCircle.ANGULAR_TOLERANCE;
            desiredIntersection = intersections[0];
        }
        if ((onlyHandleInitialPointPastIntercept && !isInitialPosPastPath)) {
            return undefined;
        }
        let needHandleFallback = isInitialPosPastPath;
        if (!desiredIntersection) {
            // The intercept course does not intersect with the path to intercept circle at all -> define the desired
            // intercept point as the point on the path to intercept circle closest to the start point.
            desiredIntersection = pathToInterceptCircle.closest(start, this.handleInvalidInterceptCache.vec3[0]);
            needHandleFallback = true;
        }
        let fallbackIntercept;
        if ((!pathToInterceptStart || !pathToInterceptEnd)
            || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, desiredIntersection)) {
            // The desired intercept point is within the bounds of the path to intercept -> only handle the fallback if we
            // need to (i.e. if the starting point is past the path to intercept, if the starting path does not intersect
            // the path to intercept, or fallback is forced)
            if (needHandleFallback || forceFallback) {
                fallbackIntercept = desiredIntersection;
            }
        }
        else {
            // The desired intercept point is not within the bounds of the path to intercept -> set the fallback intercept
            // point to the start or end of the path to intercept, whichever is closer to the desired intercept point.
            const angularOffset = pathToInterceptCircle.angleAlong(pathToInterceptStart, desiredIntersection, Math.PI);
            const distanceFromStart = Math.min(angularOffset, MathUtils.TWO_PI - angularOffset);
            const distanceFromEnd = Math.abs(angularOffset - pathToInterceptAngularWidth);
            fallbackIntercept = distanceFromStart <= distanceFromEnd ? pathToInterceptStart : pathToInterceptEnd;
        }
        return fallbackIntercept === undefined ? undefined : Vec3Math.copy(fallbackIntercept, out);
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDmeLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const dmeFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = dmeFacility === undefined ? 0 : this.getLegMagVar(leg.leg, dmeFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (dmeFacility) {
            this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
            out.circle = this.dmeCircle;
            out.start = undefined;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.radialCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const radialFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = radialFacility === undefined ? 0 : this.getLegMagVar(leg.leg, radialFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (radialFacility) {
            const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
                ? -radialFacility.magneticVariation
                : MagVar.get(radialFacility);
            this.radialCircle.setAsGreatCircle(radialFacility, leg.theta + magVar);
            out.circle = this.radialCircle;
            out.start = radialFacility;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.predictLegPathCache = {
            geoPoint: [new GeoPoint(0, 0)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0)]
        };
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        const leg = legs[calculateIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = state.currentPosition === undefined ? 0 : this.getLegMagVar(leg.leg, state.currentPosition);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        out.circle = undefined;
        out.start = undefined;
        out.end = undefined;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return out;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[0]);
                    if (terminator) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator));
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    if (facility) {
                        out.circle = FlightPathUtils.getTurnCircle(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = this.facilityCache.get(leg.fixIcao);
                    }
                    break;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    if (terminator && centerFacility) {
                        out.circle = FlightPathUtils.getTurnCircle(centerFacility, terminator.distance(centerFacility), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    if (origin) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin));
                        out.start = origin;
                    }
                    break;
                }
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDmeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (!pathStartPoint || !dmeFacility) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const dmeCircle = this.geoCircleCache[1].set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const interceptVec = this.vec3Cache[1];
        const intersections = this.intersectionCache;
        const numIntersections = path.intersection(dmeCircle, intersections);
        if (numIntersections === 0) {
            // The path along the leg's defined course does not intercept the DME circle -> define the intercept to be the
            // closest point on the DME circle to the initial fix.
            dmeCircle.closest(pathStartVec, interceptVec);
        }
        else {
            // The path along the leg's defined course intercepts the DME circle -> choose the first intercept when
            // proceeding along the path from the initial fix.
            const intersectionIndex = (numIntersections === 1 || dmeCircle.encircles(pathStartVec)) ? 0 : 1;
            Vec3Math.copy(intersections[intersectionIndex], interceptVec);
        }
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, interceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, interceptVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, interceptVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!pathStartPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const endVec = path.offsetDistanceAlong(pathStartVec, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN), this.vec3Cache[1], Math.PI);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, endVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, endVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            // We are in a fallback state -> plot a direct course to the terminator fix
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, undefined, FlightPathVectorFlags.Fallback);
            state.isFallback = false;
        }
        else {
            state.isFallback = false;
            const endCourse = this.getLegTrueCourse(leg, endPoint);
            const endVec = endPoint.toCartesian(this.vec3Cache[1]);
            const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
            if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
                // ---- CASE A ----
                // The leg begins at a discontinuity OR the previous leg is a manual termination leg.
                // Create a great-circle vector with a start point arbitrarily placed 5 NM from the terminator fix.
                const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
            }
            else {
                const startVec = startPoint.toCartesian(this.vec3Cache[0]);
                const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
                const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
                const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
                const isStartEqualToEnd = startPoint.equals(endPoint);
                const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
                // A great circle defining the threshold of the terminator fix - everything to the LEFT of (i.e. encircled by)
                // this great circle is past the terminator fix as projected along the end path.
                const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
                const isStartPastThreshold = threshold.encircles(startVec, false);
                // 175 degrees
                const areStartEndPathsAntiParallel = pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE;
                let isDone = false;
                if (!areStartEndPathsAntiParallel && isStartPastThreshold) {
                    // ---- CASE B ----
                    // The start and end paths are not antiparallel and the start point is past the terminator threshold.
                    let shouldTryFallback = true;
                    const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                        : leg.turnDirection === LegTurnDirection.Right ? 'right'
                            : undefined;
                    if (pathAngleDiff >= MathUtils.HALF_PI
                        && (desiredTurnDirection === undefined || (desiredTurnDirection === 'left') === startPath.encircles(endVec))) {
                        // The start path is either heading toward the terminator threshold or is parallel to it and the desired
                        // turn direction is not away from the end point. We now need to find the intersections between the start
                        // and end paths. There should be two intersections since both paths are great circles and they are not
                        // parallel or antiparallel.
                        const intersections = this.intersectionCache;
                        const solutionCount = startPath.intersection(endPath, intersections);
                        if (solutionCount === 2) {
                            // There are two general cases:
                            //
                            // 1. The end point lies past the intersection as measured along the end path.
                            // 2. The end point lies before the intersection as measured along the end path.
                            //
                            // In case 1, we can use the default algorithm for joining the start and end paths. Therefore there is
                            // nothing to do here; we just need to make sure the code falls through to Case E below.
                            //
                            // In case 2, we will try to join the start and end paths with a single constant radius turn. This will
                            // generate a "loop" where the path follows the start path initially away from the end point and then
                            // turns back onto the end path to head back to the end point. If that is not possible or the generated
                            // path is too long, we will fall through to Case E.
                            shouldTryFallback = false;
                            // Choose the intersection closest to the start point.
                            const intersection = Vec3Math.dot(intersections[0], startVec) > 0
                                ? intersections[0]
                                : intersections[1];
                            const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, this.vec3Cache[2]), endVec);
                            const isEndPastIntersection = intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE;
                            if (!isEndPastIntersection) {
                                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius, true, false, intersection);
                                if (vectorIndex !== 0) {
                                    // Find all the great-circle vectors in the path. These are all guaranteed to be parallel to either
                                    // the start or end paths. If the total distance of all these vectors is greater than a maximum
                                    // threshold, erase the vectors and let the code fall through to Case E, which will generate a
                                    // shorter path.
                                    let distance = 0;
                                    for (let i = 0; i < vectorIndex; i++) {
                                        const vector = vectors[i];
                                        if (FlightPathUtils.isVectorGreatCircle(vector)) {
                                            distance += vector.distance;
                                        }
                                    }
                                    if (distance > 37040 /* 20 nautical miles */) {
                                        vectorIndex = 0;
                                    }
                                }
                                isDone = vectorIndex > 0;
                            }
                        }
                    }
                    if (shouldTryFallback && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type)) {
                        // The leg does not end in a fly-over fix and the next leg is eligible for fallback -> end the current leg
                        // at the start point and set a fallback state.
                        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                        (_d = state.currentCourse) !== null && _d !== void 0 ? _d : (state.currentCourse = currentCourse);
                        state.isFallback = true;
                        isDone = true;
                    }
                }
                if (!isDone) {
                    if (areStartEndPathsAntiParallel) {
                        // ---- CASE C ----
                        // The start and end paths are antiparallel. We need to execute a procedure turn to do a 180.
                        let desiredTurnDirection;
                        switch (leg.turnDirection) {
                            // If the leg defines a turn direction, respect it.
                            case LegTurnDirection.Left:
                                desiredTurnDirection = 'left';
                                break;
                            case LegTurnDirection.Right:
                                desiredTurnDirection = 'right';
                                break;
                            default: {
                                const endDistanceFromStartPath = startPath.distance(endVec);
                                if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                                    // If the end point lies on the start path, then we want to turn toward the end path after passing
                                    // the end point along the start path (defaulting to a right turn if the start and end paths are
                                    // exactly antiparallel).
                                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? 'left' : 'right';
                                }
                                else {
                                    // If the end point does not lie on the start path, then we want to turn toward the end point from
                                    // the start path.
                                    desiredTurnDirection = endDistanceFromStartPath < 0 ? 'left' : 'right';
                                }
                            }
                        }
                        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
                        // procTurnBuilder will only build vectors up to the point where the proc turn intercepts the end path.
                        // So we need to check if we need to add a vector to connect the intercept point to the end point.
                        if (vectorIndex > 0) {
                            const lastVector = vectors[vectorIndex - 1];
                            const interceptVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                            if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) { // ~60 meter tolerance
                                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector.endLat, lastVector.endLon), endPoint);
                            }
                        }
                    }
                    else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE
                        && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE
                            || (!isStartEqualToEnd
                                && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                                    || (((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))))) {
                        // ---- CASE D ----
                        // The start and end paths are parallel, so we can just connect the start and end with a track.
                        // Or the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                        // least one calculated vector. In this case we will simply create a track from the start to end and let turn
                        // anticipation handle the initial turn into the final course.
                        if (!isStartEqualToEnd) {
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
                        }
                    }
                    else {
                        // ---- CASE E ----
                        // The default case. We will attempt to join the start and end paths with a single constant-radius turn
                        // toward the end point. If that is not possible, we will fall back to using two constant-radius turns. If
                        // that is not possible, we will fall back to a direct-to path from the start point to the end point.
                        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                                : undefined;
                        vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
                        const lastVector = vectors[vectorIndex - 1];
                        if (lastVector !== undefined
                            && !leg.flyOver
                            && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                            const lastVectorEndVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const lastVectorEndPath = FlightPathUtils.getGreatCircleTangentToVector(lastVectorEndVec, lastVector, this.geoCircleCache[3]);
                            const lastVectorCourseDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(lastVectorEndPath.center, endPath.center), -1, 1));
                            if (lastVectorCourseDiff > 0.0174533 /* 1 degree */) {
                                // We are allowed to use a fallback path which does not end at the defined terminator fix and a fallback
                                // direct-to path was calculated. We need to determine if we should end the direct-to path early if it
                                // crosses past the terminator threshold or remove it entirely and end the leg immediately at the start
                                // point.
                                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                                let useImmediateFallback = false;
                                let startTurnCircle;
                                let startTurnEnd;
                                // The direct-to path can consist of either a single turn vector, a single great-circle vector, or a
                                // starting turn vector followed by a great-circle vector.
                                if (FlightPathUtils.isVectorGreatCircle(lastVector)) {
                                    if (vectorIndex < 2) {
                                        // The direct-to path has a single great-circle vector. If the direct-to course differs from the end
                                        // course by more than 90 degrees, then the entire direct-to path is past the terminator threshold.
                                        // In that case we will end this leg at the start point and set a fallback state. If the direct-to
                                        // course is within 90 degrees of the end course, then the path must be entirely behind the
                                        // threshold. In that case we will leave the path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            useImmediateFallback = true;
                                        }
                                    }
                                    else {
                                        // The direct-to path consists of a starting turn followed by a great-circle vector. If the course of
                                        // the great-circle vector differs from the end course by more than 90 degrees, then we need to
                                        // deal with the possibility that the direct-to path starts behind the terminator threshold and then
                                        // crosses past the threshold. If the courses differ by 90 or degrees or less, then we will leave
                                        // the direct-to path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            if (isStartPastThreshold) {
                                                // If the start point is past the terminator threshold, then the entire direct-to path is
                                                // guaranteed to be past the terminator threshold. Therefore we will end this leg at the start
                                                // point and set a fallback state.
                                                useImmediateFallback = true;
                                            }
                                            else {
                                                // If the start point is not past the terminator threshold, then that means at some point the
                                                // direct-to path (specifically the starting turn) must cross the threshold. Therefore we will
                                                // trigger the evaluation code below to find out where we need to end the path early as it
                                                // crosses the threshold.
                                                const startTurnVector = vectors[vectorIndex - 2];
                                                startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                                                startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[3]);
                                            }
                                        }
                                    }
                                }
                                else {
                                    // The direct-to path is a single turn vector.
                                    if (isStartPastThreshold) {
                                        // If the start point is past the terminator threshold, we will end this leg at the start point and
                                        // set a fallback state.
                                        useImmediateFallback = true;
                                    }
                                    else {
                                        // If the start point is behind the terminator threshold, then it is possible the turn crosses past
                                        // the threshold before it ends. Therefore we will trigger the evaluation code below to find out if
                                        // we need to end the path early as it crosses the threshold.
                                        // If the direct course calculation produced only a single turn vector, it possibly reduced the radius
                                        // of the starting turn below the minimum radius in order to build a valid path to the terminator.
                                        // We always want the starting turn to respect the minimum turn radius, so we will define it ourselves.
                                        startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPath.encircles(endVec) ? 'left' : 'right'), this.geoCircleCache[3]);
                                        // If the direct course turn radius was reduced, then the terminator fix lies inside the starting turn
                                        // circle of minimum radius. Therefore, the turn technically never ends because there is no point on
                                        // the turn circle that either includes the terminator fix or is tangent to a great-circle path which
                                        // includes the terminator fix.
                                        if (Math.min(lastVector.radius, Math.PI - lastVector.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                                            startTurnEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[3]);
                                        }
                                    }
                                }
                                if (startTurnCircle !== undefined) {
                                    // Find the intersections of the direct-to starting turn circle with the terminator threshold.
                                    const intersections = this.intersectionCache;
                                    const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                                    // If the starting turn is tangent to the threshold, then the entire turn must be behind the threshold
                                    // because we are guaranteed that the start point is behind the threshold if we made it into this case.
                                    // Therefore, we only care about starting turns that are secant to the threshold.
                                    if (intersectionCount === 2) {
                                        // Because the start point is guaranteed to be behind the threshold, the next intersection of the
                                        // starting turn circle with the threshold will take the path past the threshold.
                                        const thresholdCrossing = intersections[0];
                                        const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                                        if (startTurnEnd === undefined
                                            || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                                            // The starting turn crosses the terminator threshold before the end of the turn (or the turn has
                                            // no end) -> end the turn at the crossing point and set the fallback state.
                                            vectorIndex = 0;
                                            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                                            state.isFallback = true;
                                        }
                                    }
                                }
                                if (useImmediateFallback) {
                                    vectorIndex = 0;
                                    ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                                    (_h = state.currentCourse) !== null && _h !== void 0 ? _h : (state.currentCourse = currentCourse);
                                    state.isFallback = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        const lastVector = vectors[vectorIndex - 1];
        if (lastVector !== undefined) {
            ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
];
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const originFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = originFacility === undefined ? 0 : MagVar.get(originFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            vectors.length = vectorIndex;
            return;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            vectors.length = vectorIndex;
            return;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            vectors.length = vectorIndex;
            return;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            vectors.length = vectorIndex;
            return;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        vectors.length = vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!startPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const normalizedEnd = startPoint.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, normalizedEnd);
        state.currentPosition = undefined;
        state.currentCourse = undefined;
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            const fixPosition = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
            if (fixPosition) {
                state.currentPosition = new GeoPoint(fixPosition.lat, fixPosition.lon);
            }
        }
        if (!state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const holdFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = holdFacility === undefined ? 0 : this.getLegMagVar(leg.leg, holdFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const calcs = legs[calculateIndex].calculated;
        const vectors = calcs.flightPath;
        const ingress = calcs.ingress;
        let vectorIndex = 0, ingressVectorIndex = 0;
        const holdPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            vectors.length = 0;
            ingress.length = 0;
            calcs.ingressJoinIndex = -1;
            return;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            ingressVectorIndex += this.greatCircleBuilder.build(ingress, ingressVectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const turnRadiusMeters = state.desiredHoldTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        const outboundTurnCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
        const turnRadiusRad = state.desiredHoldTurnRadius.asUnit(UnitType.GA_RADIAN);
        const outboundTurnCenter = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
        const outboundTurnEnd = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
        const oppositeCourse = NavMath.normalizeHeading(course + 180);
        const outboundEnd = outboundTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        const directionalEntryCourse = normalizedEntryCourse * turnDirectionSign;
        const isDirectEntry = directionalEntryCourse >= -70 && directionalEntryCourse <= 135;
        const skipRacetrack = leg.type === LegType.HF && !isDirectEntry;
        if (isDirectEntry) {
            // direct entry
            if (directionalEntryCourse > 0) {
                // The entry course is toward the outbound leg, so we just intercept the outbound leg directly, bypassing
                // the turn from the inbound to outbound leg.
                ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), outboundEnd, this.geoCircleCache[2].setAsGreatCircle(outboundTurnEnd, oppositeCourse), turnDirection, turnRadiusMeters, false, true, undefined, FlightPathVectorFlags.HoldDirectEntry);
                calcs.ingressJoinIndex = 1;
            }
            else if (BitFlags.isAny((_d = (_c = ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.AnticipatedTurn)) {
                // Don't erase turn anticipation for direct entries
                ingressVectorIndex = ingress.length;
            }
        }
        else if (directionalEntryCourse > 110) {
            // teardrop entry
            if (directionalEntryCourse > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse, FlightPathVectorFlags.HoldTeardropEntry | FlightPathVectorFlags.TurnToCourse);
                if (numTurnVectorsAdded > 0) {
                    ingressVectorIndex += numTurnVectorsAdded;
                    const turnVector = ingress[ingressVectorIndex - 1];
                    state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                    state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
                }
            }
            ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters, true, true, undefined, FlightPathVectorFlags.HoldTeardropEntry);
            if (skipRacetrack) {
                // If we skip the racetrack, remove the part of the hold entry that is coincident with the inbound leg
                const lastEntryVector = ingress[ingressVectorIndex - 1];
                if (lastEntryVector && FlightPathUtils.isVectorGreatCircle(lastEntryVector) && holdPos.equals(lastEntryVector.endLat, lastEntryVector.endLon)) {
                    if (UnitType.METER.convertTo(lastEntryVector.distance, UnitType.GA_RADIAN) > distance + GeoPoint.EQUALITY_TOLERANCE) {
                        const lastEntryVectorEnd = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
                        lastEntryVector.endLat = lastEntryVectorEnd.lat;
                        lastEntryVector.endLon = lastEntryVectorEnd.lon;
                        lastEntryVector.distance -= UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                    }
                    else {
                        ingressVectorIndex--;
                    }
                }
            }
            calcs.ingressJoinIndex = 0;
        }
        else if (directionalEntryCourse < -70) {
            // parallel entry
            const parallelCourse = course + 180;
            const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse, FlightPathVectorFlags.HoldParallelEntry | FlightPathVectorFlags.TurnToCourse);
            if (numTurnVectorsAdded > 0) {
                ingressVectorIndex += numTurnVectorsAdded;
                const turnVector = ingress[ingressVectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            }
            ingressVectorIndex += this.procTurnBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course, FlightPathVectorFlags.HoldParallelEntry);
            calcs.ingressJoinIndex = 0;
        }
        ingress.length = ingressVectorIndex;
        if (ingress.length === 0) {
            calcs.ingressJoinIndex = -1;
        }
        let inboundStart;
        if (skipRacetrack) {
            inboundStart = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
        }
        else {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, outboundTurnCenter, holdPos, outboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, outboundTurnEnd, outboundEnd, undefined, FlightPathVectorFlags.HoldOutboundLeg);
            const inboundTurnCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const inboundTurnCenter = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const inboundTurnEnd = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, inboundTurnCenter, outboundEnd, inboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            inboundStart = inboundTurnEnd;
        }
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, inboundStart, holdPos, undefined, FlightPathVectorFlags.HoldInboundLeg);
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        vectors.length = vectorIndex;
    }
}

/**
 * Utility class for working with flight plans.
 */
class FlightPlanUtils {
    /**
     * Checks if a leg type is an "to altitude" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "heading to" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "hold" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "hold" leg type.
     */
    static isHoldLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a manual termination leg type that ends in a discontinuity.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a manual termination leg type that ends in a discontinuity.
     */
    static isManualDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a discontinuity leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a discontinuity leg type.
     */
    static isDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    /**
     * Gets the ICAO of the facility defining the terminator of a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The ICAO of the facility defining the terminator of the specified flight plan leg, or `undefined` if
     * the leg's terminator is not defined by a facility.
     */
    static getTerminatorIcao(leg) {
        switch (leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
                return leg.fixIcao;
            default:
                return undefined;
        }
    }
}
/** Array of "to altitude" leg types. */
FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
/** Array of "heading to" leg types. */
FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold" leg types. */
FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
/** Array of manual termination leg types that end in a discontinuity. */
FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
/** Array of discontinuity leg types. */
FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];

/**
 * A flight path calculator for turns between legs.
 */
class FlightPathTurnCalculator {
    constructor() {
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired general turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     */
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
        var _a, _b, _c, _d;
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const fromLeg = legs[currentIndex];
            const toLeg = legs[currentIndex + 1];
            const fromLegCalc = fromLeg === null || fromLeg === void 0 ? void 0 : fromLeg.calculated;
            const toLegCalc = toLeg === null || toLeg === void 0 ? void 0 : toLeg.calculated;
            if (fromLegCalc
                && toLegCalc
                && !FlightPlanUtils.isManualDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(toLeg.leg.type)) {
                const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
                const toVector = toLegCalc.flightPath[0];
                if (fromVector && toVector
                    && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))
                    && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                    if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
                        continue;
                    }
                    else if (toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                    else if (fromVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                }
            }
            if (fromLegCalc && BitFlags.isAll((_b = (_a = fromLegCalc.egress[0]) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, FlightPathVectorFlags.LegToLegTurn)) {
                fromLegCalc.egress.length = 0;
                fromLegCalc.egressJoinIndex = -1;
            }
            if (toLegCalc && BitFlags.isAll((_d = (_c = toLegCalc.ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
                toLegCalc.ingress.length = 0;
                toLegCalc.ingressJoinIndex = -1;
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        if (trackAngleDiff > 175) {
            return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (isRestrictedByPrevTurn) {
            if (previousTanTheta === undefined) {
                // Check to see if there is a ingress transition on the from leg and if it shares a common flight path vector
                // with the one involved in the turn currently being calculated.
                if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
                    const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
                    restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
                }
            }
            else {
                // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
                // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
                // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
                // previous turn. This will maximize min(radius_current, radius_prev).
                const tanThetaRatio = previousTanTheta / tanTheta;
                const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
                const cosTotalD = Math.cos(totalD);
                let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
                if (prevTurnRestrictedD > totalD) {
                    prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
                }
                restrictedD = prevTurnRestrictedD;
            }
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            // prevent zero-length turns
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        // Let the course reversal "cut"
        let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
                }
            }
        }
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
        const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? 'left' : 'right';
        const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === 'left' ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
        toLegCalc.ingress.length = length;
        toLegCalc.ingressJoinIndex = 0;
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        var _a, _b;
        var _c, _d;
        const fromLeg = legs[fromIndex];
        const toLeg = legs[toIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = fromLeg.calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = toLeg.calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        const areLegsContinuous = fromVectorEndPoint.equals(toVectorStartPoint, 1e-5);
        if (!areLegsContinuous) {
            // The from-leg does not end within ~60 meters of the start of the to-leg.
            let shouldQuit = true;
            // Either the from- or to- leg is an AF or RF leg. These legs often end up discontinuous with the preceding or
            // proceeding leg due to the arcs being slightly offset from the intended origin and/or terminator fixes.
            if (fromLeg.leg.type === LegType.AF
                || fromLeg.leg.type === LegType.RF
                || toLeg.leg.type === LegType.AF
                || toLeg.leg.type === LegType.RF) {
                shouldQuit = false;
            }
            if (shouldQuit) {
                return toIndex;
            }
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        // Define the circles
        const arcPath = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(arcPath, FlightPathTurnCalculator.geoPointCache[2]);
        const arcRadiusRad = FlightPathUtils.getTurnRadiusFromCircle(arcPath);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(arcPath);
        const arcCircle = FlightPathTurnCalculator.geoCircleCache[1].set(arcCenter, arcRadiusRad);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[2]);
        const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
        const fromVectorPath = isArcFirst ? arcPath : trackPath;
        const toVectorPath = isArcFirst ? trackPath : arcPath;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
        const arcTrackIntersectionCount = arcCircle.intersection(trackPath, arcTrackIntersections);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const fromVectorEndVec = fromVectorEndPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
        const toVectorStartVec = toVectorStartPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[1]);
        const fromVectorHalfDistanceRad = UnitType.METER.convertTo(fromVector.distance / 2, UnitType.GA_RADIAN);
        const toVectorHalfDistanceRad = UnitType.METER.convertTo(toVector.distance / 2, UnitType.GA_RADIAN);
        const intersectionPoint = FlightPathTurnCalculator.geoPointCache[4];
        const intersectionVec = FlightPathTurnCalculator.vector3Cache[2];
        let intersectionFromVectorEndOffset = 0;
        let intersectionToVectorStartOffset = 0;
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // The arc circle and track path are tangent.
            if (areLegsContinuous) {
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
            }
            else {
                // The from-leg does not end within ~60 meters of the start of the to-leg.
                Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                intersectionFromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, intersectionVec);
                intersectionToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, toVectorStartVec);
                if (!this.isArcTrackIntersectionValid(intersectionVec, fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersectionFromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersectionToVectorStartOffset)) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
            }
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                if (intersectionFromVectorEndOffset === 0 && intersectionToVectorStartOffset === 0) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                }
                else {
                    if (intersectionFromVectorEndOffset !== 0) {
                        // The intersection is not coincident with the end of the from-vector. The egress path will start 1
                        // nautical mile before the intersection point or at the end of the from-vector, whichever comes
                        // earlier (without going past the mid-point of the from-vector) and follow the from-vector path.
                        if (fromVectorHalfDistanceRad + intersectionFromVectorEndOffset <= 1e-5) {
                            // The intersection is at the mid-point of the from-vector.
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const egressStartVec = fromVectorPath.offsetDistanceAlong(intersectionVec, -Math.min(0.00029, Math.max(0, intersectionFromVectorEndOffset), fromVectorHalfDistanceRad + intersectionFromVectorEndOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, egressStartVec, intersectionVec);
                        }
                    }
                    if (intersectionToVectorStartOffset !== 0) {
                        // The intersection is not coincident with the start of the to-vector. The ingress path will end 1
                        // nautical mile after the intersection point or at the start of the to-vector, whichever comes
                        // later (without going past the mid-point of the to-vector) and follow the to-vector path.
                        if (toVectorHalfDistanceRad + intersectionToVectorStartOffset <= 1e-5) {
                            // The intersection is at the mid-point of the to-vector.
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const ingressEndVec = toVectorPath.offsetDistanceAlong(intersectionVec, Math.min(0.00029, Math.max(0, intersectionToVectorStartOffset), toVectorHalfDistanceRad + intersectionToVectorStartOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, ingressEndVec);
                        }
                    }
                }
                return toIndex;
            }
            else {
                intersectionPoint.setFromCartesian(intersectionVec);
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            // The arc circle and track path are secant.
            let arcStartVec;
            let arcEndVec;
            let fromVectorIntersectionBearing;
            let toVectorIntersectionBearing;
            if (areLegsContinuous) {
                intersectionPoint.set(fromVectorEndPoint);
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
                arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                fromVectorIntersectionBearing = fromVectorEndBearing;
                toVectorIntersectionBearing = toVectorStartBearing;
            }
            else {
                const intersection0FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[0]);
                const intersection0ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[0], toVectorStartVec);
                const intersection1FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[1]);
                const intersection1ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[1], toVectorStartVec);
                const isIntersection0Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[0], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection0FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection0ToVectorStartOffset);
                const isIntersection1Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[1], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection1FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection1ToVectorStartOffset);
                if (!isIntersection0Valid && !isIntersection1Valid) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
                let intersectionIndex;
                if (!isIntersection0Valid) {
                    intersectionIndex = 1;
                }
                else if (!isIntersection1Valid) {
                    intersectionIndex = 0;
                }
                else {
                    // Both intersections are valid. We will bias toward intersections that lie after the end of the from-vector
                    // and before the start of the to-vector.
                    if (intersection0FromVectorEndOffset + intersection0ToVectorStartOffset >= intersection1FromVectorEndOffset + intersection1ToVectorStartOffset) {
                        intersectionIndex = 0;
                    }
                    else {
                        intersectionIndex = 1;
                    }
                }
                if (intersectionIndex === 0) {
                    Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                    intersectionFromVectorEndOffset = intersection0FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection0ToVectorStartOffset;
                }
                else if (isIntersection1Valid) {
                    Vec3Math.copy(arcTrackIntersections[1], intersectionVec);
                    intersectionFromVectorEndOffset = intersection1FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection1ToVectorStartOffset;
                }
                intersectionPoint.setFromCartesian(intersectionVec);
                if (isArcFirst) {
                    arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                    arcEndVec = intersectionVec;
                }
                else {
                    arcStartVec = intersectionVec;
                    arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                }
                fromVectorIntersectionBearing = fromVectorPath.bearingAt(intersectionVec, Math.PI);
                toVectorIntersectionBearing = toVectorPath.bearingAt(intersectionVec, Math.PI);
            }
            const arcStartRadial = arcCircle.bearingAt(arcStartVec, Math.PI) + 90;
            const arcEndRadial = arcCircle.bearingAt(arcEndVec, Math.PI) + 90;
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), toVectorIntersectionBearing)) >= 90
                : Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), fromVectorIntersectionBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, intersectionVec, FlightPathTurnCalculator.vector3Cache[5]);
            // If the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadiusRad))
                : Infinity;
            const trackLimitPoint = FlightPathTurnCalculator.geoPointCache[5];
            if (isArcFirst) {
                const trackLimitDistance = Math.min(toVectorHalfDistanceRad + intersectionToVectorStartOffset, maxTrackLimitDistance);
                intersectionPoint.offset(toVectorStartBearing, trackLimitDistance, trackLimitPoint);
            }
            else {
                const trackLimitDistance = Math.min(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset, maxTrackLimitDistance);
                intersectionPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, trackLimitPoint);
            }
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(trackPath.center, arcCircle.center);
            const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // Compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = FlightPathTurnCalculator.geoCircleCache[4].setAsGreatCircle(arcDirection === 'left' ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            // the angular width of the portion of the arc path from the intersection to the mid-point of the arc vector
            const arcMidPointAngularWidth = Avionics.Utils.RAD2DEG * (isArcFirst
                ? fromVectorPath.angularWidth(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset)
                : toVectorPath.angularWidth(toVectorHalfDistanceRad + intersectionToVectorStartOffset));
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcMidPointAngularWidth);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * ((arcDirection === 'left') === isArcFirst ? 1 : -1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadiusRad, FlightPathTurnCalculator.geoPointCache[5]);
                const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadiusRad));
                        arcTurnRadiusLimit = (arcRadiusRad - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[5]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[6]), FlightPathTurnCalculator.vector3Cache[6]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[3].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[4].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || intersectionPoint.distance(intersections[0]) >= intersectionPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
        const turnRadiusMeters = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusMeters, turnCenter, turnStart, turnMiddle, turnEnd, areLegsContinuous);
        // If the from- and to- legs are not continuous, then we need to check if we need to extend the turn anticipation
        // path beyond the turn vector to join the from- and to- vectors. If the legs are continuous, we don't need to
        // check because the turn vector is guaranteed to begin before the end of the from-vector and end after the start
        // of the to-vector.
        if (!areLegsContinuous) {
            const intersectionTurnStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, turnStart, intersectionVec);
            const intersectionTurnEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, turnEnd);
            if (intersectionTurnStartOffset > intersectionFromVectorEndOffset + 1e-5) {
                // The turn begins after the end of the from-vector. We need to join the turn vector to the end of the
                // from-vector.
                Object.assign((_a = (_c = fromLegCalc.egress)[1]) !== null && _a !== void 0 ? _a : (_c[1] = FlightPathUtils.createEmptyCircleVector()), fromLegCalc.egress[0]);
                FlightPathUtils.setCircleVector(fromLegCalc.egress[0], fromVectorPath, fromVectorEndPoint, turnStart, fromLegCalc.egress[0].flags);
                fromLegCalc.egress.length = 2;
            }
            else {
                fromLegCalc.egress.length = 1;
            }
            if (intersectionTurnEndOffset < intersectionToVectorStartOffset - 1e-5) {
                // The turn ends before the start of the to-vector. We need to join the turn vector to the start of the
                // to-vector.
                (_b = (_d = toLegCalc.ingress)[1]) !== null && _b !== void 0 ? _b : (_d[1] = FlightPathUtils.createEmptyCircleVector());
                FlightPathUtils.setCircleVector(toLegCalc.ingress[1], toVectorPath, turnEnd, toVectorStartPoint, toLegCalc.ingress[0].flags);
                toLegCalc.ingress.length = 2;
            }
            else {
                toLegCalc.ingress.length = 1;
            }
        }
        return toIndex;
    }
    /**
     * Checks if an intersection between an arc path and a track path is valid for computing turn anticipation between
     * arc and track vectors. The intersection is considered valid if and only if all the following conditions are true:
     * - The intersection is within one nautical mile of the end of the vector on which the turn begins.
     * - The intersection is within one nautical mile of the start of the vector on which the turn ends.
     * - The intersection is located after the mid-point of the vector on which the turn begins.
     * - The intersection is located before the mid-point of the vector on which the turn ends.
     * @param intersection The intersection to check.
     * @param fromVectorPath A geo circle defining the path of the vector on which the turn begins.
     * @param fromVectorEnd The end point of the vector on which the turn begins.
     * @param fromVectorHalfDistance Half of the distance covered by the vector on which the turn begins.
     * @param intersectionFromVectorEndOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the end point of the vector on which the turn begins. Positive offsets indicate the intersection is located
     * after the end point.
     * @param toVectorPath A geo circle defining the path of the vector on which the turn ends.
     * @param toVectorStart The start point of the vector on which the turn ends.
     * @param toVectorHalfDistance Half of the distance covered by the vector on which the turn ends.
     * @param intersectionToVectorStartOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the start point of the vector on which the turn ends. Positive offsets indicate the intersection is located
     * before the start point.
     * @returns Whether the specified intersection is valid for computing turn anticipation between arc and track
     * vectors.
     */
    isArcTrackIntersectionValid(intersection, fromVectorPath, fromVectorEnd, fromVectorHalfDistance, intersectionFromVectorEndOffset, toVectorPath, toVectorStart, toVectorHalfDistance, intersectionToVectorStartOffset) {
        const fromVectorMidVec = fromVectorPath.offsetDistanceAlong(fromVectorEnd, -fromVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[0], Math.PI);
        const toVectorMidVec = toVectorPath.offsetDistanceAlong(toVectorStart, toVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[1], Math.PI);
        return (Math.abs(intersectionFromVectorEndOffset) <= 2.9e-4
            && Math.abs(intersectionToVectorStartOffset) <= 2.9e-4
            && FlightPathUtils.isPointAlongArc(fromVectorPath, fromVectorMidVec, Math.PI, intersection)
            && !FlightPathUtils.isPointAlongArc(toVectorPath, toVectorMidVec, Math.PI, intersection));
    }
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyTurn(fromLegCalc, toLegCalc) {
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        toLegCalc.ingress.length = 0;
        toLegCalc.ingressJoinIndex = -1;
    }
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressEgressArrayLengths Whether to set the ingress and egress vector array lengths to 1. Defaults to
     * `true`.
     */
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end, setIngressEgressArrayLengths = true) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
        this.setAnticipatedTurnEgress(fromLegCalc, circle, start, middle, setIngressEgressArrayLengths);
        this.setAnticipatedTurnIngress(toLegCalc, circle, middle, end, setIngressEgressArrayLengths);
    }
    /**
     * Adds an egress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn begins.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the turn.
     * @param end The location of the end of the egress portion of the turn.
     * @param setEgressArrayLength Whether to set the egress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnEgress(legCalc, circle, start, end, setEgressArrayLength = true) {
        var _a;
        var _b;
        const egress = (_a = (_b = legCalc.egress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setEgressArrayLength) {
            legCalc.egress.length = 1;
        }
        legCalc.egressJoinIndex = legCalc.flightPath.length - 1;
        const egressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(egress, circle, start, end, egressFlags);
    }
    /**
     * Adds an ingress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn ends.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the ingress portion of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressArrayLength Whether to set the ingress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnIngress(legCalc, circle, start, end, setIngressArrayLength = true) {
        var _a;
        var _b;
        const ingress = (_a = (_b = legCalc.ingress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setIngressArrayLength) {
            legCalc.ingress.length = 1;
        }
        legCalc.ingressJoinIndex = 0;
        const ingressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(ingress, circle, start, end, ingressFlags);
    }
    /**
     * Gets the along-circle offset distance from a reference point to a query point, in great-arc radians. The offset
     * is signed, with positive values indicating offsets in the direction of the circle. The calculated offset has the
     * range `[-c / 2, c / 2)`, where `c` is the circumference of the circle.
     * @param circle The geo circle along which to measure the offset.
     * @param reference The reference point.
     * @param query The query point.
     * @param equalityTolerance The tolerance for considering the reference and query points to be equal, in great-arc
     * radians. If the absolute (direction-agnostic) along-circle distance between the reference and query points is less
     * than or equal to this value, then zero will be returned. Defaults to `0`.
     * @returns The along-circle offset distance from the specified reference point to the query point, in great-arc
     * radians.
     */
    static getAlongCircleOffset(circle, reference, query, equalityTolerance) {
        const circumference = circle.arcLength(MathUtils.TWO_PI);
        const halfCircumference = circumference / 2;
        return (circle.distanceAlong(reference, query, Math.PI, equalityTolerance) + halfCircumference) % circumference - halfCircumference;
    }
}
FlightPathTurnCalculator.vector3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
];
FlightPathTurnCalculator.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.isArcTrackIntersectionValidCache = {
    vec3: [Vec3Math.create(), Vec3Math.create()]
};
FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
};

/**
 * Modes for calculating airplane speed for use in flight path calculations.
 */
var FlightPathAirplaneSpeedMode;
(function (FlightPathAirplaneSpeedMode) {
    /** The default airplane speed is always used. */
    FlightPathAirplaneSpeedMode["Default"] = "Default";
    /** Ground speed is used. */
    FlightPathAirplaneSpeedMode["GroundSpeed"] = "GroundSpeed";
    /** True airspeed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeed"] = "TrueAirspeed";
    /** True airspeed plus wind speed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
})(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader, options, bus) {
        this.facilityLoader = facilityLoader;
        this.bus = bus;
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.turnCalculator = new FlightPathTurnCalculator();
        this.state = new FlightPathStateClass();
        this.calculateQueue = [];
        this.isBusy = false;
        this.options = Object.assign({}, options);
        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
        this.bus.getSubscriber().on('flightpath_set_options').handle(newOptions => this.setOptions(newOptions));
    }
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    setOptions(newOptions) {
        for (const key in newOptions) {
            const option = newOptions[key];
            if (option !== undefined) {
                this.options[key] = option;
                switch (key) {
                    case 'bankAngle':
                        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
                        break;
                    case 'holdBankAngle':
                        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
                        break;
                    case 'courseReversalBankAngle':
                        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
                        break;
                    case 'turnAnticipationBankAngle':
                        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
                        break;
                }
            }
        }
    }
    /**
     * Builds a bank angle lookup table.
     * @param angle A constant bank angle, in degrees, or an array of bank angle (degrees) versus airplane speed (knots)
     * breakpoints.
     * @returns A bank angle lookup table.
     */
    buildBankAngleTable(angle) {
        if (typeof angle === 'number') {
            return new LerpLookupTable([[angle, 0]]);
        }
        else {
            return new LerpLookupTable(angle);
        }
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDmeLegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDmeLegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: calc = new NoPathLegCalculator(this.facilityCache),
            [LegType.ThruDiscontinuity]: calc
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        if (this.isBusy || this.calculateQueue.length > 0) {
            return new Promise((resolve, reject) => {
                this.calculateQueue.push(() => { this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count); });
            });
        }
        else {
            return new Promise((resolve, reject) => {
                this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count);
            });
        }
    }
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    async doCalculate(resolve, reject, legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        this.isBusy = true;
        try {
            initialIndex = Math.max(0, initialIndex);
            count = Math.max(0, Math.min(legs.length - initialIndex, count));
            this.state.updatePlaneState(this.options, this.bankAngleTable, this.holdBankAngleTable, this.courseReversalBankAngleTable, this.turnAnticipationBankAngleTable);
            // Because some facilities can be mutated, we always want to get the most up-to-date version from the facility loader
            this.facilityCache.clear();
            await this.loadFacilities(legs, initialIndex, count);
            this.initCurrentLatLon(legs, initialIndex);
            this.initCurrentCourse(legs, initialIndex);
            this.initIsFallback(legs, initialIndex);
            this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
            this.turnCalculator.computeTurns(legs, initialIndex, count, this.state.desiredTurnRadius.asUnit(UnitType.METER), this.state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), this.state.desiredTurnAnticipationTurnRadius.asUnit(UnitType.METER));
            this.resolveLegsIngressToEgress(legs, initialIndex, count);
            this.updateLegDistances(legs, initialIndex, count);
            this.isBusy = false;
            resolve();
        }
        catch (e) {
            this.isBusy = false;
            reject(e);
        }
        const nextInQueue = this.calculateQueue.shift();
        if (nextInQueue !== undefined) {
            nextInQueue();
        }
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (ICAO.isFacility(icao)) {
            facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                .then(facility => {
                this.facilityCache.set(icao, facility);
                return true;
            })
                .catch(() => false));
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) || FlightPlanUtils.isManualDiscontinuityLeg(leg.leg.type)) {
                break;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initIsFallback(legs, initialIndex) {
        var _a, _b, _c;
        this.state.isFallback = (_c = (_b = (_a = legs[Math.min(initialIndex, legs.length) - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endsInFallback) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        const definition = legs[calculateIndex];
        const calcs = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state, false);
        const start = calcs.flightPath[0];
        const end = calcs.flightPath[calcs.flightPath.length - 1];
        calcs.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                calcs.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        calcs.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        calcs.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        calcs.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        calcs.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            calcs.endLat = this.state.currentPosition.lat;
            calcs.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    resolveLegsIngressToEgress(legs, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const legCalc = legs[i].calculated;
            legCalc && FlightPathUtils.resolveIngressToEgress(legCalc);
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistances(legs, initialIndex, count) {
        var _a, _b, _c, _d, _e, _f;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            // Calculate distance without transitions
            calc.distance = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distance += calc.flightPath[j].distance;
            }
            calc.cumulativeDistance = calc.distance + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
            // Calculate distance with transitions
            calc.distanceWithTransitions = 0;
            const ingressLen = calc.ingress.length;
            for (let j = 0; j < ingressLen; j++) {
                calc.distanceWithTransitions += calc.ingress[j].distance;
            }
            const ingressToEgressLen = calc.ingressToEgress.length;
            for (let j = 0; j < ingressToEgressLen; j++) {
                calc.distanceWithTransitions += calc.ingressToEgress[j].distance;
            }
            const egressLen = calc.egress.length;
            for (let j = 0; j < egressLen; j++) {
                calc.distanceWithTransitions += calc.egress[j].distance;
            }
            calc.cumulativeDistanceWithTransitions = calc.distanceWithTransitions + ((_f = (_e = (_d = legs[i - 1]) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
    }
}
/**
 * An implementation of {@link FlightPathState}
 */
class FlightPathStateClass {
    constructor() {
        this.isFallback = false;
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
        this._desiredHoldTurnRadius = UnitType.METER.createNumber(0);
        this.desiredHoldTurnRadius = this._desiredHoldTurnRadius.readonly;
        this._desiredCourseReversalTurnRadius = UnitType.METER.createNumber(0);
        this.desiredCourseReversalTurnRadius = this._desiredCourseReversalTurnRadius.readonly;
        this._desiredTurnAnticipationTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnAnticipationTurnRadius = this._desiredTurnAnticipationTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     * @param bankAngleTable A lookup table for general turn bank angle, in degrees, versus airplane speed.
     * @param holdBankAngleTable A lookup table for hold turn bank angle, in degrees, versus airplane speed, in knots.
     * If not defined, the general turn bank angle table will be used instead.
     * @param courseReversalBankAngleTable A lookup table for course reversal turn bank angle, in degrees, versus
     * airplane speed, in knots. If not defined, the general turn bank angle table will be used instead.
     * @param turnAnticipationBankAngleTable A lookup table for turn anticipation bank angle, in degrees, versus airplane
     * speed, in knots. If not defined, the general turn bank angle table will be used instead.
     */
    updatePlaneState(options, bankAngleTable, holdBankAngleTable, courseReversalBankAngleTable, turnAnticipationBankAngleTable) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        switch (options.airplaneSpeedMode) {
            case FlightPathAirplaneSpeedMode.GroundSpeed:
                this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
                break;
            case FlightPathAirplaneSpeedMode.TrueAirspeed:
            case FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind: {
                const trueAirspeed = SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots);
                const windSpeed = options.airplaneSpeedMode === FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
                    ? SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', SimVarValueType.Knots)
                    : 0;
                this._planeSpeed.set(Math.max(trueAirspeed + windSpeed, options.defaultSpeed));
                break;
            }
            default:
                this._planeSpeed.set(options.defaultSpeed);
        }
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        const planeSpeedKnots = this._planeSpeed.asUnit(UnitType.KNOT);
        this._desiredTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(bankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        if (holdBankAngleTable) {
            this._desiredHoldTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(holdBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredHoldTurnRadius.set(this._desiredTurnRadius);
        }
        if (courseReversalBankAngleTable) {
            this._desiredCourseReversalTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(courseReversalBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredCourseReversalTurnRadius.set(this._desiredTurnRadius);
        }
        if (turnAnticipationBankAngleTable) {
            this._desiredTurnAnticipationTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(turnAnticipationBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredTurnAnticipationTurnRadius.set(this._desiredTurnRadius);
        }
    }
}

var LegEventType;
(function (LegEventType) {
    LegEventType["Added"] = "Added";
    LegEventType["Removed"] = "Removed";
    LegEventType["Changed"] = "Changed";
})(LegEventType || (LegEventType = {}));
var SegmentEventType;
(function (SegmentEventType) {
    SegmentEventType["Added"] = "Added";
    SegmentEventType["Removed"] = "Removed";
    SegmentEventType["Changed"] = "Changed";
    SegmentEventType["Inserted"] = "Inserted";
})(SegmentEventType || (SegmentEventType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex, calculator, onLegNameRequested) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length` if `reverse` is `true`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse = false, startIndex, endIndex) {
        return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
     * @yields This flight plan's legs in forward order.
     */
    *_legs(startIndex = 0, endIndex = this.length) {
        endIndex = Math.min(this.length, endIndex);
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.min(segment.legs.length, endIndex - segment.offset);
                if (end <= 0) {
                    return;
                }
                for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
     * @yields This flight plan's legs in reverse order.
     */
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
        endIndex = Math.max(-1, endIndex);
        for (let i = this.planSegments.length - 1; i > -1; i--) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.max(-1, endIndex - segment.offset);
                if (end >= segment.legs.length) {
                    return;
                }
                for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment);
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment);
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        const segment = this.tryGetSegment(segmentIndex);
        if (segment === null) {
            throw new Error(`Flight plan segment with ${segmentIndex === undefined ? 'active leg' : `segment index ${segmentIndex}`} could not be found.`);
        }
        else {
            return segment;
        }
    }
    /**
     * Attempts to get a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment, or `null` if it could not be found.
     */
    tryGetSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = {
            name: this.onLegNameRequested(leg),
            leg,
            flags,
            verticalData: {
                phase: VerticalFlightPhase.Descent,
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0,
                displayAltitude1AsFlightLevel: false,
                displayAltitude2AsFlightLevel: false,
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS,
            }
        };
        if (segmentLegIndex === undefined) {
            segment.legs.push(legDefinition);
            segmentLegIndex = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(segmentLegIndex, 0, legDefinition);
        }
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition);
        return legDefinition;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLeg(arg1, arg2) {
        const leg = this._tryGetLeg(arg1, arg2);
        if (leg) {
            return leg;
        }
        throw new Error(`Leg with ${arg2 === undefined ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    tryGetLeg(arg1, arg2) {
        return this._tryGetLeg(arg1, arg2);
    }
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    _tryGetLeg(arg1, arg2) {
        var _a, _b;
        if (arg2 === undefined) {
            const legIndex = arg1;
            for (const segment of this.segments()) {
                if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                    return segment.legs[legIndex - segment.offset];
                }
            }
            return null;
        }
        else {
            const segmentIndex = arg1;
            const segmentLegIndex = arg2;
            return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
        }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (segmentLegIndex === undefined) {
            legDefinition = segment.legs.pop();
            segmentLegIndex = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(segmentLegIndex, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition);
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(globalLegIndex, notify = true) {
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);
        notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalRunway = undefined;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        // We iterate of the keys of `details` because we need to be able to set fields to undefined
        // and we only want to overwrite fields that were in the `details` object
        for (const key of Object.keys(details)) {
            this.procedureDetails[key] = details[key];
        }
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex) {
        const segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex === -1) {
            return -1;
        }
        return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            const globalLegIndex = arg1;
            if (globalLegIndex >= 0) {
                segmentIndex = this.getSegmentIndex(globalLegIndex);
                if (segmentIndex >= 0) {
                    segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegVerticalData(arg1, arg2, arg3, arg4) {
        let notify = true;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let verticalData;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            verticalData = arg2;
            notify = arg3 !== undefined ? arg3 : notify;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            verticalData = arg3;
            notify = arg4 !== undefined ? arg4 : notify;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            Object.assign(leg.verticalData, verticalData);
            notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg);
        }
        else {
            console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData(key, data, notify = true) {
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = undefined, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        this.procedureDetails.arrivalRunway = arrivalRunway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @returns The copied flight plan.
     */
    copy(planIndex, copyCalcs = false) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        newPlan.copyFrom(this, copyCalcs);
        return newPlan;
    }
    /**
     * Copies a source flight plan into this one, overriding everything in this plan with everything from the source plan.
     * @param sourcePlan The plan to copy from.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     */
    copyFrom(sourcePlan, copyCalcs = false) {
        if (sourcePlan._originAirport !== undefined) {
            this.setOriginAirport(sourcePlan._originAirport, false);
        }
        else {
            this.removeOriginAirport();
        }
        if (sourcePlan._destinationAirport !== undefined) {
            this.setDestinationAirport(sourcePlan._destinationAirport, false);
        }
        else {
            this.removeDestinationAirport();
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        this.setProcedureDetails(Object.assign(new ProcedureDetails(), sourcePlan.procedureDetails), false);
        for (let i = 0; i < sourcePlan.planSegments.length; i++) {
            const segment = sourcePlan.planSegments[i];
            if (segment !== undefined) {
                this.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
                for (const leg of segment.legs) {
                    const newLeg = this.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
                    const legIndex = this.getLegIndexFromLeg(newLeg);
                    this.setLegVerticalData(legIndex, leg.verticalData);
                    copyCalcs && FlightPlan.copyLegCalculations(leg, newLeg);
                }
            }
        }
        this.setDirectToData(sourcePlan.directToData.segmentIndex, sourcePlan.directToData.segmentLegIndex);
        // Have to copy from the private fields, because the public ones are getters, which would be lost when stringified
        this.setLateralLeg(sourcePlan._activeLateralLeg);
        this.setVerticalLeg(sourcePlan._activeVerticalLeg);
        this.setCalculatingLeg(sourcePlan._activeCalculatingLeg);
        for (const key in this.userData) {
            this.deleteUserData(key);
        }
        for (const key in sourcePlan.userData) {
            this.setUserData(key, sourcePlan.userData[key], false);
        }
    }
    /**
     * Copies leg calcs from an existing leg to a new leg.
     * @param existingLeg The leg that we want to copy the calcs from.
     * @param newLeg The leg that we want to copy the calcs to.
     * @returns the newLeg with the copied calcs.
     */
    static copyLegCalculations(existingLeg, newLeg) {
        if (existingLeg.calculated !== undefined) {
            newLeg.calculated = {
                courseMagVar: existingLeg.calculated.courseMagVar,
                initialDtk: existingLeg.calculated.initialDtk,
                distance: existingLeg.calculated.distance,
                cumulativeDistance: existingLeg.calculated.cumulativeDistance,
                distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
                cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
                startLat: existingLeg.calculated.startLat,
                startLon: existingLeg.calculated.startLon,
                endLat: existingLeg.calculated.endLat,
                endLon: existingLeg.calculated.endLon,
                flightPath: existingLeg.calculated.flightPath.map(vector => Object.assign({}, vector)),
                ingress: existingLeg.calculated.ingress.map(vector => Object.assign({}, vector)),
                ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
                ingressToEgress: existingLeg.calculated.ingressToEgress.map(vector => Object.assign({}, vector)),
                egressJoinIndex: existingLeg.calculated.egressJoinIndex,
                egress: existingLeg.calculated.egress.map(vector => Object.assign({}, vector)),
                endsInFallback: existingLeg.calculated.endsInFallback
            };
        }
        return newLeg;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0,
    verticalAngle: 0,
}, partial);

/**
 * An implementation of {@link SubEventInterface}.
 */
class SubEvent {
    constructor() {
        this.subs = [];
        this.notifyDepth = 0;
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    on(handler, paused = false) {
        const sub = new HandlerSubscription(handler, undefined, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /** @inheritdoc */
    clear() {
        this.notifyDepth++;
        for (let i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
        }
        this.notifyDepth--;
        if (this.notifyDepth === 0) {
            this.subs.length = 0;
        }
    }
    /** @inheritdoc */
    notify(sender, data) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(sender, data);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`SubEvent: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
}

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(bus, calculator, onLegNameRequested = FlightPlanner.buildDefaultLegName) {
        this.bus = bus;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        /** Invoked when we receive a flight plan response event. */
        this.flightPlanSynced = new SubEvent();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('fplsync_fplRequest').handle(data => !this.ignoreSync && this.onFlightPlanRequest(data));
        subscriber.on('fplsync_fplResponse').handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on('fplsync_fplCreated').handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on('fplsync_fplDeleted').handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on('fplsync_fplActiveLegChange').handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on('fplsync_fplLegChange').handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on('fplsync_fplSegmentChange').handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on('fplsync_fplCalculated').handle(data => !this.ignoreSync && this.onCalculated(data));
        subscriber.on('fplsync_fplOriginDestChanged').handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on('fplsync_fplProcDetailsChanged').handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on('fplsync_fplIndexChanged').handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on('fplsync_fplCopied').handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on('fplsync_fplUserDataSet').handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on('fplsync_fplUserDataDelete').handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on('fplsync_fplDirectToDataChanged').handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     * @param data The event data.
     */
    onFlightPlanRequest(data) {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplResponse', {
            uid: data.uid,
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplRequest', { uid: this.lastRequestUid = Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER) }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        if (data.uid !== this.lastRequestUid) {
            return;
        }
        this.lastRequestUid = undefined;
        for (let i = 0; i < data.flightPlans.length; i++) {
            // ignore bogus flight plans
            if (data.flightPlans[i].segmentCount === 0) {
                continue;
            }
            const newPlan = new FlightPlan(i, this.calculator, this.onLegNameRequested);
            newPlan.copyFrom(data.flightPlans[i], true);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
            // Make sure the newly loaded plans are calculated at least once from the beginning
            newPlan.calculate(0);
        }
        // Only process a plan index changed event if the plan actually exists.
        if (this.flightPlans[data.planIndex]) {
            this.onPlanIndexChanged(data);
        }
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: (segmentIndex, index, type, leg) => this.sendLegChanged(planIndex, segmentIndex, index, type, leg),
            onSegmentChanged: (segmentIndex, type, segment) => this.sendSegmentChanged(planIndex, segmentIndex, type, segment),
            onActiveLegChanged: (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => this.sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type),
            onCalculated: (index) => this.sendCalculated(planIndex, index),
            onOriginDestChanged: (type, airport) => this.sendOriginDestChanged(planIndex, type, airport),
            onProcedureDetailsChanged: (details) => this.sendProcedureDetailsChanged(planIndex, details),
            onUserDataSet: (key, data) => this.sendUserDataSet(planIndex, key, data),
            onUserDataDelete: (key) => this.sendUserDataDelete(planIndex, key),
            onDirectDataChanged: (directToData) => this.sendDirectToData(planIndex, directToData)
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, copyCalcs = false, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        const newPlan = sourcePlan.copy(targetPlanIndex, copyCalcs);
        newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
        this.flightPlans[targetPlanIndex] = newPlan;
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex, copyCalcs);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, data.copyCalcs, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     * @param copyCalcs Whether to leg calculations were copied.
     */
    sendPlanCopied(planIndex, targetPlanIndex, copyCalcs) {
        const data = { planIndex, targetPlanIndex, copyCalcs };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        const plan = this.getFlightPlan(data.planIndex);
        let localLeg;
        switch (data.type) {
            case LegEventType.Added: {
                localLeg = plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.flags, false);
                break;
            }
            case LegEventType.Removed: {
                const leg = plan.removeLeg(data.segmentIndex, data.legIndex, false);
                // We don't want to send the event locally if we didn't find a leg
                if (!leg) {
                    return;
                }
                localLeg = leg;
                break;
            }
            case LegEventType.Changed: {
                try {
                    localLeg = plan.getLeg(data.segmentIndex, data.legIndex);
                }
                catch (_a) {
                    // We don't want to send the event locally if we didn't find a leg
                    return;
                }
                plan.setLegVerticalData(data.segmentIndex, data.legIndex, data.leg.verticalData, false);
                break;
            }
        }
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg
        };
        this.sendEvent('fplLegChange', localData, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        var _a, _b;
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        let localSegment = undefined;
        switch (data.type) {
            case SegmentEventType.Added:
                localSegment = data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Inserted:
                localSegment = data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Removed:
                localSegment = (_a = plan.tryGetSegment(data.segmentIndex)) !== null && _a !== void 0 ? _a : undefined;
                plan.removeSegment(data.segmentIndex, false);
                break;
            case SegmentEventType.Changed:
                localSegment = data.segment === undefined ? undefined : (_b = plan.tryGetSegment(data.segmentIndex)) !== null && _b !== void 0 ? _b : undefined;
                if (localSegment === undefined) {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        // We need to send a reference to the local flight plan's copy of the segment with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            segment: localSegment
        };
        this.sendEvent('fplSegmentChange', localData, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    sendSegmentChanged(planIndex, index, type, segment) {
        const data = {
            planIndex, segmentIndex: index, type, segment
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) {
        const data = {
            segmentIndex, legIndex, planIndex,
            index, previousSegmentIndex, previousLegIndex, type
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    async onCalculated(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        await plan.calculate(data.index, false);
        if (this.flightPlans[data.planIndex] !== plan) {
            return;
        }
        this.sendEvent('fplCalculated', data, false);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    sendCalculated(planIndex, index) {
        const data = { planIndex, index };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    sendOriginDestChanged(planIndex, type, airport) {
        const data = { planIndex, type, airport };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        plan.setProcedureDetails(Object.assign(new ProcedureDetails(), data.details), false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    sendProcedureDetailsChanged(planIndex, details) {
        const data = { planIndex, details };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    sendUserDataSet(planIndex, key, userData) {
        const data = { planIndex, key, data: userData };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    sendUserDataDelete(planIndex, key) {
        const data = { planIndex, key, data: undefined };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    sendDirectToData(planIndex, directToData) {
        const data = { planIndex, directToData: directToData };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator, onLegNameRequested) {
        var _a;
        return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : (FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator, onLegNameRequested));
    }
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
}

/**
 * A collection of unique string waypoint type keys.
 */
var WaypointTypes;
(function (WaypointTypes) {
    WaypointTypes["Custom"] = "Custom";
    WaypointTypes["Airport"] = "Airport";
    WaypointTypes["NDB"] = "NDB";
    WaypointTypes["VOR"] = "VOR";
    WaypointTypes["Intersection"] = "Intersection";
    WaypointTypes["Runway"] = "Runway";
    WaypointTypes["User"] = "User";
    WaypointTypes["Visual"] = "Visual";
    WaypointTypes["FlightPlan"] = "FlightPlan";
    WaypointTypes["VNAV"] = "VNAV";
})(WaypointTypes || (WaypointTypes = {}));
/**
 * An abstract implementation of Waypoint.
 */
class AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(other) {
        return this.uid === other.uid;
    }
}
/**
 * A basic implementation of {@link FacilityWaypoint}.
 */
class BasicFacilityWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     * @param bus The event bus.
     */
    constructor(facility, bus) {
        super();
        this.bus = bus;
        /** @inheritdoc */
        this.isFacilityWaypoint = true;
        this._facility = Subject.create(facility);
        this._location = GeoPointSubject.createFromGeoPoint(new GeoPoint(facility.lat, facility.lon));
        this._type = BasicFacilityWaypoint.getType(facility);
        const facType = ICAO.getFacilityType(facility.icao);
        if (facType === FacilityType.VIS || facType === FacilityType.USR) {
            // These types of facilities can be mutated. So we need to listen to the event bus for change events and respond
            // accordingly.
            this.facChangeSub = this.bus.getSubscriber()
                .on(`facility_changed_${facility.icao}`)
                .handle(newFacility => {
                this._facility.set(newFacility);
                this._location.set(newFacility.lat, newFacility.lon);
            });
        }
    }
    /** @inheritdoc */
    get location() {
        return this._location;
    }
    /** @inheritdoc */
    get uid() {
        return this.facility.get().icao;
    }
    /** @inheritdoc */
    get type() {
        return this._type;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The facility associated with this waypoint.
     */
    get facility() {
        return this._facility;
    }
    /**
     * Gets a waypoint type from a facility.
     * @param facility A facility.
     * @returns The waypoint type corresponding to the facility.
     */
    static getType(facility) {
        switch (ICAO.getFacilityType(facility.icao)) {
            case FacilityType.Airport:
                return WaypointTypes.Airport;
            case FacilityType.Intersection:
                return WaypointTypes.Intersection;
            case FacilityType.NDB:
                return WaypointTypes.NDB;
            case FacilityType.RWY:
                return WaypointTypes.Runway;
            case FacilityType.USR:
                return WaypointTypes.User;
            case FacilityType.VIS:
                return WaypointTypes.Visual;
            case FacilityType.VOR:
                return WaypointTypes.VOR;
            default:
                return WaypointTypes.User;
        }
    }
}
/**
 * A utility class for working with FacilityWaypoint.
 */
class FacilityWaypointUtils {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isFacilityWaypoint(waypoint, facilityType) {
        if (waypoint.isFacilityWaypoint !== true) {
            return false;
        }
        return facilityType === undefined || FacilityUtils.isFacilityType(waypoint.facility.get(), facilityType);
    }
}
/**
 * A flight path waypoint.
 */
class FlightPathWaypoint extends AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg1, arg2, arg3, arg4, arg5) {
        super();
        if (typeof arg1 === 'number') {
            this._location = GeoPointSubject.create(new GeoPoint(arg1, arg2));
            this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg4}`;
            this.leg = arg3;
            this.ident = arg5;
        }
        else {
            this._location = arg1;
            this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg3}`;
            this.leg = arg2;
            this.ident = arg4;
        }
    }
    /** @inheritdoc */
    get location() {
        return this._location;
    }
    /** @inheritdoc */
    get uid() {
        return this._uid;
    }
    /** @inheritdoc */
    get type() { return WaypointTypes.FlightPlan; }
}
FlightPathWaypoint.UID_PREFIX = 'FLPTH';
/**
 * A VNAV waypoint.
 */
class VNavWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param uid A unique ID to assign to the VNAV waypoint.
     * @param ident This waypoint's ident string.
     */
    constructor(leg, distanceFromEnd, uid, ident) {
        super();
        this.ident = ident;
        this._uid = uid;
        this._location = GeoPointSubject.create(this.getWaypointLocation(leg, distanceFromEnd, new GeoPoint(0, 0)));
    }
    /** @inheritdoc */
    get type() { return WaypointTypes.VNAV; }
    /** @inheritdoc */
    get location() {
        return this._location;
    }
    /** @inheritdoc */
    get uid() {
        return this._uid;
    }
    /**
     * Sets this waypoint's location.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     */
    setLocation(leg, distanceFromEnd) {
        this._location.set(this.getWaypointLocation(leg, distanceFromEnd, VNavWaypoint.geoPointCache[0]));
    }
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param out The GeoPoint object to which to write the location.
     * @returns The waypoint's location.
     */
    getWaypointLocation(leg, distanceFromEnd, out) {
        var _a, _b;
        if (leg.calculated !== undefined) {
            const vectors = [...leg.calculated.ingress, ...leg.calculated.ingressToEgress, ...leg.calculated.egress];
            let vectorIndex = vectors.length - 1;
            while (vectorIndex >= 0) {
                const vector = vectors[vectorIndex];
                const vectorDistance = vector.distance;
                if (vectorDistance >= distanceFromEnd) {
                    const end = GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, VNavWaypoint.vec3Cache[0]);
                    return FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0])
                        .offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out, Math.PI);
                }
                else {
                    distanceFromEnd -= vectorDistance;
                }
                vectorIndex--;
            }
            if (vectors.length > 0) {
                out.set(vectors[0].startLat, vectors[0].startLon);
            }
            else {
                out.set((_a = leg.calculated.endLat) !== null && _a !== void 0 ? _a : 0, (_b = leg.calculated.endLon) !== null && _b !== void 0 ? _b : 0);
            }
        }
        return out;
    }
}
VNavWaypoint.vec3Cache = [new Float64Array(3)];
VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A default implementation of {@link FacilityWaypointCache}.
 */
class DefaultFacilityWaypointCache {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param size The maximum size of this cache.
     */
    constructor(bus, size) {
        this.bus = bus;
        this.size = size;
        this.cache = new Map();
    }
    /** @inheritdoc */
    get(facility) {
        const key = DefaultFacilityWaypointCache.getFacilityKey(facility);
        let existing = this.cache.get(key);
        if (!existing) {
            existing = new BasicFacilityWaypoint(facility, this.bus);
            this.addToCache(key, existing);
        }
        return existing;
    }
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param key The key of the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    addToCache(key, waypoint) {
        this.cache.set(key, waypoint);
        if (this.cache.size > this.size) {
            this.cache.delete(this.cache.keys().next().value);
        }
    }
    /**
     * Gets a FacilityWaypointCache instance.
     * @param bus The event bus.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache(bus) {
        var _a;
        return (_a = DefaultFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : (DefaultFacilityWaypointCache.INSTANCE = new DefaultFacilityWaypointCache(bus, 1000));
    }
    /**
     * Gets the cache key for a facility.
     * @param facility A facility.
     * @returns The cache key for the specified facility.
     */
    static getFacilityKey(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.Intersection) && ICAO.getFacilityType(facility.icao) !== FacilityType.Intersection) {
            return `mismatch.${facility.icao}`;
        }
        return facility.icao;
    }
}

/**
 * Types of changes made to {@link SubscribableMap}.
 */
var SubscribableMapEventType;
(function (SubscribableMapEventType) {
    /** A key was added. */
    SubscribableMapEventType["Added"] = "Added";
    /** A key's entry was changed. */
    SubscribableMapEventType["Changed"] = "Changed";
    /** A key was deleted. */
    SubscribableMapEventType["Deleted"] = "Deleted";
})(SubscribableMapEventType || (SubscribableMapEventType = {}));

/**
 * A pipe from an input subscribable map to an output mutable subscribable map. Each key-value pair
 * added/changed/removed notification received by the pipe is used to add/change/remove key-value pairs in the output
 * map.
 */
class SubscribableMapPipe extends HandlerSubscription {
    /**
     * Constructor.
     * @param from The input subscribable map.
     * @param to The output mutable subscribable map.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from, to, onDestroy) {
        const handler = (map, type, key, value) => {
            if (type === SubscribableMapEventType.Deleted) {
                to.delete(key);
            }
            else {
                to.setValue(key, value);
            }
        };
        const initialNotifyFunc = () => {
            const fromMap = from.get();
            for (const key of to.get().keys()) {
                if (!fromMap.has(key)) {
                    to.delete(key);
                }
            }
            for (const [key, value] of fromMap) {
                to.setValue(key, value);
            }
        };
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableMap {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableMap = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this map.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    getValue(key) {
        return this.get().get(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this map.
     * @param type The type of change.
     * @param key The key related to the change.
     * @param value The value related to the change.
     */
    notify(type, key, value) {
        const map = this.get();
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(map, type, key, value);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(map, type, key, value);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this map's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const map = this.get();
        for (const [key, value] of map) {
            sub.handler(map, SubscribableMapEventType.Added, key, value);
        }
    }
    /**
     * Responds to when a subscription to this map is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableMap' in to) {
                sub = new SubscribableMapPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
var SubscribableSetEventType;
(function (SubscribableSetEventType) {
    /** A key was added. */
    SubscribableSetEventType["Added"] = "Added";
    /** A key was deleted. */
    SubscribableSetEventType["Deleted"] = "Deleted";
})(SubscribableSetEventType || (SubscribableSetEventType = {}));

/**
 * A pipe from an input subscribable set to an output mutable subscribable set. Each key added/removed notification
 * received by the pipe is used to add/remove keys to/from the output set.
 */
class SubscribableSetPipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let initialNotifyFunc;
        let onDestroy;
        if (typeof arg4 === 'function') {
            const toCast = to;
            const map = arg3;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(map(key));
                }
                else {
                    const mappedKey = map(key);
                    // Only delete the mapped key if no other key in the input set maps to the same key
                    for (const inputKey of set) {
                        if (map(inputKey) === mappedKey) {
                            return;
                        }
                    }
                    toCast.delete(mappedKey);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set();
                for (const key of fromSet) {
                    toAdd.add(map(key));
                }
                for (const key of toCast.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg4;
        }
        else {
            const toCast = to;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(key);
                }
                else {
                    toCast.delete(key);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set(fromSet);
                for (const key of to.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg3;
        }
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableSet {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableSet = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this set.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    notify(type, key) {
        const set = this.get();
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(set, type, key);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(set, type, key);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const set = this.get();
        for (const key of set) {
            sub.handler(set, SubscribableSetEventType.Added, key);
        }
    }
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class ArraySubject extends AbstractSubscribableArray {
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
        super();
        this.array = arr;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of this array. */
    get length() {
        return this.array.length;
    }
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
        return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index) {
        if (index === undefined || index > this.array.length - 1) {
            index = this.array.length;
            this.array.push(item);
        }
        else {
            this.array.splice(index, 0, item);
        }
        this.notify(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
        this.array.splice(index, 0, ...arr);
        this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
        const removedItem = this.array.splice(index, 1);
        this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
        const index = this.array.indexOf(item);
        if (index > -1) {
            this.removeAt(index);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
        this.clear();
        this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
        this.array.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
        return this.array;
    }
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template I The type of the input value.
 * @template T The type of the computed output value.
 */
class ComputedSubject {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
        this.computeFn = computeFn;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
        this.rawValue = value;
        this.value = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
        return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        this.rawValue = value;
        const compValue = this.computeFn(value);
        if (compValue !== this.value) {
            this.value = compValue;
            this.notify();
        }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
        return this.value;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
        return this.rawValue;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    this.notifySubscription(sub);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ComputedSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.value, this.rawValue);
    }
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A subscribable map whose key-value pairs can be freely added and removed.
 */
class MapSubject extends AbstractSubscribableMap {
    /**
     * Constructor.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     */
    constructor(initialEntries) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableMap = true;
        this.backingMap = new Map(initialEntries);
    }
    /**
     * Creates and returns a new MapSubject.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     * @returns A new MapSubject instance.
     */
    static create(initialEntries) {
        return new MapSubject(initialEntries);
    }
    /** @inheritdoc */
    get() {
        return this.backingMap;
    }
    /**
     * Sets the key-value pairs contained in this map.
     * @param entries The key-value pairs to set.
     */
    set(entries) {
        const toAdd = entries instanceof Map ? entries : new Map(entries);
        for (const key of this.backingMap.keys()) {
            if (!toAdd.has(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd.keys()) {
            this.setValue(key, toAdd.get(key));
        }
    }
    /** @inheritdoc */
    setValue(key, value) {
        const hasKey = this.backingMap.has(key);
        const shouldNotify = !hasKey || this.backingMap.get(key) !== value;
        this.backingMap.set(key, value);
        if (shouldNotify) {
            this.notify(hasKey ? SubscribableMapEventType.Changed : SubscribableMapEventType.Added, key, value);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const value = this.backingMap.get(key);
        const wasDeleted = this.backingMap.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
        return wasDeleted;
    }
    /** @inheritdoc */
    clear() {
        for (const [key, value] of this.backingMap) {
            this.backingMap.delete(key);
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
    }
}

/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
class ObjectSubject {
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    constructor(obj) {
        this.obj = obj;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.initialNotify.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create(v) {
        return new ObjectSubject(v);
    }
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get() {
        return this.obj;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, value) {
        if (typeof arg1 === 'object') {
            for (const prop in arg1) {
                if (prop in this.obj) {
                    this.set(prop, arg1[prop]);
                }
            }
        }
        else {
            const oldValue = this.obj[arg1];
            if (value !== oldValue) {
                this.obj[arg1] = value;
                this.notify(arg1, oldValue);
            }
        }
    }
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    notify(key, oldValue) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(this.obj, key, this.obj[key], oldValue);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ObjectSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        for (const key in this.obj) {
            const v = this.obj[key];
            sub.handler(this.obj, key, v, v);
        }
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A subscribable set whose keys can be freely added and removed.
 */
class SetSubject extends AbstractSubscribableSet {
    /**
     * Constructor.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     */
    constructor(initialKeys) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableSet = true;
        this.backingSet = new Set(initialKeys);
    }
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     * @returns A new SetSubject instance.
     */
    static create(initialKeys) {
        return new SetSubject(initialKeys);
    }
    /** @inheritdoc */
    get() {
        return this.backingSet;
    }
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys) {
        const toAdd = new Set(keys);
        for (const key of this.backingSet) {
            if (!toAdd.delete(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd) {
            this.add(key);
        }
    }
    /** @inheritdoc */
    add(key) {
        const oldSize = this.backingSet.size;
        this.backingSet.add(key);
        if (oldSize !== this.backingSet.size) {
            this.notify(SubscribableSetEventType.Added, key);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const wasDeleted = this.backingSet.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableSetEventType.Deleted, key);
        }
        return wasDeleted;
    }
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set. If not defined, the key will be added to this set if it is not already present and
     * removed if it is already present.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key, force) {
        const shouldAdd = force !== null && force !== void 0 ? force : !this.backingSet.has(key);
        if (shouldAdd) {
            this.add(key);
        }
        else {
            this.delete(key);
        }
        // Explicitly query the set again instead of just returning shouldAdd in case the key was manipulated in a handler
        // triggered by its addition/removal
        return this.backingSet.has(key);
    }
    /**
     * Removes all keys from this set.
     */
    clear() {
        for (const key of this.backingSet) {
            this.backingSet.delete(key);
            this.notify(SubscribableSetEventType.Deleted, key);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for electrical information.
 */
class ElectricalPublisher extends SimVarPublisher {
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ElectricalPublisher.simvars, bus, pacer);
        this.flightStarted = false;
        this.avBusList = ['elec_av1_bus', 'elec_av2_bus'];
        for (const topic of this.avBusList) {
            if (bus.getTopicSubscriberCount(topic)) {
                this.subscribed.add(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((event) => {
            if (this.avBusList.includes(event)) {
                this.subscribed.add(event);
            }
        });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.flightStarted = true;
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.flightStarted) {
            super.onUpdate();
            if (this.av1BusLogic && this.subscribed.has('elec_av1_bus')) {
                this.publish('elec_av1_bus', this.av1BusLogic.getValue() !== 0);
            }
            if (this.av2BusLogic && this.subscribed.has('elec_av2_bus')) {
                this.publish('elec_av2_bus', this.av2BusLogic.getValue() !== 0);
            }
        }
    }
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement) {
        this.av1BusLogic = logicElement;
    }
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement) {
        this.av2BusLogic = logicElement;
    }
}
ElectricalPublisher.simvars = new Map([
    ['elec_master_battery', { name: 'ELECTRICAL MASTER BATTERY:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_avionics_on', { name: 'CIRCUIT AVIONICS ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_navcom1_on', { name: 'CIRCUIT NAVCOM1 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom2_on', { name: 'CIRCUIT NAVCOM2 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom3_on', { name: 'CIRCUIT NAVCOM3 ON', type: SimVarValueType.Bool }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE:#index#', type: SimVarValueType.Volts, indexed: true }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_2_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:2', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_3_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:3', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_4_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:4', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_5_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:5', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_6_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:6', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_2_a', { name: 'ELECTRICAL GENALT BUS AMPS:2', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_3_a', { name: 'ELECTRICAL GENALT BUS AMPS:3', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_4_a', { name: 'ELECTRICAL GENALT BUS AMPS:4', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_5_a', { name: 'ELECTRICAL GENALT BUS AMPS:5', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_6_a', { name: 'ELECTRICAL GENALT BUS AMPS:6', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_ext_power_available', { name: 'EXTERNAL POWER AVAILABLE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_ext_power_on', { name: 'EXTERNAL POWER ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_switch', { name: 'APU GENERATOR SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_active', { name: 'APU GENERATOR ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_eng_gen_switch', { name: 'GENERAL ENG MASTER ALTERNATOR:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_on', { name: 'CIRCUIT ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_switch_on', { name: 'CIRCUIT SWITCH ON:#index#', type: SimVarValueType.Bool, indexed: true }],
]);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/** A publisher for Engine information. */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const isUsingAdvancedFuelSystem = SimVar.GetSimVarValue('NEW FUEL SYSTEM', SimVarValueType.Bool) !== 0;
        const totalUnusableFuelGal = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.GAL);
        const totalUnusableFuelLb = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.LBS);
        const nonIndexedSimVars = [
            ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
            ['fuel_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_usable_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelGal, 0) }],
            ['fuel_usable_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelLb, 0) }],
            ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main', { name: 'FUEL TANK LEFT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main_pct', { name: 'FUEL TANK LEFT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_right_main', { name: 'FUEL TANK RIGHT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right_main_pct', { name: 'FUEL TANK RIGHT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_center', { name: 'FUEL TANK CENTER QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_weight_per_gallon', { name: 'FUEL WEIGHT PER GALLON', type: SimVarValueType.LBS }],
            ['fuel_tank_selector_state_1', { name: 'FUEL TANK SELECTOR:1', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_2', { name: 'FUEL TANK SELECTOR:2', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_3', { name: 'FUEL TANK SELECTOR:3', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_4', { name: 'FUEL TANK SELECTOR:4', type: SimVarValueType.Number }],
            ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
            ['apu_pct', { name: 'APU PCT RPM', type: SimVarValueType.Percent }],
            ['apu_pct_starter', { name: 'APU PCT STARTER', type: SimVarValueType.Percent }],
            ['apu_switch', { name: 'APU SWITCH', type: SimVarValueType.Bool }],
            ['eng_starter_active', { name: 'GENERAL ENG STARTER ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
        ];
        const engineIndexedSimVars = [
            ['rpm', { name: 'GENERAL ENG RPM', type: SimVarValueType.RPM }],
            ['prop_rpm', { name: 'PROP RPM', type: SimVarValueType.RPM }],
            ['n1', { name: 'TURB ENG CORRECTED N1', type: SimVarValueType.Percent }],
            ['n2', { name: 'TURB ENG CORRECTED N2', type: SimVarValueType.Percent }],
            ['torque', { name: 'TURB ENG MAX TORQUE PERCENT', type: SimVarValueType.Percent }],
            ['fuel_flow', { name: 'ENG FUEL FLOW GPH', type: SimVarValueType.GPH }],
            ['recip_ff', { name: 'RECIP ENG FUEL FLOW', type: SimVarValueType.PPH }],
            ['oil_press', { name: 'ENG OIL PRESSURE', type: SimVarValueType.PSI }],
            ['oil_temp', { name: 'ENG OIL TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['itt', { name: 'TURB ENG ITT', type: SimVarValueType.Celsius }],
            ['egt', { name: 'ENG EXHAUST GAS TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['eng_hyd_press', { name: 'ENG HYDRAULIC PRESSURE', type: SimVarValueType.PSI }],
            ['eng_starter_on', { name: 'GENERAL ENG STARTER', type: SimVarValueType.Bool }],
            ['eng_combustion', { name: 'GENERAL ENG COMBUSTION', type: SimVarValueType.Bool }],
            ['eng_ignition_switch_state', { name: 'TURB ENG IGNITION SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_igniting', { name: 'TURB ENG IS IGNITING', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_on', { name: 'GENERAL ENG FUEL PUMP ON', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_switch_state', { name: 'GENERAL ENG FUEL PUMP SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_vibration', { name: 'ENG VIBRATION', type: SimVarValueType.Number }],
            ['fuel_flow_pph', { name: 'ENG FUEL FLOW PPH', type: SimVarValueType.PPH }],
        ];
        const simvars = new Map(nonIndexedSimVars);
        // add engine-indexed simvars
        const engineCount = SimVar.GetSimVarValue('NUMBER OF ENGINES', SimVarValueType.Number);
        for (const [topic, simvar] of [...engineIndexedSimVars]) {
            // describe the indexed engine topics
            for (let i = 1; i <= engineCount; i++) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
        this.engineCount = engineCount;
        this.subscribed.add('fuel_flow_total');
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.subscribed.has('fuel_flow_total')) {
            let totalFuelFlow = 0;
            for (let i = 1; i <= this.engineCount; i++) {
                totalFuelFlow += SimVar.GetSimVarValue(`ENG FUEL FLOW GPH:${i}`, SimVarValueType.GPH);
            }
            this.publish('fuel_flow_total', totalFuelFlow);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Engine information.
 */
class WeightBalanceSimvarPublisher extends SimVarPublisher {
    /**
     * Create a WeightAndBalancePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['total_weight', { name: 'TOTAL WEIGHT', type: SimVarValueType.Pounds }],
            ['payload_station_weight', { name: 'PAYLOAD STATION WEIGHT:#index#', type: SimVarValueType.Pounds, indexed: true }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * Flight timer modes.
 */
var FlightTimerMode;
(function (FlightTimerMode) {
    FlightTimerMode[FlightTimerMode["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode[FlightTimerMode["CountingUp"] = 1] = "CountingUp";
})(FlightTimerMode || (FlightTimerMode = {}));
/**
 * A publisher for flight timer information.
 */
class FlightTimerPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, timerCount, pacer) {
        const simVars = new Map();
        const baseSimVars = [
            ['timer_mode', { name: 'L:WTFltTimer_Mode', type: SimVarValueType.Number }],
            ['timer_is_running', { name: 'L:WTFltTimer_Running', type: SimVarValueType.Bool }],
            ['timer_initial_value_ms', { name: 'L:WTFltTimer_Initial_Value', type: SimVarValueType.Number }],
            ['timer_value_ms', { name: 'L:WTFltTimer_Value', type: SimVarValueType.Number }]
        ];
        timerCount = Math.max(timerCount, 0);
        for (let i = 1; i <= timerCount; i++) {
            for (const [topic, simvar] of baseSimVars) {
                simVars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type
                });
            }
        }
        super(simVars, bus, pacer);
    }
}
/**
 * An instrument which manages zero or more flight timers. Requires the topics defined in {@link ClockEvents} to be
 * actively published to the event bus in order to function properly. All timers operate using simulation time and are
 * updated every instrument update cycle with up to millisecond precision.
 */
class FlightTimerInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     */
    constructor(bus, timerCount) {
        this.bus = bus;
        this.timers = {};
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), 0).pause();
        this.lastUpdateSimTime = this.simTime.get();
        this.timerCount = Math.max(timerCount, 0);
        for (let i = 1; i <= this.timerCount; i++) {
            this.timers[i] = new FlightTimer(bus, i);
        }
    }
    /** @inheritdoc */
    init() {
        this.simTime.resume();
        this.lastUpdateSimTime = this.simTime.get();
        for (let i = 1; i <= this.timerCount; i++) {
            this.timers[i].init(this.lastUpdateSimTime);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        const currentSimTime = this.simTime.get();
        for (let i = 1; i <= this.timerCount; i++) {
            this.timers[i].update(currentSimTime);
        }
        this.lastUpdateSimTime = currentSimTime;
    }
}
/**
 * A flight timer.
 */
class FlightTimer {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of this timer.
     */
    constructor(bus, index) {
        this.bus = bus;
        this.index = index;
        this.simVars = {
            mode: `L:WTFltTimer_Mode:${this.index}`,
            isRunning: `L:WTFltTimer_Running:${this.index}`,
            referenceTime: `L:WTFltTimer_Reference_Time:${this.index}`,
            referenceValue: `L:WTFltTimer_Reference_Value:${this.index}`,
            initialValue: `L:WTFltTimer_Initial_Value:${this.index}`,
            currentValue: `L:WTFltTimer_Value:${this.index}`
        };
        this.simTime = 0;
        this.mode = FlightTimerMode.CountingDown;
        this.isRunning = false;
        this.referenceTime = 0;
        this.referenceValue = 0;
        this.initialValue = 0;
        this.currentValue = 0;
    }
    /**
     * Initializes this timer. Once this timer is initialized, it will respond to timer control events.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     */
    init(time) {
        this.simTime = time;
        // Initialize state from simvars
        this.mode = SimVar.GetSimVarValue(this.simVars.mode, SimVarValueType.Number);
        this.isRunning = !!SimVar.GetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool);
        this.referenceTime = SimVar.GetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number);
        this.referenceValue = SimVar.GetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number);
        this.initialValue = SimVar.GetSimVarValue(this.simVars.initialValue, SimVarValueType.Number);
        this.currentValue = SimVar.GetSimVarValue(this.simVars.currentValue, SimVarValueType.Number);
        // Subscribe to control events
        const sub = this.bus.getSubscriber();
        sub.on(`timer_set_mode_${this.index}`).handle(mode => {
            this.mode = mode;
            this.referenceTime = this.simTime;
            this.referenceValue = this.currentValue;
            SimVar.SetSimVarValue(this.simVars.mode, SimVarValueType.Number, mode);
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
        });
        sub.on(`timer_set_initial_value_${this.index}`).handle(value => {
            this.initialValue = value;
            SimVar.SetSimVarValue(this.simVars.initialValue, SimVarValueType.Number, this.initialValue);
        });
        sub.on(`timer_set_value_${this.index}`).handle(value => {
            this.referenceTime = this.simTime;
            this.referenceValue = value;
            this.currentValue = value;
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
        });
        sub.on(`timer_start_${this.index}`).handle(() => {
            if (this.isRunning) {
                return;
            }
            this.isRunning = true;
            this.referenceTime = this.simTime;
            this.referenceValue = this.currentValue;
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
            SimVar.SetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool, 1);
        });
        sub.on(`timer_stop_${this.index}`).handle(() => {
            if (!this.isRunning) {
                return;
            }
            this.isRunning = false;
            SimVar.SetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool, 0);
        });
        sub.on(`timer_reset_${this.index}`).handle(() => {
            this.referenceTime = this.simTime;
            this.referenceValue = this.initialValue;
            this.currentValue = this.initialValue;
            SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
            SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
            SimVar.SetSimVarValue(this.simVars.currentValue, SimVarValueType.Number, this.currentValue);
        });
    }
    /**
     * Updates this timer's current value.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        this.simTime = time;
        if (!this.isRunning) {
            return;
        }
        const modeSign = this.mode === FlightTimerMode.CountingDown ? -1 : 1;
        const value = this.referenceValue + (time - this.referenceTime) * modeSign;
        this.currentValue = value;
        SimVar.SetSimVarValue(this.simVars.currentValue, SimVarValueType.Number, value);
    }
}

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * A publisher for global positioning and inertial data.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['zulu_time', { name: 'E:ZULU TIME', type: SimVarValueType.Seconds }],
            ['time_of_day', { name: 'E:TIME OF DAY', type: SimVarValueType.Number }],
            ['ground_speed', { name: 'GROUND VELOCITY', type: SimVarValueType.Knots }],
            ['inertial_vertical_speed', { name: 'VELOCITY WORLD Y', type: SimVarValueType.FPM }]
        ]), this.bus, this.pacer);
        this.needPublish = {
            'gps-position': false,
            'track_deg_true': false,
            'track_deg_magnetic': false,
            'magvar': false,
            'inertial_speed': false,
            'inertial_acceleration': false,
            'inertial_track_acceleration': false
        };
        for (const topic in this.needPublish) {
            this.needPublish[topic] = bus.getTopicSubscriberCount(topic) > 0;
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle(this.onTopicSubscribed.bind(this));
    }
    /**
     * Responds to when a topic is first subscribed to on the event bus.
     * @param topic The subscribed topic.
     */
    onTopicSubscribed(topic) {
        if (topic in this.needPublish) {
            this.needPublish[topic] = true;
            if (this.publishActive) {
                switch (topic) {
                    case 'gps-position':
                        this.publishPosition();
                        break;
                    case 'track_deg_true':
                        this.publishTrack(true, false, false);
                        break;
                    case 'track_deg_magnetic':
                        this.publishTrack(false, true, false);
                        break;
                    case 'magvar':
                        this.publishTrack(false, false, true);
                        break;
                    case 'inertial_speed':
                        this.publishInertialData(true, false, false);
                        break;
                    case 'inertial_acceleration':
                        this.publishInertialData(false, true, false);
                        break;
                    case 'inertial_track_acceleration':
                        this.publishInertialData(false, false, true);
                        break;
                }
            }
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        this.needPublish['gps-position'] && this.publishPosition();
        this.publishTrack(this.needPublish['track_deg_true'], this.needPublish['track_deg_magnetic'], this.needPublish['magvar']);
        this.publishInertialData(this.needPublish['inertial_speed'], this.needPublish['inertial_acceleration'], this.needPublish['inertial_track_acceleration']);
        this.simVarPublisher.onUpdate();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Meters);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the `track_deg_true`, `track_deg_magnetic`, and `magvar` topics.
     * @param publishTrue Whether to publish the `track_deg_true` topic.
     * @param publishMagnetic Whether to publish the `track_deg_magnetic` topic.
     * @param publishMagvar Whether to publish the `magvar` topic.
     */
    publishTrack(publishTrue, publishMagnetic, publishMagvar) {
        let trueTrack = 0;
        let magneticTrack = 0;
        let magvar = 0;
        if (publishTrue || publishMagnetic) {
            const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
            trueTrack = GNSSPublisher.getInstantaneousTrack(headingTrue);
        }
        if (publishMagvar || publishMagnetic) {
            magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
            if (publishMagnetic) {
                magneticTrack = NavMath.normalizeHeading(trueTrack - magvar);
            }
        }
        publishTrue && this.publish('track_deg_true', trueTrack);
        publishMagnetic && this.publish('track_deg_magnetic', magneticTrack);
        publishMagvar && this.publish('magvar', magvar);
    }
    /**
     * Publishes the `inertial_speed`, `inertial_acceleration`, and `inertial_track_acceleration` topics.
     * @param publishSpeed Whether to publish the `inertial_speed` topic.
     * @param publishAcceleration Whether to publish the `inertial_acceleration` topic.
     * @param publishTrackAcceleration Whether to publish the `inertial_track_acceleration` topic.
     */
    publishInertialData(publishSpeed, publishAcceleration, publishTrackAcceleration) {
        const velocityVec = this.vec3Cache[0];
        const accelerationVec = this.vec3Cache[1];
        let speed = 0;
        let acceleration = 0;
        if (publishSpeed || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('VELOCITY BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Z', SimVarValueType.MetersPerSecond), velocityVec);
            speed = Vec3Math.abs(velocityVec);
        }
        if (publishAcceleration || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('ACCELERATION BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Z', SimVarValueType.MetersPerSecond), accelerationVec);
            acceleration = Vec3Math.abs(accelerationVec);
        }
        publishSpeed && this.publish('inertial_speed', speed);
        publishAcceleration && this.publish('inertial_acceleration', acceleration);
        publishTrackAcceleration && this.publish('inertial_track_acceleration', speed === 0 ? acceleration : Vec3Math.dot(accelerationVec, velocityVec) / speed);
    }
    /**
     * Gets the instantaneous true track.
     * @param headingTrue The true heading, in degrees.
     * @returns The true track, in degrees.
     */
    static getInstantaneousTrack(headingTrue = 0) {
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(Math.atan2(velocityEW, velocityNS) * Avionics.Utils.RAD2DEG);
        }
        return track;
    }
}

/**
 * A heap which allocates instances of a resource.
 */
class ResourceHeap {
    /**
     * Constructor.
     * @param factory A function which creates new instances of this heap's resource.
     * @param destructor A function which destroys instances of this heap's resource.
     * @param onAllocated A function which is called when an instance of this heap's resource is allocated.
     * @param onFreed A function which is called when an instance of this heap's resource is freed.
     * @param initialSize The initial size of this heap. Defaults to `0`.
     * @param maxSize The maximum size of this heap. Defaults to `Number.MAX_SAFE_INTEGER`. This heap cannot allocate
     * more resources than its maximum size.
     * @param autoShrinkThreshold The size above which this heap will attempt to automatically reduce its size when
     * resources are freed. The heap will never reduce its size below this threshold. Defaults to
     * `Number.MAX_SAFE_INTEGER`.
     */
    constructor(factory, destructor, onAllocated, onFreed, initialSize = 0, maxSize = Number.MAX_SAFE_INTEGER, autoShrinkThreshold = Number.MAX_SAFE_INTEGER) {
        this.factory = factory;
        this.destructor = destructor;
        this.onAllocated = onAllocated;
        this.onFreed = onFreed;
        this.maxSize = maxSize;
        this.autoShrinkThreshold = autoShrinkThreshold;
        this.cache = [];
        this.numAllocated = 0;
        for (let i = 0; i < Math.min(initialSize, maxSize); i++) {
            this.cache.push(factory());
        }
    }
    /**
     * Allocates a resource instance from this heap. If this heap has an existing free resource available, one will be
     * returned. Otherwise, a new resource instance will be created, added to the heap, and returned.
     * @returns A resource.
     * @throws Error if this heap has reached its allocation limit.
     */
    allocate() {
        if (this.numAllocated >= this.maxSize) {
            throw new Error(`ResourceHeap: maximum number of allocations (${this.maxSize}) reached`);
        }
        let resource;
        if (this.numAllocated < this.cache.length) {
            resource = this.cache[this.numAllocated];
        }
        else {
            this.cache.push(resource = this.factory());
        }
        this.numAllocated++;
        if (this.onAllocated !== undefined) {
            this.onAllocated(resource);
        }
        return resource;
    }
    /**
     * Frees a resource instance allocated from this heap, allowing it to be re-used.
     * @param resource The resource to free.
     */
    free(resource) {
        const index = this.cache.indexOf(resource);
        if (index < 0 || index >= this.numAllocated) {
            return;
        }
        const freed = this.cache[index];
        this.numAllocated--;
        this.cache[index] = this.cache[this.numAllocated];
        this.cache[this.numAllocated] = freed;
        // If the heap size is over the auto-shrink threshold and the number of allocated instances drops to less than or
        // equal to half of the heap size, then reduce the size of the heap to the threshold, or 125% of the number of
        // allocated instances, whichever is greater.
        if (this.cache.length > this.autoShrinkThreshold && this.numAllocated <= this.cache.length / 2) {
            const newLength = Math.max(this.autoShrinkThreshold, this.numAllocated * 1.25);
            for (let i = newLength; i < this.cache.length; i++) {
                this.destructor(this.cache[i]);
            }
            this.cache.length = newLength;
        }
        if (this.onFreed !== undefined) {
            this.onFreed(resource);
        }
    }
}

/**
 * SBAS group names.
 */
var SBASGroupName;
(function (SBASGroupName) {
    /** Wide Area Augmentation System (USA). */
    SBASGroupName["WAAS"] = "WAAS";
    /** European Geostationary Navigation Overlay Service (EU). */
    SBASGroupName["EGNOS"] = "EGNOS";
    /** GPS Aided Geo Augmented Navigation System (India). */
    SBASGroupName["GAGAN"] = "GAGAN";
    /** Multi-functional Satellite Augmentation System (Japan). */
    SBASGroupName["MSAS"] = "MSAS";
})(SBASGroupName || (SBASGroupName = {}));
/**
 * An instrument that computes GPS satellite information.
 */
class GPSSatComputer {
    /**
     * Creates an instance of GPSSat.
     * @param index The index of this GPSSat.
     * @param bus An instance of the event bus.
     * @param ephemerisFile The HTTP path to the ephemeris file to use for computations.
     * @param sbasFile The HTTP path to the SBAS definitions file.
     * @param updateInterval The interval in milliseconds to update the satellite positions.
     * @param enabledSBASGroups The names of the SBAS satellite groups for which signal reception is enabled.
     * @param syncRole This system's sync role. A `primary` system will broadcast sync events through the event bus when
     * satellite positions are calculated, satellite states change, or the system is reset. A `replica` system will
     * listen for the aforementioned sync events on the event bus and set its state accordingly. A system with a sync
     * role of `none` does neither; it maintains its own independent state and does not sync it to other systems.
     */
    constructor(index, bus, ephemerisFile, sbasFile, updateInterval, enabledSBASGroups, syncRole = 'none') {
        this.index = index;
        this.bus = bus;
        this.ephemerisFile = ephemerisFile;
        this.sbasFile = sbasFile;
        this.updateInterval = updateInterval;
        this.syncRole = syncRole;
        this.publisher = this.bus.getPublisher();
        this.syncPublisher = this.bus.getPublisher();
        this.stateChangedTopic = `gps_system_state_changed_${this.index}`;
        this.satStateChangedTopic = `gps_sat_state_changed_${this.index}`;
        this.satPosCalcTopic = `gps_sat_pos_calculated_${this.index}`;
        this.sbasStateChangedTopic = `gps_system_sbas_state_changed_${this.index}`;
        this.pdopTopic = `gps_system_pdop_${this.index}`;
        this.hdopTopic = `gps_system_hdop_${this.index}`;
        this.vdopTopic = `gps_system_vdop_${this.index}`;
        this.satCalcSyncTopic = `gps_system_sync_sat_calc_${this.index}`;
        this.satStateSyncTopic = `gps_system_sync_sat_state_changed_${this.index}`;
        this.resetSyncTopic = `gps_system_sync_reset_${this.index}`;
        this.satStateRequestSyncTopic = `gps_system_sync_sat_state_request_${this.index}`;
        this.satStateResponseSyncTopic = `gps_system_sync_sat_state_response_${this.index}`;
        this.ephemerisData = {};
        this.sbasData = [];
        this.sbasServiceAreas = new Map();
        this.currentSbasGroupsInView = new Set();
        this.satellites = [];
        this.ppos = new GeoPoint(0, 0);
        this.pposVec = new Float64Array(2);
        this.vecHeap = new ResourceHeap(() => Vec3Math.create(), () => { });
        this.altitude = 0;
        this.previousSimTime = 0;
        this.previousUpdate = 0;
        this.simTime = 0;
        this._state = GPSSystemState.Searching;
        this._sbasState = GPSSystemSBASState.Disabled;
        this.dops = Vec3Math.create();
        this._pdop = -1;
        this._hdop = -1;
        this._vdop = -1;
        this.isInit = false;
        this.needAcquireAndUse = false;
        this.needSatCalc = false;
        this.pendingSatStateUpdates = new Map();
        this.enabledSBASGroups = 'isSubscribableSet' in enabledSBASGroups ? enabledSBASGroups : SetSubject.create(enabledSBASGroups);
        this.bus.getSubscriber().on('gps-position').handle(pos => {
            this.ppos.set(pos.lat, pos.long);
            Vec2Math.set(pos.lat, pos.long, this.pposVec);
            this.altitude = pos.alt;
        });
        this.bus.getSubscriber().on('simTime').handle(time => this.simTime = time);
    }
    /**
     * Gets the current GPS system state.
     * @returns The current GPS system state.
     */
    get state() {
        return this._state;
    }
    /**
     * Gets the current GPS system SBAS state.
     * @returns The current GPS system SBAS state.
     */
    get sbasState() {
        return this._sbasState;
    }
    /**
     * Gets this system's current position dilution of precision value (PDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current position dilution of precision value (PDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get pdop() {
        return this._pdop;
    }
    /**
     * Gets this system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get hdop() {
        return this._hdop;
    }
    /**
     * Gets this system's current vertical dilution of precision value (VDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current vertical dilution of precision value (VDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get vdop() {
        return this._vdop;
    }
    /**
     * Adds the defined SBAS satellites to the tracked satellites.
     */
    addSbasSatellites() {
        const tempVec = new Float64Array(3);
        const tempGeoPoint = new GeoPoint(0, 0);
        const orbitHeight = UnitType.KILOMETER.convertTo(35785, UnitType.GA_RADIAN);
        for (let i = 0; i < this.sbasData.length; i++) {
            const sbasDef = this.sbasData[i];
            this.sbasServiceAreas.set(sbasDef.group, sbasDef.coverage);
            for (const satDef of sbasDef.constellation) {
                const sat = new GPSSatellite(satDef.prn, sbasDef.group);
                tempGeoPoint.set(0, satDef.lon);
                const positionCartesian = Vec3Math.multScalar(tempGeoPoint.toCartesian(tempVec), orbitHeight, tempVec);
                sat.positionCartesian.set(positionCartesian);
                this.satellites.push(sat);
            }
        }
    }
    /** @inheritdoc */
    init() {
        // Publish initial state.
        this.publisher.pub(this.stateChangedTopic, this._state, false, true);
        this.publisher.pub(this.sbasStateChangedTopic, this._sbasState, false, true);
        this.publisher.pub(this.pdopTopic, this._pdop, false, true);
        this.publisher.pub(this.hdopTopic, this._hdop, false, true);
        this.publisher.pub(this.vdopTopic, this._vdop, false, true);
        this.loadEphemerisData().then(() => this.loadSbasData()).then(() => {
            this.isInit = true;
            // Setup sync logic.
            if (this.syncRole === 'replica') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satCalcSyncTopic).handle(() => { this.needSatCalc = true; });
                sub.on(this.satStateSyncTopic).handle(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                sub.on(this.resetSyncTopic).handle(() => { this.reset(); });
                sub.on(this.satStateResponseSyncTopic).handle(response => {
                    this.needSatCalc = true;
                    response.forEach(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                });
                // Request initial state.
                this.syncPublisher.pub(this.satStateRequestSyncTopic, undefined, true, false);
            }
            else if (this.syncRole === 'primary') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satStateRequestSyncTopic).handle(() => {
                    this.syncPublisher.pub(this.satStateResponseSyncTopic, this.satellites.map(sat => { return { prn: sat.prn, state: sat.state.get() }; }), true, false);
                });
            }
            if (this.needAcquireAndUse) {
                this.needAcquireAndUse = false;
                this.acquireAndUseSatellites();
            }
            else {
                this.reset();
            }
        });
    }
    /**
     * Loads the GPS ephemeris data file.
     */
    loadEphemerisData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.ephemerisData = JSON.parse(request.responseText);
                        for (const prn in this.ephemerisData) {
                            this.satellites.push(new GPSSatellite(parseInt(prn), undefined, this.ephemerisData[prn]));
                        }
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with ephemeris data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.ephemerisFile);
            request.send();
        });
    }
    /**
     * Loads the GPS SBAS data file.
     */
    loadSbasData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.sbasData = JSON.parse(request.responseText);
                        this.addSbasSatellites();
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with sbas data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.sbasFile);
            request.send();
        });
    }
    /**
     * Instantly acquires and starts using all satellites with sufficient signal strength. If signal strength allows,
     * SBAS satellites are instantly promoted to the {@link GPSSatelliteState.Acquired} state, and GPS satellites are
     * instantly promoted to the {@link GPSSatelliteState.InUse}/{@link GPSSatelliteState.InUseDiffApplied} state.
     *
     * If this system is not initialized, the operation will be delayed until just after initialization, unless `reset()`
     * is called between now and then.
     *
     * Has no effect if this system is a replica.
     */
    acquireAndUseSatellites() {
        if (this.syncRole === 'replica') {
            return;
        }
        if (this.isInit) {
            this.updateSatellites(0, true, true);
        }
        else {
            this.needAcquireAndUse = true;
        }
    }
    /**
     * Resets the GPSSatComputer system. This will set the of the system to {@link GPSSystemState.Searching} and the
     * state of every satellite to {@link GPSSatelliteState.None}.
     *
     * If this system is not initialized, this method has no effect other than to cancel any pending operations triggered
     * by previous calls to `acquireAndUseSatellites()`.
     */
    reset() {
        this.needAcquireAndUse = false;
        if (!this.isInit) {
            return;
        }
        this.satellites.forEach(sat => {
            const currentState = sat.state.get();
            sat.state.set(GPSSatelliteState.None);
            if (currentState !== GPSSatelliteState.None) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
            }
        });
        const currentState = this._state;
        this._state = GPSSystemState.Searching;
        if (currentState !== GPSSystemState.Searching) {
            this.publisher.pub(this.stateChangedTopic, GPSSystemState.Searching, false, true);
        }
        this.setDop(-1, -1, -1);
        if (this.syncRole === 'primary') {
            this.syncPublisher.pub(this.resetSyncTopic, undefined, true, false);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isInit) {
            return;
        }
        const deltaTime = this.simTime - this.previousSimTime;
        if (this.syncRole !== 'replica') {
            if (deltaTime < 0 || deltaTime > (this.updateInterval * 2)) {
                this.previousSimTime = this.simTime;
                this.previousUpdate = this.simTime;
                return;
            }
        }
        const shouldUpdatePositions = this.syncRole === 'replica'
            ? this.needSatCalc
            : this.simTime >= this.previousUpdate + this.updateInterval;
        this.needSatCalc = false;
        this.updateSatellites(deltaTime, shouldUpdatePositions, false);
    }
    /**
     * Updates the states and optionally the orbital positions of all satellites.
     * @param deltaTime The time elapsed, in milliseconds, since the last satellite update.
     * @param shouldUpdatePositions Whether to update the orbital positions of the satellites.
     * @param forceAcquireAndUse Whether to immediately force satellites to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} for SBAS satellites and {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} for GPS satellites) if signal strength is sufficient.
     */
    updateSatellites(deltaTime, shouldUpdatePositions, forceAcquireAndUse) {
        var _a, _b, _c, _d;
        let numAcquiring = 0;
        let numActiveSbas = 0;
        let shouldUpdateDop = shouldUpdatePositions;
        if (shouldUpdatePositions && this.syncRole === 'primary') {
            (_a = this.syncPublisher) === null || _a === void 0 ? void 0 : _a.pub(this.satCalcSyncTopic, undefined, true, false);
        }
        this.currentSbasGroupsInView.clear();
        const enabledSBASGroups = this.enabledSBASGroups.get();
        for (let i = 0; i < this.satellites.length; i++) {
            const sat = this.satellites[i];
            if (shouldUpdatePositions) {
                sat.computeSatellitePositions(this.simTime);
                sat.applyProjection(this.ppos, this.altitude);
            }
            sat.calculateSignalStrength(this.altitude);
            const updatedState = this.syncRole === 'replica'
                ? sat.forceUpdateState((_c = (_b = this.pendingSatStateUpdates.get(sat.prn)) === null || _b === void 0 ? void 0 : _b.state) !== null && _c !== void 0 ? _c : sat.state.get())
                : sat.updateState(deltaTime, this._state === GPSSystemState.DiffSolutionAcquired, forceAcquireAndUse);
            if (updatedState) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
                if (this.syncRole === 'primary') {
                    this.syncPublisher.pub(this.satStateSyncTopic, { prn: sat.prn, state: sat.state.get() }, true, false);
                }
                shouldUpdateDop = true;
            }
            const satState = sat.state.get();
            if (satState === GPSSatelliteState.Acquired || satState === GPSSatelliteState.DataCollected) {
                numAcquiring++;
                if (sat.sbasGroup !== undefined && enabledSBASGroups.has(sat.sbasGroup)) {
                    numActiveSbas++;
                    this.currentSbasGroupsInView.add(sat.sbasGroup);
                }
            }
        }
        this.pendingSatStateUpdates.clear();
        let withinSbasArea = false;
        for (const group of this.currentSbasGroupsInView) {
            const coverage = this.sbasServiceAreas.get(group);
            if (coverage !== undefined) {
                withinSbasArea = (_d = Vec2Math.pointWithinPolygon(coverage, this.pposVec)) !== null && _d !== void 0 ? _d : false;
            }
            if (withinSbasArea) {
                break;
            }
        }
        const newSBASState = withinSbasArea
            ? GPSSystemSBASState.Active
            : enabledSBASGroups.size === 0 ? GPSSystemSBASState.Disabled : GPSSystemSBASState.Inactive;
        let newSystemState = GPSSystemState.Searching;
        if (numAcquiring > 0) {
            newSystemState = GPSSystemState.Acquiring;
        }
        let pdop = this._pdop, hdop = this._hdop, vdop = this._vdop;
        if (shouldUpdateDop) {
            [pdop, hdop, vdop] = this.calculateDop(this.dops);
        }
        const is3dSolutionPossible = pdop >= 0;
        if (is3dSolutionPossible) {
            newSystemState = numActiveSbas > 0 && withinSbasArea ? GPSSystemState.DiffSolutionAcquired : GPSSystemState.SolutionAcquired;
        }
        if (this._state !== newSystemState) {
            this._state = newSystemState;
            this.publisher.pub(this.stateChangedTopic, newSystemState, false, true);
        }
        if (this._sbasState !== newSBASState) {
            this._sbasState = newSBASState;
            this.publisher.pub(this.sbasStateChangedTopic, newSBASState, false, true);
        }
        if (shouldUpdatePositions) {
            this.previousUpdate = this.simTime;
            this.publisher.pub(this.satPosCalcTopic, undefined, false, false);
        }
        this.setDop(pdop, hdop, vdop);
        this.previousSimTime = this.simTime;
    }
    /**
     * Gets the current satellites that are being tracked by this computer.
     * @returns The collection of current satellites.
     */
    get sats() {
        return this.satellites;
    }
    /**
     * Calculates the horizon zenith angle.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    calcHorizonAngle() {
        return Math.acos(6378100 / (6378100 + this.altitude));
    }
    /**
     * Calculates dilution of precision values (PDOP, HDOP, VDOP) for the current satellite constellation.
     * @param out The vector to which to write the results.
     * @returns Dilution of precision values for the current satellite constellation, as `[PDOP, HDOP, VDOP]`.
     */
    calculateDop(out) {
        Vec3Math.set(-1, -1, -1, out);
        const satsInUse = this.satellites.filter(sat => {
            const state = sat.state.get();
            return state === GPSSatelliteState.InUse || state === GPSSatelliteState.InUseDiffApplied;
        });
        if (satsInUse.length < 4) {
            return out;
        }
        // Get unit line-of-sight vectors for each satellite
        for (let i = 0; i < satsInUse.length; i++) {
            const [zenith, hour] = satsInUse[i].position.get();
            satsInUse[i] = Vec3Math.setFromSpherical(1, zenith, hour, this.vecHeap.allocate());
        }
        const satVecs = satsInUse;
        // First define line-of-sight matrix L composed of row vectors Si = [xi, yi, zi, 1], where xi, yi, zi are the
        // components of the unit line-of-sight vector for satellite i. Then compute the covariance matrix as C = (LᵀL)⁻¹.
        // P = LᵀL is guaranteed to be symmetric, so we need only compute the upper triangular part of the product.
        const P11 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[0], 0);
        const P12 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[1], 0);
        const P13 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[2], 0);
        const P14 = satVecs.reduce((sum, vec) => sum + vec[0], 0);
        const P22 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[1], 0);
        const P23 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[2], 0);
        const P24 = satVecs.reduce((sum, vec) => sum + vec[1], 0);
        const P33 = satVecs.reduce((sum, vec) => sum + vec[2] * vec[2], 0);
        const P34 = satVecs.reduce((sum, vec) => sum + vec[2], 0);
        const P44 = satVecs.length;
        for (let i = 0; i < satVecs.length; i++) {
            this.vecHeap.free(satVecs[i]);
        }
        // Perform block-wise inversion of LᵀL (which is 4x4, so neatly decomposes into four 2x2 matrices) with optimizations
        // presented in Ingemarsson, C and Gustafsson O, 2015.
        // P = [A  B]
        //     [Bᵀ D]
        // C = P⁻¹ = [E  F]
        //           [Fᵀ H]
        // Since we only care about the variance terms along the diagonal of C, we can skip calculating F.
        // V = A⁻¹ (A is symmetric, therefore V is also symmetric, so we only need to compute the upper triangular part)
        const detA = 1 / (P11 * P22 - P12 * P12);
        const V11 = P22 * detA;
        const V12 = -P12 * detA;
        const V22 = P11 * detA;
        // X = VB
        const X11 = V11 * P13 + V12 * P23;
        const X12 = V11 * P14 + V12 * P24;
        const X21 = V12 * P13 + V22 * P23;
        const X22 = V12 * P14 + V22 * P24;
        // H = (D - BᵀX)⁻¹ (H and D are symmetric, which means BᵀX is also symmetric)
        const Hi11 = P33 - (P13 * X11 + P23 * X21);
        const Hi12 = P34 - (P13 * X12 + P23 * X22);
        const Hi22 = P44 - (P14 * X12 + P24 * X22);
        const detHi = 1 / (Hi11 * Hi22 - Hi12 * Hi12);
        const H11 = Hi22 * detHi;
        const H12 = -Hi12 * detHi;
        const H22 = Hi11 * detHi;
        // Z = XH
        const Z11 = X11 * H11 + X12 * H12;
        const Z12 = X11 * H12 + X12 * H22;
        const Z21 = X21 * H11 + X22 * H12;
        const Z22 = X21 * H12 + X22 * H22;
        // E = V + ZXᵀ (We can skip calculating E12 and E21 since we only care about the diagonal)
        const E11 = V11 + Z11 * X11 + Z12 * X12;
        const E22 = V22 + Z21 * X21 + Z22 * X22;
        // Grab the variance terms var(x), var(y), var(z) along the diagonal of C
        const varX = E11;
        const varY = E22;
        const varZ = H11;
        if (!isFinite(varX) || !isFinite(varY) || !isFinite(varZ)) {
            return out;
        }
        const horizSumVar = varX + varY;
        const pdop = Math.sqrt(horizSumVar + varZ);
        const hdop = Math.sqrt(horizSumVar);
        const vdop = Math.sqrt(varZ);
        return Vec3Math.set(pdop, hdop, vdop, out);
    }
    /**
     * Sets this system's dilution of precision values, and if they are different from the current values, publishes the
     * new values to the event bus.
     * @param pdop The position DOP value to set.
     * @param hdop The horizontal DOP value to set.
     * @param vdop The vertical DOP valu to set.
     */
    setDop(pdop, hdop, vdop) {
        if (this._pdop !== pdop) {
            this._pdop = pdop;
            this.publisher.pub(this.pdopTopic, pdop, false, true);
        }
        if (this._hdop !== hdop) {
            this._hdop = hdop;
            this.publisher.pub(this.hdopTopic, hdop, false, true);
        }
        if (this._vdop !== vdop) {
            this._vdop = vdop;
            this.publisher.pub(this.vdopTopic, vdop, false, true);
        }
    }
}
/**
 * A tracked GPS satellite.
 */
class GPSSatellite {
    /**
     * Creates an instance of a GPSSatellite.
     * @param prn The GPS PRN number for this satellite.
     * @param sbasGroup Whether or not this satellite is a SBAS satellite.
     * @param ephemeris The ephemeris data to use for position calculation.
     */
    constructor(prn, sbasGroup, ephemeris) {
        this.prn = prn;
        this.sbasGroup = sbasGroup;
        this.ephemeris = ephemeris;
        this.stateChangeTime = (5 + (10 * Math.random())) * 1000;
        this.stateChangeTimeRemaining = 0;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        /** The current satellite state. */
        this.state = Subject.create(GPSSatelliteState.None);
        /** The current satellite position, in zenith angle radians and hour angle radians. */
        this.position = Vec2Subject.create(new Float64Array(2));
        /** The current satellite position, in cartesian coordinates. */
        this.positionCartesian = Vec3Subject.create(new Float64Array(3));
        /** The current satellite signal strength. */
        this.signalStrength = Subject.create(0);
        this.isApplyingDiffCorrections = false;
        this.hasComputedPosition = false;
    }
    /**
     * Computes the current satellite positions given the loaded ephemeris data.
     * @param simTime The current simulator time, in milliseconds UNIX epoch
     */
    computeSatellitePositions(simTime) {
        const record = this.ephemeris;
        if (record !== undefined) {
            const mu = 3.986005e14; //WGS84 gravitational constant for GPS user (meters3/sec2)
            const omegae_dot = 7.2921151467e-5; //WGS84 earth rotation rate (rad/sec)
            // Restore semi-major axis
            const a = record.sqrtA * record.sqrtA;
            // Computed mean motion
            const n0 = Math.sqrt(mu / (a * a * a));
            // Time from ephemeris reference epoch
            const now = simTime / 1000;
            const t = (now - (86400 * 3) + 1735) % 604800;
            let tk = t - record.toeTimeEphemeris;
            if (tk > 302400) {
                tk -= 604800;
            }
            else if (tk < -302400) {
                tk += 604800;
            }
            // Corrected mean motion
            const n = n0 + record.deltaN;
            // Mean anomaly
            const M = record.m0 + n * tk;
            // Initial guess of eccentric anomaly
            let E = M;
            let E_old;
            let dE;
            // Iterative computation of eccentric anomaly
            for (let i = 1; i < 20; i++) {
                E_old = E;
                E = M + record.eEccentricity * Math.sin(E);
                dE = E - E_old % (2.0 * Math.PI);
                if (Math.abs(dE) < 1e-12) {
                    // Necessary precision is reached, exit from the loop
                    break;
                }
            }
            const sek = Math.sin(E);
            const cek = Math.cos(E);
            const OneMinusecosE = 1.0 - record.eEccentricity * cek;
            const sq1e2 = Math.sqrt(1.0 - record.eEccentricity * record.eEccentricity);
            // Compute the true anomaly
            const tmp_Y = sq1e2 * sek;
            const tmp_X = cek - record.eEccentricity;
            const nu = Math.atan2(tmp_Y, tmp_X);
            // Compute angle phi (argument of Latitude)
            const phi = nu + record.omegaS;
            // Reduce phi to between 0 and 2*pi rad
            const s2pk = Math.sin(2.0 * phi);
            const c2pk = Math.cos(2.0 * phi);
            // Correct argument of latitude
            const u = phi + record.cuc * c2pk + record.cus * s2pk;
            const suk = Math.sin(u);
            const cuk = Math.cos(u);
            // Correct radius
            const r = a * OneMinusecosE + record.crc * c2pk + record.crs * s2pk;
            // Correct inclination
            const i = record.i0 + record.idot * tk + record.cic * c2pk + record.cis * s2pk;
            const sik = Math.sin(i);
            const cik = Math.cos(i);
            // Compute the angle between the ascending node and the Greenwich meridian
            const Omega_dot = record.omegaLDot - omegae_dot;
            const Omega = record.omegaL + Omega_dot * tk - omegae_dot * record.toeTimeEphemeris;
            const sok = Math.sin(Omega);
            const cok = Math.cos(Omega);
            //Compute satellite coordinates in Earth-fixed coordinates
            const xprime = r * cuk;
            const yprime = r * suk;
            const x = xprime * cok - yprime * cik * sok;
            const y = xprime * sok + yprime * cik * cok;
            const z = yprime * sik;
            this.positionCartesian.set(UnitType.METER.convertTo(x, UnitType.GA_RADIAN), UnitType.METER.convertTo(y, UnitType.GA_RADIAN), UnitType.METER.convertTo(z, UnitType.GA_RADIAN));
        }
    }
    /**
     * Applies a projection to the satellite cartesian coordinates to convert to zenith and hour angles.
     * @param ppos The current plane position.
     * @param altitude The current plane altitude in meters.
     */
    applyProjection(ppos, altitude) {
        const satPos = this.positionCartesian.get();
        const altRadians = UnitType.METER.convertTo(altitude, UnitType.GA_RADIAN);
        const pposCartesian = Vec3Math.multScalar(ppos.toCartesian(this.vec3Cache[0]), 1 + altRadians, this.vec3Cache[0]);
        const delta = Vec3Math.normalize(Vec3Math.sub(satPos, pposCartesian, this.vec3Cache[1]), this.vec3Cache[1]);
        const zenithAngle = Math.acos(Vec3Math.dot(delta, Vec3Math.normalize(pposCartesian, this.vec3Cache[2])));
        const satPos0 = Vec3Math.normalize(satPos, this.vec3Cache[1]);
        const northPole = Vec3Math.set(0, 0, 1, this.vec3Cache[2]);
        if (Math.abs(zenithAngle) < 1e-8 || Math.abs(zenithAngle - 180) < 1e-8) {
            this.position.set(zenithAngle, 0);
        }
        else {
            const A = Vec3Math.normalize(Vec3Math.cross(pposCartesian, northPole, this.vec3Cache[3]), this.vec3Cache[3]);
            const B = Vec3Math.normalize(Vec3Math.cross(pposCartesian, satPos0, this.vec3Cache[4]), this.vec3Cache[4]);
            const signBz = B[2] >= 0 ? 1 : -1;
            const hourAngle = Math.acos(Vec3Math.dot(A, B)) * signBz;
            this.position.set(zenithAngle, -hourAngle);
        }
        this.hasComputedPosition = true;
    }
    /**
     * Calculates the current signal strength.
     * @param altitude The current plane altitude in meters.
     */
    calculateSignalStrength(altitude) {
        if (this.hasComputedPosition) {
            const maxZenithAngle = GPSSatellite.calcHorizonAngle(altitude) + (Math.PI / 2);
            const signalStrength = Math.max(0, 1 - (this.position.get()[0] / maxZenithAngle));
            this.signalStrength.set(signalStrength);
        }
    }
    /**
     * Calculates the horizon zenith angle.
     * @param altitude The altitude, in meters.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    static calcHorizonAngle(altitude) {
        return Math.acos(6378100 / (6378100 + Math.max(altitude, 0)));
    }
    /**
     * Updates the state of the satellite.
     * @param deltaTime The amount of sim time that has passed, in milliseconds.
     * @param applyDiffCorrections Whether or not to apply differential corrections to this GPS satellite.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} if this is an SBAS satellite or {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} if this is a GPS satellite) if signal strength is sufficient.
     * @returns True if the satellite state changed, false otherwise.
     */
    updateState(deltaTime, applyDiffCorrections, forceAcquireAndUse) {
        const reachable = this.signalStrength.get() > 0.05;
        if (this.stateChangeTimeRemaining >= 0) {
            this.stateChangeTimeRemaining -= deltaTime;
        }
        if (forceAcquireAndUse) {
            this.isApplyingDiffCorrections = applyDiffCorrections;
            const state = this.state.get();
            if (reachable) {
                const targetState = this.sbasGroup === undefined
                    ? applyDiffCorrections ? GPSSatelliteState.InUseDiffApplied : GPSSatelliteState.InUse
                    : GPSSatelliteState.Acquired;
                if (state !== targetState) {
                    this.state.set(targetState);
                    return true;
                }
            }
            else {
                if (state !== GPSSatelliteState.Unreachable) {
                    this.state.set(GPSSatelliteState.Unreachable);
                    return true;
                }
            }
        }
        else {
            switch (this.state.get()) {
                case GPSSatelliteState.None:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    else {
                        this.state.set(GPSSatelliteState.Unreachable);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                case GPSSatelliteState.Unreachable:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.Acquired:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0 && this.sbasGroup === undefined) {
                        this.state.set(GPSSatelliteState.DataCollected);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.DataCollected:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0) {
                        this.state.set(GPSSatelliteState.InUse);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.InUse:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (applyDiffCorrections) {
                        if (this.isApplyingDiffCorrections && this.stateChangeTimeRemaining <= 0) {
                            this.state.set(GPSSatelliteState.InUseDiffApplied);
                            return true;
                        }
                        else if (!this.isApplyingDiffCorrections) {
                            this.isApplyingDiffCorrections = true;
                            this.stateChangeTimeRemaining = this.stateChangeTime;
                        }
                    }
                    break;
                case GPSSatelliteState.InUseDiffApplied:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (!applyDiffCorrections) {
                        this.isApplyingDiffCorrections = false;
                        this.state.set(GPSSatelliteState.InUse);
                        return true;
                    }
                    break;
            }
        }
        return false;
    }
    /**
     * Forces an update of this satellite's state to a specific value.
     * @param state The state to which to update this satellite.
     * @returns Whether the satellite's state was changed as a result of the forced update.
     */
    forceUpdateState(state) {
        this.stateChangeTimeRemaining = 0;
        this.isApplyingDiffCorrections = state === GPSSatelliteState.InUseDiffApplied;
        if (this.state.get() !== state) {
            this.state.set(state);
            return true;
        }
        else {
            return false;
        }
    }
}
/**
 * Possible state on GPS satellites.
 */
var GPSSatelliteState;
(function (GPSSatelliteState) {
    /** There is no current valid state. */
    GPSSatelliteState["None"] = "None";
    /** The satellite is out of view and cannot be reached. */
    GPSSatelliteState["Unreachable"] = "Unreachable";
    /** The satellite has been found and data is being downloaded. */
    GPSSatelliteState["Acquired"] = "Acquired";
    /** The satellite is faulty. */
    GPSSatelliteState["Faulty"] = "Faulty";
    /** The satellite has been found, data is downloaded, but is not presently used in the GPS solution. */
    GPSSatelliteState["DataCollected"] = "DataCollected";
    /** The satellite is being active used in the GPS solution. */
    GPSSatelliteState["InUse"] = "InUse";
    /** The satellite is being active used in the GPS solution and SBAS differential corrections are being applied. */
    GPSSatelliteState["InUseDiffApplied"] = "InUseDiffApplied";
})(GPSSatelliteState || (GPSSatelliteState = {}));
/**
 * Possible {@link GPSSatComputer} states.
 */
var GPSSystemState;
(function (GPSSystemState) {
    /** The GPS receiver is trying to locate satellites. */
    GPSSystemState["Searching"] = "Searching";
    /** The GPS receiver has found satellites and is acquiring a solution. */
    GPSSystemState["Acquiring"] = "Acquiring";
    /** A 3D solution has been acquired. */
    GPSSystemState["SolutionAcquired"] = "SolutionAcquired";
    /** A 3D solution using differential computations has been acquired. */
    GPSSystemState["DiffSolutionAcquired"] = "DiffSolutionAcquired";
})(GPSSystemState || (GPSSystemState = {}));
/**
 * Possible SBAS connection states.
 */
var GPSSystemSBASState;
(function (GPSSystemSBASState) {
    /** SBAS is disabled. */
    GPSSystemSBASState["Disabled"] = "Disabled";
    /** SBAS is enabled but not receiving differential corrections. */
    GPSSystemSBASState["Inactive"] = "Inactive";
    /** SBAS is enabled and is receiving differential corrections. */
    GPSSystemSBASState["Active"] = "Active";
})(GPSSystemSBASState || (GPSSystemSBASState = {}));

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/baseinstrument" />
/**
 * A publisher for VCockpit BaseInstrument events.
 */
class BaseInstrumentPublisher extends BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument, bus, pacer = undefined) {
        super(bus, pacer);
        this.instrument = instrument;
        this.lastGameState = undefined;
        this.lastIsPowered = undefined;
        this.lastScreenState = undefined;
        this.hasFlightStarted = false;
        instrument.addEventListener('mouseleave', (e) => {
            this.publish('vc_mouse_leave', e, false, false);
        });
        instrument.addEventListener('mouseenter', (e) => {
            this.publish('vc_mouse_enter', e, false, false);
        });
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isPublishing()) {
            return;
        }
        this.updateFromGameState(this.instrument.getGameState());
        this.updateFromPowered(this.instrument.isStarted); // Big hack here since there is no other way to get the isStarted state from BaseInstrument
        this.updateFromScreenState(this.instrument.screenState); // Another big hack
    }
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    updateFromGameState(gameState) {
        if (this.lastGameState === gameState) {
            return;
        }
        this.lastGameState = gameState;
        this.publish('vc_game_state', gameState);
        if (!this.hasFlightStarted && gameState === GameState.ingame) {
            this.publish('vc_flight_start', true);
        }
    }
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    updateFromPowered(isPowered) {
        if (this.lastIsPowered === isPowered) {
            return;
        }
        this.lastIsPowered = isPowered;
        this.publish('vc_powered', isPowered);
    }
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    updateFromScreenState(screenState) {
        if (this.lastScreenState === screenState) {
            return;
        }
        const lastScreenState = this.lastScreenState;
        this.lastScreenState = screenState;
        this.publish('vc_screen_state', { current: screenState, previous: lastScreenState });
    }
}

/** Minimums Modes */
var MinimumsMode;
(function (MinimumsMode) {
    MinimumsMode[MinimumsMode["OFF"] = 0] = "OFF";
    MinimumsMode[MinimumsMode["BARO"] = 1] = "BARO";
    MinimumsMode[MinimumsMode["RA"] = 2] = "RA";
    MinimumsMode[MinimumsMode["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
})(MinimumsMode || (MinimumsMode = {}));
/** A publisher for minimums simvar events. */
class MinimumsSimVarPublisher extends SimVarPublisher {
    /**
     * @inheritdoc
     */
    constructor(bus) {
        super(MinimumsSimVarPublisher.simvars, bus);
    }
}
MinimumsSimVarPublisher.simvars = new Map([
    ['decision_height_feet', { name: 'DECISION HEIGHT', type: SimVarValueType.Feet }],
    ['decision_altitude_feet', { name: 'DECISION ALTITUDE MSL', type: SimVarValueType.Feet }],
    ['minimums_mode', { name: 'L:WT_MINIMUMS_MODE', type: SimVarValueType.Number }]
]);
/**
 * A class that manages decision height and altitude data and events.
 */
class MinimumsManager {
    /**
     * Create a MinimumsManager
     * @param bus The event bus
     */
    constructor(bus) {
        this.currentDH = 0;
        this.currentDA = 0;
        this.daDistanceUnit = UnitType.FOOT;
        this.dhDistanceUnit = UnitType.FOOT;
        this.bus = bus;
        this.controlSubscriber = bus.getSubscriber();
        // Initialize both simvars to 0.
        SimVar.SetSimVarValue('K:SET_DECISION_HEIGHT', 'number', 0);
        SimVar.SetSimVarValue('K:SET_DECISION_ALTITUDE_MSL', 'number', 0);
        KeyEventManager.getManager(bus).then(manager => {
            manager.interceptKey('INCREASE_DECISION_HEIGHT', false);
            manager.interceptKey('DECREASE_DECISION_HEIGHT', false);
            manager.interceptKey('INCREASE_DECISION_ALTITUDE_MSL', false);
            manager.interceptKey('DECREASE_DECISION_ALTITUDE_MSL', false);
        });
        this.controlSubscriber.on('set_decision_height_feet').handle((dh) => {
            SimVar.SetSimVarValue('K:SET_DECISION_HEIGHT', SimVarValueType.Number, dh);
        });
        this.controlSubscriber.on('set_decision_altitude_feet').handle((da) => {
            SimVar.SetSimVarValue('K:SET_DECISION_ALTITUDE_MSL', SimVarValueType.Number, da);
        });
        this.controlSubscriber.on('set_minimums_mode').handle((mode) => {
            SimVar.SetSimVarValue('L:WT_MINIMUMS_MODE', SimVarValueType.Number, mode);
        });
        this.controlSubscriber.on('set_dh_distance_unit').handle((unit) => {
            this.dhDistanceUnit = unit == 'meters' ? UnitType.METER : UnitType.FOOT;
        });
        this.controlSubscriber.on('set_da_distance_unit').handle((unit) => {
            this.daDistanceUnit = unit == 'meters' ? UnitType.METER : UnitType.FOOT;
        });
        const sub = this.bus.getSubscriber();
        sub.on('key_intercept').handle((evt) => {
            let simvar;
            let curVal;
            let direction = 'up';
            let unit;
            if (evt.value0 !== undefined) {
                switch (evt.key) {
                    case 'DECREASE_DECISION_HEIGHT':
                        direction = 'down';
                    // eslint-disable-next-line no-fallthrough
                    case 'INCREASE_DECISION_HEIGHT':
                        simvar = 'K:SET_DECISION_HEIGHT';
                        unit = this.dhDistanceUnit;
                        curVal = this.currentDH;
                        break;
                    case 'DECREASE_DECISION_ALTITUDE_MSL':
                        direction = 'down';
                    // eslint-disable-next-line no-fallthrough
                    case 'INCREASE_DECISION_ALTITUDE_MSL':
                        simvar = 'K:SET_DECISION_ALTITUDE_MSL';
                        unit = this.daDistanceUnit;
                        curVal = this.currentDA;
                        break;
                }
                if (simvar !== undefined && curVal !== undefined && unit !== undefined) {
                    // There is one flaw in this logic, but I'm not sure what can be done about
                    // it.  You can set the inc/dec amount via the K event in feet or meters.
                    // If your user preference unit is one, but the simvar call uses the other,
                    // we have now way of knowing  about it so will force a conversion that's not
                    // needed.This is a fairly minor flaw, but worth acknowledging until a
                    // workaround can be found.
                    const increment = unit.convertTo(evt.value0, UnitType.FOOT) * (direction == 'down' ? -1 : 1);
                    SimVar.SetSimVarValue(simvar, 'number', curVal + increment);
                }
            }
        });
    }
}

/**
 * A simple timer for handling debounce.
 */
class DebounceTimer {
    constructor() {
        this.timer = null;
    }
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending() {
        return this.timer !== null;
    }
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action, delay) {
        this.clear();
        this.timer = setTimeout(() => {
            this.timer = null;
            action();
        }, delay);
    }
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear() {
        if (this.timer === null) {
            return;
        }
        clearTimeout(this.timer);
        this.timer = null;
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));
/** A publiher to poll transponder simvars. */
class XPDRSimVarPublisher extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus, pacer = undefined, transponderCount = 1) {
        const vars = [];
        for (let i = 0; i < transponderCount; i++) {
            vars.push([`xpdr_mode_${i + 1}`, { name: `TRANSPONDER STATE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_code_${i + 1}`, { name: `TRANSPONDER CODE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_ident_${i + 1}`, { name: `TRANSPONDER IDENT:${i + 1}`, type: SimVarValueType.Bool }]);
        }
        super(new Map(vars), bus, pacer);
    }
}
/** A transponder. */
class XPDRInstrument {
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus, transponderCount = 1) {
        this.bus = bus;
        this.transponderCount = transponderCount;
        this.identDebounceTimers = Array.from({ length: this.transponderCount }, () => new DebounceTimer());
        this.bus = bus;
        this.simVarPublisher = new XPDRSimVarPublisher(bus);
        this.controlSubscriber = bus.getSubscriber();
    }
    /** Initialize the instrument. */
    init() {
        this.simVarPublisher.startPublish();
        for (let i = 0; i < this.transponderCount; i++) {
            this.controlSubscriber.on(`publish_xpdr_code_${i + 1}`).handle(this.setXpdrCode.bind(this, i + 1));
            this.controlSubscriber.on(`publish_xpdr_mode_${i + 1}`).handle(this.setXpdrMode.bind(this, i + 1));
            this.controlSubscriber.on(`xpdr_send_ident_${i + 1}`).handle(this.sendIdent.bind(this, i + 1));
            // force standby on plane load when off
            if (this.getXpdrMode(i + 1) === XPDRMode.OFF) {
                this.setXpdrMode(i + 1, XPDRMode.STBY);
            }
        }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        // Currently, we just need to update our simvar publisher so it polls.
        this.simVarPublisher.onUpdate();
    }
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    setXpdrCode(index, code) {
        const bcdCode = Avionics.Utils.make_xpndr_bcd16(code);
        SimVar.SetSimVarValue(`K:${index}:XPNDR_SET`, 'Frequency BCD16', bcdCode);
    }
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    setXpdrMode(index, mode) {
        SimVar.SetSimVarValue(`TRANSPONDER STATE:${index}`, 'number', mode);
    }
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    getXpdrMode(index) {
        return SimVar.GetSimVarValue(`TRANSPONDER STATE:${index}`, 'number');
    }
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    sendIdent(index) {
        if (this.getXpdrMode(index) > XPDRMode.STBY) {
            SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_ON`, 'number', 1);
            this.identDebounceTimers[index - 1].schedule(() => {
                SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_OFF`, 'number', 0);
            }, 18000);
        }
    }
}

/**
 * A utility class for generating Promises that wait for certain conditions before they are fulfilled.
 */
class Wait {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    static awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    static awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    /**
     * Waits for a notification from a {@link Subscribable}, with an optional condition to end the wait based on the value
     * of the subscribable.
     * @param subscribable The subscribable to wait for.
     * @param predicate A function which evaluates whether the value of the subscribable satisfies the condition for the
     * wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive a notification from the subscribable at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the subscribable when a notification is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = subscribable.sub(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, false, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link Consumer}, with an optional condition to end the wait based on the value of the
     * consumed event.
     * @param consumer The event consumer to wait for.
     * @param predicate A function which evaluates whether the value of the consumed event satisfies the condition for
     * the wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive an event from the event consumer at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the consumed event when an event is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = consumer.handle(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link ReadonlySubEvent}, with an optional condition to end the wait based on the sender
     * and data of the event.
     * @param event The event to wait for.
     * @param predicate A function which evaluates whether the sender and data of the event satisfy the condition for
     * the wait to end. If not defined, any sender/data is considered satisfactory.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the data of the event when an event is received with a sender and data
     * that satisfy the condition for the wait to end.
     */
    static awaitSubEvent(event, predicate, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = event.on((sender, data) => {
                if (predicate === undefined || predicate(data, sender)) {
                    sub.destroy();
                    resolve(data);
                }
            }, true);
            sub.resume();
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
}

/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
class TrafficInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
        return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
        this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
        this.bus.getSubscriber()
            .on('simTime')
            .whenChanged()
            .handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
        const contact = new TrafficContactClass(entry.uId, 1000 / this.options.simTimeUpdateFreq * 5);
        this.tracked.set(contact.uid, contact);
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_added', contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_updated', contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
        this.tracked.forEach(contact => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uid);
                this.bus.pub('traffic_contact_removed', contact.uid, false, false);
            }
        });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy
            || Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_AIR_TRAFFIC'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
        }
        this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
        // noop
    }
}
/**
 * An aircraft contact that is being tracked. Each contact tracks its last reported position, altitude, and heading.
 * Successively updating these values will allow ground speed, ground track, and vertical speed to be calculated based
 * on changes in the values over time. The calculated values are exponentially smoothed to reduce artifacts from
 * potentially noisy data.
 */
class TrafficContactClass {
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
        this.uid = uid;
        this.contactTimeResetThreshold = contactTimeResetThreshold;
        // reported data
        this._lastPosition = new GeoPoint(NaN, NaN);
        this.lastPosition = this._lastPosition.readonly;
        this._lastAltitude = UnitType.FOOT.createNumber(NaN);
        this.lastAltitude = this._lastAltitude.readonly;
        this._lastHeading = NaN;
        this._lastContactTime = NaN;
        // computed data
        this._groundSpeed = UnitType.KNOT.createNumber(NaN);
        this.groundSpeed = this._groundSpeed.readonly;
        this._groundTrack = NaN;
        this._verticalSpeed = UnitType.FPM.createNumber(NaN);
        this.verticalSpeed = this._verticalSpeed.readonly;
        this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
        return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
        return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
        return this._groundTrack;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
        if (this.groundSpeed.isNaN()) {
            positionOut.set(NaN, NaN);
            altitudeOut.set(NaN);
            return;
        }
        const dt = simTime - this.lastContactTime;
        const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 3600000), UnitType.GA_RADIAN);
        this._lastPosition.offset(this._groundTrack, distance, positionOut);
        const deltaAlt = this._verticalSpeed.number * (dt / 60000);
        this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
        const dt = simTime - this._lastContactTime;
        if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
            this.reset(lat, lon, altitude, heading, simTime);
            return;
        }
        if (!isNaN(dt) && dt > 0) {
            this.updateComputedValues(dt / 1000, lat, lon, altitude);
        }
        this.setReportedValues(lat, lon, altitude, heading);
        if (this.areComputedValuesValid()) {
            this._lastContactTime = simTime;
        }
        else {
            this.reset(lat, lon, altitude, heading, simTime);
        }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
        this.setReportedValues(lat, lon, altitude, heading);
        this._groundSpeed.set(NaN);
        this._groundTrack = NaN;
        this._verticalSpeed.set(NaN);
        this.groundSpeedSmoother.reset();
        this.groundTrackSmoother.reset();
        this.verticalSpeedSmoother.reset();
        this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
        this._lastPosition.set(lat, lon);
        this._lastAltitude.set(altitude);
        this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
        const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
        const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
        const track = pos.bearingFrom(this._lastPosition);
        this.updateGroundSpeed(dt, distanceNM);
        this.updateGroundTrack(dt, track, distanceNM);
        this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
        const dtHours = dt / 3600;
        const speedKnots = distanceNM / dtHours;
        this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
        const last = this.groundTrackSmoother.last();
        if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
        }
        else {
            // if distance between current and last position is too small, computed ground track will be unreliable
            // (and if distance = 0 the track will be meaningless), so we just copy forward the last computed track,
            // or NaN if there is no previously computed track
            track = last === null ? NaN : last;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        this._groundTrack = (next + 360) % 360; // enforce range 0-359
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
        const dtMin = dt / 60;
        const deltaAltFeet = altitude - this._lastAltitude.number;
        const vsFPM = deltaAltFeet / dtMin;
        this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
        const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
        const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
        return isGroundSpeedValid && isVerticalSpeedValid;
    }
}
TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500; // knots
TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 10000; // fpm
TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852; // nautical miles
TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for fuel system information.
 */
class FuelSystemSimVarPublisher extends SimVarPublisher {
    /**
     * Create an FuelSystemSimvarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['fuel_system_valve_switch', { name: 'FUELSYSTEM VALVE SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_valve_open', { name: 'FUELSYSTEM VALVE OPEN:#index#', type: SimVarValueType.Number, indexed: true }],
            ['fuel_system_pump_switch', { name: 'FUELSYSTEM PUMP SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_pump_active', { name: 'FUELSYSTEM PUMP ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
            ['fuel_system_engine_pressure', { name: 'FUELSYSTEM ENGINE PRESSURE:#index#', type: SimVarValueType.PSI, indexed: true }],
            ['fuel_system_line_pressure', { name: 'FUELSYSTEM LINE FUEL PRESSURE:#index#', type: SimVarValueType.PSI, indexed: true }],
            ['fuel_system_line_flow', { name: 'FUELSYSTEM LINE FUEL FLOW:#index#', type: SimVarValueType.GPH, indexed: true }],
            ['fuel_system_tank_quantity', { name: 'FUELSYSTEM TANK QUANTITY:#index#', type: SimVarValueType.GAL, indexed: true }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** The acceptable priority types for a given annunciation. */
var AnnunciationType;
(function (AnnunciationType) {
    AnnunciationType[AnnunciationType["Warning"] = 0] = "Warning";
    AnnunciationType[AnnunciationType["Caution"] = 1] = "Caution";
    AnnunciationType[AnnunciationType["Advisory"] = 2] = "Advisory";
    AnnunciationType[AnnunciationType["SafeOp"] = 3] = "SafeOp";
})(AnnunciationType || (AnnunciationType = {}));

/**
 * Moderates access to a resource.
 */
class ResourceModerator {
    /**
     * Constructor.
     * @param resource This resource controlled by this moderator.
     */
    constructor(resource) {
        this.resource = resource;
        this.pendingConsumer = null;
        this.assignedConsumer = null;
        this.queuedConsumers = new SortedArray((a, b) => a.priority - b.priority);
    }
    /**
     * Makes a claim to this moderator's resource. If the resource is not currently owned, or the claiming consumer has
     * a higher priority than the current owner, access will attempt to pass to the claiming consumer. Otherwise, the
     * claiming consumer will enter a queue. After entering the queue, a consumer will gain access to the claimed
     * resource when all other consumers with a higher priority forfeit their claims to the resource.
     * @param consumer The consumer claiming the resource.
     */
    claim(consumer) {
        var _a;
        const consumerToDisplace = (_a = this.pendingConsumer) !== null && _a !== void 0 ? _a : this.assignedConsumer;
        if (consumerToDisplace === consumer) {
            return;
        }
        if (this.queuedConsumers.has(consumer)) {
            return;
        }
        if (consumerToDisplace === null || consumerToDisplace.priority < consumer.priority) {
            if (consumerToDisplace === null || consumerToDisplace === this.pendingConsumer) {
                if (consumerToDisplace) {
                    this.queuedConsumers.insert(consumerToDisplace);
                    this.pendingConsumer = null;
                }
                this.assignedConsumer = consumer;
                this.assignedConsumer.onAcquired(this.resource);
                return;
            }
            this.assignedConsumer = null;
            this.pendingConsumer = consumer;
            this.queuedConsumers.insert(consumerToDisplace);
            consumerToDisplace.onCeded(this.resource);
            if (this.pendingConsumer === consumer) {
                this.pendingConsumer = null;
                this.assignedConsumer = consumer;
                this.assignedConsumer.onAcquired(this.resource);
                return;
            }
            else {
                // Something has displaced the new pending consumer. Either something pre-empted it, in which case it is
                // now in the queue, or it forfeited its claim. In either case, there is nothing to do.
                return;
            }
        }
        this.queuedConsumers.insert(consumer);
    }
    /**
     * Forfeits a claim to this moderator's resource. If the consumer forfeiting its claim is the current owner of the
     * resource, it will immediately lose access to the resource, and access will attempt to pass to the next-highest
     * priority consumer with a claim to the resource. Otherwise, the forfeiting consumer will be removed from the queue
     * to gain access to the resource.
     * @param consumer The consumer that is forfeiting its claim.
     */
    forfeit(consumer) {
        var _a;
        if (this.pendingConsumer === consumer) {
            this.pendingConsumer = null;
            return;
        }
        if (this.assignedConsumer === null || this.assignedConsumer !== consumer) {
            this.queuedConsumers.remove(consumer);
            return;
        }
        const next = (_a = this.queuedConsumers.pop()) !== null && _a !== void 0 ? _a : null;
        this.pendingConsumer = next;
        this.assignedConsumer = null;
        consumer.onCeded(this.resource);
        if (next !== null && this.pendingConsumer === next) {
            this.pendingConsumer = null;
            this.assignedConsumer = next;
            this.assignedConsumer.onAcquired(this.resource);
        }
    }
}

/**
 * A manager for registering aural alerts. Alerts can be registered with an {@link AuralAlertSystem} through the
 * manager, which also handles registration requests from the alert system.
 */
class AuralAlertRegistrationManager {
    /**
     * Creates a new instance of AuralAlertRegistrationManager.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.registrations = new Map();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        this.requestSub = subscriber.on('aural_alert_request_all_registrations').handle(this.publishAllRegistrations.bind(this));
    }
    /**
     * Registers an aural alert.
     * @param definition The definition of the alert to register.
     */
    register(definition) {
        this.registrations.set(definition.uuid, definition);
        this.publishRegistration(definition);
    }
    /**
     * Publishes a registration event for an alert.
     * @param definition The definition of the alert to register.
     */
    publishRegistration(definition) {
        this.publisher.pub('aural_alert_register', definition, true, false);
    }
    /**
     * Publishes registration events for all currently registered alerts.
     */
    publishAllRegistrations() {
        for (const definition of this.registrations.values()) {
            this.publishRegistration(definition);
        }
    }
    /**
     * Destroys this manager.
     */
    destroy() {
        this.requestSub.destroy();
    }
}

/**
 * A controller which provides a convenient interface with which to send commands to {@link SoundServer}.
 */
class SoundServerController {
    /**
     * Creates a new instance of SoundServerController.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.publisher = bus.getPublisher();
        this.subscriber = bus.getSubscriber();
    }
    /**
     * Waits for the sound server to finish initialization.
     * @returns A Promise which fulfills with a value of `true` when the sound server finishes initialization.
     */
    awaitInitialized() {
        return Wait.awaitConsumer(this.subscriber.on('sound_server_initialized'), init => init, true);
    }
    /**
     * Requests a sound packet to be played if there is no existing packet with the same key currently being played.
     * @param packet The sound packet to play.
     */
    play(packet) {
        this.publisher.pub('sound_server_play', packet, true, false);
    }
    /**
     * Requests a sound packet to be queued. If there is no existing packet with the same key currently being played, the
     * packet will begin playing immediately. Otherwise, the new packet will begin playing after the existing packet and
     * any other queued packets with the same key are finished playing.
     * @param packet The sound packet to queue.
     */
    queue(packet) {
        this.publisher.pub('sound_server_queue', packet, true, false);
    }
    /**
     * Requests a sound packet to be played at the earliest opportunity. If there is no existing packet with the same key
     * currently being played, the packet will begin playing immediately. Otherwise, the existing packet will be stopped
     * the next time one of its sound atoms finishes playing, any queued packets with the same key will be discarded, and
     * the new packet will begin playing at that time.
     * @param packet The sound packet to play.
     */
    interrupt(packet) {
        this.publisher.pub('sound_server_interrupt', packet, true, false);
    }
    /**
     * Requests that a continuous sound packet stop playing instead of looping the next time its sequence finishes. This
     * also prevents any queued packets with the same key from
     * playing.
     * @param key The key of the sound packet to stop.
     */
    stop(key) {
        this.publisher.pub('sound_server_stop', key, true, false);
    }
    /**
     * Requests that a sound packet stop playing at the earliest opportunity (the next time one of its sound atoms
     * finishes playing). This also prevents any queued packets with the same key from playing.
     * @param key The key of the sound packet to kill.
     */
    kill(key) {
        this.publisher.pub('sound_server_kill', key, true, false);
    }
    /**
     * Requests that all currently playing continuous sound packets stop playing instead of looping the next time their
     * sequences finish. This also clears all queued packets.
     */
    stopAll() {
        this.publisher.pub('sound_server_stop_all', undefined, true, false);
    }
    /**
     * Requests that all currently playing sound packets stop playing at the earliest opportunity (the next time one of
     * their sound atoms finishes playing). This also clears all queued packets.
     */
    killAll() {
        this.publisher.pub('sound_server_kill_all', undefined, true, false);
    }
    /**
     * Requests a single sound atom to be played non-continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: false })`.
     * @param id The ID of the sound atom to play.
     */
    playSound(id) {
        this.publisher.pub('sound_server_play_sound', id, true, false);
    }
    /**
     * Requests a single sound atom to be played continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: true })`.
     * @param id The ID of the sound atom to play.
     */
    startSound(id) {
        this.publisher.pub('sound_server_start_sound', id, true, false);
    }
}

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        /** The context on this component, if any. */
        this.context = undefined;
        /** The type of context for this component, if any. */
        this.contextType = undefined;
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterRender(node) { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    getContext(context) {
        if (this.context !== undefined && this.contextType !== undefined) {
            const index = this.contextType.indexOf(context);
            return this.context[index];
        }
        throw new Error('Could not find the provided context type.');
    }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
class Context {
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue) {
        this.defaultValue = defaultValue;
        /**
         * The provider component that can be set to a specific context value.
         * @param props The props of the provider component.
         * @returns A new context provider.
         */
        this.Provider = (props) => new ContextProvider(props, this);
    }
}
/**
 * A provider component that can be set to a specific context value.
 */
class ContextProvider extends DisplayComponent {
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props, parent) {
        super(props);
        this.parent = parent;
    }
    /** @inheritdoc */
    render() {
        var _a;
        const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
        return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true
    };
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props) {
        return props.children;
    }
    FSComponent.Fragment = Fragment;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (key === 'class' && typeof prop === 'object' && 'isSubscribableSet' in prop) {
                            // Bind CSS classes to a subscribable set
                            prop.sub((set, eventType, modifiedKey) => {
                                if (eventType === SubscribableSetEventType.Added) {
                                    element.classList.add(modifiedKey);
                                }
                                else {
                                    element.classList.remove(modifiedKey);
                                }
                            }, true);
                        }
                        else if (typeof prop === 'object' && 'isSubscribable' in prop) {
                            if (key === 'style' && prop instanceof ObjectSubject) {
                                // Bind CSS styles to an object subject.
                                prop.sub((v, style, newValue) => {
                                    element.style.setProperty(style.toString(), newValue);
                                }, true);
                            }
                            else {
                                // Bind an attribute to a subscribable.
                                prop.sub((v) => {
                                    element.setAttribute(key, v);
                                }, true);
                            }
                        }
                        else if (key === 'class' && typeof prop === 'object') {
                            // Bind CSS classes to an object of key value pairs where the values can be boolean | Subscribable<boolean>
                            for (const className in prop) {
                                if (className.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[className];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub((showClass) => {
                                        element.classList.toggle(className, !!showClass);
                                    }, true);
                                }
                                else {
                                    element.classList.toggle(className, !!value);
                                }
                            }
                        }
                        else if (key === 'style' && typeof prop === 'object') {
                            // Bind styles to an object of key value pairs
                            for (const style in prop) {
                                if (style.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[style];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub(newValue => {
                                        element.style.setProperty(style, newValue !== null && newValue !== void 0 ? newValue : '');
                                    }, true);
                                }
                                else {
                                    element.style.setProperty(style, value !== null && value !== void 0 ? value : '');
                                }
                            }
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            if (typeof type === 'function' && type.name === Fragment.name) {
                let childNodes = type(props);
                //Handle the case where the single fragment children is an array of nodes passsed down from above
                while (childNodes !== null && childNodes.length === 1 && Array.isArray(childNodes[0])) {
                    childNodes = childNodes[0];
                }
                vnode = {
                    instance: null,
                    props,
                    children: childNodes
                };
            }
            else {
                let instance;
                const pluginSystem = (window._pluginSystem);
                try {
                    instance = type(props);
                }
                catch (_a) {
                    let pluginInstance = undefined;
                    if (pluginSystem !== undefined) {
                        pluginInstance = pluginSystem.onComponentCreating(type, props);
                    }
                    if (pluginInstance !== undefined) {
                        instance = pluginInstance;
                    }
                    else {
                        instance = new type(props);
                    }
                }
                if (props !== null && props.ref !== null && props.ref !== undefined) {
                    props.ref.instance = instance;
                }
                if (instance.contextType !== undefined) {
                    instance.context = instance.contextType.map(c => Subject.create(c.defaultValue));
                }
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentCreated(instance);
                }
                vnode = {
                    instance,
                    props,
                    children: [instance.render()]
                };
            }
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'object') {
                        if ('isSubscribable' in child) {
                            const node = {
                                instance: child,
                                children: null,
                                props: null,
                                root: undefined,
                            };
                            child.sub((v) => {
                                if (node.root !== undefined) {
                                    // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                    node.root.nodeValue = (v === '' || v === null || v === undefined)
                                        ? ' '
                                        : v.toString();
                                }
                            });
                            vnodes.push(node);
                        }
                        else {
                            vnodes.push(child);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            if (element !== null) {
                insertNode(node, position, element);
            }
        }
        else if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance !== null && componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (position === RenderPosition.After) {
                for (let i = node.children.length - 1; i >= 0; i--) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            else {
                for (let i = 0; i < node.children.length; i++) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            const instance = node.instance;
            if (instance instanceof ContextProvider) {
                visitNodes(node, (n) => {
                    if (n === undefined || n === null) {
                        return false;
                    }
                    const nodeInstance = n.instance;
                    if (nodeInstance !== null && nodeInstance.contextType !== undefined) {
                        const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
                        if (contextSlot >= 0) {
                            if (nodeInstance.context === undefined) {
                                nodeInstance.context = [];
                            }
                            nodeInstance.context[contextSlot].set(instance.props.value);
                        }
                        if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            if (componentInstance !== null && componentInstance.onAfterRender !== undefined) {
                const pluginSystem = (window._pluginSystem);
                componentInstance.onAfterRender(node);
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentRendered(node);
                }
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string'
            || (typeof node.instance === 'object'
                && node.instance !== null &&
                'isSubscribable' in node.instance)) {
            let toRender;
            if (typeof node.instance === 'string') {
                toRender = node.instance;
            }
            else {
                toRender = node.instance.get();
                if (toRender === '') {
                    toRender = ' '; // prevent disappearing text node
                }
            }
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', toRender);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', toRender);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', toRender);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else if (Array.isArray(node)) {
            if (position === RenderPosition.After) {
                for (let i = node.length - 1; i >= 0; i--) {
                    render(node[i], element, position);
                }
            }
            else {
                for (let i = 0; i < node.length; i++) {
                    render(node[i], element, position);
                }
            }
        }
        else {
            render(node, element, position);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext(defaultValue) {
        return new Context(defaultValue);
    }
    FSComponent.createContext = createContext;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     */
    function visitNodes(node, visitor) {
        if (node === undefined || node === null) {
            return;
        }
        const stopVisitation = visitor(node);
        if (!stopVisitation && node.children !== undefined && node.children !== null) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (Array.isArray(child)) {
                    for (let childIndex = 0; childIndex < child.length; childIndex++) {
                        visitNodes(child[childIndex], visitor);
                    }
                }
                else {
                    visitNodes(child, visitor);
                }
            }
        }
        return;
    }
    FSComponent.visitNodes = visitNodes;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @param filter A function which filters parsed classes. For each class, the function should return `true` if the
     * class should be included in the output array and `false` otherwise.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString, filter) {
        return classString.split(' ').filter(str => str !== '' && (filter === undefined || filter(str)));
    }
    FSComponent.parseCssClassesFromString = parseCssClassesFromString;
    // eslint-disable-next-line jsdoc/require-jsdoc
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
        const reservedClassSet = new Set(reservedClasses);
        if (classesToSubscribe.isSubscribableSet === true) {
            return bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet);
        }
        else {
            return bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet);
        }
    }
    FSComponent.bindCssClassSet = bindCssClassSet;
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet) {
        if (reservedClassSet.size === 0) {
            return classesToSubscribe.sub((set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
        else {
            return classesToSubscribe.sub((set, type, key) => {
                if (reservedClassSet.has(key)) {
                    return;
                }
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
    }
    /**
     * Binds a {@link MutableSubscribableSet} to a record of CSS classes. CSS classes toggled in the record will also be
     * added to and removed from the bound set, with the exception of a set of reserved classes. The presence or absence
     * of any of the reserved classes in the bound set is not affected by the subscribed record.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A record of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscriptions to the CSS class record.
     */
    function bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet) {
        const subs = [];
        for (const cssClass in classesToSubscribe) {
            if (reservedClassSet.has(cssClass)) {
                continue;
            }
            const value = classesToSubscribe[cssClass];
            if (typeof value === 'object') {
                subs.push(value.sub(setToBind.toggle.bind(setToBind, cssClass), true));
            }
            else if (value === true) {
                setToBind.add(cssClass);
            }
            else {
                setToBind.delete(cssClass);
            }
        }
        return subs;
    }
    /**
     * Adds CSS classes to a {@link ToggleableClassNameRecord}.
     * @param record The CSS class record to which to add the new classes. The record will be mutated as classes are
     * added.
     * @param classesToAdd The CSS classes to add to the record, as a space-delimited class string, an iterable of
     * individual class names, or a {@link ToggleableClassNameRecord}.
     * @param allowOverwrite Whether to allow the new classes to overwrite existing entries in the CSS class record.
     * Defaults to `true`.
     * @param filter A function which filters the classes to add. For each class, the function should return `true` if
     * the class should be included in the record and `false` otherwise.
     * @returns The mutated CSS class record, after the new classes have been added.
     */
    function addCssClassesToRecord(record, classesToAdd, allowOverwrite = true, filter) {
        if (classesToAdd === '') {
            return record;
        }
        if (typeof classesToAdd === 'string') {
            classesToAdd = FSComponent.parseCssClassesFromString(classesToAdd, filter);
            filter = undefined;
        }
        if (typeof classesToAdd[Symbol.iterator] === 'function') {
            for (const cssClass of classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = true;
                }
            }
        }
        else {
            for (const cssClass in classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = classesToAdd[cssClass];
                }
            }
        }
        return record;
    }
    FSComponent.addCssClassesToRecord = addCssClassesToRecord;
    /**
     * Traverses a VNode tree in depth-first order and destroys the first {@link DisplayComponent} encountered in each
     * branch of the tree.
     * @param root The root of the tree to traverse.
     */
    function shallowDestroy(root) {
        FSComponent.visitNodes(root, node => {
            if (node !== root && node.instance instanceof DisplayComponent) {
                node.instance.destroy();
                return true;
            }
            return false;
        });
    }
    FSComponent.shallowDestroy = shallowDestroy;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));
FSComponent.Fragment;

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
 */
class BingComponent extends DisplayComponent {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(...arguments);
        this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
        this.isListenerRegistered = false;
        this.imgRef = FSComponent.createRef();
        this.uid = 0;
        this._isBound = false;
        this._isAwake = true;
        this.isDestroyed = false;
        this.pos = new LatLong(0, 0);
        this.radius = 10;
        this.resolution = (_a = this.props.resolution) !== null && _a !== void 0 ? _a : Vec2Subject.create(Vec2Math.create(BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION));
        this.earthColors = (_b = this.props.earthColors) !== null && _b !== void 0 ? _b : ArraySubject.create(ArrayUtils.create(2, () => BingComponent.hexaToRGBColor('#000000')));
        this.earthColorsElevationRange = (_c = this.props.earthColorsElevationRange) !== null && _c !== void 0 ? _c : Vec2Subject.create(Vec2Math.create(0, 30000));
        this.skyColor = (_d = this.props.skyColor) !== null && _d !== void 0 ? _d : Subject.create(BingComponent.hexaToRGBColor('#000000'));
        this.reference = (_e = this.props.reference) !== null && _e !== void 0 ? _e : Subject.create(EBingReference.SEA);
        this.wxrMode = (_f = this.props.wxrMode) !== null && _f !== void 0 ? _f : Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 });
        this.wxrColors = (_g = this.props.wxrColors) !== null && _g !== void 0 ? _g : ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
        this.isoLines = (_h = this.props.isoLines) !== null && _h !== void 0 ? _h : Subject.create(false);
        this.wxrColorsArray = [];
        this.wxrRateArray = [];
        this.resolutionHandler = (resolution) => {
            Coherent.call('SET_MAP_RESOLUTION', this.uid, resolution[0], resolution[1]);
            // The sim ignores position/radius updates within a certain number of frames of sending a resolution change, so we
            // will keep trying to send pending updates for a few frames after any resolution change.
            this.positionRadiusInhibitFramesRemaining = BingComponent.POSITION_RADIUS_INHIBIT_FRAMES;
            if (!this.positionRadiusInhibitTimer.isPending()) {
                this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
            }
        };
        this.earthColorsHandler = () => {
            const colors = this.earthColors.getArray();
            if (colors.length < 2) {
                return;
            }
            Coherent.call('SET_MAP_HEIGHT_COLORS', this.uid, colors);
        };
        this.earthColorsElevationRangeHandler = () => {
            const colors = this.earthColors.getArray();
            if (colors.length < 2) {
                return;
            }
            // The way the map assigns colors to elevations is as follows:
            // ----------------------------------------------------------------------------------
            // - altitude range = MIN to MAX
            // - colors = array of length N >= 2 (colors[0] is the water color)
            // - STEP = (MAX - MIN) / N
            // - colors[i] is assigned to elevations from MIN + STEP * i to MIN + STEP * (i + 1)
            // - colors[1] is also assigned to all elevations < MIN + STEP
            // - colors[N - 1] is also assigned to all elevations > MIN + STEP * N
            // ----------------------------------------------------------------------------------
            const range = this.earthColorsElevationRange.get();
            const terrainColorCount = colors.length - 1;
            const desiredElevationStep = (range[1] - range[0]) / Math.max(terrainColorCount - 1, 1);
            const requiredMin = range[0] - desiredElevationStep;
            const requiredMax = range[1] + desiredElevationStep;
            Coherent.call('SET_MAP_ALTITUDE_RANGE', this.uid, requiredMin, requiredMax);
        };
        this.skyColorHandler = (color) => {
            Coherent.call('SET_MAP_CLEAR_COLOR', this.uid, color);
        };
        this.referenceHandler = (reference) => {
            const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
            this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, flags);
        };
        this.wxrModeHandler = (wxrMode) => {
            Coherent.call('SHOW_MAP_WEATHER', this.uid, wxrMode.mode, wxrMode.arcRadians);
        };
        this.wxrColorsHandler = () => {
            const array = this.wxrColors.getArray();
            if (array.length === 0) {
                return;
            }
            this.wxrColorsArray.length = array.length;
            this.wxrRateArray.length = array.length;
            for (let i = 0; i < array.length; i++) {
                this.wxrColorsArray[i] = array[i][0];
                this.wxrRateArray[i] = array[i][1];
            }
            Coherent.call('SET_MAP_WEATHER_RADAR_COLORS', this.uid, this.wxrColorsArray, this.wxrRateArray);
        };
        this.isoLinesHandler = (showIsolines) => {
            Coherent.call('SHOW_MAP_ISOLINES', this.uid, showIsolines);
        };
        this.setCurrentMapParamsTimer = null;
        this.positionRadiusInhibitFramesRemaining = 0;
        this.isPositionRadiusPending = false;
        this.positionRadiusInhibitTimer = new DebounceTimer();
        this.processPendingPositionRadius = () => {
            if (this.isPositionRadiusPending) {
                Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
            }
            if (--this.positionRadiusInhibitFramesRemaining > 0) {
                this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
            }
            else {
                this.isPositionRadiusPending = false;
            }
        };
        /**
         * A callback called when the listener is fully bound.
         * @param binder The binder from the listener.
         * @param uid The unique ID of the bound map.
         */
        this.onListenerBound = (binder, uid) => {
            if (this.isDestroyed) {
                return;
            }
            if (binder.friendlyName === this.props.id) {
                // console.log('Bing map listener bound.');
                this.binder = binder;
                this.uid = uid;
                if (this._isBound) {
                    return;
                }
                this._isBound = true;
                Coherent.call('SHOW_MAP', uid, true);
                const pause = !this._isAwake;
                this.earthColorsSub = this.earthColors.sub(() => {
                    this.earthColorsHandler();
                    this.earthColorsElevationRangeHandler();
                }, true, pause);
                this.earthColorsElevationRangeSub = this.earthColorsElevationRange.sub(this.earthColorsElevationRangeHandler, true, pause);
                this.skyColorSub = this.skyColor.sub(this.skyColorHandler, true, pause);
                this.referenceSub = this.reference.sub(this.referenceHandler, true, pause);
                this.wxrModeSub = this.wxrMode.sub(this.wxrModeHandler, true, pause);
                this.wxrColorsSub = this.wxrColors.sub(this.wxrColorsHandler, true, pause);
                this.resolutionSub = this.resolution.sub(this.resolutionHandler, true, pause);
                this.isoLinesSub = this.isoLines.sub(this.isoLinesHandler, true, pause);
                // Only when not SVT, send in initial map params (even if we are asleep), because a bing instance that doesn't
                // have params initialized causes GPU perf issues.
                if (this.modeFlags !== 4) {
                    Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
                }
                this.props.onBoundCallback && this.props.onBoundCallback(this);
            }
        };
        /**
         * A callback called when the map image is updated.
         * @param uid The unique ID of the bound map.
         * @param imgSrc The img tag src attribute to assign to the bing map image.
         */
        this.onMapUpdate = (uid, imgSrc) => {
            if (this.binder !== undefined && this.uid === uid && this.imgRef.instance !== null) {
                if (this.imgRef.instance.src !== imgSrc) {
                    this.imgRef.instance.src = imgSrc;
                }
            }
        };
        /**
         * Calls the position and radius set function to set map parameters.
         */
        this.setCurrentMapParams = () => {
            this.setPositionRadius(this.pos, this.radius);
        };
    }
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound() {
        return this._isBound;
    }
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake() {
        return this._isAwake;
    }
    /** @inheritdoc */
    onAfterRender() {
        if (window['IsDestroying']) {
            this.destroy();
            return;
        }
        const gameStateSubscribable = GameStateProvider.get();
        const gameState = gameStateSubscribable.get();
        if (gameState === GameState.briefing || gameState === GameState.ingame) {
            this.registerListener();
        }
        else {
            this.gameStateSub = gameStateSubscribable.sub(state => {
                var _a;
                if (this.isDestroyed) {
                    return;
                }
                if (state === GameState.briefing || state === GameState.ingame) {
                    (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.registerListener();
                }
            });
        }
        window.addEventListener('OnDestroy', this.destroy.bind(this));
    }
    /**
     * Registers this component's Bing map listener.
     */
    registerListener() {
        var _a;
        if (((_a = this.props.delay) !== null && _a !== void 0 ? _a : 0) > 0) {
            setTimeout(() => {
                if (this.isDestroyed) {
                    return;
                }
                this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered.bind(this));
            }, this.props.delay);
        }
        else {
            this.mapListener = RegisterViewListener('JS_LISTENER_MAPS', this.onListenerRegistered.bind(this));
        }
    }
    /**
     * A callback called when this component's Bing map listener is registered.
     */
    onListenerRegistered() {
        if (this.isDestroyed || this.isListenerRegistered) {
            return;
        }
        this.mapListener.on('MapBinded', this.onListenerBound);
        this.mapListener.on('MapUpdated', this.onMapUpdate);
        this.isListenerRegistered = true;
        this.mapListener.trigger('JS_BIND_BINGMAP', this.props.id, this.modeFlags);
    }
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this._isAwake = true;
        if (!this._isBound) {
            return;
        }
        this.setCurrentMapParams();
        // Only when not SVT, periodically send map params to Coherent in case another BingComponent binds to the same
        // bing instance and sends in the initial params set and overrides our params.
        if (this.modeFlags !== 4) {
            this.setCurrentMapParamsTimer = setInterval(this.setCurrentMapParams, 200);
        }
        (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.resume(true);
        (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.resume(true);
        (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.resume(true);
        (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.resume(true);
    }
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this._isAwake = false;
        if (!this._isBound) {
            return;
        }
        if (this.setCurrentMapParamsTimer !== null) {
            clearInterval(this.setCurrentMapParamsTimer);
        }
        (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.pause();
        (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.pause();
        (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.pause();
        (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.pause();
    }
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos, radius) {
        this.pos = pos;
        this.radius = Math.max(radius, 10); // Not sure if bad things happen when radius is 0, so we just clamp it to 10 meters.
        if (this._isBound && this._isAwake) {
            if (this.positionRadiusInhibitFramesRemaining > 0) {
                this.isPositionRadiusPending = true;
            }
            else {
                Coherent.call('SET_MAP_PARAMS', this.uid, this.pos, this.radius, 1);
            }
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { ref: this.imgRef, src: '', style: 'position: absolute; left: 0; top: 0; width: 100%; height: 100%;', class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        this.isDestroyed = true;
        this._isBound = false;
        if (this.setCurrentMapParamsTimer !== null) {
            clearInterval(this.setCurrentMapParamsTimer);
        }
        (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.earthColorsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.earthColorsElevationRangeSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.skyColorSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.referenceSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.wxrModeSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.wxrColorsSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.resolutionSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.isoLinesSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.mapListener) === null || _k === void 0 ? void 0 : _k.off('MapBinded', this.onListenerBound);
        (_l = this.mapListener) === null || _l === void 0 ? void 0 : _l.off('MapUpdated', this.onMapUpdate);
        (_m = this.mapListener) === null || _m === void 0 ? void 0 : _m.trigger('JS_UNBIND_BINGMAP', this.props.id);
        this.isListenerRegistered = false;
        this.imgRef.instance.src = '';
        (_o = this.imgRef.instance.parentNode) === null || _o === void 0 ? void 0 : _o.removeChild(this.imgRef.instance);
        super.destroy();
    }
    /**
     * Resets the img element's src attribute.
     */
    resetImgSrc() {
        const imgRef = this.imgRef.getOrDefault();
        if (imgRef !== null) {
            const currentSrc = imgRef.src;
            imgRef.src = '';
            imgRef.src = currentSrc;
        }
    }
    /**
     * Converts an HTML hex color string to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGB value equivalent of the specified hex color string, as `R + G * 256 + B * 256^2`.
     */
    static hexaToRGBColor(hexColor) {
        const hexStringColor = hexColor;
        let offset = 0;
        if (hexStringColor[0] === '#') {
            offset = 1;
        }
        const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
        const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
        const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
        return BingComponent.rgbColor(r, g, b);
    }
    /**
     * Converts a numerical RGB value to an HTML hex color string.
     * @param rgb The numerical RGB value to convert, as `R + G * 256 + B * 256^2`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGB value.
     */
    static rgbToHexaColor(rgb, poundPrefix = true) {
        const b = Math.floor((rgb % (256 * 256 * 256)) / (256 * 256));
        const g = Math.floor((rgb % (256 * 256)) / 256);
        const r = rgb % 256;
        return `${poundPrefix ? '#' : ''}${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
    /**
     * Converts RGB color components to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns The numerical RGB value of the specified components, as `R + G * 256 + B * 256^2`.
     */
    static rgbColor(r, g, b) {
        return 256 * 256 * b + 256 * g + r;
    }
    /**
     * Converts an HTML hex color string to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGBA value equivalent of the specified hex color string, as
     * `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static hexaToRGBAColor(hexColor) {
        const hexStringColor = hexColor;
        let offset = 0;
        if (hexStringColor[0] === '#') {
            offset = 1;
        }
        const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
        const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
        const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
        const a = parseInt(hexStringColor.substr(6 + offset, 2), 16);
        return BingComponent.rgbaColor(r, g, b, a);
    }
    /**
     * Converts a numerical RGBA value to an HTML hex color string.
     * @param rgba The numerical RGBA value to convert, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGBA value.
     */
    static rgbaToHexaColor(rgba, poundPrefix = true) {
        const a = Math.floor((rgba % (256 * 256 * 256 * 256)) / (256 * 256 * 256));
        const b = Math.floor((rgba % (256 * 256 * 256)) / (256 * 256));
        const g = Math.floor((rgba % (256 * 256)) / 256);
        const r = rgba % 256;
        return `${poundPrefix ? '#' : ''}${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}${a.toString(16).padStart(2, '0')}`;
    }
    /**
     * Converts RGBA color components to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @param a The alpha component, from 0 to 255.
     * @returns The numerical RGBA value of the specified components, as `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static rgbaColor(r, g, b, a) {
        return 256 * 256 * 256 * a + 256 * 256 * b + 256 * g + r;
    }
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @param minElevation The minimum elevation to which to assign a color, in feet. Defaults to 0.
     * @param maxElevation The maximum elevation to which to assign a color, in feet. Defaults to 30000.
     * @param stepCount The number of terrain color steps. Defaults to 61.
     * @returns a full Bing component earth colors array.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createEarthColorsArray(waterColor, terrainColors, minElevation = 0, maxElevation = 30000, stepCount = 61) {
        const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
        const curve = new Avionics.Curve();
        curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
        for (let i = 0; i < terrainColors.length; i++) {
            curve.add(terrainColors[i].elev, terrainColors[i].color);
        }
        const elevationStep = (maxElevation - minElevation) / Math.max(stepCount - 1, 1);
        for (let i = 0; i < stepCount; i++) {
            const color = curve.evaluate(minElevation + i * elevationStep);
            earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
        }
        return earthColors;
    }
}
/** The default resolution of the Bing Map along both horizontal and vertical axes, in pixels. */
BingComponent.DEFAULT_RESOLUTION = 1024;
BingComponent.DEFAULT_WEATHER_COLORS = [
    [BingComponent.hexaToRGBAColor('#00000000'), 0.5],
    [BingComponent.hexaToRGBAColor('#004d00ff'), 2.75],
    [BingComponent.hexaToRGBAColor('#cb7300ff'), 12.5],
    [BingComponent.hexaToRGBAColor('#ff0000ff'), 12.5]
];
BingComponent.POSITION_RADIUS_INHIBIT_FRAMES = 10;

/**
 * A scrolling digit display. The display supports number bases greater than or equal to 3. The display renders a
 * one digit for each of the following values:
 * ```
 * -(base + 2), -(base + 1), -(base), ... , -1, 0, 1, ... , base, base + 1, base + 2`
 * ```
 * The total number of rendered digits equals `(base + 2) * 2 + 1`. The display will scroll between the rendered
 * digits based on a bound value.
 *
 * When styling the scroller with CSS, select the `digit-scroller-digit` class to style all rendered digits. Each
 * individual digit can also be selected with the `digit-scroller-digit-[index]` classes, where `[index]` is replaced
 * with `0, 1, 2, ...`, starting with the lowest-valued digit. Select the `digit-scroller-nan` class to style the text
 * rendered for `NaN` values. The `--digit-scroller-line-height` variable is used to control the vertical spacing
 * between each digit (defaults to `1em`). The `--digit-scroller-line-offset-y` variable is used to control the
 * vertical offset of each digit (defaults to `0px`).
 */
class DigitScroller extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.digitCount = (this.props.base + 2) * 2 + 1;
        this.translationPerDigit = 100 / this.digitCount;
        this.tapeStyle = ObjectSubject.create({
            display: '',
            position: 'absolute',
            left: '0',
            top: `calc(50% - var(--digit-scroller-line-height, 1em) * ${this.digitCount / 2})`,
            width: '100%',
            height: `calc(var(--digit-scroller-line-height, 1em) * ${this.digitCount})`,
            transform: 'translate3d(0, 0, 0)'
        });
        this.nanTextStyle = ObjectSubject.create({
            display: 'none',
            position: 'absolute',
            left: '0%',
            top: '50%',
            width: '100%',
            transform: 'translateY(-50%)'
        });
        this.digitPlaceFactor = this.props.factor;
        this.scrollThreshold = (_a = this.props.scrollThreshold) !== null && _a !== void 0 ? _a : 0;
        this.translateY = Subject.create(0);
        if (props.base < 3 || Math.floor(props.base) !== props.base) {
            throw new Error(`DigitScroller: invalid number base (${this.props.base})`);
        }
        if (props.factor === 0) {
            throw new Error(`DigitScroller: invalid factor (${props.factor})`);
        }
    }
    /** @inheritdoc */
    onAfterRender() {
        this.translateY.sub(translateY => {
            this.tapeStyle.set('transform', `translate3d(0, ${translateY}%, 0)`);
        });
        this.valueSub = this.props.value.sub(this.update.bind(this), true);
    }
    /**
     * Updates this display.
     * @param value This display's value.
     */
    update(value) {
        if (isNaN(value)) {
            this.nanTextStyle.set('display', '');
            this.tapeStyle.set('display', 'none');
            return;
        }
        this.nanTextStyle.set('display', 'none');
        this.tapeStyle.set('display', '');
        const base = this.props.base;
        const valueSign = value < 0 ? -1 : 1;
        const valueAbs = Math.abs(value);
        let pivot = Math.floor(valueAbs / this.digitPlaceFactor) * this.digitPlaceFactor;
        let digit = Math.floor(pivot / this.digitPlaceFactor) % base;
        let digitTranslate = (valueAbs - pivot) / this.digitPlaceFactor;
        const threshold = this.scrollThreshold / this.digitPlaceFactor;
        digitTranslate = (digitTranslate > threshold) ? (digitTranslate - threshold) / (1 - threshold) : 0;
        if (digitTranslate >= 0.5) {
            pivot += this.digitPlaceFactor;
            digit = (digit + 1) % base;
            digitTranslate -= 1;
        }
        let tapeTranslate = 0;
        if (pivot <= this.digitPlaceFactor) {
            tapeTranslate = (digit + digitTranslate) * valueSign * this.translationPerDigit;
        }
        else {
            tapeTranslate = (((digit + base - 2) % base + 2) + digitTranslate) * valueSign * this.translationPerDigit;
        }
        this.translateY.set(MathUtils.round(tapeTranslate, 0.1));
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        let cssClass;
        if (this.props.class !== undefined && typeof this.props.class === 'object') {
            cssClass = SetSubject.create(['digit-scroller']);
            this.cssClassSub = FSComponent.bindCssClassSet(cssClass, this.props.class, ['digit-scroller']);
        }
        else {
            cssClass = `digit-scroller ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`;
        }
        return (FSComponent.buildComponent("div", { class: cssClass, style: 'overflow: hidden' },
            FSComponent.buildComponent("div", { class: 'digit-scroller-digit-tape', style: this.tapeStyle }, this.renderDigits()),
            FSComponent.buildComponent("div", { class: 'digit-scroller-nan', style: this.nanTextStyle }, (_b = this.props.nanString) !== null && _b !== void 0 ? _b : '–')));
    }
    /**
     * Renders text for each of this display's individual digits.
     * @returns This display's individual digit text, as an array of VNodes.
     */
    renderDigits() {
        var _a;
        const base = this.props.base;
        const renderFunc = (_a = this.props.renderDigit) !== null && _a !== void 0 ? _a : ((digit) => (Math.abs(digit) % base).toString());
        // Digits to render: -(base + 2), -(base + 1), -(base), -(base - 1), ... -1, 0, 1, ... , base - 1, base, base + 1, base + 2
        const zeroIndexOffset = base + 2;
        return Array.from({ length: this.digitCount }, (v, index) => {
            const digit = zeroIndexOffset - index;
            return (FSComponent.buildComponent("div", { style: `position: absolute; left: 0; top: calc(var(--digit-scroller-line-offset-y, 0px) + ${50 + (index - zeroIndexOffset - 0.5) * this.translationPerDigit}%); width: 100%; height: ${this.translationPerDigit}%; line-height: var(--digit-scroller-line-height, 1em);` },
                FSComponent.buildComponent("span", { class: `digit-scroller-digit digit-scroller-digit-${index}`, style: 'vertical-align: baseline;' }, renderFunc(digit))));
        });
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.cssClassSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/**
 * A base component for horizon layers.
 */
class HorizonLayer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._isAttached = false;
        this._isVisible = true;
    }
    /**
     * Checks whether this layer is attached to a horizon component.
     * @returns Whether this layer is attached to a horizon component.
     */
    isAttached() {
        return this._isAttached;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
        return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
        if (this._isVisible === val) {
            return;
        }
        this._isVisible = val;
        if (this._isAttached) {
            this.onVisibilityChanged(val);
        }
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        // noop
    }
    /**
     * This method is called when this layer is attached to its parent horizon component.
     */
    onAttached() {
        this._isAttached = true;
        if (!this._isVisible) {
            this.onVisibilityChanged(this._isVisible);
        }
    }
    /**
     * This method is called when this layer's parent horizon component is awakened.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this layer's parent horizon component is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when this layer's horizon projection changes.
     * @param projection This layer's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onProjectionChanged(projection, changeFlags) {
        // noop
    }
    /**
     * This method is called once every update cycle.
     * @param time The current time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this layer is detached from its parent horizon component.
     */
    onDetached() {
        this._isAttached = false;
    }
}

/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
class HorizonCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
        this.canvas = canvas;
        this.context = context;
        this.isDisplayed = isDisplayed;
    }
    /** @inheritdoc */
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    /** @inheritdoc */
    reset() {
        const width = this.canvas.width;
        this.canvas.width = 0;
        this.canvas.width = width;
    }
}
/**
 * A layer which uses a canvas to draw graphics.
 */
class HorizonCanvasLayer extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.displayCanvasRef = FSComponent.createRef();
        this.width = 0;
        this.height = 0;
        this.displayCanvasContext = null;
        this.isInit = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display() {
        if (!this._display) {
            throw new Error('HorizonCanvasLayer: attempted to access display before it was initialized');
        }
        return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer() {
        if (!this._buffer) {
            throw new Error('HorizonCanvasLayer: attempted to access buffer before it was initialized');
        }
        return this._buffer;
    }
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay() {
        return this._display;
    }
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer() {
        return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
        return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
        return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
        if (width === this.width) {
            return;
        }
        this.width = width;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
        if (height === this.height) {
            return;
        }
        this.height = height;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
        if (!this.isInit || !this.props.useBuffer) {
            return;
        }
        this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.displayCanvasContext = this.displayCanvasRef.instance.getContext('2d');
    }
    /** @inheritdoc */
    onVisibilityChanged() {
        if (this.isInit) {
            this.updateCanvasVisibility();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.initCanvasInstances();
        this.isInit = true;
        this.updateCanvasVisibility();
        this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
        this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
        if (this.props.useBuffer) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            this._buffer = this.createCanvasInstance(canvas, context, false);
        }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new HorizonCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
        const displayCanvas = this.display.canvas;
        displayCanvas.width = this.width;
        displayCanvas.height = this.height;
        displayCanvas.style.width = `${this.width}px`;
        displayCanvas.style.height = `${this.height}px`;
        if (this._buffer) {
            const bufferCanvas = this._buffer.canvas;
            bufferCanvas.width = this.width;
            bufferCanvas.height = this.height;
        }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', width: '0', height: '0', style: 'position: absolute;' }, " "));
    }
}

/**
 * The different types of horizon projection changes.
 */
var HorizonProjectionChangeType;
(function (HorizonProjectionChangeType) {
    HorizonProjectionChangeType[HorizonProjectionChangeType["Position"] = 1] = "Position";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Altitude"] = 2] = "Altitude";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Heading"] = 4] = "Heading";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Pitch"] = 8] = "Pitch";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Roll"] = 16] = "Roll";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Offset"] = 32] = "Offset";
    HorizonProjectionChangeType[HorizonProjectionChangeType["ProjectedSize"] = 64] = "ProjectedSize";
    HorizonProjectionChangeType[HorizonProjectionChangeType["Fov"] = 128] = "Fov";
    HorizonProjectionChangeType[HorizonProjectionChangeType["FovEndpoints"] = 256] = "FovEndpoints";
    HorizonProjectionChangeType[HorizonProjectionChangeType["PitchScaleFactor"] = 512] = "PitchScaleFactor";
    HorizonProjectionChangeType[HorizonProjectionChangeType["HeadingScaleFactor"] = 1024] = "HeadingScaleFactor";
    HorizonProjectionChangeType[HorizonProjectionChangeType["ScaleFactor"] = 2048] = "ScaleFactor";
    HorizonProjectionChangeType[HorizonProjectionChangeType["ProjectedOffset"] = 4096] = "ProjectedOffset";
    HorizonProjectionChangeType[HorizonProjectionChangeType["OffsetCenterProjected"] = 8192] = "OffsetCenterProjected";
})(HorizonProjectionChangeType || (HorizonProjectionChangeType = {}));
/**
 * A perspective projection from the point of view of an airplane.
 */
class HorizonProjection {
    /**
     * Constructor.
     * @param projectedWidth The initial projected width of the projection, in pixels.
     * @param projectedHeight The initial projected height of the projection, in pixels.
     * @param fov The initial field of view of the projection, in degrees.
     */
    constructor(projectedWidth, projectedHeight, fov) {
        this.position = new GeoPoint(0, 0);
        this.altitude = 0;
        this.heading = 0;
        this.roll = 0;
        this.pitch = 0;
        this.offset = Vec3Math.create();
        this.fovEndpoints = VecNMath.create(4, 0.5, 0, 0.5, 1);
        this.scaleFactor = 1;
        this.projectedOffset = Vec2Math.create();
        this.offsetCenterProjected = Vec2Math.create();
        this.positionAngleTransforms = [new Transform3D(), new Transform3D()];
        this.altitudeTransform = new Transform3D();
        this.positionAltitudeTransforms = [...this.positionAngleTransforms, this.altitudeTransform];
        this.positionTransform = new Transform3D();
        this.planeAngles = Vec3Math.create();
        this.planeAngleTransforms = [new Transform3D(), new Transform3D(), new Transform3D()];
        this.planeTransform = new Transform3D();
        this.cameraPos = Vec3Math.create();
        this.surfacePos = Vec3Math.create();
        this.perspectiveTransform = new TransformPerspective();
        this.oldParameters = {
            position: new GeoPoint(0, 0),
            altitude: 0,
            heading: 0,
            pitch: 0,
            roll: 0,
            offset: Vec3Math.create(),
            projectedSize: Vec2Math.create(),
            fov: 0,
            fovEndpoints: VecNMath.create(4),
            pitchScaleFactor: 1,
            headingScaleFactor: 1,
            scaleFactor: 1,
            projectedOffset: Vec2Math.create(),
            offsetCenterProjected: Vec2Math.create()
        };
        this.queuedParameters = {};
        this.updateQueued = false;
        this.changeEvent = new SubEvent();
        this.projectedSize = Vec2Math.create(projectedWidth, projectedHeight);
        this.fov = fov;
        this.pitchScaleFactor = 1;
        this.headingScaleFactor = 1;
        this.recompute();
    }
    /**
     * Gets the position of this projection.
     * @returns The position of this projection.
     */
    getPosition() {
        return this.position.readonly;
    }
    /**
     * Gets the altitude of this projection, in meters above mean sea level.
     * @returns The altitude of this projection, in meters above mean sea level.
     */
    getAltitude() {
        return this.altitude;
    }
    /**
     * Gets the true heading of this projection, in degrees.
     * @returns The true heading of this projection, in degrees.
     */
    getHeading() {
        return this.heading;
    }
    /**
     * Gets the pitch of this projection, in degrees.
     * @returns The pitch of this projection, in degrees.
     */
    getPitch() {
        return this.pitch;
    }
    /**
     * Gets the roll of this projection, in degrees.
     * @returns The roll of this projection, in degrees.
     */
    getRoll() {
        return this.roll;
    }
    /**
     * Gets the size of the projected window, as `[width, height]` in pixels.
     * @returns The size of the projected window, as `[width, height]` in pixels.
     */
    getProjectedSize() {
        return this.projectedSize;
    }
    /**
     * Gets the field of view of this projection, in degrees.
     * @returns The field of view of this projection, in degrees.
     */
    getFov() {
        return this.fov;
    }
    /**
     * Gets the projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each component
     * expressed relative to the width or height of the projected window.
     * @returns The projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each
     * component expressed relative to the width or height of the projected window.
     */
    getFovEndpoints() {
        return this.fovEndpoints;
    }
    /**
     * Gets the focal length of this projection, in meters. The focal length is set such that one meter at a distance
     * from the camera equal to the focal length subtends an angle equal to the field of view.
     * @returns The focal length of this projection, in meters.
     */
    getFocalLength() {
        return this.surfacePos[2];
    }
    /**
     * Gets the pitch angle scale factor of this projection. When a point is projected, its relative zero-roll pitch
     * angle is scaled by this value before projection. The relative zero-roll pitch angle of a point is the pitch angle
     * of the point relative to the camera if the airplane had zero degrees of roll. A scaling factor of 1 leaves points
     * unchanged. Factors less than 1 cause points to be projected closer to the pitch line corresponding to the
     * airplane's pitch. Factors greater than 1 cause points to be projected farther from the pitch line corresponding
     * to the airplane's pitch.
     * @returns The pitch angle scale factor of this projection.
     */
    getPitchScaleFactor() {
        return this.pitchScaleFactor;
    }
    /**
     * Gets the heading angle scale factor of this projection. When a point is projected, its relative heading angle is
     * scaled by this value before projection. The relative heading angle of a point is the difference between the
     * bearing of the point from the airplane and the airplane's heading. A scaling factor of 1 leaves points unchanged.
     * Factors less than 1 cause points to be projected closer to the lubber line. Factors greater than 1 cause points to
     * be projected farther from the lubber line.
     * @returns The heading angle scale factor of this projection.
     */
    getHeadingScaleFactor() {
        return this.headingScaleFactor;
    }
    /**
     * Gets the nominal scale factor of this projection. At a distance from the camera equal to the focal length, one
     * meter will be projected to a number of pixels equal to the nominal scale factor.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor() {
        return this.scaleFactor;
    }
    /**
     * Gets the projected offset of this projection's center, as `[x, y]` in pixels.
     * @returns The projected offset of this projection's center, as `[x, y]` in pixels.
     */
    getProjectedOffset() {
        return this.projectedOffset;
    }
    /**
     * Gets the projected center of this projection, including offset, as `[x, y]` in pixels.
     * @returns The projected center of this projection, including offset, as `[x, y]` in pixels.
     */
    getOffsetCenterProjected() {
        return this.offsetCenterProjected;
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
        Vec2Math.set(this.projectedSize[0] / 2 + this.projectedOffset[0], this.projectedSize[1] / 2 + this.projectedOffset[1], this.offsetCenterProjected);
        // Compute the transformation required to bring the position of the plane to [0, 0, 0]. After applying this
        // transformation, with a heading/roll/pitch of 0, the positive z axis points in the direction of the plane, the
        // positive x axis points directly upward (away from the ground), and the positive y axis points to the right.
        this.positionAngleTransforms[0].toRotationZ(-this.position.lon * Avionics.Utils.DEG2RAD);
        this.positionAngleTransforms[1].toRotationY(this.position.lat * Avionics.Utils.DEG2RAD);
        this.altitudeTransform.toTranslation(-(UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + this.altitude), 0, 0);
        Transform3D.concat(this.positionTransform, this.positionAltitudeTransforms);
        this.planeAngles[0] = -this.heading * Avionics.Utils.DEG2RAD;
        this.planeAngles[1] = this.pitch * Avionics.Utils.DEG2RAD;
        this.planeAngles[2] = this.roll * Avionics.Utils.DEG2RAD;
        this.planeAngleTransforms[0].toRotationZ(this.planeAngles[2]);
        this.planeAngleTransforms[1].toRotationY(this.planeAngles[1]);
        this.planeAngleTransforms[2].toRotationX(this.planeAngles[0]);
        Transform3D.concat(this.planeTransform, this.planeAngleTransforms);
        // Convert camera offset to world coordinates
        this.planeTransform.apply(this.offset, this.cameraPos);
        this.scaleFactor = Math.hypot(this.fovEndpoints[2] * this.projectedSize[0] - this.fovEndpoints[0] * this.projectedSize[0], this.fovEndpoints[3] * this.projectedSize[1] - this.fovEndpoints[1] * this.projectedSize[1]);
        this.surfacePos[2] = 1 / (2 * Math.tan(this.fov * 0.5 * Avionics.Utils.DEG2RAD));
        this.perspectiveTransform
            .setCameraRotation(this.planeTransform)
            .setSurfacePosition(this.surfacePos);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
        var _a, _b, _c, _d, _e, _f, _g;
        // save old values
        this.storeParameters(this.oldParameters);
        parameters.position !== undefined && this.position.set(parameters.position);
        this.altitude = (_a = parameters.altitude) !== null && _a !== void 0 ? _a : this.altitude;
        this.heading = (_b = parameters.heading) !== null && _b !== void 0 ? _b : this.heading;
        this.pitch = (_c = parameters.pitch) !== null && _c !== void 0 ? _c : this.pitch;
        this.roll = (_d = parameters.roll) !== null && _d !== void 0 ? _d : this.roll;
        parameters.offset !== undefined && this.offset.set(parameters.offset);
        parameters.projectedSize !== undefined && this.projectedSize.set(parameters.projectedSize);
        this.fov = (_e = parameters.fov) !== null && _e !== void 0 ? _e : this.fov;
        parameters.fovEndpoints !== undefined && this.fovEndpoints.set(parameters.fovEndpoints);
        this.pitchScaleFactor = (_f = parameters.pitchScaleFactor) !== null && _f !== void 0 ? _f : this.pitchScaleFactor;
        this.headingScaleFactor = (_g = parameters.headingScaleFactor) !== null && _g !== void 0 ? _g : this.headingScaleFactor;
        parameters.projectedOffset !== undefined && this.projectedOffset.set(parameters.projectedOffset);
        let changeFlags = this.computeChangeFlags(this.oldParameters);
        if ((changeFlags & HorizonProjection.RECOMPUTE_MASK) !== 0) {
            this.recompute();
            changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        }
        if (changeFlags !== 0) {
            this.changeEvent.notify(this, changeFlags);
        }
    }
    /**
     * Sets the projection parameters to be applied when `applyQueued()` is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters) {
        Object.assign(this.queuedParameters, parameters);
        this.updateQueued = true;
    }
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued() {
        if (this.updateQueued) {
            this.updateQueued = false;
            this.set(this.queuedParameters);
            for (const key in this.queuedParameters) {
                delete this.queuedParameters[key];
            }
        }
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
        record.position.set(this.position);
        record.altitude = this.altitude;
        record.heading = this.heading;
        record.pitch = this.pitch;
        record.roll = this.roll;
        record.offset.set(this.offset);
        record.projectedSize.set(this.projectedSize);
        record.fov = this.fov;
        record.fovEndpoints.set(this.fovEndpoints);
        record.pitchScaleFactor = this.pitchScaleFactor;
        record.headingScaleFactor = this.headingScaleFactor;
        record.scaleFactor = this.scaleFactor;
        record.projectedOffset.set(this.projectedOffset);
        record.offsetCenterProjected.set(this.offsetCenterProjected);
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
        return (oldParameters.position.equals(this.position) ? 0 : HorizonProjectionChangeType.Position)
            | (oldParameters.altitude === this.altitude ? 0 : HorizonProjectionChangeType.Altitude)
            | (oldParameters.heading === this.heading ? 0 : HorizonProjectionChangeType.Heading)
            | (oldParameters.pitch === this.pitch ? 0 : HorizonProjectionChangeType.Pitch)
            | (oldParameters.roll === this.roll ? 0 : HorizonProjectionChangeType.Roll)
            | (Vec3Math.equals(oldParameters.offset, this.offset) ? 0 : HorizonProjectionChangeType.Offset)
            | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : HorizonProjectionChangeType.ProjectedSize)
            | (oldParameters.fov === this.fov ? 0 : HorizonProjectionChangeType.Fov)
            | (VecNMath.equals(oldParameters.fovEndpoints, this.fovEndpoints) ? 0 : HorizonProjectionChangeType.FovEndpoints)
            | (oldParameters.pitchScaleFactor === this.pitchScaleFactor ? 0 : HorizonProjectionChangeType.PitchScaleFactor)
            | (oldParameters.headingScaleFactor === this.headingScaleFactor ? 0 : HorizonProjectionChangeType.HeadingScaleFactor)
            | (Vec2Math.equals(oldParameters.projectedOffset, this.projectedOffset) ? 0 : HorizonProjectionChangeType.ProjectedOffset);
    }
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    computeDerivedChangeFlags(oldParameters) {
        return (oldParameters.scaleFactor === this.scaleFactor ? 0 : HorizonProjectionChangeType.ScaleFactor)
            | (Vec2Math.equals(oldParameters.offsetCenterProjected, this.offsetCenterProjected) ? 0 : HorizonProjectionChangeType.OffsetCenterProjected);
    }
    /**
     * Subscribes a change listener to this projection. The listener will be called every time this projection changes.
     * A listener can be subscribed multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to subscribe.
     * @returns The new subscription.
     */
    onChange(listener) {
        return this.changeEvent.on(listener);
    }
    /**
     * Projects a point represented by a set of lat/lon coordinates and altitude.
     * @param position The lat/lon coordinates of the point to project.
     * @param altitude The altitude of the point to project, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    project(position, altitude, out) {
        const vec = GeoPoint.sphericalToCartesian(position, HorizonProjection.vec3Cache[0]);
        Vec3Math.multScalar(vec, UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + altitude, vec);
        this.positionTransform.apply(vec, vec);
        return this.projectRelativeVec(vec, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    projectRelativeCoordinates(arg1, arg2, arg3, arg4) {
        if (typeof arg1 === 'number') {
            return this.projectRelativeVec(Vec3Math.set(arg1, arg2, arg3, HorizonProjection.vec3Cache[0]), arg4);
        }
        else {
            return this.projectRelativeVec(arg1, arg2);
        }
    }
    /**
     * Projects a point relative to the position of the airplane in spherical space.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The geodetic horizontal distance from the point to project to the airplane, in meters.
     * @param height The geodetic height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeSpherical(bearing, distance, height, out) {
        return this.project(this.position.offset(bearing, UnitType.METER.convertTo(distance, UnitType.GA_RADIAN), HorizonProjection.geoPointCache[0]), this.altitude + height, out);
    }
    /**
     * Projects a point relative to the position of the airplane in Euclidean space. The point ot project is expressed
     * in terms of bearing, horizontal distance, and height. The coordinate system is defined at the position of the
     * airplane, with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel to
     * the Earth's surface at the point directly underneath the airplane.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the airplane, in meters.
     * @param height The Euclidean height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeEuclidean(bearing, distance, height, out) {
        const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = height;
        const y = vec[1];
        const z = vec[0];
        return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a point relative to the position of the airplane in Euclidean space. The point to project is expressed
     * in terms of distance, relative bearing and pitch. The coordinate system is defined at the position of the
     * airplane, with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel to
     * the Earth's surface at the point directly underneath the airplane.
     * @param distance The Euclidean distance from the point to project to the airplane, in meters.
     * @param bearing The relative bearing from the airplane to the point to project, in degrees. The relative bearing is
     * measured relative to the airplane's heading, with positive angles sweeping clockwise when viewed from above.
     * @param pitch The pitch angle from the airplane to the point to project, in degrees. The pitch angle is measured
     * relative to the horizontal plane, with positive angles sweeping above the plane.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeAngular(distance, bearing, pitch, out) {
        const trueBearing = this.heading + bearing;
        const vec = Vec3Math.setFromSpherical(distance, (90 - pitch) * Avionics.Utils.DEG2RAD, trueBearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = vec[2];
        const y = vec[1];
        const z = vec[0];
        return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a 3D vector defined relative to the airplane, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    projectRelativeVec(vec, out) {
        const vecToProject = Vec3Math.sub(vec, this.cameraPos, HorizonProjection.relativeVec3Cache[0]);
        if (this.pitchScaleFactor !== 1 || this.headingScaleFactor !== 1) {
            this.applyPitchHeadingScale(vecToProject, this.pitchScaleFactor, this.headingScaleFactor, vecToProject);
        }
        this.perspectiveTransform.apply(vecToProject, out);
        return Vec2Math.set(out[1] * this.scaleFactor + this.offsetCenterProjected[0], -out[0] * this.scaleFactor + this.offsetCenterProjected[1], out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    projectCameraRelativeCoordinates(arg1, arg2, arg3, arg4) {
        if (typeof arg1 === 'number') {
            return this.projectCameraRelativeVec(Vec3Math.set(arg1, arg2, arg3, HorizonProjection.vec3Cache[0]), arg4);
        }
        else {
            return this.projectCameraRelativeVec(arg1, arg2);
        }
    }
    /**
     * Projects a point relative to the position of the projection camera in Euclidean space. The point to project is
     * expressed in terms of bearing, horizontal distance, and height. The coordinate system is defined at the position
     * of the camera, with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel
     * to the Earth's surface at the point directly underneath the camera.
     * @param bearing The true bearing from the camera to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the camera, in meters.
     * @param height The Euclidean height of the point to project relative to the camera, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectCameraRelativeEuclidean(bearing, distance, height, out) {
        const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = height;
        const y = vec[1];
        const z = vec[0];
        return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a point relative to the position of the projection camera in Euclidean space. The point to project is
     * expressed in terms of distance, bearing and pitch. The coordinate system is defined at the position of the camera,
     * with the vertical axis perpendicular to the surface of the Earth and the horizontal plane parallel to the Earth's
     * surface at the point directly underneath the camera.
     * @param distance The Euclidean distance from the point to project to the camera, in meters.
     * @param bearing The true bearing from the camera to the point to project, in degrees.
     * @param pitch The pitch angle from the camera to the point to project, in degrees. The pitch angle is measured
     * relative to the horizontal plane, with positive angles sweeping above the plane.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectCameraRelativeAngular(distance, bearing, pitch, out) {
        const vec = Vec3Math.setFromSpherical(distance, (90 - pitch) * Avionics.Utils.DEG2RAD, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
        const x = vec[2];
        const y = vec[1];
        const z = vec[0];
        return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a 3D vector defined relative to the camera, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    projectCameraRelativeVec(vec, out) {
        if (this.pitchScaleFactor !== 1 || this.headingScaleFactor !== 1) {
            vec = this.applyPitchHeadingScale(vec, this.pitchScaleFactor, this.headingScaleFactor, HorizonProjection.cameraRelativeVec3Cache[0]);
        }
        this.perspectiveTransform.apply(vec, out);
        return Vec2Math.set(out[1] * this.scaleFactor + this.offsetCenterProjected[0], -out[0] * this.scaleFactor + this.offsetCenterProjected[1], out);
    }
    /**
     * Inverts a pair of projected coordinates to calculate the pitch angle and true bearing (both relative to the
     * horizontal plane with origin at the camera) of the set of points in 3D space that are projected to those
     * coordinates.
     * @param x The projected x coordinate to invert.
     * @param y The projected y coordinate to invert.
     * @param out The 2D vector to which to write the result.
     * @returns The pitch angle and true bearing (both relative to the horizontal plane with origin at the camera) of the
     * set of points in 3D space that are projected to the specified coordinates, as `[pitch angle, true bearing]` in
     * degrees.
     */
    invertToCameraRelativeAngles(x, y, out) {
        // We need to invert the perspective transformation. Since we are only calculating the pitch and bearing angles
        // referenced to the camera (and not also the distance), we can achieve this by choosing an arbitrary z-value for
        // the inverted position vector. If we choose the z-value to be equal to the camera's focal length, then the x and
        // y values of the inverted position vector will be exactly the x and y values of its projection.
        const perspectiveX = (this.offsetCenterProjected[1] - y) / this.scaleFactor;
        const perspectiveY = (x - this.offsetCenterProjected[0]) / this.scaleFactor;
        const cameraRelativeVec = Vec3Math.set(perspectiveX, perspectiveY, this.surfacePos[2], HorizonProjection.vec3Cache[0]);
        this.planeTransform.apply(cameraRelativeVec, cameraRelativeVec);
        if (this.pitchScaleFactor !== 1 || this.headingScaleFactor !== 1) {
            this.applyPitchHeadingScale(cameraRelativeVec, 1 / this.pitchScaleFactor, 1 / this.headingScaleFactor, cameraRelativeVec);
        }
        // Rotate the coordinate system such that z is the vertical axis and x/y form the horizontal plane so that we can
        // use standard theta/phi angles.
        Vec3Math.set(cameraRelativeVec[1], cameraRelativeVec[2], cameraRelativeVec[0], cameraRelativeVec);
        return Vec2Math.set(((90 - Vec3Math.theta(cameraRelativeVec) * Avionics.Utils.RAD2DEG) + 180) % 360 - 180, // -180 to 180
        ((90 - Vec3Math.phi(cameraRelativeVec) * Avionics.Utils.RAD2DEG) + 360) % 360, // 0 to 360
        out);
    }
    /**
     * Applies pitch and heading angle scaling to a 3D vector defined relative to the camera, as `[x, y, z]` in meters
     * with the coordinate system defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param pitchScaleFactor The pitch angle scale factor to use.
     * @param headingScaleFactor The heading angle scale factor to use.
     * @param out The 3D vector to which to write the result.
     * @returns The scaled vector.
     */
    applyPitchHeadingScale(vec, pitchScaleFactor, headingScaleFactor, out) {
        if (pitchScaleFactor !== 1 || headingScaleFactor !== 1) {
            // Rotate the coordinate system such that z is the vertical axis and x/y form the horizontal plane so that we can
            // use standard theta/phi angles.
            Vec3Math.set(vec[1], vec[2], vec[0], out);
            const length = Vec3Math.abs(out);
            if (length > 0) {
                let theta;
                let phi;
                if (pitchScaleFactor !== 1) {
                    theta = Vec3Math.theta(out);
                    const planePitchRad = this.planeAngles[1];
                    const relativePitchAngle = ((MathUtils.HALF_PI - theta) - planePitchRad + Math.PI) % MathUtils.TWO_PI - Math.PI; // range -pi to +pi
                    if (relativePitchAngle !== 0) {
                        theta = MathUtils.HALF_PI - (relativePitchAngle * pitchScaleFactor + planePitchRad);
                        phi = Vec3Math.phi(out);
                        Vec3Math.setFromSpherical(length, theta, phi, out);
                    }
                }
                if (headingScaleFactor !== 1) {
                    phi !== null && phi !== void 0 ? phi : (phi = Vec3Math.phi(out));
                    const planeHeadingRad = -this.planeAngles[0];
                    const relativeHeadingAngle = ((MathUtils.HALF_PI - phi) - planeHeadingRad + Math.PI) % MathUtils.TWO_PI - Math.PI; // range -pi to +pi
                    if (relativeHeadingAngle !== 0) {
                        phi = MathUtils.HALF_PI - (relativeHeadingAngle * headingScaleFactor + planeHeadingRad);
                        theta !== null && theta !== void 0 ? theta : (theta = Vec3Math.theta(out));
                        Vec3Math.setFromSpherical(length, theta, phi, out);
                    }
                }
                // Rotate back to the original coordinate system.
                return Vec3Math.set(out[2], out[0], out[1], out);
            }
        }
        return Vec3Math.copy(vec, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isInProjectedBounds(point, arg2, arg3) {
        let bounds;
        if (point instanceof Float64Array) {
            bounds = arg2;
        }
        else {
            point = this.project(point, arg2, HorizonProjection.vec2Cache[0]);
            bounds = arg3;
        }
        const x = point[0];
        const y = point[1];
        if (!isFinite(x) || !isFinite(y)) {
            return false;
        }
        let left;
        let top;
        let right;
        let bottom;
        if (bounds) {
            left = bounds[0];
            top = bounds[1];
            right = bounds[2];
            bottom = bounds[3];
        }
        else {
            left = 0;
            top = 0;
            right = this.projectedSize[0];
            bottom = this.projectedSize[1];
        }
        return x >= left && x <= right && y >= top && y <= bottom;
    }
}
HorizonProjection.RECOMPUTE_MASK = ~(HorizonProjectionChangeType.PitchScaleFactor | HorizonProjectionChangeType.HeadingScaleFactor);
HorizonProjection.vec2Cache = [Vec2Math.create()];
HorizonProjection.vec3Cache = [Vec3Math.create()];
HorizonProjection.geoPointCache = [new GeoPoint(0, 0)];
HorizonProjection.relativeVec3Cache = [Vec3Math.create()];
HorizonProjection.cameraRelativeVec3Cache = [Vec3Math.create()];

/**
 * A canvas horizon layer whose size and position is synced with the horizon projection window.
 */
class HorizonSyncedCanvasLayer extends HorizonCanvasLayer {
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.projection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the horizon projected window.
     * @param projectedSize The size of the horizon projected window.
     */
    updateFromProjectedSize(projectedSize) {
        this.setWidth(projectedSize[0]);
        this.setHeight(projectedSize[1]);
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = '0px';
        displayCanvas.style.top = '0px';
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(projection.getProjectedSize());
        }
    }
}

/**
 * A component which displays an artificial horizon. A horizon tracks the position, altitude, heading, pitch, and roll
 * of an airplane and uses a persepctive projection to project points in space to a planar pixel grid. Each horizon
 * component maintains a {@link HorizonComponent} instance which handles the details of the projection.
 * {@link HorizonLayer} objects added to the horizon as children determine what is drawn in the horizon window.
 */
class HorizonComponent extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.layerEntries = [];
        this.lastUpdateTime = 0;
        this._isAwake = true;
        this.projectedSize = SubscribableUtils.toSubscribable(this.props.projectedSize, true);
        this.fov = SubscribableUtils.toSubscribable(this.props.fov, true);
        if (this.props.fovEndpoints !== undefined) {
            this.fovEndpoints = SubscribableUtils.toSubscribable(this.props.fovEndpoints, true);
        }
        if (this.props.projectedOffset !== undefined) {
            this.projectedOffset = SubscribableUtils.toSubscribable(this.props.projectedOffset, true);
        }
        const initialSize = this.projectedSize.get();
        const initialFov = this.fov.get();
        if (this.props.projection !== undefined) {
            this.props.projection.set({ projectedSize: initialSize, fov: initialFov });
        }
        this.projection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new HorizonProjection(initialSize[0], initialSize[1], initialFov);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize() {
        return this.projection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this horizon is awake.
     */
    get isAwake() {
        return this._isAwake;
    }
    /**
     * Puts this horizon to sleep. While asleep, this horizon will not be updated.
     */
    sleep() {
        this.setAwakeState(false);
    }
    /**
     * Wakes this horizon, allowing it to be updated.
     */
    wake() {
        this.setAwakeState(true);
    }
    /**
     * Sets this horizon's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this horizon's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
        if (this._isAwake === isAwake) {
            return;
        }
        this._isAwake = isAwake;
        this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        var _a, _b;
        this.projection.onChange(this.onProjectionChanged.bind(this));
        this.projectedSizeSub = this.projectedSize.sub(size => {
            this.projection.set({ projectedSize: size });
        }, true);
        this.fovSub = this.fov.sub(fov => {
            this.projection.set({ fov });
        }, true);
        this.fovEndpointsSub = (_a = this.fovEndpoints) === null || _a === void 0 ? void 0 : _a.sub(fovEndpoints => {
            this.projection.set({ fovEndpoints });
        }, true);
        this.projectedOffsetSub = (_b = this.projectedOffset) === null || _b === void 0 ? void 0 : _b.sub(projectedOffset => {
            this.projection.set({ projectedOffset });
        }, true);
        this.attachLayers(thisNode);
        if (!this._isAwake) {
            this.sleepLayers();
        }
    }
    /**
     * Scans this component's VNode sub-tree for HorizonLayer components and attaches them when found. Only the top-most
     * level of HorizonLayer components are attached; layers that are themselves children of other layers are not
     * attached.
     * @param thisNode This component's VNode.
     */
    attachLayers(thisNode) {
        FSComponent.visitNodes(thisNode, node => {
            if (node.instance instanceof HorizonLayer) {
                this.attachLayer(node.instance);
                return true;
            }
            return false;
        });
    }
    /**
     * This method is called when this horizon is awakened.
     */
    onWake() {
        this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this horizon's layers.
     */
    wakeLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onWake();
        }
    }
    /**
     * This method is called when this horizon is put to sleep.
     */
    onSleep() {
        this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this horizon's layers.
     */
    sleepLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onSleep();
        }
    }
    /**
     * This method is called when this horizon's projection changes.
     * @param projection This horizon's projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onProjectionChanged(projection, changeFlags);
        }
    }
    /**
     * This method is called when the size of this horizon's projected window changes.
     */
    onProjectedSizeChanged() {
        // noop
    }
    /**
     * Attaches a layer to this horizon component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
        if (this.layerEntries.findIndex(entry => entry.layer === layer) >= 0) {
            return;
        }
        const entry = new LayerEntry$1(layer);
        this.layerEntries.push(entry);
        entry.attach();
    }
    /**
     * Detaches a layer from this horizon component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    detachLayer(layer) {
        const index = this.layerEntries.findIndex(entry => entry.layer === layer);
        if (index >= 0) {
            const entry = this.layerEntries[index];
            entry.detach();
            this.layerEntries.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Updates this horizon.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (!this._isAwake) {
            return;
        }
        this.onUpdated(time, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
        this.updateLayers(time, elapsed);
    }
    /**
     * Updates this horizon's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateLayers(time, elapsed) {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].update(time);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.props.children));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d;
        super.destroy();
        (_a = this.projectedSizeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.fovSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.fovEndpointsSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.projectedOffsetSub) === null || _d === void 0 ? void 0 : _d.destroy();
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].destroy();
        }
    }
}
/**
 * An entry for a horizon layer.
 */
let LayerEntry$1 = class LayerEntry {
    /**
     * Constructor.
     * @param layer This entry's map layer.
     */
    constructor(layer) {
        this.layer = layer;
        this.updatePeriod = 0;
        this.lastUpdated = 0;
    }
    /**
     * Attaches this layer entry.
     */
    attach() {
        var _a, _b;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
            const clamped = Math.max(0, freq);
            this.updatePeriod = clamped === 0 ? 0 : 1000 / clamped;
        }, true);
        this.layer.onAttached();
    }
    /**
     * Updates this layer entry.
     * @param currentTime The current time as a UNIX timestamp.
     */
    update(currentTime) {
        if (currentTime - this.lastUpdated >= this.updatePeriod) {
            this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
            this.lastUpdated = currentTime;
        }
    }
    /**
     * Detaches this layer entry.
     */
    detach() {
        var _a;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.layer.onDetached();
    }
    /**
     * Destroys this layer entry. This will detach this entry's layer and destroy it.
     */
    destroy() {
        this.detach();
        this.layer.destroy();
    }
};

/**
 * A base component for map layers.
 */
class MapLayer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this._isVisible = true;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
        return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
        if (this._isVisible === val) {
            return;
        }
        this._isVisible = val;
        this.onVisibilityChanged(val);
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        // noop
    }
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached() {
        // noop
    }
}

/**
 * The different types of map projection changes.
 */
var MapProjectionChangeType;
(function (MapProjectionChangeType) {
    MapProjectionChangeType[MapProjectionChangeType["Target"] = 1] = "Target";
    MapProjectionChangeType[MapProjectionChangeType["Center"] = 2] = "Center";
    MapProjectionChangeType[MapProjectionChangeType["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType[MapProjectionChangeType["Range"] = 8] = "Range";
    MapProjectionChangeType[MapProjectionChangeType["RangeEndpoints"] = 16] = "RangeEndpoints";
    MapProjectionChangeType[MapProjectionChangeType["ScaleFactor"] = 32] = "ScaleFactor";
    MapProjectionChangeType[MapProjectionChangeType["Rotation"] = 64] = "Rotation";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedSize"] = 128] = "ProjectedSize";
    MapProjectionChangeType[MapProjectionChangeType["ProjectedResolution"] = 256] = "ProjectedResolution";
})(MapProjectionChangeType || (MapProjectionChangeType = {}));
/**
 * A geographic projection model for a map. MapProjection uses a mercator projection.
 */
class MapProjection {
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth, projectedHeight) {
        // settable parameters
        this.target = new GeoPoint(0, 0);
        this.targetProjectedOffset = new Float64Array(2);
        this.targetProjected = new Float64Array(2);
        this.range = 1; // great-arc radians
        this.rangeEndpoints = new Float64Array([0.5, 0, 0.5, 1]); // [relX1, relY1, relX2, relY2]
        this.projectedSize = new Float64Array(2);
        // computed parameters
        this.center = new GeoPoint(0, 0);
        this.centerProjected = new Float64Array(2);
        this.projectedRange = 0; // projected distance between the range endpoints in pixels
        this.widthRange = 0; // great-arc radians
        this.heightRange = 0; // great-arc radians
        this.oldParameters = {
            target: new GeoPoint(0, 0),
            center: new GeoPoint(0, 0),
            targetProjected: new Float64Array(2),
            range: 1,
            rangeEndpoints: new Float64Array(4),
            scaleFactor: 1,
            rotation: 0,
            projectedSize: new Float64Array(2),
            projectedResolution: 0
        };
        this.queuedParameters = Object.assign({}, this.oldParameters);
        this.updateQueued = false;
        this.changeListeners = [];
        Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
        this.geoProjection = new MercatorProjection();
        Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
        this.targetProjected.set(this.centerProjected);
        this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
        this.recompute();
    }
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns This map projection's GeoProjection instance.
     */
    getGeoProjection() {
        return this.geoProjection;
    }
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns The target geographic point of this projection.
     */
    getTarget() {
        return this.target.readonly;
    }
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns The projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset() {
        return this.targetProjectedOffset;
    }
    /**
     * Gets the projected location of the target of this projection.
     * @returns The projected location of the target of this projection.
     */
    getTargetProjected() {
        return this.targetProjected;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured between the projection's two range endpoints.
     * @returns The range of this projection, in great-arc radians.
     */
    getRange() {
        return this.range;
    }
    /**
     * Gets the endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     * @returns The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`.
     */
    getRangeEndpoints() {
        return this.rangeEndpoints;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the center-left to the center-right of
     * the projected window.
     * @returns The range of this projection's projected window width, in great-arc radians.
     */
    getWidthRange() {
        return this.widthRange;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the top-center to the bottom-center of
     * the projected window.
     * @returns The range of this projection's projected window height, in great-arc radians.
     */
    getHeightRange() {
        return this.heightRange;
    }
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor() {
        return this.geoProjection.getScaleFactor();
    }
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns The post-projected rotation angle of this projection.
     */
    getRotation() {
        return this.geoProjection.getPostRotation();
    }
    /**
     * Gets the size of the projected window, in pixels.
     * @returns The size of the projected window.
     */
    getProjectedSize() {
        return this.projectedSize;
    }
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns The geographic point located at the center of this projection's projected window.
     */
    getCenter() {
        return this.center.readonly;
    }
    /**
     * Gets the center of this projection's projected window.
     * @returns The center of this projection's projected window.
     */
    getCenterProjected() {
        return this.centerProjected;
    }
    /**
     * Gets the average resolution, in great-arc radians per pixel, of the projected map along a line between the range
     * endpoints.
     * @returns The average resolution of the projected map along a line between the range endpoints.
     */
    getProjectedResolution() {
        return this.range / this.projectedRange;
    }
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected The projected location of the hypothetical center point to use for the calculation.
     * @returns The true range of this projection given the hypothetical projected center point.
     */
    calculateRangeAtCenter(centerProjected) {
        const endpoints = this.rangeEndpoints;
        const projectedWidth = this.projectedSize[0];
        const projectedHeight = this.projectedSize[1];
        const endpoint1 = MapProjection.tempVec2_3;
        endpoint1[0] = centerProjected[0] + projectedWidth * (endpoints[0] - 0.5);
        endpoint1[1] = centerProjected[1] + projectedHeight * (endpoints[1] - 0.5);
        const endpoint2 = MapProjection.tempVec2_4;
        endpoint2[0] = centerProjected[0] + projectedWidth * (endpoints[2] - 0.5);
        endpoint2[1] = centerProjected[1] + projectedHeight * (endpoints[3] - 0.5);
        const top = this.geoProjection.invert(endpoint1, MapProjection.tempGeoPoint_1);
        const bottom = this.geoProjection.invert(endpoint2, MapProjection.tempGeoPoint_2);
        return top.distance(bottom);
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
        const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
        if (!isFinite(currentTargetProjected[0] + currentTargetProjected[1])) {
            // Check if we can potentially fix the geo projection by resetting its scale factor and center to defaults.
            const translation = this.geoProjection.getTranslation();
            if (isFinite(this.target.lat)
                && isFinite(this.target.lon)
                && isFinite(this.geoProjection.getPostRotation())
                && isFinite(translation[0])
                && isFinite(translation[1])) {
                this.geoProjection.setScaleFactor(MapProjection.DEFAULT_SCALE_FACTOR);
                this.geoProjection.setCenter(MapProjection.tempGeoPoint_1.set(0, 0));
                this.geoProjection.setPreRotation(Vec3Math.set(0, 0, 0, MapProjection.vec3Cache[0]));
            }
            else {
                return;
            }
        }
        const currentCenterProjected = MapProjection.tempVec2_2;
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        let ratio = currentRange / this.range;
        if (!isFinite(ratio) || ratio === 0) {
            return;
        }
        // iteratively find the appropriate scale factor (empiric testing shows this typically takes less than 4 iterations
        // to converge)
        let lastScaleFactor = this.geoProjection.getScaleFactor();
        let iterCount = 0;
        let ratioError = Math.abs(ratio - 1);
        let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
        while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER
            && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE
            && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
            this.geoProjection.setScaleFactor(ratio * lastScaleFactor);
            this.geoProjection.project(this.target, currentTargetProjected);
            currentCenterProjected.set(currentTargetProjected);
            currentCenterProjected[0] -= this.targetProjectedOffset[0];
            currentCenterProjected[1] -= this.targetProjectedOffset[1];
            currentRange = this.calculateRangeAtCenter(currentCenterProjected);
            const newRatio = currentRange / this.range;
            const ratioDelta = newRatio - ratio;
            // Check to see if the ratio between current range and target range is invalid, did not change, or changed in the
            // direction opposite to what we were expecting. If so, this means that our range measurements are close to the
            // poles and range no longer monotonically increases with decreasing scale factor and vice versa. If we continue
            // iteration, we will likely push our scale factor to 0 or infinity. Therefore, we halt immediately and settle
            // for using the scale factor before we applied the most recent correction.
            if (!isFinite(ratio)
                || ratio < 1 && ratioDelta <= 0
                || ratio > 1 && ratioDelta >= 0) {
                this.geoProjection.setScaleFactor(lastScaleFactor);
            }
            lastScaleFactor = this.geoProjection.getScaleFactor();
            ratio = newRatio;
            const newRatioError = Math.abs(ratio - 1);
            deltaRatioError = Math.abs(newRatioError - ratioError);
            ratioError = newRatioError;
        }
        // calculate the center point of the projection
        this.invert(currentCenterProjected, this.center);
        this.geoProjection.setCenter(this.center);
        // set the projection's pre-rotation to avoid anti-meridian wrapping issues
        const preRotation = Vec3Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, 0, MapProjection.vec3Cache[0]);
        this.geoProjection.setPreRotation(preRotation);
        const width = this.projectedSize[0];
        const height = this.projectedSize[1];
        this.projectedRange = Math.hypot((this.rangeEndpoints[2] - this.rangeEndpoints[0]) * width, (this.rangeEndpoints[3] - this.rangeEndpoints[1]) * height);
        const left = Vec2Math.set(0, height / 2, MapProjection.tempVec2_1);
        const right = Vec2Math.set(width, height / 2, MapProjection.tempVec2_2);
        this.widthRange = this.geoDistance(left, right);
        const top = Vec2Math.set(width / 2, 0, MapProjection.tempVec2_1);
        const bottom = Vec2Math.set(width / 2, height, MapProjection.tempVec2_2);
        this.heightRange = this.geoDistance(top, bottom);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
        // save old values
        this.storeParameters(this.oldParameters);
        parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
        parameters.target && this.target.set(parameters.target);
        parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
        parameters.range !== undefined && (this.range = parameters.range);
        parameters.rangeEndpoints && this.rangeEndpoints.set(parameters.rangeEndpoints);
        parameters.rotation !== undefined && this.geoProjection.setPostRotation(parameters.rotation);
        let changeFlags = this.computeChangeFlags(this.oldParameters);
        if (changeFlags !== 0) {
            this.recompute();
            changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
            if (changeFlags !== 0) {
                this.notifyChangeListeners(changeFlags);
            }
        }
    }
    /**
     * Sets the projection parameters to be applied when applyQueued() is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters) {
        Object.assign(this.queuedParameters, parameters);
        this.updateQueued = true;
    }
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued() {
        if (this.updateQueued) {
            this.updateQueued = false;
            this.set(this.queuedParameters);
            for (const key in this.queuedParameters) {
                delete this.queuedParameters[key];
            }
        }
    }
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    setProjectedSize(size) {
        this.projectedSize.set(size);
        Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
        this.geoProjection.setTranslation(this.centerProjected);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    setTargetProjectedOffset(offset) {
        this.targetProjectedOffset.set(offset);
        Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
        record.target.set(this.target);
        record.center.set(this.center);
        record.targetProjected.set(this.targetProjected);
        record.range = this.range;
        record.rangeEndpoints.set(this.rangeEndpoints);
        record.scaleFactor = this.geoProjection.getScaleFactor();
        record.rotation = this.getRotation();
        record.projectedSize.set(this.projectedSize);
        record.projectedResolution = this.getProjectedResolution();
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
        return (oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target)
            | (Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected)
            | (oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range)
            | (VecNMath.equals(oldParameters.rangeEndpoints, this.rangeEndpoints) ? 0 : MapProjectionChangeType.RangeEndpoints)
            | (oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation)
            | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize);
    }
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    computeDerivedChangeFlags(oldParameters) {
        return (oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center)
            | (oldParameters.scaleFactor === this.geoProjection.getScaleFactor() ? 0 : MapProjectionChangeType.ScaleFactor)
            | (oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point, out) {
        return this.geoProjection.project(point, out);
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns The inverted point.
     */
    invert(vec, out) {
        return this.geoProjection.invert(vec, out);
    }
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point The point to check.
     * @param bounds The bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point, bounds) {
        let left;
        let top;
        let right;
        let bottom;
        if (bounds) {
            left = bounds[0];
            top = bounds[1];
            right = bounds[2];
            bottom = bounds[3];
        }
        else {
            left = 0;
            top = 0;
            right = this.projectedSize[0];
            bottom = this.projectedSize[1];
        }
        if (!(point instanceof Float64Array)) {
            point = this.project(point, MapProjection.tempVec2_2);
        }
        const x = point[0];
        const y = point[1];
        return x >= left && x <= right && y >= top && y <= bottom;
    }
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The geographic great-circle distance between the points.
     */
    geoDistance(point1, point2) {
        if (point1 instanceof Float64Array) {
            point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
        }
        if (point2 instanceof Float64Array) {
            point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
        }
        return point1.distance(point2);
    }
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The projected Euclidean distance between two points.
     */
    projectedDistance(point1, point2) {
        if (!(point1 instanceof Float64Array)) {
            point1 = this.project(point1, MapProjection.tempVec2_1);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = this.project(point2, MapProjection.tempVec2_2);
        }
        return Vec2Math.distance(point1, point2);
    }
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    notifyChangeListeners(changeFlags) {
        for (let i = 0; i < this.changeListeners.length; i++) {
            this.changeListeners[i](this, changeFlags);
        }
    }
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to register.
     */
    addChangeListener(listener) {
        this.changeListeners.push(listener);
    }
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener The listener to remove.
     * @returns Whether the listener was successfully removed.
     */
    removeChangeListener(listener) {
        const index = this.changeListeners.lastIndexOf(listener);
        if (index >= 0) {
            this.changeListeners.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
}
MapProjection.DEFAULT_SCALE_FACTOR = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
MapProjection.SCALE_FACTOR_MAX_ITER = 20;
MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
MapProjection.tempVec2_1 = new Float64Array(2);
MapProjection.tempVec2_2 = new Float64Array(2);
MapProjection.tempVec2_3 = new Float64Array(2);
MapProjection.tempVec2_4 = new Float64Array(2);
MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);
MapProjection.vec3Cache = [Vec3Math.create()];

/**
 * A component which displays a map. A map projects geographic coordinates onto a planar pixel grid. Each map component
 * maintains a MapProjection instance which handles the details of the projection. MapLayer objects added to the map
 * as children determine what is drawn on the map.
 */
class MapComponent extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.layerEntries = [];
        this.lastUpdateTime = 0;
        this._isAwake = true;
        this.updateCycleHandler = this.update.bind(this);
        this.projectedSize = 'isSubscribable' in this.props.projectedSize ? this.props.projectedSize : Subject.create(this.props.projectedSize);
        const initialSize = this.projectedSize.get();
        if (this.props.projection !== undefined) {
            this.props.projection.set({ projectedSize: new Float64Array(initialSize) });
        }
        this.mapProjection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new MapProjection(initialSize[0], initialSize[1]);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize() {
        return this.mapProjection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this map is awake.
     */
    get isAwake() {
        return this._isAwake;
    }
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep() {
        this.setAwakeState(false);
    }
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake() {
        this.setAwakeState(true);
    }
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
        if (this._isAwake === isAwake) {
            return;
        }
        this._isAwake = isAwake;
        this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        var _a;
        this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
        this.projectedSizeSub = this.projectedSize.sub(size => {
            this.mapProjection.set({ projectedSize: size });
        });
        (_a = this.props.updateFreq) === null || _a === void 0 ? void 0 : _a.sub(freq => {
            var _a;
            (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.updateCycleSub = this.props.bus.getSubscriber()
                .on('realTime')
                .whenChanged()
                .atFrequency(freq)
                .handle(this.updateCycleHandler);
        }, true);
        this.attachLayers(thisNode);
    }
    /**
     * Scans this component's VNode sub-tree for MapLayer components and attaches them when found. Only the top-most
     * level of MapLayer components are attached; layers that are themselves children of other layers are not attached.
     * @param thisNode This component's VNode.
     */
    attachLayers(thisNode) {
        FSComponent.visitNodes(thisNode, node => {
            if (node.instance instanceof MapLayer) {
                this.attachLayer(node.instance);
                return true;
            }
            return false;
        });
    }
    /**
     * This method is called when the map is awakened.
     */
    onWake() {
        this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this map's layers.
     */
    wakeLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onWake();
        }
    }
    /**
     * This method is called when the map is put to sleep.
     */
    onSleep() {
        this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this map's layers.
     */
    sleepLayers() {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onSleep();
        }
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.onProjectedSizeChanged();
        }
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].layer.onMapProjectionChanged(mapProjection, changeFlags);
        }
    }
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
        if (this.layerEntries.findIndex(entry => entry.layer === layer) >= 0) {
            return;
        }
        const entry = new LayerEntry(layer);
        this.layerEntries.push(entry);
        entry.attach();
    }
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    detachLayer(layer) {
        const index = this.layerEntries.findIndex(entry => entry.layer === layer);
        if (index >= 0) {
            const entry = this.layerEntries[index];
            entry.detach();
            this.layerEntries.splice(index, 1);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Updates this map.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (!this._isAwake) {
            return;
        }
        this.onUpdated(time, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
        this.updateLayers(time, elapsed);
    }
    /**
     * Updates this map's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateLayers(time, elapsed) {
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].update(time);
        }
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.projectedSizeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        const len = this.layerEntries.length;
        for (let i = 0; i < len; i++) {
            this.layerEntries[i].destroy();
        }
    }
}
/**
 * An entry for a map layer.
 */
class LayerEntry {
    /**
     * Constructor.
     * @param layer This entry's map layer.
     */
    constructor(layer) {
        this.layer = layer;
        this.updatePeriod = 0;
        this.lastUpdated = 0;
    }
    /**
     * Attaches this layer entry.
     */
    attach() {
        var _a, _b;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
            const clamped = Math.max(0, freq);
            this.updatePeriod = clamped === 0 ? 0 : 1000 / clamped;
        }, true);
        this.layer.onAttached();
    }
    /**
     * Updates this layer entry.
     * @param currentTime The current time as a UNIX timestamp.
     */
    update(currentTime) {
        if (currentTime - this.lastUpdated >= this.updatePeriod) {
            this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
            this.lastUpdated = currentTime;
        }
    }
    /**
     * Detaches this layer entry.
     */
    detach() {
        var _a;
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.layer.onDetached();
    }
    /**
     * Destroys this layer entry. This will detach this entry's layer and destroy it.
     */
    destroy() {
        this.detach();
        this.layer.destroy();
    }
}

/**
 * A model for maps. Specific functionality is added by adding one or more modules to the model. Each module added to
 * the model is assigned a name which is used to retrieve it from the model.
 */
class MapModel {
    constructor() {
        this.modules = new Map();
    }
    /**
     * Gets a module instance from the model and assigns it
     * to the provided type.
     * @param nameOrModule The module to get or the name of the module.
     * @returns The requested map data module.
     * @throws An error if
     */
    getModule(nameOrModule) {
        if (typeof nameOrModule === 'string') {
            return this.modules.get(nameOrModule);
        }
        else if (typeof nameOrModule === 'function') {
            return this.modules.get(nameOrModule.name);
        }
        throw new Error('Invalid type supplied: must be a string key or a module constructor.');
    }
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule(name, module) {
        if (this.modules.has(name)) {
            return;
        }
        this.modules.set(name, module);
    }
}

/**
 * An abstract implementation of a map text label.
 */
class AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this.text = SubscribableUtils.toSubscribable(text, true);
        this.priority = SubscribableUtils.toSubscribable(priority, true);
        this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
        this.font = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.font) !== null && _b !== void 0 ? _b : '', true);
        this.fontSize = SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _c !== void 0 ? _c : 10, true);
        this.fontStr = MappedSubject.create(([s, f]) => {
            return `${s}px ${f}`;
        }, this.fontSize, this.font);
        this.fontColor = SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _d !== void 0 ? _d : 'white', true);
        this.fontOutlineWidth = SubscribableUtils.toSubscribable((_e = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _e !== void 0 ? _e : 0, true);
        this.fontOutlineColor = SubscribableUtils.toSubscribable((_f = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _f !== void 0 ? _f : 'black', true);
        this.showBg = SubscribableUtils.toSubscribable((_g = options === null || options === void 0 ? void 0 : options.showBg) !== null && _g !== void 0 ? _g : false, true);
        this.bgColor = SubscribableUtils.toSubscribable((_h = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _h !== void 0 ? _h : 'black', true);
        this.bgPadding = SubscribableUtils.toSubscribable((_j = options === null || options === void 0 ? void 0 : options.bgPadding) !== null && _j !== void 0 ? _j : VecNMath.create(4), true);
        this.bgBorderRadius = SubscribableUtils.toSubscribable((_k = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _k !== void 0 ? _k : 0, true);
        this.bgOutlineWidth = SubscribableUtils.toSubscribable((_l = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _l !== void 0 ? _l : 0, true);
        this.bgOutlineColor = SubscribableUtils.toSubscribable((_m = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _m !== void 0 ? _m : 'white', true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
        if (this.fontSize.get() !== 0) {
            this.setTextStyle(context);
            const width = context.measureText(this.text.get()).width;
            const height = this.fontSize.get();
            const showBg = this.showBg.get();
            const bgPadding = this.bgPadding.get();
            const bgOutlineWidth = this.bgOutlineWidth.get();
            const bgExtraWidth = showBg ? bgPadding[1] + bgPadding[3] + bgOutlineWidth * 2 : 0;
            const bgExtraHeight = showBg ? bgPadding[0] + bgPadding[2] + bgOutlineWidth * 2 : 0;
            const anchor = this.anchor.get();
            const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
            const centerX = pos[0] - (anchor[0] - 0.5) * (width + bgExtraWidth);
            const centerY = pos[1] - (anchor[1] - 0.5) * (height + bgExtraHeight);
            if (showBg) {
                this.drawBackground(context, centerX, centerY, width, height);
            }
            this.drawText(context, centerX, centerY);
        }
    }
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    setTextStyle(context) {
        context.font = this.fontStr.get();
        context.textBaseline = 'middle';
        context.textAlign = 'center';
    }
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    drawText(context, centerX, centerY) {
        const text = this.text.get();
        const fontOutlineWidth = this.fontOutlineWidth.get();
        if (fontOutlineWidth > 0) {
            context.lineWidth = fontOutlineWidth * 2;
            context.strokeStyle = this.fontOutlineColor.get();
            context.strokeText(text, centerX, centerY);
        }
        context.fillStyle = this.fontColor.get();
        context.fillText(text, centerX, centerY);
    }
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    drawBackground(context, centerX, centerY, width, height) {
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        const bgBorderRadius = this.bgBorderRadius.get();
        const backgroundLeft = centerX - width / 2 - (bgPadding[3] + bgOutlineWidth);
        const backgroundTop = centerY - height / 2 - (bgPadding[0] + bgOutlineWidth);
        const backgroundWidth = width + (bgPadding[1] + bgPadding[3] + 2 * bgOutlineWidth);
        const backgroundHeight = height + (bgPadding[0] + bgPadding[2] + 2 * bgOutlineWidth);
        let isRounded = false;
        if (bgBorderRadius > 0) {
            isRounded = true;
            this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, bgBorderRadius);
        }
        if (bgOutlineWidth > 0) {
            context.lineWidth = bgOutlineWidth * 2;
            context.strokeStyle = this.bgOutlineColor.get();
            if (isRounded) {
                context.stroke();
            }
            else {
                context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
            }
        }
        context.fillStyle = this.bgColor.get();
        if (isRounded) {
            context.fill();
        }
        else {
            context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
    }
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    loadBackgroundPath(context, left, top, width, height, radius) {
        const right = left + width;
        const bottom = top + height;
        context.beginPath();
        context.moveTo(left + radius, top);
        context.lineTo(right - radius, top);
        context.arcTo(right, top, right, top + radius, radius);
        context.lineTo(right, bottom - radius);
        context.arcTo(right, bottom, right - radius, bottom, radius);
        context.lineTo(left + radius, bottom);
        context.arcTo(left, bottom, left, bottom - radius, radius);
        context.lineTo(left, top + radius);
        context.arcTo(left, top, left + radius, top, radius);
    }
}
AbstractMapTextLabel.tempVec2 = new Float64Array(2);
/**
 * A text label associated with a specific geographic location.
 */
class MapLocationTextLabel extends AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, options) {
        var _a;
        super(text, priority, options);
        this.location = SubscribableUtils.toSubscribable(location, true);
        this.offset = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
    }
    /** @inheritdoc */
    getPosition(mapProjection, out) {
        mapProjection.project(this.location.get(), out);
        Vec2Math.add(out, this.offset.get(), out);
        return out;
    }
}

/**
 * A cullable (hides labels that collide with other labels) text label associated with a specific geographic location.
 */
class MapCullableLocationTextLabel extends MapLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param alwaysShow Whether this label is immune to culling, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, alwaysShow, options) {
        super(text, priority, location, options);
        /** @inheritdoc */
        this.bounds = new Float64Array(4);
        /** @inheritdoc */
        this.invalidation = new SubEvent();
        this.subs = [];
        this.alwaysShow = SubscribableUtils.toSubscribable(alwaysShow, true);
        this.subs.push(this.priority.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.alwaysShow.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.location.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.text.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.fontSize.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.anchor.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.offset.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.bgPadding.sub(() => { this.invalidation.notify(this); }));
        this.subs.push(this.bgOutlineWidth.sub(() => { this.invalidation.notify(this); }));
    }
    /** @inheritdoc */
    updateBounds(mapProjection) {
        const fontSize = this.fontSize.get();
        const anchor = this.anchor.get();
        const width = 0.6 * fontSize * this.text.get().length;
        const height = fontSize;
        const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
        let left = pos[0] - anchor[0] * width;
        let right = left + width;
        let top = pos[1] - anchor[1] * height;
        let bottom = top + height;
        if (this.showBg.get()) {
            const bgPadding = this.bgPadding.get();
            const bgOutlineWidth = this.bgOutlineWidth.get();
            left -= (bgPadding[3] + bgOutlineWidth);
            right += (bgPadding[1] + bgOutlineWidth);
            top -= (bgPadding[0] + bgOutlineWidth);
            bottom += (bgPadding[2] + bgOutlineWidth);
        }
        this.bounds[0] = left;
        this.bounds[1] = top;
        this.bounds[2] = right;
        this.bounds[3] = bottom;
    }
    /**
     * Destroys this label.
     */
    destroy() {
        for (const sub of this.subs) {
            sub.destroy();
        }
    }
}
/**
 * Manages a set of MapCullableTextLabels. Colliding labels will be culled based on their render priority. Labels with
 * lower priorities will be culled before labels with higher priorities.
 */
class MapCullableTextLabelManager {
    /**
     * Creates an instance of the MapCullableTextLabelManager.
     * @param cullingEnabled Whether or not culling of labels is enabled.
     */
    constructor(cullingEnabled = true) {
        this.cullingEnabled = cullingEnabled;
        this.registered = new Map();
        this._visibleLabels = [];
        this.needUpdate = false;
        this.lastScaleFactor = 1;
        this.lastRotation = 0;
        this.invalidationHandler = () => { this.needUpdate = true; };
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels() {
        return this._visibleLabels;
    }
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label) {
        if (this.registered.has(label)) {
            return;
        }
        this.registered.set(label, label.invalidation.on(this.invalidationHandler));
        this.needUpdate = true;
    }
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label) {
        const sub = this.registered.get(label);
        if (sub === undefined) {
            return;
        }
        sub.destroy();
        this.registered.delete(label);
        this.needUpdate = true;
    }
    /**
     * Sets whether or not text label culling is enabled.
     * @param enabled Whether or not culling is enabled.
     */
    setCullingEnabled(enabled) {
        this.cullingEnabled = enabled;
        this.needUpdate = true;
    }
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection) {
        if (!this.needUpdate) {
            const scaleFactorRatio = mapProjection.getScaleFactor() / this.lastScaleFactor;
            if (scaleFactorRatio < MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD && scaleFactorRatio > 1 / MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD) {
                const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
                if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
                    return;
                }
            }
        }
        const labelArray = Array.from(this.registered.keys())
            .sort(MapCullableTextLabelManager.SORT_FUNC);
        if (this.cullingEnabled) {
            this._visibleLabels = [];
            const len = labelArray.length;
            for (let i = 0; i < len; i++) {
                labelArray[i].updateBounds(mapProjection);
            }
            const collisionArray = [];
            for (let i = 0; i < len; i++) {
                const label = labelArray[i];
                let show = true;
                if (!label.alwaysShow.get()) {
                    const len2 = collisionArray.length;
                    for (let j = 0; j < len2; j++) {
                        const other = collisionArray[j];
                        if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                            show = false;
                            break;
                        }
                    }
                }
                if (show) {
                    collisionArray.push(label.bounds);
                    this._visibleLabels.push(label);
                }
            }
        }
        else {
            this._visibleLabels = labelArray;
        }
        this.lastScaleFactor = mapProjection.getScaleFactor();
        this.lastRotation = mapProjection.getRotation();
        this.needUpdate = false;
    }
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    static doesCollide(a, b) {
        return a[0] < b[2]
            && a[2] > b[0]
            && a[1] < b[3]
            && a[3] > b[1];
    }
}
MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD = 1.2;
MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;
MapCullableTextLabelManager.SORT_FUNC = (a, b) => {
    const alwaysShowA = a.alwaysShow.get();
    const alwaysShowB = b.alwaysShow.get();
    if (alwaysShowA && !alwaysShowB) {
        return -1;
    }
    else if (alwaysShowB && !alwaysShowA) {
        return 1;
    }
    else {
        return b.priority.get() - a.priority.get();
    }
};

/**
 * An abstract implementation of MapWaypointIcon which supports an arbitrary anchor point and offset.
 */
class AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon, or a subscribable which provides it. Icons with higher
     * priorities should be rendered above those with lower priorities.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, size, options) {
        var _a, _b;
        this.waypoint = waypoint;
        this.priority = SubscribableUtils.toSubscribable(priority, true);
        this.size = SubscribableUtils.toSubscribable(size, true);
        this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(0.5, 0.5), true);
        this.offset = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.offset) !== null && _b !== void 0 ? _b : Vec2Math.create(), true);
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const size = this.size.get();
        const offset = this.offset.get();
        const anchor = this.anchor.get();
        const projected = mapProjection.project(this.waypoint.location.get(), MapWaypointImageIcon.tempVec2);
        const left = projected[0] + offset[0] - anchor[0] * size[0];
        const top = projected[1] + offset[1] - anchor[1] * size[1];
        this.drawIconAt(context, mapProjection, left, top);
    }
}
AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
/**
 * A waypoint icon with an image as the icon's graphic source.
 */
class MapWaypointImageIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, size, options) {
        super(waypoint, priority, size, options);
        this.img = img;
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, left, top) {
        const size = this.size.get();
        context.drawImage(this.img, left, top, size[0], size[1]);
    }
}

/**
 * A renderer that draws waypoints to a map. For the renderer to draw a waypoint, the waypoint must first be registered
 * with the renderer. Waypoints may be registered under multiple render roles. Each render role is represented as a bit
 * flag. During each render cycle, a specific role is chosen for each waypoint by a selector function. Once the role is
 * chosen, the waypoint will be rendered in that role.
 */
class MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     * @param selectRoleToRender A function which selects roles under which to render waypoints. Defaults to
     * {@link MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR}.
     */
    constructor(textManager, selectRoleToRender = MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR) {
        this.textManager = textManager;
        this.selectRoleToRender = selectRoleToRender;
        this.registered = new Map();
        this.toCleanUp = new Set();
        /**
         * This renderer's render role definitions. Waypoints assigned to be rendered under a role or combination of roles
         * with no definition will not be rendered.
         */
        this.roleDefinitions = new Map();
        /**
         * An event to subscribe to, fired when waypoints are added to the renderer.
         */
        this.onWaypointAdded = new SubEvent();
        /**
         * An event to subscribe to, fired when waypoints are removed from the render.
         */
        this.onWaypointRemoved = new SubEvent();
    }
    /**
     * Checks whether a render role has been added to this renderer.
     * @param role The render role to check.
     * @returns Whether the render role has been added to this renderer.
     */
    hasRenderRole(role) {
        return this.roleDefinitions.has(role);
    }
    /**
     * Adds a render role to this renderer. If the role has already been added to this renderer, this method does
     * nothing.
     * @param role The render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @returns Whether the render role was successfully added.
     */
    addRenderRole(role, def) {
        if (this.roleDefinitions.has(role)) {
            return false;
        }
        this.roleDefinitions.set(role, Object.assign({}, def !== null && def !== void 0 ? def : MapWaypointRenderer.NULL_ROLE_DEF));
        return true;
    }
    /**
     * Removes a render role from this renderer.
     * @param role The render role to remove.
     * @returns Whether the render role was successfully removed.
     */
    removeRenderRole(role) {
        return this.roleDefinitions.delete(role);
    }
    /**
     * Gets the definition for a render role.
     * @param role A render role.
     * @returns The definition for the specified render role, or undefined if no such role has been added to this
     * renderer.
     */
    getRenderRoleDefinition(role) {
        return this.roleDefinitions.get(role);
    }
    /**
     * Gets an iterable of render roles added to this renderer. The iterable will return the roles in the order in which
     * they were added.
     * @returns An iterable of render roles added to this renderer.
     */
    renderRoles() {
        return this.roleDefinitions.keys();
    }
    /**
     * Removes all render roles from this renderer.
     */
    clearRenderRoles() {
        this.roleDefinitions.clear();
    }
    /**
     * Sets the factory to use to create waypoint icons for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     * @returns Whether the factory was set.
     */
    setIconFactory(role, factory) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.iconFactory = factory;
        return true;
    }
    /**
     * Sets the factory to use to create waypoint labels for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint label factory.
     * @returns Whether the factory was set.
     */
    setLabelFactory(role, factory) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.labelFactory = factory;
        return true;
    }
    /**
     * Sets the canvas rendering context for a render role. If the render role has not been added to this renderer, this
     * method does nothing.
     * @param role A render role.
     * @param context A canvas 2D rendering context.
     * @returns Whether the context was set.
     */
    setCanvasContext(role, context) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.canvasContext = context;
        return true;
    }
    /**
     * Sets the handler that determines if a waypoint should visible for a render role. If the render role has not been
     * added to this renderer, this method does nothing.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     * @returns Whether the handler was set.
     */
    setVisibilityHandler(role, handler) {
        const roleDef = this.roleDefinitions.get(role);
        if (!roleDef) {
            return false;
        }
        roleDef.visibilityHandler = handler;
        return true;
    }
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint, role) {
        if (!waypoint) {
            return false;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return false;
        }
        if (role === undefined) {
            return true;
        }
        return entry.isAllRoles(role);
    }
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        let entry = this.registered.get(waypoint.uid);
        if (!entry) {
            entry = new MapWaypointRendererEntry(waypoint, this.textManager, this.roleDefinitions, this.selectRoleToRender);
            this.registered.set(waypoint.uid, entry);
            this.onWaypointAdded.notify(this, waypoint);
        }
        entry.addRole(role, sourceId);
    }
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint, role, sourceId) {
        if (role === 0 || sourceId === '') {
            return;
        }
        const entry = this.registered.get(waypoint.uid);
        if (!entry) {
            return;
        }
        entry.removeRole(role, sourceId);
        if (entry.roles === 0) {
            this.deleteEntry(entry);
            this.onWaypointRemoved.notify(this, waypoint);
        }
    }
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    deleteEntry(entry) {
        this.registered.delete(entry.waypoint.uid);
        this.toCleanUp.add(entry);
    }
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection) {
        var _a;
        this.toCleanUp.forEach(entry => {
            entry.destroy();
        });
        this.toCleanUp.clear();
        const entriesToDrawIcon = [];
        this.registered.forEach(entry => {
            entry.update();
            if (entry.icon) {
                entriesToDrawIcon.push(entry);
            }
        });
        const projectedSize = mapProjection.getProjectedSize();
        for (const roleDef of this.roleDefinitions.values()) {
            const context = roleDef.canvasContext;
            if (context) {
                context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
            }
        }
        entriesToDrawIcon.sort(MapWaypointRenderer.ENTRY_SORT_FUNC);
        const len2 = entriesToDrawIcon.length;
        for (let i = 0; i < len2; i++) {
            const entry = entriesToDrawIcon[i];
            const icon = entry.icon;
            const context = (_a = this.roleDefinitions.get(entry.lastRenderedRole)) === null || _a === void 0 ? void 0 : _a.canvasContext;
            if (context) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                icon.draw(context, mapProjection);
            }
        }
    }
    /**
     * Gets the nearest waypoint currently registered in the renderer.
     * @param pos The position to get the closest waypoint to.
     * @param first A predicate that will search the list of closest waypoints for a match, and return the first one found.
     * @returns The nearest waypoint, or undefined if none found.
     */
    getNearestWaypoint(pos, first) {
        var _a, _b;
        const ordered = [...this.registered.values()].sort((a, b) => this.orderByDistance(a.waypoint, b.waypoint, pos))
            .filter(w => {
            const roleDef = this.getRenderRoleDefinition(w.lastRenderedRole);
            if (roleDef !== undefined) {
                return roleDef.visibilityHandler(w.waypoint);
            }
            return false;
        });
        if (first !== undefined) {
            return (_a = ordered.find(entry => first(entry.waypoint))) === null || _a === void 0 ? void 0 : _a.waypoint;
        }
        return (_b = ordered[0]) === null || _b === void 0 ? void 0 : _b.waypoint;
    }
    /**
     * Orders waypoints by their distance to the plane PPOS.
     * @param a The first waypoint.
     * @param b The second waypoint.
     * @param pos The position to compare against.
     * @returns The comparison order number.
     */
    orderByDistance(a, b, pos) {
        const aDist = a.location.get().distance(pos);
        const bDist = b.location.get().distance(pos);
        return aDist - bDist;
    }
}
/** A null render role definition. Icons rendered under this role are never visible. */
MapWaypointRenderer.NULL_ROLE_DEF = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
};
/**
 * Sorts waypoint entries such that those with icons of higher priority are sorted after those with icons of lower
 * priority.
 * @param a The first waypoint entry to sort.
 * @param b The second waypoint entry to sort.
 * @returns A negative number if the first entry is to be sorted before the second, a positive number if the second
 * entry is to be sorted before the first, and zero if the entries' relative sorting order does not matter.
 */
MapWaypointRenderer.ENTRY_SORT_FUNC = (a, b) => {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return a.icon.priority.get() - b.icon.priority.get();
};
/**
 * The default render role selector. For each waypoint entry, iterates through all possible render roles in the order
 * they were originally added to the renderer and selects the first role under which the entry is registered and is
 * visible.
 * @param entry A waypoint entry.
 * @param roleDefinitions A map from all possible render roles to their definitions.
 * @returns The role under which the waypoint entry should be rendered, or 0 if the entry should not be rendered
 * under any role.
 */
MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR = (entry, roleDefinitions) => {
    for (const role of roleDefinitions.keys()) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (entry.isAllRoles(role) && roleDefinitions.get(role).visibilityHandler(entry.waypoint)) {
            return role;
        }
    }
    return 0;
};
/**
 * An entry for a waypoint registered with {@link MapWaypointRenderer}.
 */
class MapWaypointRendererEntry {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this entry.
     * @param textManager The text manager to which to register this entry's labels.
     * @param roleDefinitions A map of all valid render roles to their definitions.
     * @param selectRoleToRender A function to use to select roles under which to render this entry.
     */
    constructor(waypoint, textManager, roleDefinitions, selectRoleToRender) {
        this.waypoint = waypoint;
        this.textManager = textManager;
        this.roleDefinitions = roleDefinitions;
        this.selectRoleToRender = selectRoleToRender;
        this.registrations = {};
        this._roles = 0;
        this._icon = null;
        this._label = null;
        this._lastRenderedRole = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The render role(s) assigned to this entry. */
    get roles() {
        return this._roles;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastRenderedRole() {
        return this._lastRenderedRole;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint icon. */
    get icon() {
        return this._icon;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint label. */
    get label() {
        return this._label;
    }
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAny(toCompare, roles);
    }
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return toCompare === roles;
    }
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles, useLastRendered = false) {
        let toCompare;
        if (useLastRendered) {
            toCompare = this.lastRenderedRole;
        }
        else {
            toCompare = this.roles;
        }
        return BitFlags.isAll(toCompare, roles);
    }
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            var _a;
            var _b, _c;
            ((_a = (_b = this.registrations)[_c = 1 << index]) !== null && _a !== void 0 ? _a : (_b[_c] = new Set())).add(sourceId);
        }, true);
        this._roles = this._roles | roles;
    }
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles, sourceId) {
        BitFlags.forEach(roles, (value, index) => {
            const role = 1 << index;
            const registrations = this.registrations[role];
            if (registrations) {
                registrations.delete(sourceId);
                if (registrations.size === 0) {
                    this._roles = this._roles & ~role;
                }
            }
        }, true);
    }
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    prepareRender(showRole, iconFactory, labelFactory) {
        var _a, _b;
        if (showRole === this._lastRenderedRole) {
            return;
        }
        this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(showRole, this.waypoint)) !== null && _a !== void 0 ? _a : null;
        const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(showRole, this.waypoint)) !== null && _b !== void 0 ? _b : null;
        if (this._label && this._label !== label) {
            this.textManager.deregister(this._label);
        }
        if (label && label !== this._label) {
            this.textManager.register(label);
        }
        this._label = label;
        this._lastRenderedRole = showRole;
    }
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     */
    update() {
        var _a, _b;
        const showRole = this.selectRoleToRender(this, this.roleDefinitions);
        const roleDef = this.roleDefinitions.get(showRole);
        const iconFactory = (_a = roleDef === null || roleDef === void 0 ? void 0 : roleDef.iconFactory) !== null && _a !== void 0 ? _a : null;
        const labelFactory = (_b = roleDef === null || roleDef === void 0 ? void 0 : roleDef.labelFactory) !== null && _b !== void 0 ? _b : null;
        this.prepareRender(showRole, iconFactory, labelFactory);
    }
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy() {
        if (this._label) {
            this.textManager.deregister(this._label);
        }
    }
}

/**
 * A path stream which does nothing on any input.
 */
class NullPathStream {
    /**
     * Does nothing.
     */
    beginPath() {
        // noop
    }
    /**
     * Does nothing.
     */
    moveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    lineTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    bezierCurveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    quadraticCurveTo() {
        // noop
    }
    /**
     * Does nothing.
     */
    arc() {
        // noop
    }
    /**
     * Does nothing.
     */
    closePath() {
        // noop
    }
}
/** An instance of a {@link NullPathStream}. */
NullPathStream.INSTANCE = new NullPathStream();
/**
 * An abstract implementation of a path stream which sends a transformed version of its input to be consumed by another
 * stream.
 */
class AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     */
    constructor(consumer) {
        this.consumer = consumer;
    }
    /** @inheritdoc */
    getConsumer() {
        return this.consumer;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        this.consumer = consumer;
    }
}

/**
 * Bitflags describing the relative location of a point with respect to a rectangular bounding box.
 */
var Outcode;
(function (Outcode) {
    Outcode[Outcode["Inside"] = 0] = "Inside";
    Outcode[Outcode["Left"] = 1] = "Left";
    Outcode[Outcode["Top"] = 2] = "Top";
    Outcode[Outcode["Right"] = 4] = "Right";
    Outcode[Outcode["Bottom"] = 8] = "Bottom";
})(Outcode || (Outcode = {}));
/**
 * A path stream which performs clipping to an axis-aligned rectangular bounding box before sending the clipped path
 * to another stream. Clipping is only supported for path segments added via the `lineTo()` and `arc()` methods. Path
 * segments added via `bezierCurveTo()` and `quadraticCurveTo()` will be passed to the consumer stream unclipped.
 */
class ClippedPathStream extends AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param bounds A subscribable which provides the clipping bounds for this stream, as `[left, top, right, bottom]`.
     * Whenever the clipping bounds change, the state of this stream will be reset, as if `beginPath()` were called.
     */
    constructor(consumer, bounds) {
        super(consumer);
        this.bounds = bounds;
        this.boundsLines = [
            new Float64Array(3),
            new Float64Array(3),
            new Float64Array(3),
            new Float64Array(3)
        ];
        this.isBoundingRectNonZero = false;
        this.firstPoint = new Float64Array([NaN, NaN]);
        this.prevPoint = new Float64Array([NaN, NaN]);
        this.prevPointOutcode = 0;
        this.boundsSub = bounds.sub(this.onBoundsChanged.bind(this), true);
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
        this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
            return;
        }
        if (isNaN(this.firstPoint[0])) {
            Vec2Math.set(x, y, this.firstPoint);
        }
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
        if (this.prevPointOutcode === 0) {
            this.consumer.moveTo(x, y);
        }
    }
    /** @inheritdoc */
    lineTo(x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        const outcode = this.getOutcode(x, y);
        if ((this.prevPointOutcode | outcode) === 0) {
            // Both the previous point and current point are within bounds.
            this.consumer.lineTo(x, y);
        }
        else if ((this.prevPointOutcode & outcode) === 0) {
            // One or both of the previous point and current point are out of bounds, and the line connecting them may
            // cross through the bounding rect
            const bounds = this.bounds.get();
            const line = ClippedPathStream.getLineCoordinates(this.prevPoint[0], this.prevPoint[1], x, y, ClippedPathStream.vec3Cache[1]);
            let entryPoint, exitPoint;
            const outcodeOr = this.prevPointOutcode | outcode;
            if ((outcodeOr & ~(Outcode.Left | Outcode.Right)) === 0 || (outcodeOr & ~(Outcode.Top | Outcode.Bottom)) === 0) {
                // The connecting line does not cross zones diagonally -> no need to check if the intersection of the line and
                // boundary falls outside the bounds of the orthogonal axis.
                // find entry point
                for (let i = 0; i < 4; i++) {
                    if (this.prevPointOutcode & (1 << i)) {
                        entryPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
                        break;
                    }
                }
                // find exit point
                for (let i = 0; i < 4; i++) {
                    if (outcode & (1 << i)) {
                        exitPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
                        break;
                    }
                }
            }
            else {
                // The connecting line crosses zones diagonally -> we need to check if the intersection of the line and each
                // boundary falls outside the bounds of the orthogonal axis.
                // find entry point
                for (let i = 0; i < 4; i++) {
                    if (this.prevPointOutcode & (1 << i)) {
                        const boundsAxisIndex = (i + 1) % 2;
                        const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
                        if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                            entryPoint = intersection;
                            break;
                        }
                    }
                }
                // find exit point
                for (let i = 0; i < 4; i++) {
                    if (outcode & (1 << i)) {
                        const boundsAxisIndex = (i + 1) % 2;
                        const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
                        if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                            exitPoint = intersection;
                            break;
                        }
                    }
                }
            }
            if (entryPoint) {
                this.consumer.moveTo(entryPoint[0], entryPoint[1]);
            }
            if (exitPoint) {
                this.consumer.lineTo(exitPoint[0], exitPoint[1]);
            }
            else if (outcode === Outcode.Inside) {
                this.consumer.lineTo(x, y);
            }
        }
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = outcode;
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        if (this.prevPointOutcode !== Outcode.Inside) {
            this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
        }
        this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        if (this.prevPointOutcode !== Outcode.Inside) {
            this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
        }
        this.consumer.quadraticCurveTo(cpx, cpy, x, y);
        Vec2Math.set(x, y, this.prevPoint);
        this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
        if (!this.isBoundingRectNonZero) {
            return;
        }
        if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        if (radius === 0 || startAngle === endAngle) {
            return;
        }
        const pi2 = 2 * Math.PI;
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
            // Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
            // doesn't match the counterClockwise flag.
            const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
            endAngle = startAngle + angleDiff * directionSign;
        }
        // Canvas context arc() clamps angular width to 2pi, so we will too.
        const angularWidth = Math.min(pi2, (endAngle - startAngle) * directionSign);
        endAngle = startAngle + angularWidth * directionSign;
        const bounds = this.bounds.get();
        const radiusSq = radius * radius;
        const startPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[2]), Vec2Math.setFromPolar(radius, startAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[2]);
        const startPointOutcode = this.getOutcode(startPoint[0], startPoint[1]);
        const endPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[3]), Vec2Math.setFromPolar(radius, endAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[3]);
        const endPointOutcode = this.getOutcode(endPoint[0], endPoint[1]);
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(startPoint[0], startPoint[1]);
        }
        else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
            this.lineTo(startPoint[0], startPoint[1]);
        }
        // Find all intersections of the arc circle with the clipping bounds; there can be up to 8 (two for each boundary
        // line).
        const intersections = ClippedPathStream.intersectionCache;
        let intersectionCount = 0;
        for (let i = 0; i < 4; i++) {
            const axisCoordIndex = i % 2;
            const crossAxisCoordIndex = (i + 1) % 2;
            const centerAxisCoord = i % 2 === 0 ? x : y;
            const centerCrossAxisCoord = i % 2 === 0 ? y : x;
            const deltaToBound = bounds[i] - centerAxisCoord;
            if (Math.abs(deltaToBound) < radius) {
                const radialOffsetSign = axisCoordIndex === 0 ? 1 : -1;
                const crossAxisBoundMin = bounds[crossAxisCoordIndex];
                const crossAxisBoundMax = bounds[crossAxisCoordIndex + 2];
                //const radialOffset = Math.acos(deltaToBound / radius);
                const crossAxisOffset = Math.sqrt(radiusSq - deltaToBound * deltaToBound);
                let intersectionRadialOffset;
                {
                    const intersectionCrossAxisCoord = centerCrossAxisCoord + crossAxisOffset;
                    if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
                        const intersection = intersections[intersectionCount];
                        intersection.point[axisCoordIndex] = bounds[i];
                        intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
                        const radial = axisCoordIndex * Math.PI / 2 + (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : (intersectionRadialOffset = Math.acos(MathUtils.clamp(deltaToBound / radius, -1, 1)))) * radialOffsetSign;
                        intersection.radial = (radial + pi2) % pi2; // [0, 2 * pi)
                        intersectionCount++;
                    }
                }
                {
                    const intersectionCrossAxisCoord = centerCrossAxisCoord - crossAxisOffset;
                    if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
                        const intersection = intersections[intersectionCount];
                        intersection.point[axisCoordIndex] = bounds[i];
                        intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
                        const radial = axisCoordIndex * Math.PI / 2 - (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : (intersectionRadialOffset = Math.acos(MathUtils.clamp(deltaToBound / radius, -1, 1)))) * radialOffsetSign;
                        intersection.radial = (radial + pi2) % pi2; // [0, 2 * pi)
                        intersectionCount++;
                    }
                }
            }
        }
        if (intersectionCount > 1) {
            // Set all unused intersection radials to infinity so they are guaranteed to be sorted last.
            for (let i = intersectionCount; i < intersections.length; i++) {
                intersections[i].radial = Infinity;
            }
            // Sort the intersections such that they are in clockwise order.
            intersections.sort(ClippedPathStream.compareCircleBoundsIntersections);
        }
        // Begin at the start radial, then in order (either clockwise or counterclockwise depending on the arc direction)
        // iterate through the intersection points. At each intersection, move to the point if we are currently out of
        // bounds or path an arc from the last visited radial to the point if we are inbounds. Every time we visit an
        // intersection we go from out of bounds to in bounds and vice versa. Stop when the radial to the intersection
        // is past the end radial of the arc.
        let isOutside = startPointOutcode !== Outcode.Inside;
        let prevRadial = startAngle;
        let intersectionStartIndex = -1;
        let minAngularDiff = Infinity;
        for (let i = 0; i < intersectionCount; i++) {
            const angularDiff = MathUtils.diffAngle(startAngle * directionSign, intersections[i].radial * directionSign);
            if (angularDiff < minAngularDiff) {
                intersectionStartIndex = i;
                minAngularDiff = angularDiff;
            }
        }
        if (intersectionStartIndex >= 0) {
            let angularWidthRemaining = angularWidth;
            for (let i = 0; i < intersectionCount; i++) {
                const index = (intersectionStartIndex + intersectionCount + i * directionSign) % intersectionCount;
                const intersection = intersections[index];
                const segmentAngularWidth = MathUtils.diffAngle(prevRadial * directionSign, intersection.radial * directionSign);
                if (segmentAngularWidth >= angularWidthRemaining) {
                    angularWidthRemaining = 0;
                    break;
                }
                const currentRadial = prevRadial + segmentAngularWidth * directionSign;
                if (isOutside) {
                    this.consumer.moveTo(intersection.point[0], intersection.point[1]);
                }
                else {
                    this.consumer.arc(x, y, radius, prevRadial, currentRadial, counterClockwise);
                }
                isOutside = !isOutside;
                prevRadial = currentRadial;
                angularWidthRemaining = (endAngle - prevRadial) * directionSign;
            }
        }
        if (!isOutside) {
            // If the last segment is not outside, then we will path an arc to the end radial.
            this.consumer.arc(x, y, radius, prevRadial, endAngle, counterClockwise);
        }
        else if (endPointOutcode === Outcode.Inside) {
            // If the last segment is outside but the endpoint is inside, then this means the endpoint is very close to the
            // clipping bounds and floating point error caused the discrepancy. In this case, we will not bother to draw an
            // arc because any such arc would be extremely short. Instead, we will move to the end point to ensure we leave
            // the consumer stream in the correct state for the next path command.
            this.consumer.moveTo(endPoint[0], endPoint[1]);
        }
        Vec2Math.copy(endPoint, this.prevPoint);
        this.prevPointOutcode = endPointOutcode;
    }
    /** @inheritdoc */
    closePath() {
        if (!isNaN(this.firstPoint[0])) {
            this.lineTo(this.firstPoint[0], this.firstPoint[1]);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        Vec2Math.set(NaN, NaN, this.firstPoint);
        Vec2Math.set(NaN, NaN, this.prevPoint);
        this.prevPointOutcode = 0;
    }
    /**
     * Gets the Cohen-Sutherland outcode for a point.
     * @param x The x-coordinate of the query point.
     * @param y The y-coordinate of the query point.
     * @returns The outcode for the point.
     */
    getOutcode(x, y) {
        const bounds = this.bounds.get();
        let code = 0;
        if (x < bounds[0]) {
            code |= Outcode.Left;
        }
        else if (x > bounds[2]) {
            code |= Outcode.Right;
        }
        if (y < bounds[1]) {
            code |= Outcode.Top;
        }
        else if (y > bounds[3]) {
            code |= Outcode.Bottom;
        }
        return code;
    }
    /**
     * Handles clipping bounds change events.
     */
    onBoundsChanged() {
        const bounds = this.bounds.get();
        Vec3Math.set(1, 0, -bounds[0], this.boundsLines[0]);
        Vec3Math.set(0, 1, -bounds[1], this.boundsLines[1]);
        Vec3Math.set(1, 0, -bounds[2], this.boundsLines[2]);
        Vec3Math.set(0, 1, -bounds[3], this.boundsLines[3]);
        this.isBoundingRectNonZero = bounds[0] < bounds[2] && bounds[1] < bounds[3];
        this.beginPath();
    }
    /**
     * Destroys this stream.
     */
    destroy() {
        this.boundsSub.destroy();
    }
    /**
     * Gets the line coordinate vector for a line passing through two points.
     * @param x1 The x-coordinate of the first point on the line.
     * @param y1 The y-coordinate of the first point on the line.
     * @param x2 The x-coordinate of the second point on the line.
     * @param y2 The y-coordinate of the second point on the line.
     * @param out A Float64Array object to which to write the result.
     * @returns The line coordinate vector of the line passing through the two points.
     */
    static getLineCoordinates(x1, y1, x2, y2, out) {
        const a = y1 - y2;
        const b = x2 - x1;
        const c = -(a * x1 + b * y1);
        return Vec3Math.set(a, b, c, out);
    }
    /**
     * Finds the intersection point between two lines in 2D Euclidean space.
     * @param line1 The line coordinate vector of the first line.
     * @param line2 The line coordinate vector of the second line.
     * @param out A Float64Array object to which to write the result.
     * @returns The intersection point of the two lines, or undefined if the two lines are parallel.
     */
    static findLineLineIntersection(line1, line2, out) {
        const cross = Vec3Math.cross(line1, line2, ClippedPathStream.vec3Cache[0]);
        const w = cross[2];
        if (w === 0) {
            return undefined;
        }
        return Vec2Math.set(cross[0] / w, cross[1] / w, out);
    }
    /**
     * Compares two circle-bounding box intersections and returns whether the first intersection's radial is less than,
     * greater than, or equal to the second's radial.
     * @param a The first intersection to compare.
     * @param b The second intersection to compare.
     * @returns A negative number if the first intersection's radial is less than the second, a positive number if the
     * first intersection's radial is greater than the second, or zero if both intersections' radials are equal.
     */
    static compareCircleBoundsIntersections(a, b) {
        return a.radial - b.radial;
    }
}
ClippedPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
ClippedPathStream.vec3Cache = [new Float64Array(3), new Float64Array(3)];
ClippedPathStream.intersectionCache = Array.from({ length: 8 }, () => {
    return { point: new Float64Array(2), radial: Infinity };
});

/**
 * A path stream which transforms a path stream in geographic spherical coordinates to one in projected planar
 * coordinates.
 */
class GeoProjectionPathStream extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
        super(consumer);
        this.projection = projection;
        this.firstPoint = new GeoPoint(NaN, NaN);
        this.prevPoint = new GeoPoint(NaN, NaN);
        this.prevPointProjected = new Float64Array(2);
        this.resampleHandler = this.onResampled.bind(this);
        if (arg1 instanceof GeoCircleResampler) {
            this.resampler = arg1;
        }
        else {
            this.resampler = new GeoCircleResampler(arg1, arg2, arg3);
        }
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
        return this.projection;
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
        this.projection = projection;
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
        this.consumer.beginPath();
    }
    /**
     * Moves to a specified point.
     * @param lon The longitude of the point to which to move, in degrees.
     * @param lat The latitude of the point to which to move, in degrees.
     */
    moveTo(lon, lat) {
        if (!(isFinite(lon) && isFinite(lat))) {
            return;
        }
        if (isNaN(this.firstPoint.lat)) {
            this.firstPoint.set(lat, lon);
        }
        this.prevPoint.set(lat, lon);
        const projected = this.projection.project(this.prevPoint, this.prevPointProjected);
        this.consumer.moveTo(projected[0], projected[1]);
    }
    /**
     * Paths a great-circle arc from the current point to a specified point.
     * @param lon The longitude of the end point, in degrees.
     * @param lat The latitude of the end point, in degrees.
     * @throws Error if the specified point is antipodal to the last pathed point.
     */
    lineTo(lon, lat) {
        if (!(isFinite(lon) && isFinite(lat))) {
            return;
        }
        if (!isNaN(this.prevPoint.lat) && this.prevPoint.equals(lat, lon)) {
            return;
        }
        if (isNaN(this.prevPoint.lat)) {
            this.moveTo(lon, lat);
            return;
        }
        const point = GeoProjectionPathStream.geoPointCache[0].set(lat, lon);
        const circle = GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint, point);
        if (!isFinite(circle.center[0])) {
            throw new Error(`Cannot unambiguously path a great circle from ${this.prevPoint.lat} lat, ${this.prevPoint.lon} lon to ${lat} lat, ${lon} lon`);
        }
        this.resampler.resample(this.projection, circle, this.prevPoint, point, this.resampleHandler);
        this.prevPoint.set(lat, lon);
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    bezierCurveTo() {
        throw new Error('GeodesicResamplerStream: bezierCurveTo() is not supported');
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    quadraticCurveTo() {
        throw new Error('GeodesicResamplerStream: quadraticCurveTo() is not supported');
    }
    /**
     * Paths a small-circle arc.
     * @param lon The longitude of the center of the circle containing the arc, in degrees.
     * @param lat The latitude of the center of the circle containing the arc, in degrees.
     * @param radius The radius of the arc, in great-arc radians.
     * @param startAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the start of the arc; otherwise the longitude, in degrees, of the start
     * of the arc.
     * @param endAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the end of the arc; otherwise the longitude, in degrees, of the end of
     * the arc.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(lon, lat, radius, startAngle, endAngle, counterClockwise) {
        if (!(isFinite(lon) && isFinite(lat) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        if (radius === 0 || Math.abs(startAngle - endAngle) <= GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
            return;
        }
        if (MathUtils.diffAngle(startAngle * Avionics.Utils.DEG2RAD, endAngle * Avionics.Utils.DEG2RAD, false) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Since we early return above if startAngle and endAngle are equal, hitting this case means they are a multiple
            // of 360 degrees apart. The resampler will interpret them as being the same point and won't draw a full circle
            // so we will split the arc into two.
            const midAngle = startAngle + 180 * Math.sign(endAngle - startAngle);
            this.arc(lon, lat, radius, startAngle, midAngle, counterClockwise);
            this.arc(lon, lat, radius, midAngle, endAngle, counterClockwise);
            return;
        }
        const center = GeoProjectionPathStream.geoPointCache[1].set(lat, lon);
        const start = GeoProjectionPathStream.geoPointCache[2];
        const end = GeoProjectionPathStream.geoPointCache[3];
        if (Math.abs(lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
            // The center of the arc circle is one of the poles
            const circleLat = Math.sign(lat) * (MathUtils.HALF_PI - radius) * Avionics.Utils.RAD2DEG;
            start.set(circleLat, startAngle);
            end.set(circleLat, endAngle);
        }
        else {
            center.offset(startAngle, radius, start);
            center.offset(endAngle, radius, end);
        }
        if (isNaN(start.lat) || isNaN(start.lon) || isNaN(end.lat) || isNaN(end.lon)) {
            return;
        }
        if (isNaN(this.prevPoint.lat)) {
            this.moveTo(start.lon, start.lat);
        }
        else if (!start.equals(this.prevPoint)) {
            this.lineTo(start.lon, start.lat);
        }
        const circle = GeoProjectionPathStream.geoCircleCache[0].set(center, radius);
        if (!counterClockwise) {
            circle.reverse();
        }
        this.resampler.resample(this.projection, circle, start, end, this.resampleHandler);
        this.prevPoint.set(end);
    }
    /**
     * Paths a great-circle arc from the current point to the first point defined by the current path.
     */
    closePath() {
        if (!isNaN(this.firstPoint.lat)) {
            this.lineTo(this.firstPoint.lon, this.firstPoint.lat);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        this.firstPoint.set(NaN, NaN);
        this.prevPoint.set(NaN, NaN);
    }
    /**
     * Handles resampled points.
     * @param vector A vector which describes the projected path terminating at the resampled point.
     */
    onResampled(vector) {
        switch (vector.type) {
            case 'start':
                return;
            case 'line':
                this.consumer.lineTo(vector.projected[0], vector.projected[1]);
                break;
            case 'arc':
                this.consumer.arc(vector.projectedArcCenter[0], vector.projectedArcCenter[1], vector.projectedArcRadius, vector.projectedArcStartAngle, vector.projectedArcEndAngle, vector.projectedArcStartAngle > vector.projectedArcEndAngle);
                break;
        }
        Vec2Math.copy(vector.projected, this.prevPointProjected);
    }
}
GeoProjectionPathStream.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GeoProjectionPathStream.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * A {@link TransformingPathStream} which applies an affine transformation to its input.
 *
 * The types of transformation supported by this class are:
 * * Translation.
 * * Uniform scaling.
 * * Rotation.
 */
class AffineTransformPathStream extends AbstractTransformingPathStream {
    constructor() {
        super(...arguments);
        this.transform = new Transform2D();
        this.concatCache = [];
        this.scale = 1;
        this.rotation = 0;
    }
    /**
     * Adds a translation to this stream's transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the translation before this stream's current transformation.
     * * `'after'` - Applies the translation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addTranslation(x, y, order = 'after') {
        const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
        if (order === 'before') {
            this.concatCache[0] = translation;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = translation;
        }
        Transform2D.concat(this.transform, this.concatCache);
        return this;
    }
    /**
     * Adds a uniform scaling to this stream's transformation.
     * @param factor The scaling factor.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the scaling before this stream's current transformation.
     * * `'after'` - Applies the scaling after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addScale(factor, order = 'after') {
        const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
        if (order === 'before') {
            this.concatCache[0] = scale;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = scale;
        }
        Transform2D.concat(this.transform, this.concatCache);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Adds a rotation to this stream's transformation.
     * @param angle The rotation angle, in radians.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the rotation before this stream's current transformation.
     * * `'after'` - Applies the rotation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addRotation(angle, order = 'after') {
        const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
        if (order === 'before') {
            this.concatCache[0] = rotation;
            this.concatCache[1] = this.transform;
        }
        else {
            this.concatCache[0] = this.transform;
            this.concatCache[1] = rotation;
        }
        Transform2D.concat(this.transform, this.concatCache);
        this.updateScaleRotation();
        return this;
    }
    /**
     * Resets this stream's transformation to the identity transformation.
     * @returns This stream, after its transformation has been changed.
     */
    resetTransform() {
        this.transform.toIdentity();
        this.updateScaleRotation();
        return this;
    }
    /** @inheritdoc */
    beginPath() {
        this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.moveTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        const transformed = this.applyTransform(x, y);
        this.consumer.lineTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        const cp1Transformed = this.applyTransform(cp1x, cp1y);
        cp1x = cp1Transformed[0];
        cp1y = cp1Transformed[1];
        const cp2Transformed = this.applyTransform(cp2x, cp2y);
        cp2x = cp2Transformed[0];
        cp2y = cp2Transformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        const cpTransformed = this.applyTransform(cpx, cpy);
        cpx = cpTransformed[0];
        cpy = cpTransformed[1];
        const endTransformed = this.applyTransform(x, y);
        x = endTransformed[0];
        y = endTransformed[1];
        this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        const transformed = this.applyTransform(x, y);
        this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.consumer.closePath();
    }
    /**
     * Updates this stream's cached scale and rotation values from its transformation.
     */
    updateScaleRotation() {
        const params = this.transform.getParameters();
        this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
        this.rotation = Math.atan2(params[3], params[0]);
    }
    /**
     * Applies this stream's transformation to a point.
     * @param x The x-coordinate of the point to transform.
     * @param y The y-coordinate of the point to transform.
     * @returns The transformed point.
     */
    applyTransform(x, y) {
        const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
        return this.transform.apply(vec, vec);
    }
}
AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
AffineTransformPathStream.transformCache = [new Transform2D()];

/**
 * A stack of {@link TransformingPathStream}s. Inputs are passed through the entire stack from top to bottom before the
 * final transformed output is sent to a consuming stream.
 */
class TransformingPathStreamStack extends AbstractTransformingPathStream {
    constructor() {
        super(...arguments);
        this.stack = [];
    }
    /**
     * Adds a transforming path stream to the top of this stack.
     * @param stream A transforming path stream.
     */
    push(stream) {
        var _a;
        stream.setConsumer((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer);
        this.stack.push(stream);
    }
    /**
     * Removes the top-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    pop() {
        const removed = this.stack.pop();
        removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
        return removed;
    }
    /**
     * Adds a transforming path stream to the bottom of this stack.
     * @param stream A transforming path stream.
     */
    unshift(stream) {
        const displaced = this.stack[0];
        displaced === null || displaced === void 0 ? void 0 : displaced.setConsumer(stream);
        stream.setConsumer(this.consumer);
        this.stack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shift() {
        var _a;
        const removed = this.stack.shift();
        removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
        (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(this.consumer);
        return removed;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        var _a;
        (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(consumer);
        super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        var _a;
        ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.stack[this.stack.length - 1].closePath();
    }
}

/**
 * A stack of {@link TransformingPathStream}s which transforms an input in spherical geographic coordinates to planar
 * projected coordinates. The stack contains two sub-stacks: a pre-projected stack which transforms the path before
 * it is projected, and a post-projected stack which transforms the projected path before it is sent to the consumer.
 * Transforming streams can be added to the top and bottom of each sub-stack. The input will be passed through each
 * stream in the pre-projected stack from top to bottom, then projected, then passed through each stream in the post-
 * projected stack from top to bottom, and the final transformed output will be passed to the consumer.
 */
class GeoProjectionPathStreamStack extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
        super(consumer);
        this.postStack = new TransformingPathStreamStack(consumer);
        if (arg1 instanceof GeoCircleResampler) {
            this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1);
        }
        else {
            this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1, arg2, arg3);
        }
        this.preStack = new TransformingPathStreamStack(this.projectionStream);
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
        return this.projectionStream.getProjection();
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
        this.projectionStream.setProjection(projection);
    }
    /**
     * Adds a transforming path stream to the top of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    pushPreProjected(stream) {
        this.preStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPreProjected() {
        return this.preStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPreProjected(stream) {
        this.preStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPreProjected() {
        return this.preStack.shift();
    }
    /**
     * Adds a transforming path stream to the top of the post-projected stack.
     * @param stream A transforming path stream.
     */
    pushPostProjected(stream) {
        this.postStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the post-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPostProjected() {
        return this.postStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the post-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPostProjected(stream) {
        this.postStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the post-projected stack. The removed stream will have its consumer set
     * to {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPostProjected() {
        return this.postStack.shift();
    }
    /** @inheritdoc */
    setConsumer(consumer) {
        this.postStack.setConsumer(consumer);
        super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
        this.preStack.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        this.preStack.moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        this.preStack.lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.preStack.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        this.preStack.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        this.preStack.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
        this.preStack.closePath();
    }
}

/**
 * Renders arcs along geo circles to a path stream stack.
 */
class GeoCirclePathRenderer {
    /**
     * Renders an arc along a geo circle to a path stream stack.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param streamStack The path stream stack to which to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath = false) {
        if (!continuePath) {
            streamStack.beginPath();
            streamStack.moveTo(startLon, startLat);
        }
        if (circle.isGreatCircle()) {
            const startPoint = GeoPoint.sphericalToCartesian(startLat, startLon, GeoCirclePathRenderer.vec3Cache[0]);
            const distance = circle.distanceAlong(startPoint, GeoCirclePathRenderer.geoPointCache[0].set(endLat, endLon), Math.PI);
            if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
                const midPoint = circle.offsetDistanceAlong(startPoint, distance / 2, GeoCirclePathRenderer.geoPointCache[0], Math.PI);
                const midLat = midPoint.lat;
                const midLon = midPoint.lon;
                streamStack.lineTo(midLon, midLat);
                streamStack.lineTo(endLon, endLat);
            }
            else {
                streamStack.lineTo(endLon, endLat);
            }
        }
        else {
            const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, GeoCirclePathRenderer.geoPointCache[0]);
            const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
            const isCenterPole = Math.abs(turnCenter.lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG;
            let startAngle, endAngle;
            if (isCenterPole) {
                startAngle = startLon;
                endAngle = endLon;
            }
            else {
                startAngle = turnCenter.bearingTo(startLat, startLon);
                endAngle = turnCenter.bearingTo(endLat, endLon);
            }
            streamStack.arc(turnCenter.lon, turnCenter.lat, FlightPathUtils.getTurnRadiusFromCircle(circle), startAngle, endAngle, turnDirection === 'left');
        }
    }
}
GeoCirclePathRenderer.NORTH_POLE_VEC = new Float64Array([0, 0, 1]);
GeoCirclePathRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
GeoCirclePathRenderer.vec3Cache = [new Float64Array(3)];

/**
 * Renders arcs along geo circles as curved lines.
 */
class GeoCircleLineRenderer {
    constructor() {
        this.pathRenderer = new GeoCirclePathRenderer();
    }
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     * @param lineCap The line cap style to use. Defaults to `'butt'`.
     */
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, width, style, dash, outlineWidth = 0, outlineStyle = 'black', lineCap = 'butt') {
        this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack);
        if (outlineWidth > 0) {
            context.lineWidth = width + (outlineWidth * 2);
            context.strokeStyle = outlineStyle;
            context.lineCap = lineCap;
            context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
            context.stroke();
        }
        context.lineWidth = width;
        context.strokeStyle = style;
        context.lineCap = lineCap;
        context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
        context.stroke();
    }
}
GeoCircleLineRenderer.EMPTY_DASH = [];

/**
 * Renders flight plan paths one leg at a time in either forward or reverse order. Optionally forces the rendering of
 * the active flight plan leg to be last.
 */
class AbstractFlightPathPlanRenderer {
    /**
     * Constructor.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in
     * a first-to-last fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(renderOrder = 'forward', renderActiveLegLast = true) {
        this.renderOrder = renderOrder;
        this.renderActiveLegLast = renderActiveLegLast;
    }
    /**
     * Renders a flight plan path to a canvas.
     * @param plan The flight plan to render.
     * @param startIndex The global index of the first flight plan leg to render, inclusive. Defaults to `0`.
     * @param endIndex The global index of the last flight plan leg to render, inclusive. Defaults to `plan.length - 1`.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param args Additional arguments.
     */
    render(plan, startIndex, endIndex, context, streamStack, ...args) {
        startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0);
        endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = plan.length - 1);
        const activeLegIndex = plan.activeLateralLeg < plan.length ? plan.activeLateralLeg : -1;
        const activeLeg = plan.activeLateralLeg < plan.length ? plan.getLeg(plan.activeLateralLeg) : undefined;
        const isReverse = this.renderOrder === 'reverse';
        if (isReverse) {
            const oldEndIndex = endIndex;
            endIndex = startIndex;
            startIndex = oldEndIndex;
        }
        let index = startIndex;
        const delta = isReverse ? -1 : 1;
        for (const leg of plan.legs(isReverse, startIndex)) {
            if ((index - endIndex) * delta > 0) {
                break;
            }
            if (this.renderActiveLegLast && index === activeLegIndex) {
                index += delta;
                continue;
            }
            this.renderLeg(leg, plan, activeLeg, index, activeLegIndex, context, streamStack, ...args);
            index += delta;
        }
        if (this.renderActiveLegLast && activeLeg) {
            this.renderLeg(activeLeg, plan, activeLeg, activeLegIndex, activeLegIndex, context, streamStack, ...args);
        }
    }
}

/**
 * Parts of a flight plan leg path to render.
 */
var FlightPathLegRenderPart;
(function (FlightPathLegRenderPart) {
    /** None. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["None"] = 0] = "None";
    /** The ingress transition. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Ingress"] = 1] = "Ingress";
    /** The base path. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Base"] = 2] = "Base";
    /** The egress transition. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["Egress"] = 4] = "Egress";
    /** The entire leg path. */
    FlightPathLegRenderPart[FlightPathLegRenderPart["All"] = 7] = "All";
})(FlightPathLegRenderPart || (FlightPathLegRenderPart = {}));
/**
 * Renders flight plan leg paths one vector at a time, optionally excluding the ingress and/or egress transition
 * vectors.
 */
class AbstractFlightPathLegRenderer {
    constructor() {
        this.tempVector = FlightPathUtils.createEmptyCircleVector();
    }
    /**
     * Renders a flight plan leg path to a canvas.
     * @param leg The flight plan leg to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param partsToRender The parts of the leg to render, as a combination of {@link FlightPathLegRenderPart}
     * values.
     * @param args Additional arguments.
     */
    render(leg, context, streamStack, partsToRender, ...args) {
        const legCalc = leg.calculated;
        if (!legCalc || !BitFlags.isAny(partsToRender, FlightPathLegRenderPart.Ingress | FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Egress)) {
            return;
        }
        const excludeIngress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Ingress);
        const excludeBase = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Base);
        const excludeEgress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Egress);
        let mainVectors = legCalc.ingressToEgress;
        let mainVectorStartIndex = 0;
        let mainVectorEndIndex = legCalc.ingressToEgress.length;
        if (excludeIngress || excludeEgress) {
            mainVectors = legCalc.flightPath;
            mainVectorEndIndex = excludeEgress || legCalc.egressJoinIndex < 0 || legCalc.egress.length === 0 ? legCalc.flightPath.length : legCalc.egressJoinIndex;
        }
        if (!excludeIngress) {
            for (let i = 0; i < legCalc.ingress.length; i++) {
                this.renderVector(legCalc.ingress[i], true, false, leg, context, streamStack, ...args);
            }
            if (excludeEgress && !excludeBase) {
                mainVectorStartIndex = Math.max(0, legCalc.ingressJoinIndex);
                const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
                const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
                if (lastIngressVector && ingressJoinVector) {
                    const ingressEnd = AbstractFlightPathLegRenderer.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
                    const vectorEnd = AbstractFlightPathLegRenderer.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
                    if (!ingressEnd.equals(vectorEnd)) {
                        const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
                        FlightPathUtils.setCircleVector(this.tempVector, ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
                        this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
                    }
                    mainVectorStartIndex++;
                }
            }
        }
        if (!excludeBase) {
            const len = Math.min(mainVectorEndIndex, mainVectors.length);
            for (let i = mainVectorStartIndex; i < len; i++) {
                this.renderVector(mainVectors[i], false, false, leg, context, streamStack, ...args);
            }
        }
        if (!excludeEgress) {
            if (excludeIngress && !excludeBase) {
                const firstEgressVector = legCalc.egress[0];
                const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
                if (firstEgressVector && egressJoinVector) {
                    const egressStart = AbstractFlightPathLegRenderer.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                    const egressJoinVectorStart = AbstractFlightPathLegRenderer.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                    if (!egressStart.equals(egressJoinVectorStart)) {
                        const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
                        FlightPathUtils.setCircleVector(this.tempVector, egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                        this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
                    }
                }
            }
            for (let i = 0; i < legCalc.egress.length; i++) {
                this.renderVector(legCalc.egress[i], false, true, leg, context, streamStack, ...args);
            }
        }
    }
}
AbstractFlightPathLegRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
AbstractFlightPathLegRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * Renders flight path vectors as a curved line.
 */
class FlightPathVectorLineRenderer {
    constructor() {
        this.renderer = new GeoCircleLineRenderer();
    }
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     * @param lineCap The line cap style to use. Defaults to `'butt'`.
     */
    render(vector, context, streamStack, width, style, dash, outlineWidth, outlineStyle, lineCap = 'butt') {
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorLineRenderer.geoCircleCache[0]);
        this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, width, style, dash, outlineWidth, outlineStyle, lineCap);
    }
}
FlightPathVectorLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/**
 * Map own airplane icon orientations.
 */
var MapOwnAirplaneIconOrientation;
(function (MapOwnAirplaneIconOrientation) {
    MapOwnAirplaneIconOrientation["HeadingUp"] = "HeadingUp";
    MapOwnAirplaneIconOrientation["TrackUp"] = "TrackUp";
    MapOwnAirplaneIconOrientation["MapUp"] = "MapUp";
})(MapOwnAirplaneIconOrientation || (MapOwnAirplaneIconOrientation = {}));
/**
 * A module describing properties of the own airplane icon.
 */
class MapOwnAirplaneIconModule {
    constructor() {
        /** Whether to show the airplane icon. */
        this.show = Subject.create(true);
        /** The orientation of the airplane icon. */
        this.orientation = Subject.create(MapOwnAirplaneIconOrientation.HeadingUp);
    }
}

/**
 * A module describing the state of the own airplane.
 */
class MapOwnAirplanePropsModule {
    constructor() {
        /** The airplane's position. */
        this.position = GeoPointSubject.create(new GeoPoint(0, 0));
        /** The airplane's true heading, in degrees. */
        this.hdgTrue = Subject.create(0);
        /** The airplane's turn rate, in degrees per second. */
        this.turnRate = Subject.create(0);
        /** The airplane's indicated altitude. */
        this.altitude = NumberUnitSubject.create(UnitType.FOOT.createNumber(0));
        /** The airplane's vertical speed. */
        this.verticalSpeed = NumberUnitSubject.create(UnitType.FPM.createNumber(0));
        /** The airplane's true ground track, in degrees. */
        this.trackTrue = Subject.create(0);
        /** The airplane's ground speed. */
        this.groundSpeed = NumberUnitSubject.create(UnitType.KNOT.createNumber(0));
        /** Whether the airplane is on the ground. */
        this.isOnGround = Subject.create(true);
        /** The magnetic variation at the airplane's position. */
        this.magVar = Subject.create(0);
    }
}

/**
 * A module describing the state of the autopilot.
 */
class MapAutopilotPropsModule {
    constructor() {
        /** The altitude preselector setting. */
        this.selectedAltitude = NumberUnitSubject.create(UnitType.FOOT.createNumber(0));
    }
}

/**
 * A module describing the display of airspaces.
 */
class MapAirspaceModule {
    /**
     * Constructor.
     * @param showTypes A map of this module's airspace show types to their associated nearest boundary search filter
     * bitflags.
     */
    constructor(showTypes) {
        this.showTypes = showTypes;
        this.show = {};
        for (const type in showTypes) {
            this.show[type] = Subject.create(false);
        }
    }
}

/**
 * An abstract implementation of {@link CssTransform}
 */
class AbstractCssTransform {
    /**
     * Constructor.
     * @param initialParams The transform's initial parameters.
     */
    constructor(initialParams) {
        this.params = new Float64Array(initialParams);
        this.cachedParams = new Float64Array(initialParams);
    }
    /** @inheritdoc */
    resolve() {
        if (this.stringValue !== undefined && VecNMath.equals(this.params, this.cachedParams)) {
            return this.stringValue;
        }
        VecNMath.copy(this.params, this.cachedParams);
        this.stringValue = this.buildString(this.params);
        return this.stringValue;
    }
}
/**
 * A CSS `matrix` transform.
 */
class CssMatrixTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    constructor() {
        super(CssMatrixTransform.DEFAULT_PARAMS);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewY, skewX, scaleY, translateX, translateY) {
        let scaleX;
        if (typeof arg1 === 'number') {
            scaleX = arg1;
        }
        else {
            [scaleX, skewX, skewY, scaleY, translateX, translateY] = arg1.getParameters();
        }
        this.params[0] = scaleX;
        this.params[1] = skewY;
        this.params[2] = skewX;
        this.params[3] = scaleY;
        this.params[4] = translateX;
        this.params[5] = translateY;
    }
    /** @inheritdoc */
    buildString(params) {
        return `matrix(${params.join(', ')})`;
    }
}
CssMatrixTransform.DEFAULT_PARAMS = [1, 0, 0, 1, 0, 0];
/**
 * A CSS `rotate` transform.
 */
class CssRotateTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
        super(CssRotateTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's rotation angle.
     * @param angle The angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(angle, precision = 0) {
        this.params[0] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `rotate(${params[0]}${this.unit})`;
    }
}
CssRotateTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `rotate3d` transform.
 */
class CssRotate3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
        super(CssRotate3dTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's rotation.
     * @param x The x component of the rotation axis vector.
     * @param y The y component of the rotation axis vector.
     * @param z The z component of the rotation axis vector.
     * @param angle The rotation angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, y, z, angle, precision = 0) {
        this.params[0] = x;
        this.params[1] = y;
        this.params[2] = z;
        this.params[3] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `rotate3d(${params[0]}, ${params[1]}, ${params[2]}, ${params[3]}${this.unit})`;
    }
}
CssRotate3dTransform.DEFAULT_PARAMS = [0, 0, 1, 0];
/**
 * A CSS `translateX` transform.
 */
class CssTranslateXTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateXTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param x The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(x, precision = 0) {
        this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateX(${params[0]}${this.unit})`;
    }
}
CssTranslateXTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translateY` transform.
 */
class CssTranslateYTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateYTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param y The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(y, precision = 0) {
        this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateY(${params[0]}${this.unit})`;
    }
}
CssTranslateYTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translateZ` transform.
 */
class CssTranslateZTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
        super(CssTranslateZTransform.DEFAULT_PARAMS);
        this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param z The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(z, precision = 0) {
        this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translateZ(${params[0]}${this.unit})`;
    }
}
CssTranslateZTransform.DEFAULT_PARAMS = [0];
/**
 * A CSS `translate` transform.
 */
class CssTranslateTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX) {
        super(CssTranslateTransform.DEFAULT_PARAMS);
        this.unitX = unitX;
        this.unitY = unitY;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translate(${params[0]}${this.unitX}, ${params[1]}${this.unitY})`;
    }
}
CssTranslateTransform.DEFAULT_PARAMS = [0, 0];
/**
 * A CSS `translate3d` transform.
 */
class CssTranslate3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     * @param unitZ The unit to use for this transform's z translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX, unitZ = unitX) {
        super(CssTranslate3dTransform.DEFAULT_PARAMS);
        this.unitX = unitX;
        this.unitY = unitY;
        this.unitZ = unitZ;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param z The z translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     * @param precisionZ The precision with which to set the z translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
        this.params[2] = precisionZ === 0 ? z : MathUtils.round(z, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
        return `translate3d(${params[0]}${this.unitX}, ${params[1]}${this.unitY}, ${params[2]}${this.unitZ})`;
    }
}
CssTranslate3dTransform.DEFAULT_PARAMS = [0, 0, 0];
/**
 * A CSS `scaleX` transform.
 */
class CssScaleXTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleXTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, precision = 0) {
        this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleX(${params[0]})`;
    }
}
CssScaleXTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scaleY` transform.
 */
class CssScaleYTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleYTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param y The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(y, precision = 0) {
        this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleY(${params[0]})`;
    }
}
CssScaleYTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scaleZ` transform.
 */
class CssScaleZTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleZTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param z The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(z, precision = 0) {
        this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scaleZ(${params[0]})`;
    }
}
CssScaleZTransform.DEFAULT_PARAMS = [1];
/**
 * A CSS `scale` transform.
 */
class CssScaleTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScaleTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scale(${params[0]}, ${params[1]})`;
    }
}
CssScaleTransform.DEFAULT_PARAMS = [1, 1];
/**
 * A CSS `scale3d` transform.
 */
class CssScale3dTransform extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    constructor() {
        super(CssScale3dTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param z The z scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     * @param precisionZ The precision with which to set the z scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
        this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
        this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
        this.params[2] = precisionZ === 0 ? z : MathUtils.round(y, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
        return `scale3d(${params[0]}, ${params[1]}, ${params[2]})`;
    }
}
CssScale3dTransform.DEFAULT_PARAMS = [1, 1, 1];
/**
 * A concatenated chain of CSS transforms.
 */
class CssTransformChain {
    /**
     * Creates a new chain of CSS transforms.
     * @param transforms The individual child transforms that will constitute the new transform chain. The order of
     * the children passed to the constructor determines the order of concatenation. Concatenation follows the standard
     * CSS transform convention: for a concatenation of transforms `[A, B, C]`, the resulting transformation is
     * equivalent to the one produced by multiplying the transformation matrices in the order `(A * B) * C`.
     */
    constructor(...transforms) {
        this.stringValues = [];
        this.transforms = transforms;
    }
    /**
     * Gets one of this chain's child transforms.
     * @param index The index of the child to get.
     * @returns The child transform at the specified index in this chain.
     * @throws RangeError if `index` is out of bounds.
     */
    getChild(index) {
        if (index < 0 || index >= this.transforms.length) {
            throw new RangeError();
        }
        return this.transforms[index];
    }
    /** @inheritdoc */
    resolve() {
        let needRebuildString = false;
        for (let i = 0; i < this.transforms.length; i++) {
            const stringValue = this.transforms[i].resolve();
            if (this.stringValues[i] !== stringValue) {
                this.stringValues[i] = stringValue;
                needRebuildString = true;
            }
        }
        if (needRebuildString || this.chainedStringValue === undefined) {
            this.chainedStringValue = this.stringValues.join(' ');
        }
        return this.chainedStringValue;
    }
}
/**
 * A subscribable subject whose value is a CSS transform string resolved from a {@link CssTransform}.
 */
class CssTransformSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param transform The new subject's CSS transform.
     */
    constructor(transform) {
        super();
        this._transform = transform;
        this.stringValue = transform.resolve();
        this.transform = transform;
    }
    /** @inheritdoc */
    get() {
        return this.stringValue;
    }
    /**
     * Resolves this subject's CSS transform to a CSS transform string, and sets this subject's value to the resolved
     * string. If this changes this subject's value, subscribers will be notified.
     */
    resolve() {
        const stringValue = this._transform.resolve();
        if (stringValue !== this.stringValue) {
            this.stringValue = stringValue;
            this.notify();
        }
    }
    /**
     * Creates a new instance of {@link CssTransformSubject} whose value is resolved from a CSS transform.
     * @param transform A CSS transform.
     * @returns A new instance of {@link CssTransformSubject} whose value is resolved from the specified CSS transform.
     */
    static create(transform) {
        return new CssTransformSubject(transform);
    }
}
/**
 * A utility class for building CSS transforms.
 */
class CssTransformBuilder {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     * @returns A new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    static matrix() {
        return new CssMatrixTransform();
    }
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate` transform, initialized to zero rotation.
     */
    static rotate(unit) {
        return new CssRotateTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     */
    static rotate3d(unit) {
        return new CssRotate3dTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateX` transform, initialized to zero translation.
     */
    static translateX(unit) {
        return new CssTranslateXTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateY` transform, initialized to zero translation.
     */
    static translateY(unit) {
        return new CssTranslateYTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateZ` transform, initialized to zero translation.
     */
    static translateZ(unit) {
        return new CssTranslateZTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @returns A new instance of a CSS `translate` transform, initialized to zero translation.
     */
    static translate(unitX, unitY) {
        return new CssTranslateTransform(unitX, unitY);
    }
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @param unitZ The unit to use for the new transform's z translation.
     * @returns A new instance of a CSS `translate3d` transform, initialized to zero translation.
     */
    static translate3d(unitX, unitY, unitZ) {
        return new CssTranslate3dTransform(unitX, unitY, unitZ);
    }
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    static scaleX() {
        return new CssScaleXTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    static scaleY() {
        return new CssScaleYTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    static scaleZ() {
        return new CssScaleZTransform();
    }
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    static scale() {
        return new CssScaleTransform();
    }
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    static scale3d() {
        return new CssScale3dTransform();
    }
    /**
     * Concatenates zero or more CSS transformations.
     * @param transforms The individual transforms to concatentate. The order of the transforms passed to the function
     * determines the order of concatenation. Concatenation follows the standard CSS transform convention: for a
     * concatenation of transforms `[A, B, C]`, the resulting transformation is equivalent to the one produced by
     * multiplying the transformation matrices in the order `(A * B) * C`.
     * @returns A new {@link CssTransformChain} object representing the concatenation of the specified transforms.
     */
    static concat(...transforms) {
        return new CssTransformChain(...transforms);
    }
}

/**
 * A utility class for creating number formatters.
 *
 * Each number formatter is a function which generates output strings from input numeric values. The formatting
 * behavior of a formatter is defined by its options. Please refer to the {@link NumberFormatterOptions} type
 * documentation for more information on each individual option.
 */
class NumberFormatter {
    /**
     * Formats a number to a string.
     * @param number The number to format.
     * @param opts Options describing how to format the number.
     * @returns The formatted string representation of the specified number.
     */
    static formatNumber(number, opts) {
        if (isNaN(number)) {
            return opts.nanString;
        }
        const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
        const sign = number < 0 ? -1 : 1;
        const abs = Math.abs(number);
        let rounded = abs;
        if (precision !== 0) {
            rounded = roundFunc(abs / precision) * precision;
        }
        if (cache) {
            if (opts.cachedString !== undefined && opts.cachedNumber === rounded) {
                return opts.cachedString;
            }
            opts.cachedNumber = rounded;
        }
        const signText = sign === -1
            ? useMinusSign ? '−' : '-'
            : '+';
        let formatted;
        if (precision != 0) {
            const precisionString = `${precision}`;
            const decimalIndex = precisionString.indexOf('.');
            if (decimalIndex >= 0) {
                formatted = rounded.toFixed(precisionString.length - decimalIndex - 1);
            }
            else {
                formatted = `${rounded}`;
            }
        }
        else {
            formatted = `${abs}`;
        }
        let decimalIndex = formatted.indexOf('.');
        if (!forceDecimalZeroes && decimalIndex >= 0) {
            formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, '');
            if (formatted.indexOf('.') == formatted.length - 1) {
                formatted = formatted.substring(0, formatted.length - 1);
            }
        }
        decimalIndex = formatted.indexOf('.');
        if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
            const shift = Math.max(maxDigits - decimalIndex, 0);
            const shiftPrecision = Math.pow(0.1, shift);
            formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
        }
        if (pad === 0) {
            formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, '.');
        }
        else if (pad > 1) {
            decimalIndex = formatted.indexOf('.');
            if (decimalIndex < 0) {
                decimalIndex = formatted.length;
            }
            formatted = formatted.padStart(pad + formatted.length - decimalIndex, '0');
        }
        if (showCommas) {
            const parts = formatted.split('.');
            parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ',');
            formatted = parts.join('.');
        }
        formatted = ((forceSign || signText !== '+') ? signText : '') + formatted;
        if (cache) {
            opts.cachedString = formatted;
        }
        return formatted;
    }
    /**
     * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
     * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
     * more information on each individual option.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `precision = 0`
     * * `round = 0`
     * * `maxDigits = Infinity`
     * * `forceDecimalZeroes = true`
     * * `pad = 1`
     * * `showCommas = false`
     * * `useMinusSign = false`
     * * `forceSign = false`
     * * `nanString = 'NaN'`
     * * `cache = false`
     * @returns A function which formats numeric values to strings.
     */
    static create(options) {
        const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
        optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
        return (number) => {
            return NumberFormatter.formatNumber(number, optsToUse);
        };
    }
}
NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: 'NaN',
    cache: false
};
NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
};
NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;

/**
 * A path stream which builds SVG path strings from its input path commands.
 */
class SvgPathStream {
    /**
     * Constructor.
     * @param precision The precision of this stream. All coordinates will be rounded to this stream's precision when
     * building the SVG path string. A value of `0` indicates infinite precision. Defaults to `0`.
     */
    constructor(precision = 0) {
        this.svgPath = '';
        this.firstPoint = new Float64Array([NaN, NaN]);
        this.prevPoint = new Float64Array([NaN, NaN]);
        this.precision = precision;
        this.formatter = NumberFormatter.create({ precision, forceDecimalZeroes: false });
    }
    /**
     * Gets the SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     * @returns The SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     */
    getSvgPath() {
        return this.svgPath.trim();
    }
    /**
     * Gets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @returns The precision of this stream.
     */
    getPrecision() {
        return this.precision;
    }
    /**
     * Sets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @param precision The precision of this stream. Negative numbers will be converted to their absolute values.
     */
    setPrecision(precision) {
        this.precision = Math.abs(precision);
        this.formatter = NumberFormatter.create({ precision: this.precision, forceDecimalZeroes: false });
    }
    /** @inheritdoc */
    beginPath() {
        this.reset();
    }
    /** @inheritdoc */
    moveTo(x, y) {
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (isNaN(this.firstPoint[0])) {
            Vec2Math.set(x, y, this.firstPoint);
        }
        this.svgPath += `M ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    lineTo(x, y) {
        if (!(isFinite(x) && isFinite(y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `L ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `C ${this.formatter(cp1x)} ${this.formatter(cp1y)} ${this.formatter(cp2x)} ${this.formatter(cp2y)} ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
        if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
            return;
        }
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(x, y);
            return;
        }
        this.svgPath += `Q ${this.formatter(cpx)} ${this.formatter(cpy)} ${this.formatter(x)} ${this.formatter(y)} `;
        Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
        if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
            return;
        }
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
            // Replicate behavior of canvas context arc() when the sign of the difference between start and end angles
            // doesn't match the counterClockwise flag.
            const angleDiff = counterClockwise ? MathUtils.diffAngle(endAngle, startAngle) : MathUtils.diffAngle(startAngle, endAngle);
            endAngle = startAngle + angleDiff * directionSign;
        }
        // Clamp to 2pi because we don't need to draw anything past a full circle.
        const angularWidth = Math.min(MathUtils.TWO_PI, (endAngle - startAngle) * directionSign);
        if (angularWidth === MathUtils.TWO_PI) {
            // SVG arc commands cannot draw a full circle, so we need to split the circle into two half circles
            const midAngle = startAngle + Math.PI * directionSign;
            this.arc(x, y, radius, startAngle, midAngle, counterClockwise);
            this.arc(x, y, radius, midAngle, startAngle, counterClockwise);
            return;
        }
        const startPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[0]);
        if (isNaN(this.prevPoint[0])) {
            this.moveTo(startPoint[0], startPoint[1]);
        }
        else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
            this.lineTo(startPoint[0], startPoint[1]);
        }
        const endPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[1]), Vec2Math.setFromPolar(radius, endAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[1]);
        const radiusString = this.formatter(radius);
        this.svgPath += `A ${radiusString} ${radiusString} 0 ${angularWidth > Math.PI ? 1 : 0} ${counterClockwise ? 0 : 1} ${this.formatter(endPoint[0])} ${this.formatter(endPoint[1])} `;
        Vec2Math.copy(endPoint, this.prevPoint);
    }
    /** @inheritdoc */
    closePath() {
        if (!isNaN(this.firstPoint[0])) {
            this.lineTo(this.firstPoint[0], this.firstPoint[1]);
        }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
        Vec2Math.set(NaN, NaN, this.firstPoint);
        Vec2Math.set(NaN, NaN, this.prevPoint);
        this.svgPath = '';
    }
}
SvgPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];

/**
 * A collection of common keys used by the MapSystem API.
 */
class MapSystemKeys {
}
MapSystemKeys.TargetControl = 'targetControlModerator';
MapSystemKeys.RotationControl = 'rotationControlModerator';
MapSystemKeys.RangeControl = 'rangeControlModerator';
MapSystemKeys.ClockUpdate = 'clockUpdate';
MapSystemKeys.OwnAirplaneProps = 'ownAirplaneProps';
MapSystemKeys.AutopilotProps = 'autopilotProps';
MapSystemKeys.AltitudeArc = 'altitudeArc';
MapSystemKeys.TerrainColors = 'terrainColors';
MapSystemKeys.Weather = 'weather';
MapSystemKeys.FollowAirplane = 'followAirplane';
MapSystemKeys.Rotation = 'rotation';
MapSystemKeys.OwnAirplaneIcon = 'ownAirplaneIcon';
MapSystemKeys.OwnAirplaneIconOrientation = 'ownAirplaneIconOrientation';
MapSystemKeys.TextLayer = 'text';
MapSystemKeys.TextManager = 'textManager';
MapSystemKeys.Bing = 'bing';
MapSystemKeys.WaypointRenderer = 'waypointRenderer';
MapSystemKeys.IconFactory = 'iconFactory';
MapSystemKeys.LabelFactory = 'labelFactory';
MapSystemKeys.NearestWaypoints = 'nearestWaypoints';
MapSystemKeys.FlightPlan = 'flightPlan';
MapSystemKeys.FlightPlanner = 'flightPlanner';
MapSystemKeys.FlightPathRenderer = 'flightPathRenderer';
MapSystemKeys.Airspace = 'airspace';
MapSystemKeys.AirspaceManager = 'airspaceRenderManager';
MapSystemKeys.Traffic = 'traffic';
MapSystemKeys.DataIntegrity = 'dataIntegrity';

/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
class MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
        this.canvas = canvas;
        this.context = context;
        this.isDisplayed = isDisplayed;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset() {
        const width = this.canvas.width;
        this.canvas.width = 0;
        this.canvas.width = width;
    }
}
/**
 * A layer which uses a canvas to draw graphics.
 */
class MapCanvasLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.displayCanvasRef = FSComponent.createRef();
        this.width = 0;
        this.height = 0;
        this.displayCanvasContext = null;
        this.isInit = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display() {
        if (!this._display) {
            throw new Error('MapCanvasLayer: attempted to access display before it was initialized');
        }
        return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer() {
        if (!this._buffer) {
            throw new Error('MapCanvasLayer: attempted to access buffer before it was initialized');
        }
        return this._buffer;
    }
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay() {
        return this._display;
    }
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer() {
        return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
        return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
        return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
        if (width === this.width) {
            return;
        }
        this.width = width;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
        if (height === this.height) {
            return;
        }
        this.height = height;
        if (this.isInit) {
            this.updateCanvasSize();
        }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
        if (!this.isInit || !this.props.useBuffer) {
            return;
        }
        this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
        this.displayCanvasContext = this.displayCanvasRef.instance.getContext('2d');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        if (this.isInit) {
            this.updateCanvasVisibility();
        }
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        this.initCanvasInstances();
        this.isInit = true;
        this.updateCanvasVisibility();
        this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
        this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
        if (this.props.useBuffer) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            this._buffer = this.createCanvasInstance(canvas, context, false);
        }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
        const displayCanvas = this.display.canvas;
        displayCanvas.width = this.width;
        displayCanvas.height = this.height;
        displayCanvas.style.width = `${this.width}px`;
        displayCanvas.style.height = `${this.height}px`;
        if (this._buffer) {
            const bufferCanvas = this._buffer.canvas;
            bufferCanvas.width = this.width;
            bufferCanvas.height = this.height;
        }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
        this.display.canvas.style.display = this.isVisible() ? 'block' : 'none';
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', width: '0', height: '0', style: 'position: absolute;' }));
    }
}

/**
 * A canvas map layer whose size and position is synced with the map projection window.
 */
class MapSyncedCanvasLayer extends MapCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        this.setWidth(projectedSize[0]);
        this.setHeight(projectedSize[1]);
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = '0px';
        displayCanvas.style.top = '0px';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
    }
}

/**
 * A map layer which displays an altitude intercept arc.
 */
class MapAltitudeArcLayer extends MapLayer {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(...arguments);
        this.layerRef = FSComponent.createRef();
        this.arcAngularWidth = ((_a = this.props.arcAngularWidth) !== null && _a !== void 0 ? _a : MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
        this.arcRadius = (_b = this.props.arcRadius) !== null && _b !== void 0 ? _b : MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;
        this.strokeWidth = (_c = this.props.strokeWidth) !== null && _c !== void 0 ? _c : MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;
        this.strokeStyle = (_d = this.props.strokeStyle) !== null && _d !== void 0 ? _d : MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;
        this.strokeLineCap = (_e = this.props.strokeLineCap) !== null && _e !== void 0 ? _e : MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP;
        this.outlineWidth = (_f = this.props.outlineWidth) !== null && _f !== void 0 ? _f : MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;
        this.outlineStyle = (_g = this.props.outlineStyle) !== null && _g !== void 0 ? _g : MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;
        this.outlineLineCap = (_h = this.props.outlineLineCap) !== null && _h !== void 0 ? _h : MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP;
        this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.autopilotModule = this.props.model.getModule(MapSystemKeys.AutopilotProps);
        this.vsPrecisionFpm = ('isSubscribable' in this.props.verticalSpeedPrecision)
            ? this.vsPrecisionMap = this.props.verticalSpeedPrecision.map(v => v.asUnit(UnitType.FPM))
            : Subject.create(this.props.verticalSpeedPrecision.asUnit(UnitType.FPM));
        this.vsThresholdFpm = ('isSubscribable' in this.props.verticalSpeedThreshold)
            ? this.vsThresholdMap = this.props.verticalSpeedThreshold.map(v => v.asUnit(UnitType.FPM))
            : Subject.create(this.props.verticalSpeedThreshold.asUnit(UnitType.FPM));
        this.altDevThresholdFeet = ('isSubscribable' in this.props.altitudeDeviationThreshold)
            ? this.altDevThresholdMap = this.props.altitudeDeviationThreshold.map(v => v.asUnit(UnitType.FOOT))
            : Subject.create(this.props.altitudeDeviationThreshold.asUnit(UnitType.FOOT));
        this.vsFpm = this.ownAirplanePropsModule.verticalSpeed.map(vs => vs.asUnit(UnitType.FPM));
        this.vsFpmQuantized = MappedSubject.create(([vsFpm, precision]) => {
            return Math.round(vsFpm / precision) * precision;
        }, this.vsFpm, this.vsPrecisionFpm);
        this.projectedPlanePosition = Vec2Subject.create(Vec2Math.create());
        this.projectPlanePositionHandler = () => {
            const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapAltitudeArcLayer.vec2Cache[0]);
            this.projectedPlanePosition.set(projected);
        };
        this.isArcVisibleDynamic = MappedSubject.create(([vsFpm, alt, selectedAlt, vsThreshold, altDevThresholdFeet]) => {
            if (Math.abs(vsFpm) < vsThreshold) {
                return false;
            }
            const altDevFeet = selectedAlt.asUnit(UnitType.FOOT) - alt.asUnit(UnitType.FOOT);
            return Math.abs(altDevFeet) >= altDevThresholdFeet && altDevFeet * vsFpm > 0;
        }, this.vsFpmQuantized, this.ownAirplanePropsModule.altitude, this.autopilotModule.selectedAltitude, this.vsThresholdFpm, this.altDevThresholdFeet).pause();
        this.projectedArcPosition = Vec2Subject.create(Vec2Math.create());
        this.projectedArcAngle = Subject.create(0);
        this.needUpdate = false;
        this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a;
        (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(isVisible);
        if (isVisible) {
            this.needUpdate = true;
        }
    }
    /** @inheritdoc */
    onAttached() {
        var _a, _b;
        this.layerRef.instance.onAttached();
        this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
        const scheduleUpdate = () => { this.needUpdate = true; };
        const altitudeArcModule = this.props.model.getModule(MapSystemKeys.AltitudeArc);
        const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
        this.isArcVisibleStatic = MappedSubject.create(([show, isGpsValid, isAdcValid]) => {
            return show && isGpsValid && isAdcValid;
        }, altitudeArcModule.show, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true));
        const isArcVisibleDynamicSub = this.isArcVisibleDynamic.sub(isVisible => { this.setVisible(isVisible); }, false, true);
        this.isArcVisibleStatic.sub(isVisible => {
            if (isVisible) {
                this.isArcVisibleDynamic.resume();
                isArcVisibleDynamicSub.resume(true);
            }
            else {
                this.isArcVisibleDynamic.pause();
                isArcVisibleDynamicSub.pause();
                this.setVisible(false);
            }
        }, true);
        this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));
        this.vsFpmQuantized.sub(scheduleUpdate);
        this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate, true));
        this.layerRef.instance.setVisible(this.isVisible());
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.layerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.projectPlanePositionHandler();
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const track = this.ownAirplanePropsModule.trackTrue.get();
        const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
        const altitude = this.ownAirplanePropsModule.altitude.get();
        const selectedAltitude = this.autopilotModule.selectedAltitude.get();
        const vsFpm = this.vsFpmQuantized.get();
        const timeToAltitudeMinute = (selectedAltitude.asUnit(UnitType.FOOT) - altitude.asUnit(UnitType.FOOT)) / vsFpm;
        const distanceToAltitudeFeet = groundSpeed.asUnit(UnitType.FPM) * timeToAltitudeMinute;
        const distancePx = UnitType.FOOT.convertTo(distanceToAltitudeFeet, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - MathUtils.HALF_PI;
        const projectedPlanePos = this.projectedPlanePosition.get();
        const projectedArcPos = Vec2Math.add(Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapAltitudeArcLayer.vec2Cache[0]), projectedPlanePos, MapAltitudeArcLayer.vec2Cache[0]);
        this.projectedArcPosition.set(projectedArcPos);
        this.projectedArcAngle.set(projectedTrackAngle);
        this.layerRef.instance.onUpdated();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        const props = {
            ref: this.layerRef,
            model: this.props.model,
            mapProjection: this.props.mapProjection,
            arcAngularWidth: this.arcAngularWidth,
            arcRadius: this.arcRadius,
            strokeWidth: this.strokeWidth,
            strokeStyle: this.strokeStyle,
            strokeLineCap: this.strokeLineCap,
            outlineWidth: this.outlineWidth,
            outlineStyle: this.outlineStyle,
            outlineLineCap: this.outlineLineCap,
            projectedArcPosition: this.projectedArcPosition,
            projectedArcAngle: this.projectedArcAngle,
            class: this.props.class,
        };
        return this.props.renderMethod === 'canvas'
            ? (FSComponent.buildComponent(MapAltitudeArcCanvasLayer, Object.assign({}, props))) : (FSComponent.buildComponent(MapAltitudeArcSvgLayer, Object.assign({}, props)));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e;
        (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.vsPrecisionMap) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.vsThresholdMap) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.altDevThresholdMap) === null || _d === void 0 ? void 0 : _d.destroy();
        this.vsFpm.destroy();
        (_e = this.isArcVisibleStatic) === null || _e === void 0 ? void 0 : _e.destroy();
        this.isArcVisibleDynamic.destroy();
        this.subscriptions.forEach(sub => sub.destroy());
        super.destroy();
    }
}
MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH = 60; // degrees
MapAltitudeArcLayer.DEFAULT_ARC_RADIUS = 64; // px
MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH = 2; // px
MapAltitudeArcLayer.DEFAULT_STROKE_STYLE = 'cyan';
MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP = 'butt';
MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH = 1; // px
MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE = '#505050';
MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP = 'butt';
MapAltitudeArcLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A map layer which draws an altitude intercept arc using canvas.
 */
class MapAltitudeArcCanvasLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
        this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
        this.canvasLayerRef = FSComponent.createRef();
        this.subscriptions = [];
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a, _b;
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
        const scheduleUpdate = () => { this.needUpdate = true; };
        this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const arcPos = this.props.projectedArcPosition.get();
        const display = this.canvasLayerRef.instance.display;
        display.clear();
        // Do not draw the arc if it is out of bounds.
        const projectedSize = this.props.mapProjection.getProjectedSize();
        const arcX = arcPos[0];
        const arcY = arcPos[1];
        const twiceRadius = this.props.arcRadius * 2;
        if (arcX <= -twiceRadius
            || arcX >= projectedSize[0] + twiceRadius
            || arcY <= -twiceRadius
            || arcY >= projectedSize[1] + twiceRadius) {
            return;
        }
        display.context.beginPath();
        const projectedArcAngle = this.props.projectedArcAngle.get();
        const center = Vec2Math.add(Vec2Math.setFromPolar(-this.props.arcRadius, projectedArcAngle, MapAltitudeArcCanvasLayer.vec2Cache[0]), arcPos, MapAltitudeArcCanvasLayer.vec2Cache[0]);
        const arcStart = Vec2Math.add(Vec2Math.setFromPolar(this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, MapAltitudeArcCanvasLayer.vec2Cache[1]), center, MapAltitudeArcCanvasLayer.vec2Cache[1]);
        display.context.moveTo(arcStart[0], arcStart[1]);
        display.context.arc(center[0], center[1], this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, projectedArcAngle + this.arcHalfAngularWidth);
        if (this.props.outlineWidth > 0) {
            display.context.lineWidth = this.totalArcThickness;
            display.context.strokeStyle = this.props.outlineStyle;
            display.context.lineCap = this.props.outlineLineCap;
            display.context.stroke();
        }
        if (this.props.strokeWidth > 0) {
            display.context.lineWidth = this.props.strokeWidth;
            display.context.strokeStyle = this.props.strokeStyle;
            display.context.lineCap = this.props.strokeLineCap;
            display.context.stroke();
        }
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: this.props.class }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.subscriptions.forEach(sub => sub.destroy());
        super.destroy();
    }
}
MapAltitudeArcCanvasLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A map layer which draws an altitude intercept arc using SVG.
 */
class MapAltitudeArcSvgLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
        this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
        this.width = this.props.arcRadius * (1 - Math.cos(this.arcHalfAngularWidth)) + this.totalArcThickness + 2;
        this.height = 2 * this.props.arcRadius * Math.sin(Math.min(this.arcHalfAngularWidth, MathUtils.HALF_PI)) + this.totalArcThickness + 2;
        this.svgStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': `${(this.totalArcThickness / 2 + 1) - this.width}px`,
            'top': `${-this.height / 2}px`,
            'width': `${this.width}px`,
            'height': `${this.height}px`,
            'transform': 'translate3d(0px, 0px, 0px) rotate(0rad)',
            'transform-origin': `${this.width - (this.totalArcThickness / 2 + 1)}px ${this.height / 2}px`
        });
        this.svgTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('rad'));
        this.needUpdate = false;
        this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            this.svgStyle.set('display', 'none');
        }
    }
    /** @inheritdoc */
    onAttached() {
        const scheduleUpdate = () => { this.needUpdate = true; };
        this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const arcPos = this.props.projectedArcPosition.get();
        // Hide the arc if it is out of bounds.
        const projectedSize = this.props.mapProjection.getProjectedSize();
        const arcX = arcPos[0];
        const arcY = arcPos[1];
        const twiceRadius = this.props.arcRadius * 2;
        if (arcX <= -twiceRadius
            || arcX >= projectedSize[0] + twiceRadius
            || arcY <= -twiceRadius
            || arcY >= projectedSize[1] + twiceRadius) {
            this.svgStyle.set('display', 'none');
        }
        else {
            this.svgStyle.set('display', '');
            this.svgTransform.getChild(0).set(arcX, arcY, 0, 0.1);
            this.svgTransform.getChild(1).set(this.props.projectedArcAngle.get(), 1e-4);
            this.svgStyle.set('transform', this.svgTransform.resolve());
        }
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        const svgPathStream = new SvgPathStream(0.01);
        const transformPathStream = new AffineTransformPathStream(svgPathStream);
        // Top of the arc is at (0, 0), so the center is at (-radius, 0).
        transformPathStream.beginPath();
        transformPathStream
            .addRotation(-this.arcHalfAngularWidth)
            .addTranslation(-this.props.arcRadius, 0);
        transformPathStream.moveTo(this.props.arcRadius, 0);
        transformPathStream.arc(0, 0, this.props.arcRadius, 0, this.props.arcAngularWidth);
        const path = svgPathStream.getSvgPath();
        return (FSComponent.buildComponent("svg", { viewBox: `${(this.totalArcThickness / 2 + 1) - this.width} ${-this.height / 2} ${this.width} ${this.height}`, style: this.svgStyle, class: this.props.class },
            FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.outlineStyle, "stroke-width": this.totalArcThickness, "stroke-linecap": this.props.outlineLineCap }),
            FSComponent.buildComponent("path", { d: path, fill: 'none', stroke: this.props.strokeStyle, "stroke-width": this.props.strokeWidth, "stroke-linecap": this.props.strokeLineCap })));
    }
    /** @inheritdoc */
    destroy() {
        this.subscriptions.forEach(sub => sub.destroy());
        super.destroy();
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
class MapBingLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.bingRef = FSComponent.createRef();
        this.wrapperStyle = ObjectSubject.create({
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'display': '',
            'transform': '',
            'opacity': '',
        });
        this.resolution = Vec2Subject.create(Vec2Math.create(1024, 1024));
        this.rotationTransform = CssTransformBuilder.rotate('rad');
        /** The length of this layer's diagonal, in pixels. */
        this.size = 0;
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.wrapperStyle.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        var _a;
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        (_a = this.props.opacity) === null || _a === void 0 ? void 0 : _a.sub((v) => {
            this.wrapperStyle.set('opacity', v.toString());
        }, true);
        if (this.props.wxrMode !== undefined) {
            this.props.wxrMode.sub(() => {
                this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
                this.needUpdate = true;
            });
        }
    }
    /** @inheritdoc */
    onWake() {
        this.bingRef.instance.wake();
    }
    /** @inheritdoc */
    onSleep() {
        this.bingRef.instance.sleep();
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        let offsetX, offsetY;
        if (this.props.wxrMode && this.props.wxrMode.get().mode === EWeatherRadar.HORIZONTAL) {
            const offsetSize = new Float64Array([projectedSize[0], projectedSize[1]]);
            const offset = this.props.mapProjection.getTargetProjectedOffset();
            offsetSize[0] += offset[0];
            offsetSize[1] += offset[1];
            this.size = this.getSize(offsetSize);
            offsetX = ((projectedSize[0] - this.size) / 2) + offset[0];
            offsetY = ((projectedSize[1] - this.size) / 2) + offset[1];
        }
        else {
            this.size = this.getSize(projectedSize);
            offsetX = (projectedSize[0] - this.size) / 2;
            offsetY = (projectedSize[1] - this.size) / 2;
        }
        this.wrapperStyle.set('left', `${offsetX}px`);
        this.wrapperStyle.set('top', `${offsetY}px`);
        this.wrapperStyle.set('width', `${this.size}px`);
        this.wrapperStyle.set('height', `${this.size}px`);
        this.resolution.set(this.size, this.size);
    }
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * We get the length of the hypotenuse so that the map edges won't show when rotating.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    getSize(projectedSize) {
        return Vec2Math.abs(projectedSize);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.ProjectedSize | MapProjectionChangeType.TargetProjected)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
        }
        if (this.bingRef.instance.isBound()) {
            this.needUpdate = true;
        }
    }
    /**
     * A callback which is called when the Bing component is bound.
     */
    onBingBound() {
        this.needUpdate = true;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.needUpdate) {
            return;
        }
        this.updatePositionRadius();
        this.needUpdate = false;
    }
    /**
     * Resets the underlying Bing component's img src attribute.
     */
    resetImgSrc() {
        this.bingRef.instance.resetImgSrc();
    }
    /**
     * Updates the Bing map center position and radius.
     */
    updatePositionRadius() {
        const center = this.props.mapProjection.getCenter();
        const radius = this.calculateDesiredRadius(this.props.mapProjection);
        this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
        if (!this.props.wxrMode || (this.props.wxrMode && this.props.wxrMode.get().mode !== EWeatherRadar.HORIZONTAL)) {
            this.rotationTransform.set(this.props.mapProjection.getRotation(), 1e-3);
        }
        else {
            this.rotationTransform.set(0);
        }
        this.wrapperStyle.set('transform', this.rotationTransform.resolve());
    }
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    calculateDesiredRadius(mapProjection) {
        const scaleFactor = mapProjection.getScaleFactor();
        const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
        const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
        return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        return (FSComponent.buildComponent("div", { style: this.wrapperStyle, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' },
            FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, onBoundCallback: this.onBingBound.bind(this), resolution: this.resolution, mode: (_b = this.props.mode) !== null && _b !== void 0 ? _b : EBingMode.PLANE, earthColors: this.props.earthColors, earthColorsElevationRange: this.props.earthColorsElevationRange, reference: this.props.reference, wxrMode: this.props.wxrMode, wxrColors: this.props.wxrColors, isoLines: this.props.isoLines, delay: this.props.delay })));
    }
}

/**
 * Implementation of MapCachedCanvasLayerReference.
 */
class MapCachedCanvasLayerReferenceClass {
    constructor() {
        this._center = new GeoPoint(0, 0);
        this._scaleFactor = 1;
        this._rotation = 0;
    }
    /** @inheritdoc */
    get center() {
        return this._center.readonly;
    }
    /** @inheritdoc */
    get scaleFactor() {
        return this._scaleFactor;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /**
     * Syncs this reference with the current state of a map projection.
     * @param mapProjection The map projection with which to sync.
     */
    syncWithMapProjection(mapProjection) {
        this._center.set(mapProjection.getCenter());
        this._scaleFactor = mapProjection.getScaleFactor();
        this._rotation = mapProjection.getRotation();
    }
    /**
     * Syncs this reference with another reference.
     * @param reference - the reference with which to sync.
     */
    syncWithReference(reference) {
        this._center.set(reference.center);
        this._scaleFactor = reference.scaleFactor;
        this._rotation = reference.rotation;
    }
}
/**
 * Implementation of MapCachedCanvasLayerTransform.
 */
class MapCachedCanvasLayerTransformClass {
    constructor() {
        this._scale = 0;
        this._rotation = 0;
        this._translation = new Float64Array(2);
        this._margin = 0;
        this._marginRemaining = 0;
    }
    /** @inheritdoc */
    get scale() {
        return this._scale;
    }
    /** @inheritdoc */
    get rotation() {
        return this._rotation;
    }
    /** @inheritdoc */
    get translation() {
        return this._translation;
    }
    /** @inheritdoc */
    get margin() {
        return this._margin;
    }
    /** @inheritdoc */
    get marginRemaining() {
        return this._marginRemaining;
    }
    /**
     * Updates this transform given the current map projection and a reference.
     * @param mapProjection The current map projection.
     * @param reference The reference to use.
     * @param referenceMargin The reference margin, in pixels.
     */
    update(mapProjection, reference, referenceMargin) {
        this._scale = mapProjection.getScaleFactor() / reference.scaleFactor;
        this._rotation = mapProjection.getRotation() - reference.rotation;
        mapProjection.project(reference.center, this._translation);
        Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
        this._margin = referenceMargin * this._scale;
        this._marginRemaining = this._margin - Math.max(Math.abs(this._translation[0]), Math.abs(this._translation[1]));
    }
    /**
     * Copies another transform's parameters to this one.
     * @param other The other transform.
     */
    copyFrom(other) {
        this._scale = other.scale;
        this._rotation = other.rotation;
        this._translation.set(other.translation);
        this._margin = other.margin;
    }
}
/**
 * An implementation of MapCachedCanvasLayerCanvasInstance.
 */
class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @param getReferenceMargin A function which gets this canvas instance's reference margin, in pixels. The reference
     * margin is the maximum amount of translation allowed without invalidation at a scale factor of 1.
     */
    constructor(canvas, context, isDisplayed, getReferenceMargin) {
        super(canvas, context, isDisplayed);
        this.getReferenceMargin = getReferenceMargin;
        this._reference = new MapCachedCanvasLayerReferenceClass();
        this._transform = new MapCachedCanvasLayerTransformClass();
        this._isInvalid = false;
        this._geoProjection = new MercatorProjection();
        this.canvasTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.scale(), CssTransformBuilder.translate('px'), CssTransformBuilder.rotate('rad')));
        this.canvasTransform.sub(transform => { this.canvas.style.transform = transform; }, true);
    }
    /** @inheritdoc */
    get reference() {
        return this._reference;
    }
    /** @inheritdoc */
    get transform() {
        return this._transform;
    }
    /** @inheritdoc */
    get isInvalid() {
        return this._isInvalid;
    }
    /** @inheritdoc */
    get geoProjection() {
        return this._geoProjection;
    }
    /** @inheritdoc */
    syncWithMapProjection(mapProjection) {
        const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
        this._reference.syncWithMapProjection(mapProjection);
        this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
        this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
        this._isInvalid = false;
        if (this.isDisplayed) {
            this.transformCanvasElement();
        }
    }
    /** @inheritdoc */
    syncWithCanvasInstance(other) {
        this._reference.syncWithReference(other.reference);
        this._geoProjection.copyParametersFrom(other.geoProjection);
        this._transform.copyFrom(other.transform);
        this._isInvalid = other.isInvalid;
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     */
    updateTransform(mapProjection) {
        this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
        if (!this._isInvalid) {
            const scaleFactorRatio = mapProjection.getScaleFactor() / this._reference.scaleFactor;
            this._isInvalid = scaleFactorRatio >= MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD
                || scaleFactorRatio <= 1 / MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD
                || this._transform.marginRemaining < 0;
        }
        if (this.isDisplayed && !this._isInvalid) {
            this.transformCanvasElement();
        }
    }
    /**
     * Transforms this instance's canvas element.
     */
    transformCanvasElement() {
        const transform = this.transform;
        const offsetX = transform.translation[0] / transform.scale;
        const offsetY = transform.translation[1] / transform.scale;
        this.canvasTransform.transform.getChild(0).set(transform.scale, transform.scale, 0.001);
        this.canvasTransform.transform.getChild(1).set(offsetX, offsetY, 0.1);
        this.canvasTransform.transform.getChild(2).set(transform.rotation, 1e-4);
        this.canvasTransform.resolve();
    }
    /** @inheritdoc */
    invalidate() {
        this._isInvalid = true;
        this.clear();
    }
}
MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD = 1.2;
MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
/**
 * A canvas map layer whose image can be cached and transformed as the map projection changes.
 */
class MapCachedCanvasLayer extends MapCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.size = 0;
        this.referenceMargin = 0;
        this.needUpdateTransforms = false;
        this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize() {
        return this.size;
    }
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale factor of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin() {
        return this.referenceMargin;
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
        this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    createCanvasInstance(canvas, context, isDisplayed) {
        return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed, this.getReferenceMargin.bind(this));
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
        const projectedWidth = projectedSize[0];
        const projectedHeight = projectedSize[1];
        const diag = Math.hypot(projectedWidth, projectedHeight);
        this.size = diag * this.props.overdrawFactor;
        this.referenceMargin = (this.size - diag) / 2;
        this.setWidth(this.size);
        this.setHeight(this.size);
        const posX = (projectedWidth - this.size) / 2;
        const posY = (projectedHeight - this.size) / 2;
        const displayCanvas = this.display.canvas;
        displayCanvas.style.left = `${posX}px`;
        displayCanvas.style.top = `${posY}px`;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        var _a;
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateFromProjectedSize(mapProjection.getProjectedSize());
            this.display.invalidate();
            (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.invalidate();
        }
        this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        if (!this.needUpdateTransforms) {
            return;
        }
        this.updateTransforms();
    }
    /**
     * Updates this layer's canvas instances' transforms.
     */
    updateTransforms() {
        var _a;
        const mapProjection = this.props.mapProjection;
        this.display.updateTransform(mapProjection);
        (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.updateTransform(mapProjection);
        this.needUpdateTransforms = false;
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A layer which draws an own airplane icon. The icon is positioned at the projected location of the airplane and is
 * rotated to match the airplane's heading.
 */
class MapOwnAirplaneLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.imageFilePath = SubscribableUtils.isSubscribable(this.props.imageFilePath)
            ? this.props.imageFilePath.map(SubscribableMapFunctions.identity())
            : this.props.imageFilePath;
        this.style = ObjectSubject.create({
            display: '',
            position: 'absolute',
            left: '0px',
            top: '0px',
            width: '0px',
            height: '0px',
            transform: 'translate3d(0, 0, 0) rotate(0deg)',
            'transform-origin': '50% 50%'
        });
        this.ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        this.ownAirplaneIconModule = this.props.model.getModule('ownAirplaneIcon');
        this.iconSize = SubscribableUtils.toSubscribable(this.props.iconSize, true);
        this.iconAnchor = SubscribableUtils.toSubscribable(this.props.iconAnchor, true);
        this.iconOffset = Vec2Math.create();
        this.visibilityBounds = VecNMath.create(4);
        this.iconTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('deg'));
        this.isGsAboveTrackThreshold = this.ownAirplanePropsModule.groundSpeed.map(gs => gs.asUnit(UnitType.KNOT) >= 5).pause();
        this.showIcon = true;
        this.isInsideVisibilityBounds = true;
        this.planeRotation = 0;
        this.needUpdateVisibility = false;
        this.needUpdatePositionRotation = false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    /** @inheritdoc */
    onAttached() {
        this.showSub = this.ownAirplaneIconModule.show.sub(show => {
            this.needUpdateVisibility = true;
            this.needUpdatePositionRotation = this.showIcon = show && this.isVisible();
        });
        this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
            this.needUpdatePositionRotation = this.showIcon;
        });
        this.headingSub = this.ownAirplanePropsModule.hdgTrue.sub(hdg => {
            this.planeRotation = hdg;
            this.needUpdatePositionRotation = this.showIcon;
        }, false, true);
        this.trackSub = this.ownAirplanePropsModule.trackTrue.sub(track => {
            this.planeRotation = track;
            this.needUpdatePositionRotation = this.showIcon;
        }, false, true);
        this.trackThresholdSub = this.isGsAboveTrackThreshold.sub(isAboveThreshold => {
            if (isAboveThreshold) {
                this.headingSub.pause();
                this.trackSub.resume(true);
            }
            else {
                this.trackSub.pause();
                this.headingSub.resume(true);
            }
        }, false, true);
        this.iconSizeSub = this.iconSize.sub(size => {
            this.style.set('width', `${size}px`);
            this.style.set('height', `${size}px`);
            this.updateOffset();
        }, true);
        this.iconAnchorSub = this.iconAnchor.sub(() => {
            this.updateOffset();
        });
        this.orientationSub = this.ownAirplaneIconModule.orientation.sub(orientation => {
            switch (orientation) {
                case MapOwnAirplaneIconOrientation.HeadingUp:
                    this.isGsAboveTrackThreshold.pause();
                    this.trackThresholdSub.pause();
                    this.trackSub.pause();
                    this.headingSub.resume(true);
                    break;
                case MapOwnAirplaneIconOrientation.TrackUp:
                    this.headingSub.pause();
                    this.trackSub.pause();
                    this.isGsAboveTrackThreshold.resume();
                    this.trackThresholdSub.resume(true);
                    break;
                default:
                    this.needUpdatePositionRotation = this.showIcon;
                    this.isGsAboveTrackThreshold.pause();
                    this.trackThresholdSub.pause();
                    this.headingSub.pause();
                    this.trackSub.pause();
                    this.planeRotation = 0;
            }
        }, true);
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = true;
    }
    /**
     * Updates the icon's offset from the projected position of the airplane.
     */
    updateOffset() {
        const anchor = this.iconAnchor.get();
        this.iconOffset.set(anchor);
        Vec2Math.multScalar(this.iconOffset, -this.iconSize.get(), this.iconOffset);
        this.style.set('left', `${this.iconOffset[0]}px`);
        this.style.set('top', `${this.iconOffset[1]}px`);
        this.style.set('transform-origin', `${anchor[0] * 100}% ${anchor[1] * 100}%`);
        this.updateVisibilityBounds();
    }
    /**
     * Updates the boundaries within the map's projected window that define a region such that if the airplane's
     * projected position falls outside of it, the icon is not visible and therefore does not need to be updated.
     */
    updateVisibilityBounds() {
        const size = this.iconSize.get();
        // Find the maximum possible protrusion of the icon from its anchor point, defined as the distance from the
        // anchor point to the farthest point within the bounds of the icon. This farthest point is always one of the
        // four corners of the icon.
        const maxProtrusion = Math.max(Math.hypot(this.iconOffset[0], this.iconOffset[1]), // top left corner
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1]), // top right corner
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1] + size), // bottom right corner
        Math.hypot(this.iconOffset[0], this.iconOffset[1] + size));
        const boundsOffset = maxProtrusion + 50; // Add some additional buffer
        const projectedSize = this.props.mapProjection.getProjectedSize();
        this.visibilityBounds[0] = -boundsOffset;
        this.visibilityBounds[1] = -boundsOffset;
        this.visibilityBounds[2] = projectedSize[0] + boundsOffset;
        this.visibilityBounds[3] = projectedSize[1] + boundsOffset;
        this.needUpdatePositionRotation = this.showIcon;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateVisibilityBounds();
        }
        this.needUpdatePositionRotation = this.showIcon;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (this.needUpdatePositionRotation) {
            this.updateIconPositionRotation();
            this.needUpdatePositionRotation = false;
            this.needUpdateVisibility = false;
        }
        else if (this.needUpdateVisibility) {
            this.updateIconVisibility();
            this.needUpdateVisibility = false;
        }
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
        this.style.set('display', this.isInsideVisibilityBounds && this.showIcon ? '' : 'none');
    }
    /**
     * Updates the airplane icon's projected position and rotation.
     */
    updateIconPositionRotation() {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.vec2Cache[0]);
        this.isInsideVisibilityBounds = this.props.mapProjection.isInProjectedBounds(projected, this.visibilityBounds);
        // If the projected position of the icon is far enough out of bounds that the icon is not visible, do not bother to
        // update the icon.
        if (this.isInsideVisibilityBounds) {
            let rotation;
            switch (this.ownAirplaneIconModule.orientation.get()) {
                case MapOwnAirplaneIconOrientation.HeadingUp:
                case MapOwnAirplaneIconOrientation.TrackUp:
                    rotation = this.planeRotation + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
                    break;
                default:
                    rotation = 0;
            }
            this.iconTransform.getChild(0).set(projected[0], projected[1], 0, 0.1);
            this.iconTransform.getChild(1).set(rotation, 0.1);
            this.style.set('transform', this.iconTransform.resolve());
        }
        this.updateIconVisibility();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("img", { src: this.imageFilePath, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '', style: this.style }));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (SubscribableUtils.isSubscribable(this.imageFilePath)) {
            this.imageFilePath.destroy();
        }
        this.isGsAboveTrackThreshold.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.positionSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.headingSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.trackSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.trackThresholdSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.iconSizeSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.iconAnchorSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.orientationSub) === null || _h === void 0 ? void 0 : _h.destroy();
        super.destroy();
    }
}
MapOwnAirplaneLayer.vec2Cache = [Vec2Math.create()];

/**
 * A layer which displays text which can be culled to avoid overlap.
 */
class MapCullableTextLayer extends MapSyncedCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        super.onUpdated(time, elapsed);
        this.props.manager.update(this.props.mapProjection);
        this.redrawLabels();
    }
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    redrawLabels() {
        const labels = this.props.manager.visibleLabels;
        const display = this.display;
        display.clear();
        for (let i = labels.length - 1; i >= 0; i--) {
            labels[i].draw(display.context, this.props.mapProjection);
        }
    }
}

/**
 * A layer which draws airspaces.
 */
class MapAirspaceLayer extends MapLayer {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.clipBoundsSub = VecNSubject.createFromVector(new Float64Array(4));
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), async () => {
            this.searchSession = new NearestLodBoundarySearchSession(this.props.lodBoundaryCache, await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary), 0.5);
            this.isAttached && this.scheduleSearch(0, true);
        });
        this.searchedAirspaces = new Map();
        this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;
        this.renderTimeBudget = (_b = this.props.renderTimeBudget) !== null && _b !== void 0 ? _b : MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;
        this.activeRenderProcess = null;
        this.renderTaskQueueHandler = {
            renderTimeBudget: this.renderTimeBudget,
            // eslint-disable-next-line jsdoc/require-jsdoc
            onStarted() {
                // noop
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
                return timeElapsed < this.renderTimeBudget;
            },
            // eslint-disable-next-line jsdoc/require-jsdoc
            onPaused: this.onRenderPaused.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onFinished: this.onRenderFinished.bind(this),
            // eslint-disable-next-line jsdoc/require-jsdoc
            onAborted: this.onRenderAborted.bind(this)
        };
        this.searchDebounceTimer = 0;
        this.isSearchScheduled = false;
        this.needRefilter = false;
        this.isSearchBusy = false;
        this.lastDesiredSearchRadius = 0; // meters
        this.lastSearchRadius = 0; // meters
        this.isRenderScheduled = false;
        this.isBackgroundRenderScheduled = false;
        this.isDisplayInvalidated = true;
        this.isAttached = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
        this.updateClipBounds();
        this.clippedPathStream = new ClippedPathStream(this.canvasLayerRef.instance.buffer.context, this.clipBoundsSub);
        this.props.maxSearchRadius.sub(radius => {
            const radiusMeters = radius.asUnit(UnitType.METER);
            if (radiusMeters < this.lastSearchRadius || radiusMeters > this.lastDesiredSearchRadius) {
                this.scheduleSearch(0, false);
            }
        });
        this.props.maxSearchItemCount.sub(() => { this.scheduleSearch(0, false); });
        this.initModuleListeners();
        this.isAttached = true;
        this.searchSession && this.scheduleSearch(0, true);
    }
    /**
     * Initializes this layer's airspace module property listeners.
     */
    initModuleListeners() {
        const airspaceModule = this.props.model.getModule('airspace');
        for (const type of Object.values(airspaceModule.show)) {
            type.sub(this.onAirspaceTypeShowChanged.bind(this));
        }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.updateClipBounds();
        }
    }
    /**
     * Updates this layer's canvas clipping bounds.
     */
    updateClipBounds() {
        const size = this.canvasLayerRef.instance.getSize();
        this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER, -MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER);
    }
    /**
     * Schedules a search. If a search was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     * @param refilter Whether to update the search's boundary class filter.
     */
    scheduleSearch(delay, refilter) {
        if (!this.searchSession) {
            return;
        }
        this.searchDebounceTimer = delay;
        this.isSearchScheduled = true;
        this.needRefilter || (this.needRefilter = refilter);
    }
    /**
     * Schedules a render to be executed during the next update cycle.
     */
    scheduleRender() {
        this.isRenderScheduled = true;
    }
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     * @param refilter Whether to update the search's boundary class filter.
     */
    async searchAirspaces(refilter) {
        this.isSearchBusy = true;
        const center = this.props.mapProjection.getCenter();
        const drawableDiag = this.canvasLayerRef.instance.display.canvas.width * Math.SQRT2;
        this.lastDesiredSearchRadius = UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution() * drawableDiag / 2, UnitType.METER);
        this.lastSearchRadius = Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER), this.lastDesiredSearchRadius);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const session = this.searchSession;
        refilter && session.setFilter(this.getBoundaryFilter());
        const results = await session.searchNearest(center.lat, center.lon, this.lastSearchRadius, this.props.maxSearchItemCount.get());
        for (let i = 0; i < results.added.length; i++) {
            const airspace = results.added[i];
            this.searchedAirspaces.set(airspace.facility.id, airspace);
        }
        for (let i = 0; i < results.removed.length; i++) {
            this.searchedAirspaces.delete(results.removed[i]);
        }
        this.isSearchBusy = false;
        this.scheduleRender();
    }
    /**
     * Gets the boundary class filter based on the current airspace type visibility settings.
     * @returns The boundary class filter based on the current airspace type visibility settings.
     */
    getBoundaryFilter() {
        const module = this.props.model.getModule('airspace');
        const show = module.show;
        let filter = 0;
        for (const type in show) {
            if (show[type].get()) {
                filter |= module.showTypes[type];
            }
        }
        return filter;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
        this.updateFromInvalidation();
        this.updateScheduledRender();
        this.updateScheduledSearch(elapsed);
    }
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    updateFromInvalidation() {
        const canvasLayer = this.canvasLayerRef.instance;
        const display = canvasLayer.display;
        const buffer = canvasLayer.buffer;
        const needBackgroundRender = !this.isBackgroundRenderScheduled
            && !this.activeRenderProcess
            && (display.transform.marginRemaining / display.transform.margin <= MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD);
        const shouldScheduleSearch = needBackgroundRender
            || display.isInvalid
            || (buffer.isInvalid && this.activeRenderProcess);
        this.isBackgroundRenderScheduled || (this.isBackgroundRenderScheduled = needBackgroundRender);
        if (display.isInvalid) {
            this.isDisplayInvalidated = true;
            this.isBackgroundRenderScheduled = false;
            display.clear();
            display.syncWithMapProjection(this.props.mapProjection);
        }
        if (buffer.isInvalid) {
            if (this.activeRenderProcess) {
                this.activeRenderProcess.abort();
                this.cleanUpRender();
            }
            buffer.clear();
            buffer.syncWithMapProjection(this.props.mapProjection);
        }
        if (shouldScheduleSearch) {
            this.scheduleSearch(this.searchDebounceDelay, false);
        }
    }
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledSearch(elapsed) {
        if (!this.isSearchScheduled) {
            return;
        }
        this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
        if (this.searchDebounceTimer === 0 && !this.isSearchBusy) {
            this.searchAirspaces(this.needRefilter);
            this.isSearchScheduled = false;
            this.needRefilter = false;
        }
    }
    /**
     * Executes a render if one is scheduled.
     */
    updateScheduledRender() {
        if (!this.isRenderScheduled) {
            return;
        }
        this.startRenderProcess();
        this.isRenderScheduled = false;
        this.isBackgroundRenderScheduled = false;
    }
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     */
    startRenderProcess() {
        const canvasLayer = this.canvasLayerRef.instance;
        if (this.activeRenderProcess) {
            this.activeRenderProcess.abort();
        }
        const buffer = canvasLayer.buffer;
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection);
        this.props.airspaceRenderManager.clearRegisteredAirspaces();
        for (const airspace of this.searchedAirspaces.values()) {
            if (this.isAirspaceInBounds(airspace, buffer)) {
                this.props.airspaceRenderManager.registerAirspace(airspace);
            }
        }
        const lod = this.selectLod(this.props.mapProjection.getProjectedResolution());
        this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection, buffer.context, this.renderTaskQueueHandler, lod, this.clippedPathStream);
        this.activeRenderProcess.start();
    }
    /**
     * Checks whether an airspace is within the projected bounds of a cached canvas instance.
     * @param airspace An airspace.
     * @param canvas A cached canvas instance.
     * @returns Whether the airspace is within the projected bounds of the cached canvas instance.
     */
    isAirspaceInBounds(airspace, canvas) {
        const corner = MapAirspaceLayer.geoPointCache[0];
        const cornerProjected = MapAirspaceLayer.vec2Cache[0];
        let minX, maxX, minY, maxY;
        canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.topLeft.long), cornerProjected);
        minX = maxX = cornerProjected[0];
        minY = maxY = cornerProjected[1];
        canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.bottomRight.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.bottomRight.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.topLeft.long), cornerProjected);
        minX = Math.min(minX, cornerProjected[0]);
        maxX = Math.max(maxX, cornerProjected[0]);
        minY = Math.min(minY, cornerProjected[1]);
        maxY = Math.max(maxY, cornerProjected[1]);
        const width = canvas.canvas.width;
        const height = canvas.canvas.height;
        return minX < width
            && maxX > 0
            && minY < height
            && maxY > 0;
    }
    /**
     * Selects an LOD level based on projected map resolution.
     * @param resolution A projected map resolution, in great-arc radians per pixel.
     * @returns An LOD level based on the projected map resolution.
     */
    selectLod(resolution) {
        const thresholds = this.props.lodBoundaryCache.lodDistanceThresholds;
        let i = thresholds.length - 1;
        while (i >= 0) {
            if (resolution * 2 >= thresholds[i]) {
                break;
            }
            i--;
        }
        return i;
    }
    /**
     * Cleans up the active render process.
     */
    cleanUpRender() {
        this.canvasLayerRef.instance.buffer.reset();
        this.activeRenderProcess = null;
    }
    /**
     * Renders airspaces from the buffer to the display.
     */
    renderAirspacesToDisplay() {
        const display = this.canvasLayerRef.instance.display;
        const buffer = this.canvasLayerRef.instance.buffer;
        display.clear();
        display.syncWithCanvasInstance(buffer);
        this.canvasLayerRef.instance.copyBufferToDisplay();
    }
    /**
     * This method is called when the airspace render process pauses.
     */
    onRenderPaused() {
        if (this.isDisplayInvalidated) {
            this.renderAirspacesToDisplay();
        }
    }
    /**
     * This method is called when the airspace render process finishes.
     */
    onRenderFinished() {
        this.renderAirspacesToDisplay();
        this.cleanUpRender();
        this.isDisplayInvalidated = false;
    }
    /**
     * This method is called when the airspace render process is aborted.
     */
    onRenderAborted() {
        this.cleanUpRender();
    }
    /**
     * This method is called when an airspace show property changes.
     */
    onAirspaceTypeShowChanged() {
        this.scheduleSearch(0, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 }));
    }
}
MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY = 500; // milliseconds
MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET = 0.2; // milliseconds per frame
MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD = 0.1; // relative to total margin
MapAirspaceLayer.CLIP_BOUNDS_BUFFER = 10; // number of pixels from edge of canvas to extend the clipping bounds, in pixels
MapAirspaceLayer.geoPointCache = [new GeoPoint(0, 0)];
MapAirspaceLayer.vec2Cache = [new Float64Array(2)];

/**
 * An abstract implementation of a map layer which displays waypoints (airports, navaids, and intersections) within a
 * search radius.
 */
class MapNearestWaypointsLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : 500;
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
        this.searchRadius = 0;
        this.searchMargin = 0;
        this.userFacilityHasChanged = false;
        /** A set of the ICAOs of all waypoints that should be rendered. */
        this.icaosToRender = new Set();
        /** A map of rendered waypoints from their ICAOs. */
        this.cachedRenderedWaypoints = new Map();
        this.isInit = false;
        this.facilityRepoSubs = [];
    }
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    onFacilityLoaderInitialized() {
        Promise.all([
            this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
            this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection),
            this.facLoader.startNearestSearchSession(FacilitySearchType.User)
        ]).then((value) => {
            const [airportSession, vorSession, ndbSession, intSession, userSession] = value;
            this.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
        });
    }
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     * @param userSession The user facility search session.
     */
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession) {
        const callback = this.processSearchResults.bind(this);
        this.facilitySearches = {
            [FacilitySearchType.Airport]: new MapNearestWaypointsLayerSearch(airportSession, callback),
            [FacilitySearchType.Vor]: new MapNearestWaypointsLayerSearch(vorSession, callback),
            [FacilitySearchType.Ndb]: new MapNearestWaypointsLayerSearch(ndbSession, callback),
            [FacilitySearchType.Intersection]: new MapNearestWaypointsLayerSearch(intSession, callback),
            [FacilitySearchType.User]: new MapNearestWaypointsLayerSearch(userSession, callback)
        };
        const sub = this.props.bus.getSubscriber();
        // Watch for changes to user facilities so that we can trigger search refreshes to ensure that the layer does not
        // display outdated user waypoints.
        this.facilityRepoSubs.push(sub.on('facility_added').handle(fac => {
            if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
                this.userFacilityHasChanged = true;
            }
        }), sub.on('facility_changed').handle(fac => {
            if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
                this.userFacilityHasChanged = true;
            }
        }), sub.on('facility_removed').handle(fac => {
            if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
                this.userFacilityHasChanged = true;
            }
        }));
        this.props.onSessionsStarted && this.props.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
        if (this.isInit) {
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.canvasLayerRef.instance.onAttached();
        this.doInit();
        this.isInit = true;
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
    }
    /**
     * Initializes this layer.
     */
    doInit() {
        this.initWaypointRenderer();
        this.updateSearchRadius();
    }
    /**
     * Gets the search center for the waypoint searches on this layer.
     * @returns The waypoint search center geo point.
     */
    getSearchCenter() {
        return this.props.getSearchCenter ? this.props.getSearchCenter(this.props.mapProjection) : this.props.mapProjection.getCenter();
    }
    /**
     * Initializes this layer's waypoint renderer.
     */
    initWaypointRenderer() {
        this.props.initRenderer && this.props.initRenderer(this.props.waypointRenderer, this.canvasLayerRef.instance);
    }
    /** Forces a refresh of all the waypoints. */
    refreshWaypoints() {
        this.tryRefreshAllSearches(undefined, undefined, true);
        this.cachedRenderedWaypoints.forEach(w => {
            this.props.deregisterWaypoint(w, this.props.waypointRenderer);
        });
        this.cachedRenderedWaypoints.forEach(w => {
            this.props.registerWaypoint(w, this.props.waypointRenderer);
        });
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.RangeEndpoints | MapProjectionChangeType.ProjectedSize)) {
            this.updateSearchRadius();
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
        else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
            this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
        }
    }
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    updateSearchRadius() {
        let mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
        //Limit lower end of radius so that even at high zooms the surrounding area waypoints are captured.
        mapHalfDiagRange = Math.max(mapHalfDiagRange, UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
        this.searchRadius = mapHalfDiagRange * MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
        this.searchMargin = mapHalfDiagRange * (MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        var _a;
        // If a user facility was added, changed, or removed, schedule a user waypoint search refresh so that we always
        // have the latest user facility data.
        if (this.userFacilityHasChanged) {
            const search = (_a = this.facilitySearches) === null || _a === void 0 ? void 0 : _a[FacilitySearchType.User];
            if (search !== undefined) {
                this.userFacilityHasChanged = false;
                this.scheduleSearchRefresh(FacilitySearchType.User, search, this.getSearchCenter(), this.searchRadius);
            }
        }
        this.updateSearches(elapsed);
    }
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSearches(elapsed) {
        if (!this.facilitySearches) {
            return;
        }
        this.facilitySearches[FacilitySearchType.Airport].update(elapsed);
        this.facilitySearches[FacilitySearchType.Vor].update(elapsed);
        this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);
        this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);
        this.facilitySearches[FacilitySearchType.User].update(elapsed);
    }
    /**
     * Attempts to refresh all of the nearest facility searches. Searches will only be refreshed if the desired search
     * radius is different from the last refreshed search radius or the desired search center is outside of the margin
     * of the last refreshed search center.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshAllSearches(center, radius, force) {
        center !== null && center !== void 0 ? center : (center = this.getSearchCenter());
        radius !== null && radius !== void 0 ? radius : (radius = this.searchRadius);
        this._tryRefreshAllSearches(center, radius, force);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if the desired search radius is different
     * from the last refreshed search radius or the desired search center is outside of the margin of the last refreshed
     * search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshSearch(type, center, radius, force) {
        center !== null && center !== void 0 ? center : (center = this.getSearchCenter());
        radius !== null && radius !== void 0 ? radius : (radius = this.searchRadius);
        this._tryRefreshSearch(type, center, radius, force);
    }
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    _tryRefreshAllSearches(center, radius, force) {
        this._tryRefreshSearch(FacilitySearchType.Airport, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.Vor, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.Ndb, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.Intersection, center, radius, force);
        this._tryRefreshSearch(FacilitySearchType.User, center, radius, force);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if `this.shouldRefreshSearch()` returns
     * true and and the desired search radius is different from the last refreshed search radius or the desired search
     * center is outside of the margin of the last refreshed search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    _tryRefreshSearch(type, center, radius, force) {
        const search = this.facilitySearches && this.facilitySearches[type];
        if (!search || (!force && !this.shouldRefreshSearch(type, center, radius))) {
            return;
        }
        const radiusLimit = this.props.searchRadiusLimit ? this.props.searchRadiusLimit(type, center, radius) : undefined;
        if (radiusLimit !== undefined && isFinite(radiusLimit)) {
            radius = Math.min(radius, Math.max(0, radiusLimit));
        }
        if (force || search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
            this.scheduleSearchRefresh(type, search, center, radius);
        }
    }
    /**
     * Checks whether one of this layer's searches should be refreshed.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @returns Whether the search should be refreshed.
     */
    shouldRefreshSearch(type, center, radius) {
        return this.props.shouldRefreshSearch ? this.props.shouldRefreshSearch(type, center, radius) : true;
    }
    /**
     * Schedules a refresh of this one of this layer's searches.
     * @param type The type of nearest search to refresh.
     * @param search The search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    scheduleSearchRefresh(type, search, center, radius) {
        const itemLimit = this.props.searchItemLimit ? this.props.searchItemLimit(type, center, radius) : 100;
        search.scheduleRefresh(center, radius, itemLimit, this.searchDebounceDelay);
    }
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are
     * deregistered.
     * @param results Nearest facility search results.
     */
    processSearchResults(results) {
        if (!results) {
            return;
        }
        const numAdded = results.added.length;
        for (let i = 0; i < numAdded; i++) {
            const icao = results.added[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.registerIcao(icao);
        }
        const numRemoved = results.removed.length;
        for (let i = 0; i < numRemoved; i++) {
            const icao = results.removed[i];
            if (icao === undefined || icao === ICAO.emptyIcao) {
                continue;
            }
            this.deregisterIcao(icao);
        }
    }
    /**
     * Registers an ICAO string with this layer. Once an ICAO is registered, its corresponding facility is drawn to this
     * layer using a waypoint renderer.
     * @param icao The ICAO string to register.
     */
    async registerIcao(icao) {
        this.icaosToRender.add(icao);
        try {
            const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
            if (!this.icaosToRender.has(icao)) {
                return;
            }
            this.registerWaypointWithRenderer(this.props.waypointRenderer, facility);
        }
        catch (_a) {
            // noop
        }
    }
    /**
     * Registers a facility with this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to register.
     */
    registerWaypointWithRenderer(renderer, facility) {
        const waypoint = this.props.waypointForFacility(facility);
        this.cachedRenderedWaypoints.set(facility.icao, waypoint);
        this.props.registerWaypoint(waypoint, renderer);
    }
    /**
     * Deregisters an ICAO string from this layer.
     * @param icao The ICAO string to deregister.
     */
    async deregisterIcao(icao) {
        this.icaosToRender.delete(icao);
        try {
            const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
            if (this.icaosToRender.has(icao)) {
                return;
            }
            this.deregisterWaypointWithRenderer(this.props.waypointRenderer, facility);
        }
        catch (_a) {
            if (this.icaosToRender.has(icao)) {
                return;
            }
            // If we can't find the facility from the ICAO, it could be that the facility has been removed, in which case
            // we grab the cached waypoint (the waypoint that was most recently registered with the renderer under the
            // removed ICAO) and deregister it.
            const cachedWaypoint = this.cachedRenderedWaypoints.get(icao);
            if (cachedWaypoint !== undefined) {
                this.cachedRenderedWaypoints.delete(icao);
                this.props.deregisterWaypoint(cachedWaypoint, this.props.waypointRenderer);
            }
        }
    }
    /**
     * Deregisters a facility from this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to deregister.
     */
    deregisterWaypointWithRenderer(renderer, facility) {
        const waypoint = this.props.waypointForFacility(facility);
        this.cachedRenderedWaypoints.delete(facility.icao);
        this.props.deregisterWaypoint(waypoint, renderer);
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.canvasLayerRef.instance.setVisible(val);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.facilityRepoSubs.forEach(sub => { sub.destroy(); });
        super.destroy();
    }
}
MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
/**
 * A nearest facility search for MapAbstractNearestWaypointsLayer.
 */
class MapNearestWaypointsLayerSearch {
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session, refreshCallback) {
        this.session = session;
        this.refreshCallback = refreshCallback;
        this._lastCenter = new GeoPoint(0, 0);
        this._lastRadius = 0;
        this.maxItemCount = 0;
        this.refreshDebounceTimer = 0;
        this.isRefreshScheduled = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this search's last refresh.
     */
    get lastCenter() {
        return this._lastCenter.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius() {
        return this._lastRadius;
    }
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param maxItemCount The maximum number of results returned by the refresh.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center, radius, maxItemCount, delay) {
        this._lastCenter.set(center);
        this._lastRadius = radius;
        this.maxItemCount = maxItemCount;
        if (!this.isRefreshScheduled) {
            this.refreshDebounceTimer = delay;
            this.isRefreshScheduled = true;
        }
    }
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed) {
        if (!this.isRefreshScheduled) {
            return;
        }
        this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
        if (this.refreshDebounceTimer === 0) {
            this.refresh();
            this.isRefreshScheduled = false;
        }
    }
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled when the refresh completes.
     */
    async refresh() {
        const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxItemCount);
        this.refreshCallback(results);
    }
}

/**
 * A map controller.
 */
class MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     */
    constructor(context) {
        this._isAlive = true;
        this.context = context;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this controller is alive. */
    get isAlive() {
        return this._isAlive;
    }
    /**
     * This method is called after this controller' map is rendered.
     * @param ref A reference to the rendered map.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterMapRender(ref) {
        // noop
    }
    /**
     * This method is called when the dead zone of this controller's map changes.
     * @param deadZone The map's new dead zone.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDeadZoneChanged(deadZone) {
        // noop
    }
    /**
     * This method is called when the projection of this controller's map changes.
     * @param mapProjection The map projection.
     * @param changeFlags Bit flags describing the type of change.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
        // noop
    }
    /**
     * This method is called immediately before this controller's map updates its layers.
     * @param time The current time, as a Javascript timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onBeforeUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called immediately after this controller's map updates its layers.
     * @param time The current time, as a Javascript timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterUpdated(time, elapsed) {
        // noop
    }
    /**
     * This method is called when this controller's map is awakened.
     */
    onWake() {
        // noop
    }
    /**
     * This method is called when this controller's map is put to sleep.
     */
    onSleep() {
        // noop
    }
    /**
     * This method is called when this controller's map is destroyed.
     */
    onMapDestroyed() {
        // noop
    }
    /**
     * Destroys this controller.
     */
    destroy() {
        this._isAlive = false;
    }
}

/**
 * A controller which maintains an arbitrary number of bindings.
 */
class MapBindingsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param bindings This controller's bindings.
     * @param onDestroy A function to execute when the controller is destroyed.
     */
    constructor(context, bindings, onDestroy) {
        super(context);
        this.bindings = bindings;
        this.onDestroy = onDestroy;
        this.maps = [];
        this.pipes = [];
    }
    /** @inheritdoc */
    onAfterMapRender() {
        for (const binding of this.bindings) {
            if ('map' in binding) {
                if ('sources' in binding) {
                    const map = MappedSubject.create(...binding.sources);
                    this.maps.push(map);
                    this.pipes.push(map.pipe(binding.target, binding.map));
                }
                else {
                    this.pipes.push(binding.source.pipe(binding.target, binding.map));
                }
            }
            else {
                this.pipes.push(binding.source.pipe(binding.target));
            }
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    onWake() {
        this.maps.forEach(map => { map.resume(); });
        this.pipes.forEach(pipe => { pipe.resume(true); });
    }
    /** @inheritdoc */
    onSleep() {
        this.maps.forEach(map => { map.pause(); });
        this.pipes.forEach(pipe => { pipe.pause(); });
    }
    /** @inheritdoc */
    destroy() {
        this.onDestroy && this.onDestroy();
        this.maps.forEach(map => { map.destroy(); });
        this.pipes.forEach(pipe => { pipe.destroy(); });
        super.destroy();
    }
}

/**
 * Updates a map at regular intervals based on event bus clock events.
 */
class MapClockUpdateController extends MapSystemController {
    /** @inheritdoc */
    onAfterMapRender(ref) {
        this.freqSub = this.context.updateFreq.sub(freq => {
            var _a;
            (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.clockSub = this.context.bus.getSubscriber().on('realTime').atFrequency(freq).handle(realTime => {
                ref.update(realTime);
            });
        }, true);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.freqSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/**
 * Controls the map system's flight plan module.
 */
class MapFlightPlanController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
        this.planCopiedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.targetPlanIndex));
            this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).planChanged.notify(this);
        };
        this.planCreatedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.planIndex));
        };
        this.planDeletedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(undefined);
        };
        this.planChangeHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).planChanged.notify(this);
        };
        this.planCalculatedHandler = (evt) => {
            this.flightPlanModule.getPlanSubjects(evt.planIndex).planCalculated.notify(this);
        };
        this.activeLegChangedHandler = (evt) => {
            if (evt.type === ActiveLegType.Lateral) {
                this.flightPlanModule.getPlanSubjects(evt.planIndex).activeLeg.set(evt.index);
            }
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.fplCopiedSub = sub.on('fplCopied').handle(this.planCopiedHandler);
        this.fplCreatedSub = sub.on('fplCreated').handle(this.planCreatedHandler);
        this.fplDeletedSub = sub.on('fplDeleted').handle(this.planDeletedHandler);
        this.fplDirectToDataChangedSub = sub.on('fplDirectToDataChanged').handle(this.planChangeHandler);
        this.fplLoadedSub = sub.on('fplLoaded').handle(this.planCreatedHandler);
        this.fplOriginDestChangedSub = sub.on('fplOriginDestChanged').handle(this.planChangeHandler);
        this.fplProcDetailsChangedSub = sub.on('fplProcDetailsChanged').handle(this.planChangeHandler);
        this.fplSegmentChangeSub = sub.on('fplSegmentChange').handle(this.planChangeHandler);
        this.fplUserDataDeleteSub = sub.on('fplUserDataDelete').handle(this.planChangeHandler);
        this.fplUserDataSetSub = sub.on('fplUserDataSet').handle(this.planChangeHandler);
        this.fplActiveLegChangeSub = sub.on('fplActiveLegChange').handle(this.activeLegChangedHandler);
        this.fplCalculatedSub = sub.on('fplCalculated').handle(this.planCalculatedHandler);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super.destroy();
        (_a = this.fplCopiedSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.fplCreatedSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.fplDeletedSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.fplDirectToDataChangedSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.fplLoadedSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.fplOriginDestChangedSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.fplProcDetailsChangedSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.fplSegmentChangeSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.fplUserDataDeleteSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.fplUserDataSetSub) === null || _k === void 0 ? void 0 : _k.destroy();
        (_l = this.fplActiveLegChangeSub) === null || _l === void 0 ? void 0 : _l.destroy();
        (_m = this.fplCalculatedSub) === null || _m === void 0 ? void 0 : _m.destroy();
    }
}

/**
 * Controls the target position of a map to follow the player airplane.
 */
class MapFollowAirplaneController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.isFollowingAirplane = this.context.model.getModule(MapSystemKeys.FollowAirplane).isFollowing;
        this.mapProjectionParams = {
            target: new GeoPoint(0, 0)
        };
        this.targetControl = this.context[MapSystemKeys.TargetControl];
        this.targetControlConsumer = {
            priority: 0,
            onAcquired: () => {
                this.isFollowingAirplane.set(true);
            },
            onCeded: () => {
                this.isFollowingAirplane.set(false);
            }
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.targetControl.claim(this.targetControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.isFollowingAirplane.get()) {
            this.mapProjectionParams.target.set(this.ownAirplanePropsModule.position.get());
            this.context.projection.setQueued(this.mapProjectionParams);
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.targetControl.forfeit(this.targetControlConsumer);
    }
}

/**
 * An enumeration of possible map rotation types.
 */
var MapRotation;
(function (MapRotation) {
    /** Map up position does not follow a defined pattern. */
    MapRotation["Undefined"] = "Undefined";
    /** Map up position points towards true north. */
    MapRotation["NorthUp"] = "NorthUp";
    /** Map up position points towards the current airplane track. */
    MapRotation["TrackUp"] = "TrackUp";
    /** Map up position points towards the current airplane heading. */
    MapRotation["HeadingUp"] = "HeadingUp";
    /** Map up position points towards the current nav desired track. */
    MapRotation["DtkUp"] = "DtkUp";
})(MapRotation || (MapRotation = {}));
/**
 * A module describing the rotation behavior of the map.
 */
class MapRotationModule {
    constructor() {
        /** The type of map rotation to use. */
        this.rotationType = Subject.create(MapRotation.HeadingUp);
    }
}

/**
 * Controls the orientation of the own airplane icon set in {@link MapOwnAirplaneIconModule} based on a desired
 * orientation and the map rotation type. If the desired orientation matches the map rotation (e.g. both Heading Up),
 * the icon orientation is set to Map Up; otherwise the orientation is set to the desired orientation.
 */
class MapOwnAirplaneIconOrientationController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     */
    constructor(context, desiredOrientation) {
        super(context);
        this.ownAirplaneIconModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
        this.needUpdateIconOrientation = false;
        this.desiredIconOrientation = SubscribableUtils.toSubscribable(desiredOrientation, true);
        this.orientationState = MappedSubject.create(this.desiredIconOrientation, this.context.model.getModule(MapSystemKeys.Rotation).rotationType);
    }
    /** @inheritdoc */
    onAfterMapRender() {
        var _a;
        (_a = this.orientationState) === null || _a === void 0 ? void 0 : _a.sub(() => { this.needUpdateIconOrientation = true; }, true);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.needUpdateIconOrientation) {
            const [desiredOrientation, rotation] = this.orientationState.get();
            if ((desiredOrientation === MapOwnAirplaneIconOrientation.HeadingUp && rotation === MapRotation.HeadingUp)
                || (desiredOrientation === MapOwnAirplaneIconOrientation.TrackUp && rotation === MapRotation.TrackUp)) {
                this.ownAirplaneIconModule.orientation.set(MapOwnAirplaneIconOrientation.MapUp);
            }
            else {
                this.ownAirplaneIconModule.orientation.set(desiredOrientation);
            }
            this.needUpdateIconOrientation = false;
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        this.orientationState.destroy();
        super.destroy();
    }
}

/**
 * Updates the properties in a {@link MapOwnAirplanePropsModule}.
 */
class MapOwnAirplanePropsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz.
     */
    constructor(context, properties, updateFreq) {
        super(context);
        this.properties = properties;
        this.updateFreq = updateFreq;
        this.module = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.updateFreqSub = this.updateFreq.sub(freq => {
            var _a;
            for (const property of this.properties) {
                (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
                this.subs[property] = this.bindProperty(sub, property, freq);
            }
        }, true);
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
        switch (property) {
            case 'position':
                return sub.on('gps-position').atFrequency(updateFreq).handle(lla => { this.module.position.set(lla.lat, lla.long); });
            case 'altitude':
                return sub.on('indicated_alt').atFrequency(updateFreq).handle(alt => { this.module.altitude.set(alt, UnitType.FOOT); });
            case 'groundSpeed':
                return sub.on('ground_speed').atFrequency(updateFreq).handle(gs => { this.module.groundSpeed.set(gs, UnitType.KNOT); });
            case 'hdgTrue':
                return sub.on('hdg_deg_true').atFrequency(updateFreq).handle(hdg => { this.module.hdgTrue.set(hdg); });
            case 'trackTrue':
                return sub.on('track_deg_true').atFrequency(updateFreq).handle(track => { this.module.trackTrue.set(track); });
            case 'verticalSpeed':
                return sub.on('vertical_speed').atFrequency(updateFreq).handle(vs => { this.module.verticalSpeed.set(vs, UnitType.FPM); });
            case 'turnRate':
                return sub.on('delta_heading_rate').atFrequency(updateFreq).handle(turnRate => { this.module.turnRate.set(turnRate); });
            case 'isOnGround':
                return sub.on('on_ground').atFrequency(updateFreq).handle(isOnGround => { this.module.isOnGround.set(isOnGround); });
            case 'magVar':
                return sub.on('magvar').atFrequency(updateFreq).handle(magVar => { this.module.magVar.set(magVar); });
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const property of this.properties) {
            (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * Controls the rotation of a map based on the behavior defined in {@link MapRotationModule}.
 */
class MapRotationController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
        this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.rotationParam = {
            rotation: 0
        };
        this.hasRotationControl = false;
        this.rotationControl = this.context[MapSystemKeys.RotationControl];
        this.rotationControlConsumer = {
            priority: 0,
            onAcquired: () => {
                this.hasRotationControl = true;
            },
            onCeded: () => {
                this.hasRotationControl = false;
            }
        };
        this.rotationFuncs = {
            [MapRotation.NorthUp]: () => 0,
            [MapRotation.HeadingUp]: this.ownAirplanePropsModule === undefined
                ? () => 0
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                : () => -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD,
            [MapRotation.TrackUp]: this.ownAirplanePropsModule === undefined
                ? () => 0
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                : () => this.ownAirplanePropsModule.groundSpeed.get().asUnit(UnitType.KNOT) < 5
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    ? -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    : -this.ownAirplanePropsModule.trackTrue.get() * Avionics.Utils.DEG2RAD,
            [MapRotation.DtkUp]: () => 0 // TODO
        };
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.rotationSub = this.rotationModule.rotationType.sub(type => {
            this.rotationFunc = this.rotationFuncs[type];
        }, true);
        this.rotationControl.claim(this.rotationControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
        if (this.hasRotationControl && this.rotationFunc !== undefined) {
            this.rotationParam.rotation = this.rotationFunc();
            this.context.projection.setQueued(this.rotationParam);
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        super.onMapDestroyed();
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.rotationSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.rotationControl.forfeit(this.rotationControlConsumer);
    }
}

/**
 * Waypoint roles used by the map system waypoint display system.
 */
var MapSystemWaypointRoles;
(function (MapSystemWaypointRoles) {
    /** The normal waypoint display role. */
    MapSystemWaypointRoles["Normal"] = "Normal";
    /** The waypoint role for displaying waypoints along the flight plan. */
    MapSystemWaypointRoles["FlightPlan"] = "FlightPlan";
})(MapSystemWaypointRoles || (MapSystemWaypointRoles = {}));

/**
 * A map system layer that draws the flight plan.
 */
class MapSystemFlightPlanLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.instanceId = MapSystemFlightPlanLayer.instanceId++;
        this.flightPathLayerRef = FSComponent.createRef();
        this.waypointLayerRef = FSComponent.createRef();
        this.defaultRoleId = (_a = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan)) !== null && _a !== void 0 ? _a : 0;
        this.planModule = this.props.model.getModule(MapSystemKeys.FlightPlan);
        this.waypointPrefix = `${MapSystemFlightPlanLayer.WAYPOINT_PREFIX}_${this.instanceId}`;
        this.legWaypoints = new Map();
        this.waypointsUpdating = false;
        this.waypointId = 0;
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
        this.facWaypointCache = DefaultFacilityWaypointCache.getCache(this.props.bus);
        this.clipBounds = VecNSubject.create(new Float64Array(4));
        this.clippedPathStream = new ClippedPathStream(NullPathStream.INSTANCE, this.clipBounds);
        this.pathStreamStack = new GeoProjectionPathStreamStack(NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), Math.PI / 12, 0.25, 8);
        this.updateScheduled = false;
    }
    /** @inheritdoc */
    onAttached() {
        this.flightPathLayerRef.instance.onAttached();
        this.waypointLayerRef.instance.onAttached();
        this.pathStreamStack.pushPostProjected(this.clippedPathStream);
        this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
        this.initWaypointRenderer();
        this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(() => this.updateScheduled = true);
        this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(() => this.updateScheduled = true);
        this.props.waypointRenderer.onRolesAdded.on(() => this.initWaypointRenderer());
        super.onAttached();
    }
    /**
     * Initializes the waypoint renderer for this layer.
     */
    initWaypointRenderer() {
        let hasDefaultRole = false;
        const flightPlanRoles = this.props.waypointRenderer.getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${this.props.planIndex}`);
        for (let i = 0; i < flightPlanRoles.length; i++) {
            const roleId = this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);
            if (roleId !== undefined) {
                this.props.waypointRenderer.setCanvasContext(roleId, this.waypointLayerRef.instance.display.context);
                this.props.waypointRenderer.setIconFactory(roleId, this.props.iconFactory);
                this.props.waypointRenderer.setLabelFactory(roleId, this.props.labelFactory);
                if (!hasDefaultRole) {
                    this.props.flightPathRenderer.defaultRoleId = roleId;
                    hasDefaultRole = true;
                }
            }
        }
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.flightPathLayerRef.instance.onUpdated(time, elapsed);
        this.waypointLayerRef.instance.onUpdated(time, elapsed);
        if (this.isVisible()) {
            const display = this.flightPathLayerRef.instance.display;
            if (display.isInvalid) {
                display.clear();
                display.syncWithMapProjection(this.props.mapProjection);
                this.updateScheduled = true;
            }
            if (this.updateScheduled) {
                if (!this.waypointsUpdating) {
                    this.updateWaypoints();
                }
                const context = display.context;
                display.clear();
                const plan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
                if (plan !== undefined) {
                    this.pathStreamStack.setProjection(display.geoProjection);
                    this.props.flightPathRenderer.render(plan, undefined, undefined, context, this.pathStreamStack);
                }
                this.updateScheduled = false;
            }
        }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        const size = this.flightPathLayerRef.instance.getSize();
        this.clipBounds.set(-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, -MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER);
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.waypointLayerRef.instance.setVisible(val);
        this.flightPathLayerRef.instance.setVisible(val);
    }
    /**
     * Updates waypoints for the flight plan.
     * @throws An error if the waypoints are already updating.
     */
    async updateWaypoints() {
        if (this.waypointsUpdating) {
            throw new Error('A flight plan waypoint update is already in progress.');
        }
        this.waypointsUpdating = true;
        const flightPlan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
        const activeLegIndex = this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();
        if (flightPlan === undefined) {
            for (const legWaypoint of this.legWaypoints.values()) {
                const [waypoint, roleId] = legWaypoint;
                this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            }
            this.legWaypoints.clear();
            this.waypointsUpdating = false;
            return;
        }
        const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
        const legsToDisplay = new Map();
        let legIndex = 0;
        for (const leg of flightPlan.legs()) {
            let roleId = this.defaultRoleId;
            const handler = this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);
            if (handler !== undefined) {
                roleId = handler(flightPlan, leg, activeLeg, legIndex, activeLegIndex);
            }
            if (roleId !== 0) {
                legsToDisplay.set(leg, roleId);
            }
            legIndex++;
        }
        // Remove records of legs that are no longer in the set of legs to display.
        for (const leg of this.legWaypoints) {
            const [legDefinition, legWaypoint] = leg;
            const [waypoint, roleId] = legWaypoint;
            if (!legsToDisplay.has(legDefinition)) {
                this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.delete(legDefinition);
            }
        }
        const waypointRefreshes = [];
        // Create or refresh waypoints to display
        for (const leg of legsToDisplay) {
            waypointRefreshes.push(this.buildPlanWaypoint(leg[0], leg[1]));
        }
        await Promise.all(waypointRefreshes);
        this.waypointsUpdating = false;
    }
    /**
     * Builds or refreshes a flight plan waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildPlanWaypoint(leg, roleId) {
        switch (leg.leg.type) {
            case LegType.CD:
            case LegType.VD:
            case LegType.CR:
            case LegType.VR:
            case LegType.FC:
            case LegType.FD:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.CI:
            case LegType.VI:
                await this.buildTerminatorWaypoint(leg, roleId);
                break;
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                break;
            default:
                await this.buildFixWaypoint(leg, roleId);
                break;
        }
    }
    /**
     * Builds a flight path terminator based waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildTerminatorWaypoint(leg, roleId) {
        var _a, _b, _c, _d, _e, _f;
        const currentLeg = this.legWaypoints.get(leg);
        if (currentLeg !== undefined) {
            const [waypoint, currentRoleId] = currentLeg;
            const lastVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 1];
            if (lastVector !== undefined) {
                if (!waypoint.location.get().equals(lastVector.endLat, lastVector.endLon)) {
                    this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                    const ident = (_c = leg.name) !== null && _c !== void 0 ? _c : '';
                    const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
                    this.legWaypoints.set(leg, [newWaypoint, roleId]);
                    this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                }
                else if (currentRoleId !== roleId) {
                    this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                    this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                    this.legWaypoints.set(leg, [waypoint, roleId]);
                }
            }
            else {
                this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            }
        }
        else {
            const lastVector = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) - 1];
            if (lastVector !== undefined) {
                const ident = (_f = leg.name) !== null && _f !== void 0 ? _f : '';
                const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
                this.legWaypoints.set(leg, [newWaypoint, roleId]);
                this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            }
        }
    }
    /**
     * Builds a standard facility fix waypoint for flight plan waypoint display.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildFixWaypoint(leg, roleId) {
        var _a;
        const legWaypoint = this.legWaypoints.get(leg);
        if (legWaypoint === undefined) {
            const facIcao = leg.leg.fixIcao;
            let facility;
            try {
                facility = await this.facLoader.getFacility(ICAO.getFacilityType(facIcao), facIcao);
            }
            catch (err) {
                /* continue */
            }
            if (facility !== undefined) {
                const waypoint = this.facWaypointCache.get(facility);
                const ident = (_a = leg.name) !== null && _a !== void 0 ? _a : '';
                const newWaypoint = new FlightPathWaypoint(waypoint.location, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
                this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.set(leg, [newWaypoint, roleId]);
            }
        }
        else {
            const [waypoint, currentRoleId] = legWaypoint;
            if (currentRoleId !== roleId) {
                this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
                this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
                this.legWaypoints.set(leg, [waypoint, roleId]);
            }
        }
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, overdrawFactor: Math.SQRT2, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }),
            FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_b = this.props.class) !== null && _b !== void 0 ? _b : '' })));
    }
}
MapSystemFlightPlanLayer.WAYPOINT_PREFIX = 'MapSystemFplLayer';
MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER = 10;
MapSystemFlightPlanLayer.instanceId = 0;

/**
 * TCAS operating modes.
 */
var TcasOperatingMode;
(function (TcasOperatingMode) {
    TcasOperatingMode["Off"] = "Off";
    TcasOperatingMode["Standby"] = "Standby";
    TcasOperatingMode["TAOnly"] = "TAOnly";
    TcasOperatingMode["TA_RA"] = "TA/RA";
    TcasOperatingMode["Test"] = "Test";
    TcasOperatingMode["Failed"] = "Failed";
})(TcasOperatingMode || (TcasOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TcasAlertLevel;
(function (TcasAlertLevel) {
    TcasAlertLevel[TcasAlertLevel["None"] = 0] = "None";
    TcasAlertLevel[TcasAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel[TcasAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel[TcasAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TcasAlertLevel || (TcasAlertLevel = {}));
/**
 * Bit flags describing TCAS resolution advisories.
 */
var TcasResolutionAdvisoryFlags;
(function (TcasResolutionAdvisoryFlags) {
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Corrective"] = 1] = "Corrective";
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["UpSense"] = 2] = "UpSense";
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DownSense"] = 4] = "DownSense";
    /** A resolution advisory which crosses an intruder's altitude. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Crossing"] = 8] = "Crossing";
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Climb"] = 16] = "Climb";
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Descend"] = 32] = "Descend";
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Increase"] = 64] = "Increase";
    /** A CLIMB or DESCEND resolution advisory that reverses sense. Commands a vertical speed above 1500 FPM or below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Reversal"] = 128] = "Reversal";
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceClimb"] = 256] = "ReduceClimb";
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceDescent"] = 512] = "ReduceDescent";
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotClimb"] = 1024] = "DoNotClimb";
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotDescend"] = 2048] = "DoNotDescend";
})(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
/**
 * Types of TCAS resolution advisories.
 */
var TcasResolutionAdvisoryType;
(function (TcasResolutionAdvisoryType) {
    /** Upward sense, positive, corrective, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["Climb"] = "Climb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingClimb"] = "CrossingClimb";
    /** Upward sense, positive, corrective, required vertical speed 1500 to 4400 fpm. */
    TcasResolutionAdvisoryType["MaintainClimb"] = "MaintainClimb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    /** Upward sense, positive, corrective, required vertical speed 2500 to 3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseClimb"] = "IncreaseClimb";
    /** Upward sense, positive, corrective, transition from downward sense, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["ReversalClimb"] = "ReversalClimb";
    /** Upward sense, negative, corrective, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceDescent"] = "ReduceDescent";
    /** Upward sense, negative, preventative, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend0"] = "DoNotDescend0";
    /** Upward sense, negative, preventative, required vertical speed >= -500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend500"] = "DoNotDescend500";
    /** Upward sense, negative, preventative, required vertical speed >= -1000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1000"] = "DoNotDescend1000";
    /** Upward sense, negative, preventative, required vertical speed >= -1500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1500"] = "DoNotDescend1500";
    /** Upward sense, negative, preventative, required vertical speed >= -2000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend2000"] = "DoNotDescend2000";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["Descend"] = "Descend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["CrossingDescend"] = "CrossingDescend";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["MaintainDescend"] = "MaintainDescend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    /** Downward sense, positive, corrective, required vertical speed -2500 to -3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseDescend"] = "IncreaseDescend";
    /** Downward sense, positive, corrective, transition from upward sense, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["ReversalDescend"] = "ReversalDescend";
    /** Downward sense, negative, corrective, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceClimb"] = "ReduceClimb";
    /** Downward sense, negative, preventative, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb0"] = "DoNotClimb0";
    /** Downward sense, negative, preventative, required vertical speed <= 500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb500"] = "DoNotClimb500";
    /** Downward sense, negative, preventative, required vertical speed <= 1000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1000"] = "DoNotClimb1000";
    /** Downward sense, negative, preventative, required vertical speed <= 1500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1500"] = "DoNotClimb1500";
    /** Downward sense, negative, preventative, required vertical speed <= 2000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb2000"] = "DoNotClimb2000";
    /** Clear of conflict. */
    TcasResolutionAdvisoryType["Clear"] = "Clear";
})(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
/**
 * A TCAS-II-like system.
 */
class Tcas {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.bus = bus;
        this.tfcInstrument = tfcInstrument;
        this.maxIntruderCount = maxIntruderCount;
        this.realTimeUpdateFreq = realTimeUpdateFreq;
        this.simTimeUpdateFreq = simTimeUpdateFreq;
        this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.intrudersRA = new Set();
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.ownAirplaneSubs = {
            position: GeoPointSubject.create(new GeoPoint(0, 0)),
            altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            groundTrack: ConsumerSubject.create(null, 0),
            groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
            verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
            radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            isOnGround: ConsumerSubject.create(null, false)
        };
        this.simTime = ConsumerSubject.create(null, 0);
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.alertLevelSubs = new Map();
        this.eventPublisher = this.bus.getPublisher();
        this.eventSubscriber = this.bus.getSubscriber();
        this.paSeparationCache = {
            horizontal: UnitType.NMILE.createNumber(0),
            vertical: UnitType.FOOT.createNumber(0)
        };
        this.sensitivity = this.createSensitivity();
        this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
        const fullRAOptions = {
            initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
            initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
            subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
            subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
            allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : (() => true),
            allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : (() => true),
            allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100),
            allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450)
        };
        this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
        return this.intrudersFiltered;
    }
    /**
     * Gets this system's resolution advisory host.
     * @returns This system's resolution advisory host.
     */
    getResolutionAdvisoryHost() {
        return this.resolutionAdvisoryHost;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
        // init contact listeners
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('traffic_contact_added');
        this.contactRemovedConsumer = sub.on('traffic_contact_removed');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        // add all existing contacts
        this.tfcInstrument.forEachContact(contact => { this.onContactAdded(contact.uid); });
        // init own airplane subjects
        sub.on('gps-position').atFrequency(this.realTimeUpdateFreq).handle(lla => {
            this.ownAirplaneSubs.position.set(lla.lat, lla.long);
            this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
        });
        sub.on('ground_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(gs => { this.ownAirplaneSubs.groundSpeed.set(gs); });
        sub.on('vertical_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(vs => { this.ownAirplaneSubs.verticalSpeed.set(vs); });
        sub.on('radio_alt').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(alt => { this.ownAirplaneSubs.radarAltitude.set(alt); });
        this.ownAirplaneSubs.groundTrack.setConsumer(sub.on('track_deg_true'));
        this.ownAirplaneSubs.isOnGround.setConsumer(sub.on('on_ground'));
        // init sim time subject
        this.simTime.setConsumer(sub.on('simTime'));
        // init operating mode notifier
        this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
        // init update loop
        sub.on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    onOperatingModeChanged(mode) {
        this.bus.pub('tcas_operating_mode', mode, false, true);
        if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
            // We are in a mode where TCAS is not operating normally.
            // Cancel any active resolution advisories.
            this.resolutionAdvisoryHost.cancel(this.simTime.get());
            // Clean up all intruders.
            for (let i = 0; i < this.intrudersFiltered.length; i++) {
                this.cleanUpIntruder(this.intrudersFiltered[i]);
            }
            this.intrudersFiltered = [];
        }
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
        // always sort intruders with valid predictions first
        if (a.isPredictionValid && !b.isPredictionValid) {
            return -1;
        }
        else if (!a.isPredictionValid && b.isPredictionValid) {
            return 1;
        }
        else if (a.isPredictionValid) {
            let tcaPredictionA, tcaPredictionB;
            // Always sort intruders predicted to violate RA protected volume first (or for whom an RA has been issued), then
            // TA protected volume (or for whom a TA has been issued)
            const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (a.tcaRA.isValid && a.tcaRA.isThreat);
            const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (b.tcaRA.isValid && b.tcaRA.isThreat);
            if (aRA && !bRA) {
                return -1;
            }
            else if (!aRA && bRA) {
                return 1;
            }
            else if (aRA && bRA) {
                tcaPredictionA = a.tcaRA;
                tcaPredictionB = b.tcaRA;
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (a.tcaTA.isValid && a.tcaTA.isThreat);
                const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (b.tcaTA.isValid && b.tcaTA.isThreat);
                if (aTA && !bTA) {
                    return -1;
                }
                else if (!aTA && bTA) {
                    return 1;
                }
                else if (aTA && bTA) {
                    tcaPredictionA = a.tcaTA;
                    tcaPredictionB = b.tcaTA;
                }
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
                    return -1;
                }
                else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            // If both are predicted to violate the RA or TA protected volume, sort by time to CPA.
            // Otherwise sort by how close they approach the protected volume at CPA.
            const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
            const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
            let firstComparison;
            let secondComparison;
            if (tcaPredictionA.isThreat) {
                firstComparison = tcaComparison;
                secondComparison = normComparison;
            }
            else {
                firstComparison = normComparison;
                secondComparison = tcaComparison;
            }
            if (firstComparison === 0) {
                return secondComparison;
            }
            else {
                return firstComparison;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
        const contact = this.tfcInstrument.getContact(uid);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
        const sortedIndex = this.intrudersSorted.findIndex(intruder => intruder.contact.uid === uid);
        const culledIndex = this.intrudersFiltered.findIndex(intruder => intruder.contact.uid === uid);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
        switch (this.operatingModeSub.get()) {
            case TcasOperatingMode.Off:
            case TcasOperatingMode.Standby:
            case TcasOperatingMode.Failed:
            case TcasOperatingMode.Test: // TODO: support TEST mode
                return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq) {
            return;
        }
        this.doUpdate(simTime);
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    doUpdate(simTime) {
        this.updateSensitivity();
        this.updateIntruderPredictions(simTime);
        this.updateIntruderArrays();
        this.updateFilteredIntruderAlertLevels(simTime);
        this.updateResolutionAdvisory(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateIntruderPredictions(simTime) {
        this.ownAirplane.update(simTime);
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            const sensitivity = this.sensitivity.selectParameters(intruder);
            intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
        }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
            const intruder = this.intrudersSorted[i];
            if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filterIntruder(intruder) {
        return true;
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateFilteredIntruderAlertLevels(simTime) {
        let taCount = 0, raCount = 0;
        const len = this.intrudersFiltered.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersFiltered[i];
            this.updateIntruderAlertLevel(simTime, intruder);
            switch (intruder.alertLevel.get()) {
                case TcasAlertLevel.TrafficAdvisory:
                    taCount++;
                    break;
                case TcasAlertLevel.ResolutionAdvisory:
                    raCount++;
                    break;
            }
        }
        this.eventPublisher.pub('tcas_ta_intruder_count', taCount, false, true);
        this.eventPublisher.pub('tcas_ra_intruder_count', raCount, false, true);
    }
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    updateIntruderAlertLevel(simTime, intruder) {
        const currentAlertLevel = intruder.alertLevel.get();
        if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
            if (this.canIssueResolutionAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory
            && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat)
            && !this.canCancelResolutionAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
            if (this.canIssueTrafficAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory
            && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat)
            && !this.canCancelTrafficAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.isPredictionValid) {
            const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
            const radius = parametersPA.protectedRadius;
            const height = parametersPA.protectedHeight;
            if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
                intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
                if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0
                    && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
                    intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
                    return;
                }
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
            return;
        }
        intruder.alertLevel.set(TcasAlertLevel.None);
    }
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() === TcasOperatingMode.TA_RA
            && intruder.tcaRA.isValid
            && intruder.tcaRA.tcpa.number > 0
            && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA
            || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateResolutionAdvisory(simTime) {
        if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
            this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
        }
        else {
            this.resolutionAdvisoryHost.cancel(simTime);
        }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
        this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
        this.eventPublisher.pub('tcas_intruder_added', intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
        var _a;
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.delete(intruder);
        }
        (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
        this.eventPublisher.pub('tcas_intruder_removed', intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.add(intruder);
        }
        else {
            this.intrudersRA.delete(intruder);
        }
        this.eventPublisher.pub('tcas_intruder_alert_changed', intruder, false, false);
    }
}
Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
};
/**
 * An airplane managed by TCAS.
 */
class TcasAirplane {
    constructor() {
        this._position = new GeoPoint(0, 0);
        /** The position of this airplane at the time of the most recent update. */
        this.position = this._position.readonly;
        /** The altitude of this airplane at the time of the most recent update. */
        this._altitude = UnitType.FOOT.createNumber(0);
        this.altitude = this._altitude.readonly;
        this._groundTrack = 0;
        /** The ground speed of this airplane at the time of the most recent update. */
        this._groundSpeed = UnitType.KNOT.createNumber(0);
        this.groundSpeed = this._groundSpeed.readonly;
        /** The vertical speed of this airplane at the time of the most recent update. */
        this._verticalSpeed = UnitType.FPM.createNumber(0);
        this.verticalSpeed = this._verticalSpeed.readonly;
        /**
         * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
         * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
         * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
         * airplane.
         */
        this.positionVec = new Float64Array(3);
        /**
         * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters per second. The coordinate system is defined the same as for position vectors.
         */
        this.velocityVec = new Float64Array(3);
        this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
        return this._groundTrack;
    }
}
/**
 * The own airplane managed by TCAS.
 */
class OwnAirplane extends TcasAirplane {
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
        super();
        this.subs = subs;
        /** The radar altitude of this airplane at the time of the most recent update. */
        this._radarAltitude = UnitType.FOOT.createNumber(0);
        this.radarAltitude = this._radarAltitude.readonly;
        this._isOnGround = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this airplane is on the ground. */
    get isOnGround() {
        return this._isOnGround;
    }
    /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime, out) {
        const dt = (simTime - this.lastUpdateTime) / 1000;
        return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
        this.updateParameters();
        this.updateVectors();
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    updateParameters() {
        this._position.set(this.subs.position.get());
        this._altitude.set(this.subs.altitude.get());
        this._groundTrack = this.subs.groundTrack.get();
        this._groundSpeed.set(this.subs.groundSpeed.get());
        this._verticalSpeed.set(this.subs.verticalSpeed.get());
        this._radarAltitude.set(this.subs.radarAltitude.get());
        this._isOnGround = this.subs.isOnGround.get();
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
        Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
}
/**
 * An abstract implementation of {@link TcasIntruder}.
 */
class AbstractTcasIntruder extends TcasAirplane {
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
        super();
        this.contact = contact;
        this.alertLevel = Subject.create(TcasAlertLevel.None);
        /** The 3D position vector of this intruder relative to own airplane. */
        this.relativePositionVec = new Float64Array(3);
        /** The 3D velocity vector of this intruder relative to own airplane. */
        this.relativeVelocityVec = new Float64Array(3);
        this._isPredictionValid = false;
        /** @inheritdoc */
        this.tcaTA = new TcasTcaPredictionClass(this);
        /** @inheritdoc */
        this.tcaRA = new TcasTcaPredictionClass(this);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
        return this._isPredictionValid;
    }
    /** @inheritdoc */
    predictDisplacement(simTime, out) {
        if (!this._isPredictionValid) {
            return Vec3Math.set(NaN, NaN, NaN, out);
        }
        const dt = (simTime - this.contact.lastContactTime) / 1000;
        return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    /** @inheritdoc */
    predictSeparation(simTime, horizontalOut, verticalOut) {
        if (!this._isPredictionValid) {
            horizontalOut.set(NaN);
            verticalOut.set(NaN);
            return;
        }
        const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
        AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
        AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime, ownAirplane, sensitivity) {
        this.updateParameters(simTime, ownAirplane);
        if (this.isPredictionValid) {
            const taParams = sensitivity.parametersTA;
            const raParams = sensitivity.parametersRA;
            this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
            this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
        }
        else {
            this.invalidatePredictions();
        }
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
        if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
            this._isPredictionValid = false;
            this._position.set(NaN, NaN);
            this._altitude.set(NaN);
            this._groundTrack = NaN;
            this._groundSpeed.set(NaN);
            this._verticalSpeed.set(NaN);
            Vec3Math.set(NaN, NaN, NaN, this.positionVec);
            Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
        }
        else {
            this.updatePosition(simTime, ownAirplane);
            this.updateVelocity(ownAirplane);
            this._groundSpeed.set(this.contact.groundSpeed);
            this._verticalSpeed.set(this.contact.verticalSpeed);
            this._isPredictionValid = true;
        }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
        this.contact.predict(simTime, this._position, this._altitude);
        this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
        const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
        const bearing = ownAirplane.position.bearingTo(this._position);
        Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
        const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
        this.positionVec[2] = verticalPosition;
        Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    updateVelocity(ownAirplane) {
        Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
        Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePredictions() {
        this.tcaTA.invalidate();
        this.tcaRA.invalidate();
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
        return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
        return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
}
AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
/**
 * An default implementation of {@link TcasIntruder}.
 */
class DefaultTcasIntruder extends AbstractTcasIntruder {
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
class TcasTcaPredictionClass {
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder) {
        this.intruder = intruder;
        this._isValid = false;
        this._time = NaN;
        this._tcpa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcpa = this._tcpa.readonly;
        this._tcoa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcoa = this._tcoa.readonly;
        this._isThreat = false;
        /** @inheritdoc */
        this.cpaDisplacement = new Float64Array(3);
        this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
        /** @inheritdoc */
        this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
        this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
        /** @inheritdoc */
        this.cpaVerticalSep = this._cpaVerticalSep.readonly;
        this._cpaNorm = NaN;
    }
    /** @inheritdoc */
    get isValid() {
        return this._isValid;
    }
    /** @inheritdoc */
    get time() {
        return this._time;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get isThreat() {
        return this._isThreat;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get cpaNorm() {
        return this._cpaNorm;
    }
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tau The maximum lookahead time.
     * @param dmod The radius of the own airplane's protected volume.
     * @param zthr The half-height of the own airplane's protected volume.
     * @param hmd The distance threshold for the horizontal miss distance filter. If not defined, the HMD filter will
     * not be applied.
     */
    update(simTime, tau, dmod, zthr, hmd) {
        var _a;
        this._time = simTime;
        if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
            this.invalidate();
            return;
        }
        // Source: Munoz, CA and Narkawicz, AJ. "A TCAS-II Resolution Advisory Detection Algorithm."
        // https://ntrs.nasa.gov/api/citations/20140002736/downloads/20140002736.pdf
        const tauSeconds = tau.asUnit(UnitType.SECOND);
        const s = this.intruder.relativePositionVec;
        const v = this.intruder.relativeVelocityVec;
        const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
        const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
        const h = zthr.asUnit(UnitType.METER);
        const r = dmod.asUnit(UnitType.METER);
        const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
        const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
        const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
        const rSquared = r * r;
        // Time to closest horizontal approach
        const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
        // Modified tau
        const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
        // Time to co-altitude
        const tcoa = -s[2] / v[2];
        const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
        const isVerticalThreat = Math.abs(s[2]) <= h || (tcoa >= 0 && tcoa <= tauSeconds);
        let passHmdFilter = true;
        if (hmd !== undefined && isHorizontalThreat && isVerticalThreat) {
            const d = hmd.asUnit(UnitType.METER);
            const dSquared = d * d;
            if (vHorizSquared === 0) {
                passHmdFilter = sHorizSquared <= dSquared;
            }
            else {
                const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
                if (delta < 0) {
                    passHmdFilter = false;
                }
                else {
                    const a = vHorizSquared;
                    const b = 2 * dotSHorizVHoriz;
                    const c = sHorizSquared - dSquared;
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant < 0) {
                        passHmdFilter = false;
                    }
                    else {
                        passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
                    }
                }
            }
        }
        this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
        this._tcpa.set(tcpa);
        this._tcoa.set(tcoa);
        TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
        AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
        AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
        this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
        this._isValid = true;
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate() {
        this._isValid = false;
        this._isThreat = false;
        this._tcpa.set(NaN);
        this._tcoa.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
        this._cpaHorizontalSep.set(NaN);
        this._cpaVerticalSep.set(NaN);
        this._cpaNorm = NaN;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
        return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
        const horizLength = Math.hypot(vector[0], vector[1]);
        return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
}
TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
/**
 * An implementation of {@link TcasResolutionAdvisoryHost}.
 */
class TcasResolutionAdvisoryHostClass {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how the host should calculate resolution advisories.
     * @param ownAirplane The own airplane.
     */
    constructor(bus, options, ownAirplane) {
        this.options = options;
        this.ownAirplane = ownAirplane;
        this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
        this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
        this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.intruders = new Set();
        this.intruderArray = [];
        this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
        this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.minVerticalSpeed = this._minVerticalSpeed.readonly;
        this._flags = 0;
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._secondaryType = null;
        this._primaryFlags = 0;
        this._secondaryFlags = 0;
        this.vsConstraints = [];
        this.lastStateChangeTime = 0;
        this.stateChangeDelay = 0;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    get flags() {
        return this._flags;
    }
    /** @inheritdoc */
    get primaryType() {
        return this._primaryType;
    }
    /** @inheritdoc */
    get secondaryType() {
        return this._secondaryType;
    }
    /** @inheritdoc */
    get primaryFlags() {
        return this._primaryFlags;
    }
    /** @inheritdoc */
    get secondaryFlags() {
        return this._secondaryFlags;
    }
    /**
     * Checks whether this host can issue a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder The query intruder.
     * @returns Whether this host can issue a resolution advisory for an intruder.
     */
    canIssueResolutionAdvisory(simTime, intruder) {
        // Inhibit resolution advisories for intruders whose time to closest horizontal approach is less than or equal to
        // zero (indicating the closest point of approach has already been passed) and whose horizontal separation from the
        // own airplane is increasing.
        if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
            return false;
        }
        if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Checks whether this host can cancel a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @returns Whether this host can cancel a resolution advisory for an intruder.
     */
    canCancelResolutionAdvisory(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Updates this host's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    update(simTime, alim, intruders) {
        if (this.intruderArray.length === 0 && intruders.size === 0) {
            return;
        }
        if (simTime < this.lastStateChangeTime) {
            this.lastStateChangeTime = simTime;
        }
        if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
            return;
        }
        if (intruders.size === 0) {
            this.cancel(simTime);
        }
        else {
            const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
            const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
            const alimMeters = alim.asUnit(UnitType.METER);
            const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
            const responseTimeSecondsRemaining = isInitial
                ? responseTimeSeconds
                : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1000, 0, responseTimeSeconds);
            const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
            this.updateIntruders(intruders);
            this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
            if (isInitial) {
                this.selectInitialState(simTime, ownAirplaneVsMps);
            }
            else {
                if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
                    this.updatePositive(simTime);
                }
                else if (this._secondaryType === null) {
                    this.updateNegative(simTime, ownAirplaneVsMps);
                }
                else {
                    this.updateComposite(simTime, ownAirplaneVsMps);
                }
            }
        }
    }
    /**
     * Updates this host's resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    updateIntruders(intruders) {
        // Remove one sense reversal used for every intruder that was removed from the RA.
        for (let i = 0; i < this.intruderArray.length; i++) {
            if (!intruders.has(this.intruderArray[i])) {
                this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
            }
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        for (const intruder of intruders) {
            this.intruders.add(intruder);
            this.intruderArray.push(intruder);
        }
        this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    /**
     * Updates the vertical speed constraints associated with the intruders participating in this host's current
     * resolution advisory.
     * @param alimMeters The value of ALIM (the minimum desired vertical separation between the own airplane and an
     * intruder at time of closest approach), in meters.
     * @param responseTimeSeconds The predicted amount of time, in seconds, for the own airplane to respond to the most
     * recently issued resolution advisory, relative to the present.
     * @param accelMps The predicted vertical acceleration, in meters per second squared, of the own airplane when
     * responding to the most recently issued resolution advisory.
     */
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
        var _a;
        var _b;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        for (let i = 0; i < this.intruderArray.length; i++) {
            const intruder = this.intruderArray[i];
            let above = -Infinity;
            let below = Infinity;
            if (intruder.tcaRA.isValid) {
                const t0 = intruder.tcaRA.time;
                const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
                const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1000;
                const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
                const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                // The altitude own airplane needs to be above in order to pass above the intruder with ALIM vertical separation at CPA.
                const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
                // The altitude own airplane needs to be below in order to pass below the intruder with ALIM vertical separation at CPA.
                const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
                const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
                const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
                if (aboveAlimSense === 1) {
                    // Own airplane needs to adjust vertical speed in the positive direction in order to pass above the intruder with
                    // ALIM vertical separation at CPA.
                    above = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters)
                        : NaN;
                    if (isNaN(above)) {
                        above = Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass above the intruder with ALIM vertical separation at CPA.
                    above = tcpaSeconds > 0
                        ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : -Infinity;
                }
                if (belowAlimSense === -1) {
                    // Own airplane needs to adjust vertical speed in the negative direction in order to pass below the intruder with
                    // ALIM vertical separation at CPA
                    below = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters)
                        : NaN;
                    if (isNaN(below)) {
                        below = -Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass below the intruder with ALIM vertical separation at CPA.
                    below = tcpaSeconds > 0
                        ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : Infinity;
                }
            }
            const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : (_b[i] = { above: 0, below: 0 });
            constraint.above = above;
            constraint.below = below;
        }
        this.vsConstraints.length = this.intruderArray.length;
    }
    /**
     * Selects an initial state for a new resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    selectInitialState(simTime, ownAirplaneVsMps) {
        // We need to first select either upward or downward sense.
        // The minimum vertical speed own airplane can target while still achieving ALIM separation ABOVE all intruders
        let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
        // The maximum vertical speed own airplane can target while still achieving ALIM separation BELOW all intruders
        let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
        // The strongest initial upward and downward sense RAs are CLIMB and DESCEND, respectively (or their crossing/maintain
        // variants, but all have the same vertical speed target).
        let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
        const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
        const canClimb = this.options.allowClimb(simTime);
        const canDescend = this.options.allowDescend(simTime);
        const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
        const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
        minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
        maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
        let sense;
        let senseIsCrossing = false;
        let doesSenseAchieveAlim = false;
        let senseRequiredVs = 0;
        // If one sense RA achieves ALIM separation and the other does not, choose the one that achieves ALIM separation.
        if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
            sense = 1;
        }
        else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
            sense = -1;
        }
        else {
            // If both or neither sense RA achieves ALIM separation, choose the non-crossing sense. Only the closest intruder
            // is evaluated, since in a multi-intruder RA there is the opportunity to reverse sense with each intruder.
            const closestIntruder = this.intruderArray[0];
            const t0 = closestIntruder.tcaRA.time;
            const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
            const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
            const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
            const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
            if (crossingSense === -1 && !isUpSenseInhibited) {
                sense = 1;
            }
            else if (crossingSense === 1 && !isDownSenseInhibited) {
                sense = -1;
            }
            else {
                // If neither sense is crossing or the non-crossing sense is inhibited, choose the one that is not inhibited.
                if (!isUpSenseInhibited && isDownSenseInhibited) {
                    sense = 1;
                }
                else if (isUpSenseInhibited && !isDownSenseInhibited) {
                    sense = -1;
                }
                else {
                    // If neither or both senses are inhibited, choose the one that gives the greatest potential separation at
                    // CPA (i.e. the one that requires the least change in vertical speed). Again, only the closest intruder is evaluated.
                    if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
                        sense = 1;
                    }
                    else {
                        sense = -1;
                    }
                }
                senseIsCrossing = sense === crossingSense;
            }
        }
        doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
        doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
        doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
        senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
        // For multi-intruder RAs, there is the option to choose an initial composite RA which combines two negative RAs of
        // opposite senses.
        if (this.intruderArray.length > 1) {
            // Because the composite RA always includes a vertical speed of 0 within its vertical speed target range, it
            // achieves ALIM separation from all intruders if and only if a vertical speed of 0 does.
            const doesCompositeAchieveAlim = this.vsConstraints.every(constraint => constraint.above <= 0 || constraint.below >= 0);
            // If the composite RA achieves ALIM separation from all intruders and the selected up/down sense RA does not,
            // choose the composite RA.
            if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
                sense = 0;
                doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
            else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
                // If both or neither the composite RA or the selected up/down sense RA achieves ALIM separation from all
                // intruders, choose the composite RA if the up/down sense RA is crossing.
                if (senseIsCrossing) {
                    sense = 0;
                    doesSenseAchieveAlim = doesCompositeAchieveAlim;
                }
                else {
                    // If both or neither the composite RA or the selected up/down sense RA is crossing, choose the one that
                    // provides the greatest potential vertical separation at CPA. Again, only the closest intruder is
                    // evaluated.
                    if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
                        sense = 0;
                        doesSenseAchieveAlim = doesCompositeAchieveAlim;
                    }
                }
            }
        }
        // Now that we have selected the sense, we need to choose the appropriate initial RA type.
        let primaryType;
        let secondaryType = null;
        switch (sense) {
            case 0: // Composite RA
                if (doesSenseAchieveAlim) {
                    // Find the vertical speed limits required to achieve ALIM separation.
                    const maxVsMps = this.getCompositeRequiredMaxVs();
                    const minVsMps = this.getCompositeRequiredMinVs();
                    if (ownAirplaneVsMps > maxVsMps) {
                        // Downward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                    }
                    else if (ownAirplaneVsMps < minVsMps) {
                        // Upward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                    else {
                        // Preventative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                }
                else {
                    primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
                }
                break;
            case 1: // Upward sense single RA
                if (ownAirplaneVsMps < minUpSenseVsMps) {
                    // Corrective
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    }
                }
                else {
                    // Preventative
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
                    }
                }
                break;
            case -1: // Downward sense single RA
                if (ownAirplaneVsMps > maxDownSenseVsMps) {
                    // Corrective
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                    }
                }
                else {
                    // Preventative
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
                    }
                }
                break;
        }
        this.setState(simTime, primaryType, secondaryType, true);
    }
    /**
     * Updates an existing positive resolution advisory. Positive resolution advisories include the CLIMB and DESCEND and
     * related types (CROSSING, MAINTAIN, INCREASE, REVERSAL).
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updatePositive(simTime) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
        // Check if we are inhibited, if so -> convert the current RA to its negative preventative counterpart.
        const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        if (isInhibited) {
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
            return;
        }
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, attempt to
        // weaken the RA. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            // If weakening to a REDUCE CLIMB/DESCENT RA would still provide ALIM separation, do so.
            if (requiredVsMps * sense <= 0) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
            }
        }
        else {
            // Check if strengthening to an INCREASE CLIMB/DESCENT RA would provide ALIM separation
            const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
            let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
            }
        }
    }
    /**
     * Updates an existing negative resolution advisory. Negative resolution advisories include the REDUCE CLIMB/DESCENT
     * and DO NOT CLIMB/DESCEND types.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    updateNegative(simTime, ownAirplaneVsMps) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, we do nothing since
        // negative RAs cannot be weakened. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            return;
        }
        const requirePositive = requiredVsMps * sense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // negative RA we can.
        }
        if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
            // We need to issue a corrective negative RA.
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            this.setState(simTime, sense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
        }
    }
    /**
     * Updates an existing composite resolution advisory. Composite resolution advisories consist of a (corrective or
     * preventative) negative resolution advisory combined with a negative preventative resolution advisory of the
     * opposite sense.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     * @throws Error if a composite resolution advisory is not active.
     */
    updateComposite(simTime, ownAirplaneVsMps) {
        if (this._secondaryType === null) {
            throw new Error('TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active');
        }
        const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
        const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredMinVsMps = this.getCompositeRequiredMinVs();
        const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
        const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
        if (primarySense === 1) {
            primaryCurrentVsMps = currentMinVsMps;
            primaryRequiredVsMps = requiredMinVsMps;
            secondaryCurrentVsMps = currentMaxVsMps;
            secondaryRequiredVsMps = requiredMaxVsMps;
        }
        else {
            primaryCurrentVsMps = currentMaxVsMps;
            primaryRequiredVsMps = requiredMaxVsMps;
            secondaryCurrentVsMps = currentMinVsMps;
            secondaryRequiredVsMps = requiredMinVsMps;
        }
        const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
        const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
        const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0
            || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // pair of negative RAs we can.
        }
        let primaryType;
        if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
            // We need to issue a corrective negative RA.
            primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            primaryType = primarySense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
        }
        const secondaryType = primarySense === 1
            ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps)
            : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
        this.setState(simTime, primaryType, secondaryType);
    }
    /**
     * Sets the state of this host's current resolution advisory. If the specified state is equal to the current state
     * of the resolution advisory, this method does nothing. If the state is successfully set, the `tcas_ra_issued`
     * event will be published if `isInitial` is `true`, or the `tcas_ra_updated` event if `isInitial` is `false`.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param primaryType The primary type of the resolution advisory.
     * @param secondaryType The secondary type of the resolution advisory.
     * @param isInitial Whether the state to set is for an initial resolution advisory.
     */
    setState(simTime, primaryType, secondaryType, isInitial = false) {
        if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
            return;
        }
        let minSpeed, maxSpeed;
        const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
        this._primaryType = primaryType;
        this._primaryFlags = primaryTypeDef.flags;
        this._secondaryType = secondaryType;
        if (secondaryType !== null) {
            const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
            this._secondaryFlags = secondaryTypeDef.flags;
            minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
            maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
        }
        else {
            this._secondaryFlags = 0;
            minSpeed = primaryTypeDef.minVerticalSpeed;
            maxSpeed = primaryTypeDef.maxVerticalSpeed;
        }
        this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
        this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
        this.isInitial = isInitial;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE
            + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1000;
        if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
            this.senseReversalCount++;
        }
        if (isInitial) {
            this.publisher.pub('tcas_ra_issued', this, false, false);
        }
        else {
            this.publisher.pub('tcas_ra_updated', this, false, false);
        }
    }
    /**
     * Cancels this host's current resolution advisory. If there is no currently active resolution advisory, this
     * method does nothing. If the resolution advisory is successfully cancelled, the `tcas_ra_canceled` event will be
     * published.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    cancel(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
            return;
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        this._maxVerticalSpeed.set(NaN);
        this._minVerticalSpeed.set(NaN);
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._primaryFlags = 0;
        this._secondaryType = null;
        this._secondaryFlags = 0;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher.pub('tcas_ra_canceled', undefined, false, false);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * above all current RA intruders.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation above all current RA intruders.
     */
    getUpSenseRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * below all current RA intruders.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation below all current RA intruders.
     */
    getDownSenseRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tcpa The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
        const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
        if (signedAccel === 0) {
            return vs;
        }
        const y0 = currentAlt + vs * responseTime;
        const tc = tcpa - responseTime;
        const a = signedAccel / 2;
        const b = -signedAccel * tc;
        const c = targetAlt - y0 - vs * tc;
        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
            return NaN;
        }
        const sqrtDiscr = Math.sqrt(discriminant);
        const t1 = (-b + sqrtDiscr) / (2 * a);
        const t2 = (-b - sqrtDiscr) / (2 * a);
        if (t1 <= tc && t1 >= 0) {
            return vs + signedAccel * t1;
        }
        if (t2 <= tc && t2 >= 0) {
            return vs + signedAccel * t2;
        }
        return NaN;
    }
    /**
     * Gets the least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for a given minimum
     * vertical speed requirement.
     * @param minVsMps A minimum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for the specified
     * minimum vertical speed requirement.
     */
    static getDoNotDescendType(minVsMps) {
        if (minVsMps > -500) {
            return TcasResolutionAdvisoryType.DoNotDescend0;
        }
        else if (minVsMps > -1000) {
            return TcasResolutionAdvisoryType.DoNotDescend500;
        }
        else if (minVsMps > -1500) {
            return TcasResolutionAdvisoryType.DoNotDescend1000;
        }
        else if (minVsMps > -2000) {
            return TcasResolutionAdvisoryType.DoNotDescend1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotDescend2000;
        }
    }
    /**
     * Gets the least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for a given maximum
     * vertical speed requirement.
     * @param maxVsMps A maximum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for the specified
     * maximum vertical speed requirement.
     */
    static getDoNotClimbType(maxVsMps) {
        if (maxVsMps < 500) {
            return TcasResolutionAdvisoryType.DoNotClimb0;
        }
        else if (maxVsMps < 1000) {
            return TcasResolutionAdvisoryType.DoNotClimb500;
        }
        else if (maxVsMps < 1500) {
            return TcasResolutionAdvisoryType.DoNotClimb1000;
        }
        else if (maxVsMps < 2000) {
            return TcasResolutionAdvisoryType.DoNotClimb1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotClimb2000;
        }
    }
}
/** The base amount of delay between state changes, in milliseconds, before predicted response time is taken into account. */
TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5000;
TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
        return -1;
    }
    else if (tcpaComparison > 0) {
        return 1;
    }
    else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
        return -1;
    }
    else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
        return 1;
    }
    else {
        return 0;
    }
};
TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
        flags: 0,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 2500,
        maxVerticalSpeed: 3000
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -3000,
        maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1000
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 2000
    },
};
TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];

/**
 * Standard TCAS-II sensitivity parameters.
 */
class TcasIISensitivityParameters {
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude, radarAltitude) {
        const altFeet = altitude.asUnit(UnitType.FOOT);
        const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
        let level;
        if (radarAltFeet > 2350) {
            if (altFeet > 42000) {
                level = 6;
            }
            else if (altFeet > 20000) {
                level = 5;
            }
            else if (altFeet > 10000) {
                level = 4;
            }
            else if (altFeet > 5000) {
                level = 3;
            }
            else {
                level = 2;
            }
        }
        else if (radarAltFeet > 1000) {
            level = 1;
        }
        else {
            level = 0;
        }
        return level;
    }
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    altitude, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    radarAltitude) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPA(level) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level) {
        return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
}
TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
};
TcasIISensitivityParameters.TA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.33),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.48),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(40),
        protectedRadius: UnitType.NMILE.createNumber(0.75),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(45),
        protectedRadius: UnitType.NMILE.createNumber(1),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(1200)
    }
];
TcasIISensitivityParameters.RA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.35),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.55),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(350),
        hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.8),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(400),
        hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(700),
        alim: UnitType.FOOT.createNumber(600),
        hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(800),
        alim: UnitType.FOOT.createNumber(700),
        hmd: UnitType.NMILE.createNumber(0.98)
    }
];
/**
 * An implementation of {@link TCASSensitivity} which provides sensitivity parameters as defined in the official
 * TCAS II specification.
 */
class TcasIISensitivity {
    constructor() {
        this.sensitivity = new TcasIISensitivityParameters();
        this.level = 0;
        this.params = {
            parametersPA: this.sensitivity.getPA(0),
            parametersTA: this.sensitivity.getTA(0),
            parametersRA: this.sensitivity.getRA(0)
        };
    }
    /** @inheritdoc */
    selectParameters() {
        return this.params;
    }
    /** @inheritdoc */
    selectRAAlim() {
        return this.sensitivity.getRAAlim(this.level);
    }
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude, radarAltitude) {
        this.level = this.sensitivity.selectLevel(altitude, radarAltitude);
        this.params.parametersPA = this.sensitivity.getPA(this.level);
        this.params.parametersTA = this.sensitivity.getTA(this.level);
        this.params.parametersRA = this.sensitivity.getRA(this.level);
    }
}

/**
 * Traffic alert level modes.
 */
var MapTrafficAlertLevelVisibility;
(function (MapTrafficAlertLevelVisibility) {
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["Other"] = 1] = "Other";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ProximityAdvisory"] = 2] = "ProximityAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["TrafficAdvisory"] = 4] = "TrafficAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["ResolutionAdvisory"] = 8] = "ResolutionAdvisory";
    MapTrafficAlertLevelVisibility[MapTrafficAlertLevelVisibility["All"] = 15] = "All";
})(MapTrafficAlertLevelVisibility || (MapTrafficAlertLevelVisibility = {}));
/**
 * A module describing the display of traffic.
 */
class MapTrafficModule {
    /**
     * Creates an instance of a MapTrafficModule.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas) {
        this.tcas = tcas;
        /** Whether to show traffic information. */
        this.show = Subject.create(true);
        /** The TCAS operating mode. */
        this.operatingMode = Subject.create(TcasOperatingMode.Standby);
        /**
         * The distance from the own airplane beyond which intruders are considered off-scale. If the value is `NaN`,
         * intruders are never considered off-scale.
         */
        this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
        /** Alert level visibility flags. */
        this.alertLevelVisibility = Subject.create(MapTrafficAlertLevelVisibility.All);
        /** The difference in altitude above the own airplane above which intruders will not be displayed. */
        this.altitudeRestrictionAbove = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
        /** The difference in altitude below the own airplane below which intruders will not be displayed. */
        this.altitudeRestrictionBelow = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
        /** Whether displayed intruder altitude is relative. */
        this.isAltitudeRelative = Subject.create(true);
        this.tcas.getEventSubscriber().on('tcas_operating_mode').whenChanged().handle(mode => {
            this.operatingMode.set(mode);
        });
    }
}

/**
 * A map layer which displays traffic intruders.
 */
class MapSystemTrafficLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.iconLayerRef = FSComponent.createRef();
        this.trafficModule = this.props.model.getModule(MapSystemKeys.Traffic);
        this.intruderIcons = {
            [TcasAlertLevel.None]: new Map(),
            [TcasAlertLevel.ProximityAdvisory]: new Map(),
            [TcasAlertLevel.TrafficAdvisory]: new Map(),
            [TcasAlertLevel.ResolutionAdvisory]: new Map()
        };
        this.needHandleOffscaleOob = this.props.offScaleIntruders !== undefined || this.props.oobIntruders !== undefined;
        this.oobOffset = (_a = this.props.oobOffset) !== null && _a !== void 0 ? _a : Subject.create(VecNMath.create(4));
        this.oobBounds = VecNSubject.createFromVector(VecNMath.create(4));
        this.isInit = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a, _b;
        if (!isVisible) {
            if (this.isInit) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.iconLayerRef.instance.display.clear();
            }
            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.clear();
            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    /** @inheritdoc */
    onAttached() {
        this.iconLayerRef.instance.onAttached();
        this.oobOffset.sub(this.updateOobBounds.bind(this), true);
        this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
        this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
        this.initCanvasStyles();
        this.initIntruders();
        this.initTCASHandlers();
        this.isInit = true;
    }
    /**
     * Initializes canvas styles.
     */
    initCanvasStyles() {
        this.props.initCanvasStyles && this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);
    }
    /**
     * Initializes all currently existing TCAS intruders.
     */
    initIntruders() {
        const intruders = this.trafficModule.tcas.getIntruders();
        const len = intruders.length;
        for (let i = 0; i < len; i++) {
            this.onIntruderAdded(intruders[i]);
        }
    }
    /**
     * Initializes handlers to respond to TCAS events.
     */
    initTCASHandlers() {
        const tcasSub = this.props.context.bus.getSubscriber();
        tcasSub.on('tcas_intruder_added').handle(this.onIntruderAdded.bind(this));
        tcasSub.on('tcas_intruder_removed').handle(this.onIntruderRemoved.bind(this));
        tcasSub.on('tcas_intruder_alert_changed').handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            this.initCanvasStyles();
            this.updateOobBounds();
        }
    }
    /**
     * Updates the boundaries of the intruder out-of-bounds area.
     */
    updateOobBounds() {
        const projectedSize = this.props.mapProjection.getProjectedSize();
        const oobOffset = this.oobOffset.get();
        this.oobBounds.set(oobOffset[0], oobOffset[1], projectedSize[0] - oobOffset[2], projectedSize[1] - oobOffset[3]);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.redrawIntruders();
    }
    /**
     * Redraws all tracked intruders.
     */
    redrawIntruders() {
        const alertLevelVisFlags = this.trafficModule.alertLevelVisibility.get();
        const offScaleRange = this.trafficModule.offScaleRange.get();
        const oobBounds = this.oobBounds.get();
        const iconDisplay = this.iconLayerRef.instance.display;
        iconDisplay.clear();
        for (let i = 0; i < MapSystemTrafficLayer.DRAW_GROUPS.length; i++) {
            const group = MapSystemTrafficLayer.DRAW_GROUPS[i];
            if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
                this.intruderIcons[group.alertLevel].forEach(icon => {
                    var _a, _b, _c, _d, _e, _f;
                    icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
                    if (this.needHandleOffscaleOob) {
                        if (icon.isOffScale) {
                            (_a = this.props.oobIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                            (_b = this.props.offScaleIntruders) === null || _b === void 0 ? void 0 : _b.add(icon.intruder);
                        }
                        else if (!this.props.mapProjection.isInProjectedBounds(icon.projectedPos, oobBounds)) {
                            (_c = this.props.offScaleIntruders) === null || _c === void 0 ? void 0 : _c.delete(icon.intruder);
                            (_d = this.props.oobIntruders) === null || _d === void 0 ? void 0 : _d.add(icon.intruder);
                        }
                        else {
                            (_e = this.props.offScaleIntruders) === null || _e === void 0 ? void 0 : _e.delete(icon.intruder);
                            (_f = this.props.oobIntruders) === null || _f === void 0 ? void 0 : _f.delete(icon.intruder);
                        }
                    }
                });
            }
            else if (this.needHandleOffscaleOob) {
                this.intruderIcons[group.alertLevel].forEach(icon => {
                    var _a, _b;
                    (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                    (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
                });
            }
        }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
        const operatingMode = this.trafficModule.tcas.getOperatingMode();
        this.setVisible(this.trafficModule.show.get()
            && (operatingMode === TcasOperatingMode.TAOnly
                || operatingMode === TcasOperatingMode.TA_RA
                || operatingMode === TcasOperatingMode.Test));
    }
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    onIntruderAdded(intruder) {
        const icon = this.props.iconFactory(intruder, this.props.context);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    onIntruderRemoved(intruder) {
        var _a, _b;
        (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(intruder);
        (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(intruder);
        this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    onIntruderAlertLevelChanged(intruder) {
        let oldAlertLevel;
        let view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.None].get(intruder);
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ProximityAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.TrafficAdvisory].get(intruder));
        view !== null && view !== void 0 ? view : (view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ResolutionAdvisory].get(intruder));
        if (view) {
            this.intruderIcons[oldAlertLevel].delete(intruder);
            this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
}
MapSystemTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.Other, alertLevel: TcasAlertLevel.None },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ProximityAdvisory, alertLevel: TcasAlertLevel.ProximityAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.TrafficAdvisory, alertLevel: TcasAlertLevel.TrafficAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ResolutionAdvisory, alertLevel: TcasAlertLevel.ResolutionAdvisory },
];
/**
 * An abstract implementation of {@link MapTrafficIntruderIcon} which handles the projection of the intruder's position
 * and off-scale calculations.
 */
class AbstractMapTrafficIntruderIcon {
    /**
     * Constructor.
     * @param intruder This icon's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The ownship module for this icon's parent map.
     */
    constructor(intruder, trafficModule, ownshipModule) {
        this.intruder = intruder;
        this.trafficModule = trafficModule;
        this.ownshipModule = ownshipModule;
        this.projectedPos = new Float64Array(2);
        this.isOffScale = false;
    }
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this icon.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    draw(projection, context, offScaleRange) {
        this.updatePosition(projection, offScaleRange);
        this.drawIcon(projection, context, this.projectedPos, this.isOffScale);
    }
    /**
     * Updates this icon's intruder's projected position and off-scale status.
     * @param projection The map projection.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    updatePosition(projection, offScaleRange) {
        const ownAirplanePos = this.ownshipModule.position.get();
        if (offScaleRange.isNaN()) {
            projection.project(this.intruder.position, this.projectedPos);
            this.isOffScale = false;
        }
        else {
            this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
        }
    }
    /**
     * Updates this icon's intruder's projected position and off-scale status using a specific range from the own
     * airplane to define off-scale.
     * @param projection The map projection.
     * @param ownAirplanePos The position of the own airplane.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale.
     */
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
        const intruderPos = this.intruder.position;
        const horizontalSeparation = intruderPos.distance(ownAirplanePos);
        const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
        if (horizontalSeparation > offscaleRangeRad) {
            this.isOffScale = true;
            projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, AbstractMapTrafficIntruderIcon.geoPointCache[0]), this.projectedPos);
        }
        else {
            this.isOffScale = false;
            projection.project(intruderPos, this.projectedPos);
        }
    }
}
AbstractMapTrafficIntruderIcon.geoPointCache = [new GeoPoint(0, 0)];

/**
 * A class that renders waypoints into a layer.
 */
class MapSystemWaypointsLayer extends MapLayer {
    constructor() {
        var _a;
        super(...arguments);
        this.waypointsLayer = FSComponent.createRef();
        this.displayModule = this.props.model.getModule(MapSystemKeys.NearestWaypoints);
        this.waypointCache = (_a = this.props.waypointCache) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.getCache(this.props.bus);
        this.searchItemLimits = {
            [FacilitySearchType.Airport]: 500,
            [FacilitySearchType.Vor]: 250,
            [FacilitySearchType.Ndb]: 250,
            [FacilitySearchType.Intersection]: 500,
            [FacilitySearchType.User]: 100
        };
        this.searchRadiusLimits = {
            [FacilitySearchType.Airport]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Vor]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Ndb]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.Intersection]: Number.POSITIVE_INFINITY,
            [FacilitySearchType.User]: Number.POSITIVE_INFINITY
        };
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.waypointsLayer.instance.onAttached();
        this.initEventHandlers();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.waypointsLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        if (this.isVisible()) {
            this.waypointsLayer.instance.onUpdated(time, elapsed);
        }
    }
    /** @inheritdoc */
    initEventHandlers() {
        this.displayModule.numAirports.sub(num => this.searchItemLimits[FacilitySearchType.Airport] = num, true);
        this.displayModule.numIntersections.sub(num => this.searchItemLimits[FacilitySearchType.Intersection] = num, true);
        this.displayModule.numVors.sub(num => this.searchItemLimits[FacilitySearchType.Vor] = num, true);
        this.displayModule.numNdbs.sub(num => this.searchItemLimits[FacilitySearchType.Ndb] = num, true);
        this.displayModule.airportsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Airport] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.intersectionsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Intersection] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.vorsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Vor] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.ndbsRange.sub(num => this.searchRadiusLimits[FacilitySearchType.Ndb] = num.asUnit(UnitType.GA_RADIAN), true);
        this.displayModule.refreshWaypoints.on(() => this.waypointsLayer.instance.refreshWaypoints());
    }
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     */
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession) {
        this.displayModule.intersectionsFilter.sub(filters => intSession.setIntersectionFilter(filters.typeMask, filters.showTerminalWaypoints), true);
        this.displayModule.vorsFilter.sub(filters => vorSession.setVorFilter(filters.classMask, filters.typeMask), true);
        this.displayModule.airportsFilter.sub(filters => {
            airportSession.setAirportFilter(filters.showClosed, filters.classMask);
        }, true);
        this.displayModule.extendedAirportsFilter.sub(filters => {
            airportSession.setExtendedAirportFilters(filters.runwaySurfaceTypeMask, filters.approachTypeMask, filters.toweredMask, filters.minimumRunwayLength);
        }, true);
    }
    /**
     * Initializes this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    initWaypointRenderer(renderer, canvasLayer) {
        this.defineRenderRole(renderer, canvasLayer);
        renderer.onRolesAdded.on(this.defineRenderRole.bind(this, renderer, canvasLayer));
    }
    /**
     * Defines the render role for this layer's waypoints.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    defineRenderRole(renderer, canvasLayer) {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach(id => {
            const roleId = renderer.getRoleFromName(id);
            if (roleId !== undefined) {
                renderer.setCanvasContext(roleId, canvasLayer.display.context);
                renderer.setIconFactory(roleId, this.props.iconFactory);
                renderer.setLabelFactory(roleId, this.props.labelFactory);
                renderer.setVisibilityHandler(roleId, this.isWaypointVisible.bind(this));
            }
        });
    }
    /** @inheritdoc */
    setVisible(val) {
        super.setVisible(val);
        this.waypointsLayer.instance.setVisible(val);
    }
    /**
     * Checks to see if a waypoint should be visible.
     * @param waypoint The waypoint to check.
     * @returns True if visible, false otherwise.
     */
    isWaypointVisible(waypoint) {
        if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
            switch (waypoint.type) {
                case WaypointTypes.Airport:
                    return this.displayModule.showAirports.get()(waypoint);
                case WaypointTypes.Intersection:
                    return this.displayModule.showIntersections.get()(waypoint);
                case WaypointTypes.VOR:
                    return this.displayModule.showVors.get()(waypoint);
                case WaypointTypes.NDB:
                    return this.displayModule.showNdbs.get()(waypoint);
            }
        }
        return false;
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapNearestWaypointsLayer, { ref: this.waypointsLayer, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: this.registerWaypoint.bind(this), deregisterWaypoint: this.deregisterWaypoint.bind(this), searchItemLimit: (type) => this.searchItemLimits[type], searchRadiusLimit: (type) => this.searchRadiusLimits[type], getSearchCenter: this.props.useMapTargetAsSearchCenter === true ? (mapProjection) => mapProjection.getTarget() : undefined, onSessionsStarted: this.onSessionsStarted.bind(this), class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /**
     * Registers a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to register.
     * @param renderer The renderer to register the waypoint to.
     */
    registerWaypoint(waypoint, renderer) {
        const selector = this.displayModule.waypointRoleSelector.get();
        if (selector) {
            const id = selector(waypoint);
            const roleId = renderer.getRoleFromName(id);
            if (roleId !== undefined) {
                renderer.register(waypoint, roleId, 'waypoints-layer');
            }
        }
        else {
            const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
            groupRoles.forEach(id => {
                const roleId = renderer.getRoleFromName(id);
                if (roleId !== undefined) {
                    renderer.register(waypoint, roleId, 'waypoints-layer');
                }
            });
        }
    }
    /**
     * Deregisters a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to deregister.
     * @param renderer The renderer to deregister the waypoint from.
     */
    deregisterWaypoint(waypoint, renderer) {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach(id => {
            const roleId = renderer.getRoleFromName(id);
            if (roleId !== undefined) {
                renderer.deregister(waypoint, roleId, 'waypoints-layer');
            }
        });
    }
}

/**
 * A map data module that controls the terrain color reference point.
 */
class MapTerrainColorsModule {
    constructor() {
        /** The terrain colors reference point. */
        this.reference = Subject.create(EBingReference.SEA);
        /** Whether or not to show the map terrain isolines. */
        this.showIsoLines = Subject.create(false);
        /** The terrain colors array. */
        this.colors = ArraySubject.create(BingComponent.createEarthColorsArray('#0000FF', [
            {
                elev: 0,
                color: '#000000'
            }
        ], 0, 30000, 1));
        /** The elevation range over which to assign the terrain colors, as `[minimum, maximum]` in feet. */
        this.colorsElevationRange = Vec2Subject.create(Vec2Math.create(0, 30000));
    }
}

/**
 * A map data module that handles the display of flight plan data.
 */
class MapFlightPlanModule {
    constructor() {
        this.plans = [];
    }
    /**
     * Gets the flight plan subjects for a specified flight plan.
     * @param index The index of the flight plan.
     * @returns The subject for the specified plan index.
     */
    getPlanSubjects(index) {
        let planSubject = this.plans[index];
        if (planSubject === undefined) {
            planSubject = new PlanSubjects();
            this.plans[index] = planSubject;
        }
        return planSubject;
    }
}
/**
 * A collection of subjects for consuming flight plan data in the flight plan module.
 */
class PlanSubjects {
    constructor() {
        /** The current flight plan to display, if any. */
        this.flightPlan = Subject.create(undefined);
        /** An event that fires when the plan is changed. */
        this.planChanged = new SubEvent();
        /** An event that fired when the flight path of the plan is recalculated. */
        this.planCalculated = new SubEvent();
        /** The active leg index currently being navigated to. */
        this.activeLeg = Subject.create(0);
    }
}

/**
 * A module which describes whether the map is following the player airplane.
 */
class MapFollowAirplaneModule {
    constructor() {
        /** Whether the map is following the player airplane. */
        this.isFollowing = Subject.create(false);
    }
}

/**
 * A map data module that controls waypoint display options.
 */
class MapWaypointDisplayModule {
    constructor() {
        /** A handler that dictates airport waypoint visibility. */
        this.showAirports = Subject.create(() => true);
        /** A handler that dictates intersection waypoint visibility. */
        this.showIntersections = Subject.create(() => false);
        /** A handler that dictates NDB waypoint visibility. */
        this.showNdbs = Subject.create(() => true);
        /** A handler that dictates VOR waypoint visibility. */
        this.showVors = Subject.create(() => true);
        /** The maximum range at which airport waypoints should be searched for. */
        this.airportsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
        /** The maximum range at which intersection waypoints should be searched for. */
        this.intersectionsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
        /** The maximum range at which NDB waypoints should be searched for. */
        this.ndbsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
        /** The maximum range at which VOR waypoints should be searched for. */
        this.vorsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
        /** The maximum number of airports that should be displayed. */
        this.numAirports = Subject.create(40);
        /** The maximum number of intersections that should be displayed. */
        this.numIntersections = Subject.create(40);
        /** The maximum number of NDBs that should be displayed. */
        this.numNdbs = Subject.create(40);
        /** The maximum number of VORs that should be displayed. */
        this.numVors = Subject.create(40);
        /** The filter to apply to the intersection search. */
        this.intersectionsFilter = Subject.create({
            typeMask: NearestIntersectionSearchSession.Defaults.TypeMask,
            showTerminalWaypoints: true
        });
        /** The filter to apply to the VOR search. */
        this.vorsFilter = Subject.create({
            typeMask: NearestVorSearchSession.Defaults.TypeMask,
            classMask: NearestVorSearchSession.Defaults.ClassMask
        });
        /** The filter to apply to the airport search. */
        this.airportsFilter = Subject.create({
            classMask: NearestAirportSearchSession.Defaults.ClassMask,
            showClosed: NearestAirportSearchSession.Defaults.ShowClosed
        });
        /** The extended airport filter to apply to the airport search. */
        this.extendedAirportsFilter = Subject.create({
            runwaySurfaceTypeMask: NearestAirportSearchSession.Defaults.SurfaceTypeMask,
            approachTypeMask: NearestAirportSearchSession.Defaults.ApproachTypeMask,
            minimumRunwayLength: NearestAirportSearchSession.Defaults.MinimumRunwayLength,
            toweredMask: NearestAirportSearchSession.Defaults.ToweredMask
        });
        /** A function that will be called with a waypoint when it is registered,
         * and should return the role to use for that waypoint. */
        this.waypointRoleSelector = Subject.create(undefined);
        /** Forces a refresh of all the waypoints. Useful if a waypoint needs a different role to be selected. */
        this.refreshWaypoints = new SubEvent();
    }
}

/**
 * A module that describes the display of weather on a Bing Map instance.
 */
class MapWxrModule {
    constructor() {
        /** Whether the weather radar is enabled. */
        this.isEnabled = Subject.create(false);
        /** The current map weather radar arc sweep angle in degrees. */
        this.weatherRadarArc = NumberUnitSubject.create(UnitType.DEGREE.createNumber(90));
        /** The current weather radar mode. */
        this.weatherRadarMode = Subject.create(EWeatherRadar.HORIZONTAL);
        /**
         * The current weather radar colors. Each entry `E_i` of the array is a tuple `[color, rate]` that defines a color
         * stop, where `color` is an RGBA color expressed as `R + G * 256 + B * 256^2 + A * 256^3` and `rate` is a
         * precipitation rate in millimeters per hour.
         *
         * In general, the color defined by `E_i` is applied to precipitation rates ranging from the rate defined by `E_i-1`
         * to the rate defined by `E_i`. There are two special cases. The color defined by `E_0` is applied to the
         * precipitation rates from zero to the rate defined by `E_0`. The color defined by `E_n-1`, where `n` is the length
         * of the array, is applied to the precipitation rates from the rate defined by `E_n-2` to positive infinity.
         */
        this.weatherRadarColors = ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
        this._wxrMode = MappedSubject.create(([isEnabled, arc, mode]) => {
            return {
                mode: isEnabled ? mode : EWeatherRadar.OFF,
                arcRadians: arc.asUnit(UnitType.RADIAN),
            };
        }, this.isEnabled, this.weatherRadarArc, this.weatherRadarMode);
    }
    /**
     * A subscribable containing the combined WxrMode from the mode and arc subjects,
     * suitable for consumption in a MapBingLayer.
     * @returns The WxrMode subscribable.
     */
    get wxrMode() {
        return this._wxrMode;
    }
}

/**
 * A module describing the display of the altitude intercept arc.
 */
class MapAltitudeArcModule {
    /**
     * MapAltitudeArcModule constructor.
     * @param show When passed, the `show` field will be initialized to this value.
     */
    constructor(show) {
        /** Whether to show the altitude intercept arc. */
        this.show = Subject.create(false);
        if (show !== undefined) {
            this.show.set(show);
        }
    }
}

/**
 * A class that builds a configuration for the waypoint display.
 */
class WaypointDisplayBuilder {
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     */
    constructor(iconFactory, labelFactory, waypointRenderer) {
        this.iconFactory = iconFactory;
        this.labelFactory = labelFactory;
        this.waypointRenderer = waypointRenderer;
        this.roleGroup = MapSystemWaypointRoles.Normal;
        this.isCenterTarget = false;
    }
    /**
     * Adds a icon configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an icon for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addIcon(role, type, config) {
        this.iconFactory.addIconFactory(this.determineRoleId(role), type, config);
        return this;
    }
    /**
     * Adds a default icon configuration to the waypoint display system, if no other configuration is found.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultIcon(role, config) {
        this.iconFactory.addDefaultIconFactory(this.determineRoleId(role), config);
        return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an label for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addLabel(role, type, config) {
        this.labelFactory.addLabelFactory(this.determineRoleId(role), type, config);
        return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultLabel(role, config) {
        this.labelFactory.addDefaultLabelFactory(this.determineRoleId(role), config);
        return this;
    }
    /**
     * Determines the role ID given either a numeric or string based role.
     * @param role The role to determine.
     * @returns The numeric role ID.
     */
    determineRoleId(role) {
        let roleId = 0;
        if (typeof role === 'string') {
            const roleIdFromName = this.waypointRenderer.getRoleFromName(role);
            if (roleIdFromName !== undefined) {
                roleId = roleIdFromName;
            }
        }
        else {
            roleId = role;
        }
        return roleId;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
        this.waypointRenderer.addRenderRole(name, undefined, this.roleGroup);
        return this;
    }
    /**
     * Gets the ID of a role in the waypoint display system.
     * @param role The name of the role to get the ID for.
     * @returns The ID of the role.
     * @throws An error if an invalid role name is supplied.
     */
    getRoleId(role) {
        const roleId = this.waypointRenderer.getRoleFromName(role);
        if (roleId === undefined) {
            throw new Error(`The role with name ${role} was not defined and could not be found.`);
        }
        return roleId;
    }
    /**
     * Configures the center for waypoint searches for this display.
     * @param center If center, then waypoint searches will use the map center. If target,
     * waypoint searches will use the map target with offset.
     * @returns The modified builder.
     */
    withSearchCenter(center) {
        if (center === 'center') {
            this.isCenterTarget = false;
        }
        else {
            this.isCenterTarget = true;
        }
        return this;
    }
    /**
     * Gets if the waypoint search is using the map target with offset as the search center.
     * @returns True if the search center is the map target, false if it is the map center.
     */
    getIsCenterTarget() {
        return this.isCenterTarget;
    }
    /**
     * Configures the facility waypoint cache to use with the waypoint display.
     * @param cache The facility waypoint cache to use, or undefined to use the default.
     * @returns The modified builder.
     */
    withWaypointCache(cache) {
        this.facilityWaypointCache = cache;
        return this;
    }
    /**
     * Gets the currently set facility waypoint cache.
     * @returns The currently set facility waypoint cache.
     */
    getWaypointCache() {
        return this.facilityWaypointCache;
    }
}

/**
 * A class that builds the configuration for the flight plan display.
 */
class FlightPlanDisplayBuilder extends WaypointDisplayBuilder {
    /**
     * Creates an instance of the FlightPlanDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     * @param flightPlanRenderer The flight plan renderer to use with this builder.
     * @param planIndex The flight plan index to be displayed by this system.
     */
    constructor(iconFactory, labelFactory, waypointRenderer, flightPlanRenderer, planIndex) {
        super(iconFactory, labelFactory, waypointRenderer);
        this.flightPlanRenderer = flightPlanRenderer;
        this.planIndex = planIndex;
        this.roleGroup = MapSystemWaypointRoles.FlightPlan;
        this.roleGroup = `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`;
        flightPlanRenderer.legStyleHandlers;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
        this.waypointRenderer.insertRenderRole(name, MapSystemWaypointRoles.Normal, undefined, this.roleGroup);
        return this;
    }
    /**
     * Configures the flight path display to use styles returned by the provided function.
     * @param handler The handler to use to return the required path rendering styles.
     * @returns The modified builder.
     */
    withLegPathStyles(handler) {
        this.flightPlanRenderer.legStyleHandlers.set(this.planIndex, handler);
        return this;
    }
    /**
     * Configures the flight plan waypoint display to use the roles returned by the
     * provided function.
     * @param handler The handler to use to return the required waypoint display roles.
     * @returns The modified builder.
     */
    withLegWaypointRoles(handler) {
        this.flightPlanRenderer.legWaypointHandlers.set(this.planIndex, handler);
        return this;
    }
    /**
     * Configures the flight plan flight path display to set visibility of leg-to-leg
     * turn anticipation transitions.
     * @param visible Whether or not the leg-to-leg turn anticipation transitions will be visible.
     * @returns The modified builder.
     */
    withAnticipationTurns(visible) {
        const visibleSub = SubscribableUtils.toSubscribable(visible, true);
        this.flightPlanRenderer.renderEgress = visibleSub;
        this.flightPlanRenderer.renderIngress = visibleSub;
        return this;
    }
}

/**
 * An generic implementation of {@link MapAirspaceRenderManager}.
 */
class GenericAirspaceRenderManager {
    /**
     * Constructor.
     * @param renderOrder A function which determines the order in which this manager renders airspaces. The function
     * should return a negative number when airspace `a` should be rendered before (below) airspace `b`, a positive
     * number when airspace `a` should be rendered after (above) airspace `b`, and `0` when the relative render order
     * of the two airspaces does not matter.
     * @param selectRenderer A function which selects airspace renderers for individual airspaces.
     */
    constructor(renderOrder, selectRenderer) {
        this.renderOrder = renderOrder;
        this.selectRenderer = selectRenderer;
        this.airspaces = new Map();
    }
    /** @inheritdoc */
    getRegisteredAirspaces() {
        return Array.from(this.airspaces.values());
    }
    /** @inheritdoc */
    registerAirspace(airspace) {
        if (this.airspaces.has(airspace.facility.id)) {
            return false;
        }
        this.airspaces.set(airspace.facility.id, airspace);
        return true;
    }
    /** @inheritdoc */
    deregisterAirspace(airspace) {
        return this.airspaces.delete(airspace.facility.id);
    }
    /** @inheritdoc */
    replaceRegisteredAirspaces(airspaces) {
        let changed = false;
        let numMatched = 0;
        for (const airspace of airspaces) {
            changed || (changed = !this.airspaces.has(airspace.facility.id));
            if (changed) {
                break;
            }
            else {
                numMatched++;
            }
        }
        changed || (changed = numMatched !== this.airspaces.size);
        if (!changed) {
            return false;
        }
        this.airspaces.clear();
        for (const airspace of airspaces) {
            this.registerAirspace(airspace);
        }
        return true;
    }
    /** @inheritdoc */
    clearRegisteredAirspaces() {
        if (this.airspaces.size === 0) {
            return false;
        }
        this.airspaces.clear();
        return true;
    }
    /** @inheritdoc */
    prepareRenderProcess(projection, context, taskQueueHandler, lod = 0, stream) {
        const sorted = Array.from(this.airspaces.values()).sort(this.renderOrder);
        const tasks = sorted.map(airspace => {
            const renderer = this.selectRenderer(airspace);
            // The explicit cast is to avoid a bogus typescript error
            return renderer.render.bind(renderer, airspace, projection, context, lod, stream);
        });
        return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
}

/**
 * Updates the properties in a {@link MapAutopilotPropsModule}.
 */
class MapAutopilotPropsController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz. If not defined, the properties
     * will be updated every frame.
     */
    constructor(context, properties, updateFreq) {
        super(context);
        this.properties = properties;
        this.updateFreq = updateFreq;
        this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
        this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        if (this.updateFreq) {
            this.updateFreqSub = this.updateFreq.sub(freq => {
                var _a;
                for (const property of this.properties) {
                    (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.subs[property] = this.bindProperty(sub, property, freq);
                }
            }, true);
        }
        else {
            for (const property of this.properties) {
                this.subs[property] = this.bindProperty(sub, property);
            }
        }
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
        switch (property) {
            case 'selectedAltitude':
                return (updateFreq === undefined ? sub.on('ap_altitude_selected') : sub.on('ap_altitude_selected').atFrequency(updateFreq))
                    .handle(alt => { this.module.selectedAltitude.set(alt, UnitType.FOOT); });
        }
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        super.destroy();
        (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const property of this.properties) {
            (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
        }
    }
}

/**
 * A component that encompasses the compiled map system.
 */
class MapSystemComponent extends MapComponent {
    /** @inheritdoc */
    constructor(props) {
        var _a;
        super(props);
        this.rootStyles = ObjectSubject.create({
            width: '0px',
            height: '0px'
        });
        this.deadZone = (_a = this.props.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.create(new Float64Array(4));
        this.deadZone.sub(this.onDeadZoneChanged.bind(this));
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
        super.onAfterRender(thisNode);
        this.onProjectedSizeChanged();
        this.props.onAfterRender();
    }
    /**
     * This method is called when the size of this map's dead zone changes.
     * @param deadZone The dead zone.
     */
    onDeadZoneChanged(deadZone) {
        this.props.onDeadZoneChanged(deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        this.props.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
        this.rootStyles.set('width', `${size[0]}px`);
        this.rootStyles.set('height', `${size[1]}px`);
    }
    /** @inheritdoc */
    onProjectedSizeChanged() {
        this.setRootSize(this.mapProjection.getProjectedSize());
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.props.onBeforeUpdated(time, elapsed);
        super.onUpdated(time, elapsed);
        this.props.onAfterUpdated(time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
        super.onWake();
        this.props.onWake();
    }
    /** @inheritdoc */
    onSleep() {
        super.onSleep();
        this.props.onSleep();
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { style: this.rootStyles, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }, this.props.children));
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.props.onDestroy();
    }
}

/**
 * An implementation of the base properties in {@link MapSystemContext}.
 */
class DefaultMapSystemContext {
    /**
     * Creates an instance of a MapSystemContext.
     * @param bus This context's event bus.
     * @param projection This context's map projection.
     * @param projectedSize A subscribable which provides the projected size of this context's map.
     * @param deadZone A subscribable which provides the dead zone of this context's map.
     */
    constructor(bus, projection, projectedSize, deadZone) {
        this.bus = bus;
        this.projection = projection;
        this.projectedSize = projectedSize;
        this.deadZone = deadZone;
        /** This context's map model. */
        this.model = new MapModel();
        this.layers = new Map();
        this.controllers = new Map();
    }
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer(key) {
        return this.layers.get(key);
    }
    /**
     * Retrieves a controller from this context.
     * @param key The key fo the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController(key) {
        return this.controllers.get(key);
    }
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer(key, layer) {
        this.layers.set(key, layer);
    }
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController(key, controller) {
        this.controllers.set(key, controller);
    }
}

/**
 * A map controller which delegates its behavior to injected callback functions.
 */
class MapSystemGenericController extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param callbacks The callback functions to which this controller delegates its behavior.
     */
    constructor(context, callbacks) {
        super(context);
        this.callbacks = callbacks;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.callbacks.onAfterMapRender && this.callbacks.onAfterMapRender(this.context);
    }
    /** @inheritdoc */
    onDeadZoneChanged(deadZone) {
        this.callbacks.onDeadZoneChanged && this.callbacks.onDeadZoneChanged(this.context, deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.callbacks.onMapProjectionChanged && this.callbacks.onMapProjectionChanged(this.context, mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onBeforeUpdated(time, elapsed) {
        this.callbacks.onBeforeUpdated && this.callbacks.onBeforeUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onAfterUpdated(time, elapsed) {
        this.callbacks.onAfterUpdated && this.callbacks.onAfterUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
        this.callbacks.onWake && this.callbacks.onWake(this.context);
    }
    /** @inheritdoc */
    onSleep() {
        this.callbacks.onSleep && this.callbacks.onSleep(this.context);
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.callbacks.onMapDestroyed && this.callbacks.onMapDestroyed(this.context);
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.callbacks.onDestroyed && this.callbacks.onDestroyed(this.context);
    }
}

/**
 * A map flight plan renderer that can be supplied styling from the outside.
 */
class MapSystemPlanRenderer extends AbstractFlightPathPlanRenderer {
    /**
     * Creates an instance of the MapSystemPlanRenderer.
     * @param defaultRoleId The default role ID to render the plan waypoints under.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in a first-to-last
     * fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(defaultRoleId, renderOrder, renderActiveLegLast) {
        super(renderOrder, renderActiveLegLast);
        this.defaultRoleId = defaultRoleId;
        this.legRenderer = new MapSystemLegRenderer();
        /**
         * A handler that returns a leg rendering style for a given set of leg data.
         * @returns A leg rendering style.
         */
        this.legStyleHandlers = new Map();
        /**
         * A handler that returns whether or not a leg waypoint should be displayed.
         * @returns Whether or not the leg should be displayed.
         */
        this.legWaypointHandlers = new Map();
        /** Whether or not to render flight path ingress turns. */
        this.renderIngress = Subject.create(false);
        /** Whether or not to render flight path egress turns. */
        this.renderEgress = Subject.create(false);
    }
    /** @inheritdoc */
    renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
        this.legRenderer.currentRenderStyle = FlightPathRenderStyle.Default;
        const handler = this.legStyleHandlers.get(plan.planIndex);
        if (handler !== undefined) {
            this.legRenderer.currentRenderStyle = handler(plan, leg, activeLeg, legIndex, activeLegIndex);
        }
        let partsToRender = FlightPathLegRenderPart.Base
            | (this.renderIngress.get() ? FlightPathLegRenderPart.Ingress : 0)
            | (this.renderEgress.get() ? FlightPathLegRenderPart.Egress : 0);
        if (this.legRenderer.currentRenderStyle.partsToRender !== undefined) {
            partsToRender = this.legRenderer.currentRenderStyle.partsToRender;
        }
        this.legRenderer.render(leg, context, streamStack, partsToRender);
    }
}
/**
 * A map system flight plan leg renderer that uses a swappable style.
 */
class MapSystemLegRenderer extends AbstractFlightPathLegRenderer {
    constructor() {
        super(...arguments);
        this.vectorRenderer = new FlightPathVectorLineRenderer();
        this.currentRenderStyle = new FlightPathRenderStyle();
    }
    /** @inheritdoc */
    renderVector(vector, isIngress, isEgress, leg, context, streamStack) {
        if ('styleBuilder' in this.currentRenderStyle) {
            const currentRenderStyle = this.currentRenderStyle.styleBuilder(vector, isIngress, isEgress);
            this.vectorRenderer.render(vector, context, streamStack, currentRenderStyle.width, currentRenderStyle.style, currentRenderStyle.dash, currentRenderStyle.outlineWidth, currentRenderStyle.outlineStyle, currentRenderStyle.lineCap);
        }
        else {
            if (this.currentRenderStyle.isDisplayed) {
                this.vectorRenderer.render(vector, context, streamStack, this.currentRenderStyle.width, this.currentRenderStyle.style, this.currentRenderStyle.dash, this.currentRenderStyle.outlineWidth, this.currentRenderStyle.outlineStyle, this.currentRenderStyle.lineCap);
            }
        }
    }
}
/**
 * A vector line rendering style to apply to a flight path display on the map.
 */
class FlightPathRenderStyle {
    /**
     * Creates an instance of a FlightPathRenderStyle.
     * @param isDisplayed Whether or not the path is displayed.
     */
    constructor(isDisplayed = true) {
        this.isDisplayed = isDisplayed;
        /** The pixel width of the path line. */
        this.width = 2;
        /** The style string for the line. */
        this.style = '';
    }
}
/** The default rendering style. */
FlightPathRenderStyle.Default = new FlightPathRenderStyle();
/** A style that does not display the path. */
FlightPathRenderStyle.Hidden = new FlightPathRenderStyle(false);

/**
 * Utility methods related to MapSystem.
 */
class MapSystemUtils {
    /**
     * Converts a nominal relative projected x coordinate to a true relative projected x coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelX A nominal relative projected x coordinate.
     * @param width The width of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected x coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeX(nominalRelX, width, deadZone) {
        return (nominalRelX * (width - deadZone[0] - deadZone[2]) + deadZone[0]) / width;
    }
    /**
     * Converts a nominal relative projected y coordinate to a true relative projected y coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelY A nominal relative projected y coordinate.
     * @param height The height of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected y coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeY(nominalRelY, height, deadZone) {
        return (nominalRelY * (height - deadZone[1] - deadZone[3]) + deadZone[1]) / height;
    }
    /**
     * Converts nominal relative projected coordinates to a true relative projected coordinates. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominal Nominal relative projected coordinates.
     * @param size The size of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @param out The vector to which to write the result.
     * @returns The true relative projected coordinates that are equivalent to the specified nominal coordinates.
     */
    static nominalToTrueRelativeXY(nominal, size, deadZone, out) {
        return Vec2Math.set(MapSystemUtils.nominalToTrueRelativeX(nominal[0], size[0], deadZone), MapSystemUtils.nominalToTrueRelativeY(nominal[1], size[1], deadZone), out);
    }
}

/**
 * A waypoint renderer for the MapSystem API. Supports addition of string-keyed render roles. Each render role is
 * assigned a position in an ordered list that determines the priority of being chosen when roles are selected for
 * rendering waypoints. For each waypoint, the renderer iterates through all render roles in the priority order list
 * and selects the first role under which the waypoint is registered and is visible.
 */
class MapSystemWaypointsRenderer extends MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager) {
        super(textManager, (entry, roleDefinitions) => {
            var _a;
            for (let i = 0; i < this.rolePriorityOrder.length; i++) {
                const role = this.rolePriorityOrder[i];
                if (entry.isAllRoles(role) && ((_a = roleDefinitions.get(role)) === null || _a === void 0 ? void 0 : _a.visibilityHandler(entry.waypoint))) {
                    return role;
                }
            }
            return 0;
        });
        this.rolePriorityOrder = [];
        this.rolesByGroup = new Map();
        this.roleIdMap = new Map();
        this.currentBit = 1;
        /** An event that fires when any roles are added. */
        this.onRolesAdded = new SubEvent();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRenderRole(arg1, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
        if (typeof arg1 === 'number') {
            return false;
        }
        this.roleIdMap.set(arg1, this.currentBit);
        super.addRenderRole(this.currentBit, def);
        this.rolePriorityOrder.push(this.currentBit);
        let roleGroup = this.rolesByGroup.get(group);
        if (roleGroup === undefined) {
            roleGroup = [];
            this.rolesByGroup.set(group, roleGroup);
        }
        roleGroup.push(arg1);
        this.currentBit *= 2;
        this.onRolesAdded.notify(this);
        return true;
    }
    /**
     * Adds a new named render role to this renderer and inserts it before an existing render role in this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param insertBefore The name of the role before which to insert the new role in this renderer's render role
     * selection priority order. If the name does not match any of this renderer's existing render roles, the new role
     * will be placed at the end of the priority order.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully inserted.
     */
    insertRenderRole(name, insertBefore, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
        const role = this.currentBit;
        this.addRenderRole(name, def, group);
        const roleToInsertBefore = this.roleIdMap.get(insertBefore);
        if (roleToInsertBefore !== undefined) {
            const indexToInsertBefore = this.rolePriorityOrder.indexOf(roleToInsertBefore);
            if (indexToInsertBefore >= 0 && indexToInsertBefore < this.rolePriorityOrder.length - 1) {
                this.rolePriorityOrder.pop();
                this.rolePriorityOrder.splice(indexToInsertBefore, 0, role);
            }
        }
        return true;
    }
    /**
     * Gets a render role associated with a name.
     * @param name The name of the role.
     * @returns The render role associated with the specified name, or undefined if there is no such role.
     */
    getRoleFromName(name) {
        return this.roleIdMap.get(name);
    }
    /**
     * Gets the names of roles in a specified group.
     * @param group A render role group.
     * @returns An array of the names of all render roles belonging to the specified group.
     */
    getRoleNamesByGroup(group) {
        const roleNames = this.rolesByGroup.get(group);
        if (roleNames !== undefined) {
            return roleNames;
        }
        return [];
    }
}
/** The default render role group. */
MapSystemWaypointsRenderer.DefaultGroup = 'DEFAULT_GROUP';
/**
 * A class that creates icons for the map system waypoint renderer.
 */
class MapSystemIconFactory {
    constructor() {
        this.cache = new Map();
        this.iconFactories = new Map();
        this.defaultIconFactories = new Map();
    }
    /**
     * Adds an icon factory to the container.
     * @param role The role that this icon factory will be assigned to.
     * @param iconType The unique string type name of the icon.
     * @param factory The factory that will produce the icon.
     */
    addIconFactory(role, iconType, factory) {
        if (!this.iconFactories.has(role)) {
            this.iconFactories.set(role, new Map());
        }
        const roleFactories = this.iconFactories.get(role);
        roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default icon factory for a role.
     * @param role The role to add a default icon factory for.
     * @param factory The factory that will produce the icons.
     */
    addDefaultIconFactory(role, factory) {
        this.defaultIconFactories.set(role, factory);
    }
    /** @inheritdoc */
    getIcon(role, waypoint) {
        if (!this.cache.has(role)) {
            this.cache.set(role, new Map());
        }
        const roleCache = this.cache.get(role);
        let icon = roleCache.get(waypoint.uid);
        if (icon === undefined) {
            icon = this.createIcon(role, waypoint);
            roleCache.set(waypoint.uid, icon);
        }
        return icon;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(role, waypoint) {
        if (!this.iconFactories.has(role)) {
            this.iconFactories.set(role, new Map());
        }
        const roleFactories = this.iconFactories.get(role);
        const factory = roleFactories.get(waypoint.type);
        if (factory !== undefined) {
            return factory(waypoint);
        }
        else {
            const defaultFactory = this.defaultIconFactories.get(role);
            if (defaultFactory !== undefined) {
                return defaultFactory(waypoint);
            }
        }
        const imageEl = document.createElement('img');
        imageEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFjSURBVFhHvZarTsVAEIa3qCMQCAxPgEEikDwGAkGCAIFAIHgQHgGJ4C0Q4AiBN8CQQAIJuOGfs9N0d3p62tlLv+RPd2fFNrNfLy4Lov1lMtiQayqnyJkfzg3RAvlEfpEtqZrJ6cARwhsvkGMuzAvRA0KSZ6nOBNFesHmbA1k1kXoEq8SbScZOPt2BJBlTOtDKx7whT344l4yxfFfIeTCvLGMsH7d8G9lEvqXGMcloPYJQtHvXNB/ID8a3vrSkkox9+Q5lhdf4m9DWs96MwxCdBJu8SrWD6DFYv5BqQbR8mqoyrpJPkyjjVAn78mmqybhOPk0VGcfk0xSXcUw+TVEZp8inMco4JuG4fJpiMlrk0xSR0SqfJltGq3yaLBlT5NNMlHFIQrt8mokyNnLtYPmce0dace6QFz80s4vwLxzzh+zgxr78dIhYvtK5lF3WEMtXOr2nKT4C3/5rP6nGTZJTdXDuH4TJQyPZ/x+gAAAAAElFTkSuQmCC';
        return new MapWaypointImageIcon(waypoint, 0, imageEl, Vec2Math.create(24, 24));
    }
}
/**
 * A class that create labels for the map system waypoint renderer.
 */
class MapSystemLabelFactory {
    constructor() {
        this.cache = new Map();
        this.labelFactories = new Map();
        this.defaultLabelFactories = new Map();
    }
    /**
     * Adds an label factory to the container.
     * @param role The role to add this label factory for.
     * @param iconType The unique string type name of the waypoint.
     * @param factory The factory that will produce the waypoint label.
     */
    addLabelFactory(role, iconType, factory) {
        if (!this.labelFactories.has(role)) {
            this.labelFactories.set(role, new Map());
        }
        const roleFactories = this.labelFactories.get(role);
        roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default label factory for a role.
     * @param role The role to add a default label factory for.
     * @param factory The factory that will produce the labels.
     */
    addDefaultLabelFactory(role, factory) {
        this.defaultLabelFactories.set(role, factory);
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        if (!this.cache.has(role)) {
            this.cache.set(role, new Map());
        }
        const roleCache = this.cache.get(role);
        let label = roleCache.get(waypoint.uid);
        if (label === undefined) {
            label = this.createLabel(role, waypoint);
            roleCache.set(waypoint.uid, label);
        }
        return label;
    }
    /**
     * Creates a new label for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint to create a label for.
     * @returns A new waypoint label.
     */
    createLabel(role, waypoint) {
        if (!this.labelFactories.has(role)) {
            this.labelFactories.set(role, new Map());
        }
        const roleFactories = this.labelFactories.get(role);
        const factory = roleFactories.get(waypoint.type);
        if (factory !== undefined) {
            return factory(waypoint);
        }
        else {
            const defaultFactory = this.defaultLabelFactories.get(role);
            if (defaultFactory !== undefined) {
                return defaultFactory(waypoint);
            }
        }
        let text = '';
        if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
            text = ICAO.getIdent(waypoint.facility.get().icao);
        }
        return new MapCullableLocationTextLabel(text, 0, waypoint.location, false, { fontSize: 22, font: 'monospace', anchor: new Float64Array([-0.25, 0.4]) });
    }
}

/**
 * Builds maps. Each builder is configured with a series of build steps which collectively define how the builder
 * compiles finished maps. In addition to defining basic map properties such as size and range, build steps can also
 * customize map behavior and appearance through adding map model modules, layers, and controllers.
 *
 * Each map compiled by the builder is associated with a {@link MapSystemContext}, which holds references to the map
 * projection, map model, all layers and controllers, and other data associated with the map. Layers and controllers
 * have access to the context when they are created during compilation, and a reference to the context is stored with
 * the compiled map.
 *
 * A single builder can compile multiple maps. Each compiled map is a separate entity, with its own model, layers,
 * controllers, and context.
 */
class MapSystemBuilder {
    /**
     * Creates an instance of a map system builder.
     * @param bus This builder's event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.moduleFactories = new Map();
        this.layerFactories = new Map();
        this.controllerFactories = new Map();
        this.contextFactories = new Map();
        this.initCallbacks = new Map();
        this.projectedSize = Subject.create(Vec2Math.create(100, 100));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map model modules added to this builder. */
    get moduleCount() {
        return this.moduleFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map layers added to this builder. */
    get layerCount() {
        return this.layerFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map controllers added to this builder. */
    get controllerCount() {
        return this.controllerFactories.size;
    }
    /**
     * Creates a new Garmin map builder. The builder is initialized with a default projected size of `[100, 100]` pixels.
     * @param bus The event bus.
     * @returns A new Garmin map builder.
     */
    static create(bus) {
        return new MapSystemBuilder(bus);
    }
    /**
     * Configures this builder to generate a map with a given projected window size.
     * @param size The size of the projected window, as `[width, height]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withProjectedSize(size) {
        this.projectedSize = 'isSubscribable' in size ? size : Subject.create(size);
        return this;
    }
    /**
     * Configures this builder to generate a map with a given dead zone.
     * @param deadZone The dead zone, as `[left, top, right, bottom]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withDeadZone(deadZone) {
        this.deadZone = 'isSubscribable' in deadZone ? deadZone : VecNSubject.createFromVector(new Float64Array(deadZone));
        return this;
    }
    /**
     * Configures this builder to generate a map with an initial projected target offset.
     * @param offset The initial projected target offset, as `[x, y]` in pixels.
     * @returns This builder, after it has been configured.
     */
    withTargetOffset(offset) {
        this.targetOffset = offset;
        return this;
    }
    /**
     * Configures this builder to generate a map with specific initial range endpoints. The endpoints are defined
     * relative to the width and height of the map's projected window, *excluding* the dead zone.
     * @param endpoints The initial range endpoints, as `[x1, y1, x2, y2]`.
     * @returns This builder, after it has been configured.
     */
    withRangeEndpoints(endpoints) {
        this.nominalRangeEndpoints = endpoints;
        return this;
    }
    /**
     * Configures this build to generate a map with a specific initial range.
     * @param range The initial range.
     * @returns This builder, after it has been configured.
     */
    withRange(range) {
        this.range = range.asUnit(UnitType.GA_RADIAN);
        return this;
    }
    /**
     * Adds a map module to this builder. When this builder compiles its map, all added modules will be created and added
     * to the map's model. If an existing module has been added to this builder with the same key, it will be replaced.
     * @param key The key (name) of the module.
     * @param factory A function which creates the module.
     * @returns This builder, after the map module has been added.
     */
    withModule(key, factory) {
        this.moduleFactories.set(key, { key, factory });
        return this;
    }
    /**
     * Adds a map layer to this builder. When this builder compiles its map, all added layers will be created and
     * attached to the map. Layers with a lower assigned order will be attached before and appear below layers with
     * greater assigned order values. If an existing layer has been added to this builder with the same key, it will be
     * replaced.
     * @param key The key of the layer.
     * @param factory A function which renders the layer as a VNode.
     * @param order The order assigned to the layer. Layers with lower assigned order will be attached to the map before
     * and appear below layers with greater assigned order values. Defaults to the number of layers already added to this
     * builder.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the layer.
     */
    withLayer(key, factory, order) {
        // Delete the key to ensure a consistent layer order.
        const wasDeleted = this.layerFactories.delete(key);
        this.layerFactories.set(key, { key, factory, order: order !== null && order !== void 0 ? order : (this.layerFactories.size + (wasDeleted ? 1 : 0)) });
        return this;
    }
    /**
     * Adds a controller to this builder. When this builder compiles its map, all added controllers will be created and
     * hooked up to the map's lifecycle callbacks. If an existing controller has been added to this builder with the same
     * key, it will be replaced.
     * @param key The key of the controller.
     * @param factory A function which creates the controller.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the controller.
     */
    withController(key, factory) {
        this.controllerFactories.set(key, { factory });
        return this;
    }
    /**
     * Adds a context property to this builder. When the builder compiles its map, all added properties will be available
     * on the context. Properties are created on the context in the order they were added to the builder, and property
     * factories have access to previously created properties on the context. If an existing property has been added to
     * this builder with the same key, it will be replaced.
     * @param key The key of the property to add.
     * @param factory A function which creates the value of the property.
     * @returns This builder, after the context property has been added.
     */
    withContext(key, factory) {
        var _a;
        if (!MapSystemBuilder.RESTRICTED_CONTEXT_KEYS.has(key)) {
            const existing = this.contextFactories.get(key);
            const order = (_a = existing === null || existing === void 0 ? void 0 : existing.order) !== null && _a !== void 0 ? _a : this.contextFactories.size;
            this.contextFactories.set(key, { key, factory, order });
        }
        return this;
    }
    /**
     * Configures this builder to execute a callback function immediately after it is finished compiling a map. If an
     * existing callback has been added to this builder with the same key, it will be replaced.
     * @param key The key of the callback.
     * @param callback The callback function to add.
     * @returns This builder, after the callback has been added.
     */
    withInit(key, callback) {
        this.initCallbacks.set(key, callback);
        return this;
    }
    /**
     * Assigns an order value to a layer. Layers with a lower assigned order will be attached before and appear below
     * layers with greater assigned order values.
     * @param key The key of the layer to which to assign the order value.
     * @param order The order value to assign.
     * @returns This builder, after the order value has been assigned.
     */
    withLayerOrder(key, order) {
        const factory = this.layerFactories.get(key);
        if (factory) {
            // Delete the key to ensure a consistent layer order.
            this.layerFactories.delete(key);
            factory.order = order;
            this.layerFactories.set(key, factory);
        }
        return this;
    }
    /**
     * Configures this builder to add a controller which maintains a list of bindings from source to target
     * subscribables.
     * @param key The key of the controller.
     * @param bindings The bindings to maintain.
     * @param onDestroy A function to execute when the controller is destroyed.
     * @returns This builder, after it has been configured.
     */
    withBindings(key, bindings, onDestroy) {
        return this.withController(key, context => new MapBindingsController(context, bindings(context), onDestroy));
    }
    /**
     * Configures this builder to generate a map which is updated at a regular frequency based on event bus clock events.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'updateFreq': Subscribable<number>`
     *
     * Controllers:
     * * `[MapSystemKeys.ClockUpdate]: MapClockUpdateController`.
     * @param updateFreq The map's update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withClockUpdate(updateFreq) {
        return this
            .withContext('updateFreq', () => typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq)
            .withController(MapSystemKeys.ClockUpdate, context => new MapClockUpdateController(context));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's projection target.
     *
     * Adds the context property `[MapSystemKeys.TargetControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withTargetControlModerator() {
        return this.withContext(MapSystemKeys.TargetControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's rotation.
     *
     * Adds the context property `[MapSystemKeys.RotationControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRotationControlModerator() {
        return this.withContext(MapSystemKeys.RotationControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's range.
     *
     * Adds the context property `[MapSystemKeys.RangeControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRangeControlModerator() {
        return this.withContext(MapSystemKeys.RangeControl, () => new ResourceModerator(undefined));
    }
    /**
     * Configures this builder to generate a map whose projection target follows the player airplane. The follow airplane
     * behavior will be active if and only if the controller owns the projection target control resource. The
     * controller's priority for the resource is `0`.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TargetControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
     *
     * Controllers:
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneController`
     * @returns This builder, after it has been configured.
     */
    withFollowAirplane() {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule)
            .withModule(MapSystemKeys.FollowAirplane, () => new MapFollowAirplaneModule())
            .withTargetControlModerator()
            .withController(MapSystemKeys.FollowAirplane, context => new MapFollowAirplaneController(context));
    }
    /**
     * Configures this builder to generate a map which supports common rotation behavior. The rotation behavior will be
     * active if and only if the controller owns the rotation control resource. The controller's priority for the
     * resource is `0`.
     *
     * Requires the module `'ownAirplaneProps': MapOwnAirplanePropsModule` to support player airplane-derived rotation
     * behavior, such as Heading Up and Track Up.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'[MapSystemKeys.RotationControl]': ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * @returns This builder, after it has been configured.
     */
    withRotation() {
        return this
            .withModule(MapSystemKeys.Rotation, () => new MapRotationModule())
            .withRotationControlModerator()
            .withController(MapSystemKeys.Rotation, context => new MapRotationController(context));
    }
    /**
     * Configures this builder to generate a map which displays an icon depicting the position of the player airplane.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule`
     *
     * Layers:
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneLayer`
     * @param iconSize The size of the icon, in pixels.
     * @param iconFilePath The path to the icon's image asset, or a subscribable which provides it.
     * @param iconAnchor The point on the icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with `[0, 0]` at the
     * top left and `[1, 1]` at the bottom right.
     * @param cssClass The CSS class(es) to apply to the root of the airplane icon layer.
     * @param order The order assigned to the icon layer. Layers with lower assigned order will be attached to the map
     * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
     * to this builder.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIcon(iconSize, iconFilePath, iconAnchor, cssClass, order) {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
            .withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule())
            .withLayer(MapSystemKeys.OwnAirplaneIcon, (context) => {
            return (FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: iconFilePath, iconSize: iconSize, iconAnchor: iconAnchor, class: cssClass }));
        }, order);
    }
    /**
     * Configures this builder to add a controller which controls and optimizes the orientation of the own airplane icon
     * in response to a desired orientation and the map rotation type. If the desired orientation matches the map
     * rotation (e.g. both Heading Up), the icon orientation is set to Map Up; otherwise the orientation is set to the
     * desired orientation.
     *
     * Requires the modules `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule` and
     * `[MapSystemKeys.Rotation]: MapRotationModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneIconOrientation]: MapOwnAirplaneIconOrientationController`.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIconOrientation(desiredOrientation) {
        return this.withController(MapSystemKeys.OwnAirplaneIconOrientation, context => new MapOwnAirplaneIconOrientationController(context, desiredOrientation));
    }
    /**
     * Configures this builder to bind properties in an added {@link MapOwnAirplanePropsModule} to data derived from
     * event bus events.
     *
     * Requires the module `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsController`.
     * @param properties The properties to bind.
     * @param updateFreq The update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplanePropBindings(properties, updateFreq) {
        return this.withController(MapSystemKeys.OwnAirplaneProps, context => new MapOwnAirplanePropsController(context, properties, typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq));
    }
    /**
     * Configures this builder to add a module describing the player airplane's autopilot properties, and optionally
     * binds the module's properties to data received over the event bus.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsController` (optional)
     * @param propertiesToBind Properties on the autopilot module to bind to data received over the event bus.
     * @param updateFreq The update frequency, in hertz, of the data bindings, or a subscribable which provides it. If
     * not defined, the data bindings will update every frame. Ignored if `propertiesToBind` is undefined.
     * @returns This builder, after it has been configured.
     */
    withAutopilotProps(propertiesToBind, updateFreq) {
        this.withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule());
        if (propertiesToBind !== undefined) {
            this.withController(MapSystemKeys.AutopilotProps, context => new MapAutopilotPropsController(context, propertiesToBind, typeof updateFreq === 'number' ? Subject.create(updateFreq) : updateFreq));
        }
        return this;
    }
    /**
     * Configures this builder to generate a map which includes a layer displaying text.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     *
     * Layers:
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param enableCulling Whether to enable text culling. Defaults to `false`.
     * @param order The order value to assign to the text layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to this builder.
     * @param cssClass The CSS class(es) to apply to the text layer.
     * @returns This builder, after it has been configured.
     */
    withTextLayer(enableCulling, order, cssClass) {
        return this.withContext(MapSystemKeys.TextManager, () => new MapCullableTextLabelManager(enableCulling))
            .withLayer(MapSystemKeys.TextLayer, (context) => {
            return (FSComponent.buildComponent(MapCullableTextLayer, { model: context.model, mapProjection: context.projection, manager: context.textManager, class: cssClass }));
        }, order);
    }
    /**
     * Configures this builder to generate a map which displays Bing Map terrain and weather.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsModule`
     * * `[MapSystemKeys.Weather]: MapWxrModule`
     *
     * Layers:
     * * `[MapSystemKeys.Bing]: MapBingLayer`
     * @param bingId The ID to assign to the Bing Map instance bound to the layer.
     * @param delay The delay, in milliseconds, to wait after the Bing layer has been rendered before attempting to bind
     * a Bing Map instance.
     * @param mode The mode of the map, optional. If omitted, will be EBingMode.PLANE.
     * @param order The order value to assign to the Bing layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @param cssClass The CSS class(es) to apply to the root of the map bing layer.
     * @param opacity The opacity to apply to the layer. If not defined, control of opacity will be left to CSS.
     * @returns This builder, after it has been configured.
     */
    withBing(bingId, delay = 0, mode, order, cssClass, opacity) {
        return this
            .withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule())
            .withModule(MapSystemKeys.Weather, () => new MapWxrModule())
            .withLayer(MapSystemKeys.Bing, context => {
            const terrainColors = context.model.getModule('terrainColors');
            const weather = context.model.getModule('weather');
            return (FSComponent.buildComponent(MapBingLayer, { model: context.model, mapProjection: context.projection, bingId: bingId, reference: terrainColors.reference, earthColors: terrainColors.colors, earthColorsElevationRange: terrainColors.colorsElevationRange, isoLines: terrainColors.showIsoLines, wxrMode: weather.wxrMode, wxrColors: weather.weatherRadarColors, mode: mode, delay: delay, class: cssClass, opacity: opacity }));
        }, order);
    }
    /**
     * Configures this builder to generate a map which uses a {@link MapSystemWaypointsRenderer} to render waypoints.
     *
     * Requires the `[MapSystemKeys.TextManager]: MapCullableTextLabelManager` context property.
     *
     * Adds the `[MapSystemKeys.WaypointRenderer]: MapSystemWaypointsRenderer` context property.
     * @returns This builder, after it has been configured.
     */
    withWaypoints() {
        return this
            .withContext(MapSystemKeys.WaypointRenderer, context => new MapSystemWaypointsRenderer(context[MapSystemKeys.TextManager]))
            .withController('waypointRendererUpdate', context => new MapSystemGenericController(context, {
            onAfterUpdated: (contextArg) => { contextArg[MapSystemKeys.WaypointRenderer].update(context.projection); }
        }));
    }
    /**
     * Configures this builder to generate a map which displays waypoints near the map center or target. Waypoints
     * displayed in this manner are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule`
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapSystemWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param configure A function to configure the waypoint display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the nearest waypoints layer.
     * @returns This builder, after it has been configured.
     */
    withNearestWaypoints(configure, enableTextCulling = false, order, cssClass) {
        this
            .withTextLayer(enableTextCulling)
            .withModule(MapSystemKeys.NearestWaypoints, () => new MapWaypointDisplayModule())
            .withWaypoints()
            .withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory())
            .withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory());
        let facilityWaypointCache = undefined;
        this.withContext('useTargetAsWaypointSearchCenter', context => {
            context[MapSystemKeys.WaypointRenderer].addRenderRole(MapSystemWaypointRoles.Normal, undefined, MapSystemWaypointRoles.Normal);
            const builder = new WaypointDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer]);
            configure(builder);
            facilityWaypointCache = builder.getWaypointCache();
            return builder.getIsCenterTarget();
        });
        const layerCount = this.layerCount;
        return this
            .withLayer(MapSystemKeys.NearestWaypoints, context => {
            return (FSComponent.buildComponent(MapSystemWaypointsLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], useMapTargetAsSearchCenter: context.useTargetAsWaypointSearchCenter, waypointCache: facilityWaypointCache, class: cssClass }));
        }, order)
            .withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays a flight plan. Waypoints displayed as part of the flight
     * plan are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.FlightPlanner]: FlightPlanner`
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     * * `[MapSystemKeys.FlightPathRenderer]: MapSystemPlanRenderer`
     *
     * Modules:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanModule`
     *
     * Layers:
     * * `` `${[MapSystemKeys.FlightPlan]}${planIndex}`: MapSystemFlightPlanLayer ``
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanController`
     * @param configure A function to configure the waypoint display.
     * @param flightPlanner The flight planner.
     * @param planIndex The index of the flight plan to display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the plan layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the flight plan canvas elements.
     * @returns This builder, after it has been configured.
     */
    withFlightPlan(configure, flightPlanner, planIndex, enableTextCulling = false, order, cssClass) {
        this
            .withTextLayer(enableTextCulling, undefined, 'flight-plan-text-layer')
            .withModule(MapSystemKeys.FlightPlan, () => new MapFlightPlanModule())
            .withWaypoints()
            .withContext(MapSystemKeys.FlightPlanner, () => flightPlanner)
            .withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory())
            .withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory())
            .withContext(MapSystemKeys.FlightPathRenderer, () => new MapSystemPlanRenderer(1))
            .withController(MapSystemKeys.FlightPlan, context => new MapFlightPlanController(context))
            .withInit(`${MapSystemKeys.FlightPlan}${planIndex}`, context => {
            const builder = new FlightPlanDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer], context[MapSystemKeys.FlightPathRenderer], planIndex);
            context[MapSystemKeys.WaypointRenderer].insertRenderRole(MapSystemWaypointRoles.FlightPlan, MapSystemWaypointRoles.Normal, undefined, `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
            configure(builder, context);
        });
        const layerCount = this.layerCount;
        return this
            .withLayer(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
            return (FSComponent.buildComponent(MapSystemFlightPlanLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], flightPathRenderer: context[MapSystemKeys.FlightPathRenderer], planIndex: planIndex, class: cssClass }));
        }, order)
            .withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays airspaces.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
     *
     * Modules:
     * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
     *
     * Layers:
     * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
     * @param cache The airspace cache to use to store airspaces retrieved for rendering.
     * @param showTypes The airspace show types to define in the airspace module. Each show type will be assigned a
     * {@link Subject} in the `show` property of the module. The Subject controls the visibility of airspace types
     * included in its show type. Airspace types that are not included in any defined show type will never be displayed.
     * @param selectRenderer A function which selects a {@link MapAirspaceRenderer}
     * @param renderOrder A function which determines the rendering order of airspaces. The function should return a
     * negative number when airspace `a` should be rendered before (below) airspace `b`, a positive number when airspace
     * `a` should be rendered after (above) airspace `b`, and `0` when the relative render order of the two airspaces
     * does not matter. If not defined, there will be no guarantee on the order in which airspaces are rendered.
     * @param options Options for the airspace layer. Option defaults are as follows:
     * * `maxSearchRadius`: 10 nautical miles
     * * `maxSearchItemCount`: 100
     * * `searchDebounceDelay`: 500 (milliseconds)
     * * `renderTimeBudget`: 0.2 (milliseconds)
     * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withAirspaces(cache, showTypes, selectRenderer, renderOrder = () => 0, options, order) {
        return this
            .withModule(MapSystemKeys.Airspace, () => new MapAirspaceModule(showTypes))
            .withContext(MapSystemKeys.AirspaceManager, () => new GenericAirspaceRenderManager(renderOrder, selectRenderer))
            .withLayer(MapSystemKeys.Airspace, context => {
            var _a, _b;
            const optionsToUse = Object.assign({}, options);
            (_a = optionsToUse.maxSearchRadius) !== null && _a !== void 0 ? _a : (optionsToUse.maxSearchRadius = Subject.create(UnitType.NMILE.createNumber(10)));
            (_b = optionsToUse.maxSearchItemCount) !== null && _b !== void 0 ? _b : (optionsToUse.maxSearchItemCount = Subject.create(100));
            return (FSComponent.buildComponent(MapAirspaceLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus, lodBoundaryCache: cache, airspaceRenderManager: context[MapSystemKeys.AirspaceManager] }, optionsToUse)));
        }, order);
    }
    /**
     * Configures this builder to generate a map which displays TCAS intruders.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.Traffic]: MapTrafficModule`
     *
     * Layers:
     * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
     * @param tcas The TCAS used by the traffic display.
     * @param iconFactory A function which creates intruder icons for the traffic display.
     * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
     * @param offScaleOobOptions A function which generates options for handling off-scale and out-of-bounds intruders.
     * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the traffic component.
     * @returns This builder, after it has been configured.
     */
    withTraffic(tcas, iconFactory, initCanvasStyles, offScaleOobOptions, order, cssClass) {
        return this
            .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
            .withModule(MapSystemKeys.Traffic, () => new MapTrafficModule(tcas))
            .withLayer(MapSystemKeys.Traffic, context => {
            const options = offScaleOobOptions !== undefined ? Object.assign({}, offScaleOobOptions(context)) : {};
            if (options.oobOffset !== undefined && !('isSubscribable' in options.oobOffset)) {
                options.oobOffset = Subject.create(options.oobOffset);
            }
            return (FSComponent.buildComponent(MapSystemTrafficLayer, Object.assign({ context: context, model: context.model, mapProjection: context.projection, iconFactory: iconFactory, initCanvasStyles: initCanvasStyles, class: cssClass }, options)));
        }, order);
    }
    /**
     * Configures this builder using a custom build step.
     * @param builder A function which defines a custom build step.
     * @param args Arguments to pass to the custom build function.
     * @returns This builder, after it has been configured.
     */
    with(builder, ...args) {
        return builder(this, ...args);
    }
    /**
     * Compiles a map. The compiled map consists of a map context, a rendered map (as a VNode), and a node reference to
     * the rendered map component.
     *
     * The compiled map will be bound to a model (accessible through the map context) which contains all the modules
     * added to this builder.
     *
     * The map will also contain all layers added to this builder, with layers assigned lower order values appearing
     * below layers assigned greater order values. The layers can be retrieved by their keys from the map context.
     *
     * All controllers added to this builder will be created with the map and hooked up to the map's lifecycle callbacks.
     * The controllers can be retrieved by their keys from the map context.
     * @param cssClass The CSS class(es) to apply to the root of the rendered map component.
     * @returns A compiled map.
     */
    build(cssClass) {
        const context = this.buildContext();
        const controllers = [];
        const ref = FSComponent.createRef();
        const onAfterRender = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onAfterMapRender(ref.instance);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onAfterMapRender() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onDeadZoneChanged = (deadZone) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onDeadZoneChanged(deadZone);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onDeadZoneChanged() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onMapProjectionChanged = (mapProjection, changeFlags) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onMapProjectionChanged(mapProjection, changeFlags);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onMapProjectionChanged() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onBeforeUpdated = (time, elapsed) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onBeforeUpdated(time, elapsed);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onBeforeUpdated() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
            context.projection.applyQueued();
        };
        const onAfterUpdated = (time, elapsed) => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onAfterUpdated(time, elapsed);
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onAfterUpdated() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onWake = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onWake();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onWake() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onSleep = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onSleep();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onSleep() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const onDestroy = () => {
            for (let i = 0; i < controllers.length; i++) {
                if (!controllers[i].isAlive) {
                    controllers.splice(i, 1);
                    i--;
                }
                try {
                    controllers[i].onMapDestroyed();
                }
                catch (e) {
                    console.error(`MapSystem: error in controller .onMapDestroyed() callback: ${e}`);
                    if (e instanceof Error) {
                        console.error(e.stack);
                    }
                }
            }
        };
        const map = (FSComponent.buildComponent(MapSystemComponent, { ref: ref, model: context.model, projection: context.projection, bus: context.bus, projectedSize: this.projectedSize, onAfterRender: onAfterRender, onDeadZoneChanged: onDeadZoneChanged, onMapProjectionChanged: onMapProjectionChanged, onBeforeUpdated: onBeforeUpdated, onAfterUpdated: onAfterUpdated, onWake: onWake, onSleep: onSleep, onDestroy: onDestroy, class: cssClass }, Array.from(this.layerFactories.values()).sort((a, b) => a.order - b.order).map(factory => {
            const node = factory.factory(context);
            context.setLayer(factory.key, node.instance);
            return node;
        })));
        const controllerEntries = Array.from(this.controllerFactories)
            .map(([key, factory]) => [key, factory.factory(context)]);
        for (const [key, controller] of controllerEntries) {
            context.setController(key, controller);
        }
        controllers.push(...controllerEntries.map(([, controller]) => controller));
        for (const callback of this.initCallbacks.values()) {
            callback(context);
        }
        return { context, map, ref };
    }
    /**
     * Builds a new map context. The map context will be initialized with all context properties and modules added to
     * this builder.
     * @returns The new map context.
     */
    buildContext() {
        var _a;
        const context = new DefaultMapSystemContext(this.bus, new MapProjection(this.projectedSize.get()[0], this.projectedSize.get()[1]), this.projectedSize, (_a = this.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.createFromVector(new Float64Array(4)));
        context.projection.set({
            targetProjectedOffset: this.targetOffset,
            rangeEndpoints: this.nominalRangeEndpoints !== undefined
                ? MapSystemUtils.nominalToTrueRelativeXY(this.nominalRangeEndpoints, context.projectedSize.get(), context.deadZone.get(), Vec2Math.create())
                : undefined,
            range: this.range
        });
        for (const factory of Array.from(this.contextFactories.values()).sort((a, b) => a.order - b.order)) {
            context[factory.key] = factory.factory(context);
        }
        for (const factory of this.moduleFactories.values()) {
            context.model.addModule(factory.key, factory.factory());
        }
        return context;
    }
}
MapSystemBuilder.RESTRICTED_CONTEXT_KEYS = new Set([
    'bus',
    'model',
    'projection',
    'projectedSize',
    'deadZone',
    'getLayer',
    'setLayer',
    'getController',
    'setController'
]);

/** The acceptable priority types for a given warning. */
var WarningType;
(function (WarningType) {
    WarningType[WarningType["Warning"] = 0] = "Warning";
    WarningType[WarningType["Caution"] = 1] = "Caution";
    WarningType[WarningType["Test"] = 2] = "Test";
    WarningType[WarningType["SoundOnly"] = 3] = "SoundOnly";
})(WarningType || (WarningType = {}));
/** The main logic for a system warning. */
class Warning {
    /**
     * Creates an instance of a Warning.
     * @param type The type of warning this is.
     * @param condition An XML logic element with the trigger logic.
     * @param shortText The warning message in short form.
     * @param longText The warning message in long form.
     * @param soundId The sound name to use with this warning.
     * @param once True if this warning only fires once
     */
    constructor(type, condition, shortText, longText, soundId, once) {
        this.type = type;
        this.shortText = shortText;
        this.longText = longText;
        this.soundId = soundId;
        this.condition = condition;
        this.once = once;
        this._triggered = false;
        if (this.soundId) {
            this._soundEventId = new Name_Z(this.soundId);
        }
    }
    /**
     * Whether or not we have any text at all.
     * @returns True if any non-empty text strings are set.
     */
    get hasText() {
        return this.shortText || this.longText ? true : false;
    }
    /**
     * The alert is being fired, take action.
     */
    trigger() {
        this._triggered = true;
    }
    /**
     * A text description for the warning, for debugging purposes.
     * @returns A string
     */
    get description() {
        return `<${this.shortText}|${this.longText}|${this.soundId}>`;
    }
    /**
     * Whether or not the warning has been triggered in this session.
     * @returns True if the warning has been triggered.
     */
    get triggered() {
        return this._triggered;
    }
    /**
     * Can this alert fire?
     * @returns True if the current configuration allows the alert to fire.
     */
    get canTrigger() {
        return !this.once || !this._triggered;
    }
    /**
     * The event ID Coherent returns when this sound has been played.
     * @returns A Name_Z based on the sound ID.
     */
    get eventId() {
        return this._soundEventId;
    }
}
/** The basic component for handling warning logic. */
class WarningManager {
    /**
     * Create a WarningManager.
     * @param warnings An array of warnings to manage.
     * @param logicHost An event bus.
     * @param textCb A callback to display new warning text.
     * @param soundCb A callback to play an instrument sound from a sound ID.
     */
    constructor(warnings, logicHost, textCb, soundCb) {
        this.warnings = warnings;
        this.logicHost = logicHost;
        this.textCb = textCb;
        this.soundCb = soundCb;
        this.curSndIdx = null;
        this.curTxtIdx = null;
        this.warnActiveStates = new Array();
        for (let i = 0; i < warnings.length; i++) {
            this.logicHost.addLogicAsNumber(warnings[i].condition, this.handleWarning.bind(this, i), 0);
            this.warnActiveStates.push(false);
        }
    }
    /**
     * Handle a warning firing.  This is rather complex, but it basically keeps
     * track of every warning that is active, both for text and for sound, and
     * makes sure that the highest priority version of each is played or
     * displayed, masking and restoring lower priority warnings as needed.
     * @param warnIndex The index of our warnings array that's firing.
     * @param active 1 if the warning is active, 0 otherwise.
     */
    handleWarning(warnIndex, active) {
        const warning = this.warnings[warnIndex];
        // Handle a warning that is going active.
        if (active && warning.canTrigger) {
            this.warnActiveStates[warnIndex] = true;
            warning.trigger();
            // Only worry about text if the warning has text.
            if (warning.hasText) {
                // If there is no existing text displayed, or text of a lower priority, replace it.
                if ((this.curTxtIdx == undefined || this.curTxtIdx > warnIndex)) {
                    // First, if the prior warning was a one-shot, force it to inactive so it won't be restored later.
                    if (this.curTxtIdx && this.warnings[this.curTxtIdx].once) {
                        this.warnActiveStates[this.curTxtIdx] = false;
                    }
                    this.textCb(warning);
                    this.curTxtIdx = warnIndex;
                }
            }
            // Now check for sound.
            if (this.soundCb !== undefined && warning.soundId) {
                // Make sure we have the right to play our sound.
                if (this.curSndIdx == undefined || this.curSndIdx > warnIndex) {
                    // Disable a prior sound, if one was playing.
                    if (this.curSndIdx && this.curSndIdx > warnIndex) {
                        this.soundCb(this.warnings[this.curSndIdx], false);
                        // If the prior warning was a one-shot, force it to inactive so it won't be restored.
                        if (this.warnings[this.curSndIdx].once) {
                            this.warnActiveStates[this.curSndIdx] = false;
                        }
                    }
                    this.soundCb(warning, true);
                    this.curSndIdx = warnIndex;
                }
            }
            // If that was a one-time alert, turn it off, too.
            if (warning.once) {
                this.handleWarning(warnIndex, 0);
            }
        }
        else if (!active) {
            this.warnActiveStates[warnIndex] = false;
            let isCurSnd = this.curSndIdx == warnIndex ? true : false;
            let isCurTxt = this.curTxtIdx == warnIndex ? true : false;
            // If this warning is the current active text or sound, we need to disable it.
            if (isCurSnd && this.soundCb) {
                this.soundCb(warning, false);
            }
            if (isCurTxt) {
                this.textCb(undefined);
            }
            // If either of those were true, let's see if there's anything else
            // of lower prirority that should be made active.
            if (isCurSnd || isCurTxt) {
                // We know there was no higher-priority warning, so we step through
                // everything lower than us.
                let i = warnIndex + 1;
                while ((isCurSnd || isCurTxt) && i < this.warnings.length) {
                    // Only continue this iteration if the next potential warning
                    // is active.
                    if (this.warnActiveStates[i]) {
                        const nextWarning = this.warnings[i];
                        // Make sure we can trigger the warning.   This will be false if
                        // it's a one-shot that's already triggered.  If so, just fall
                        // through to the next iteration.
                        if (nextWarning.canTrigger) {
                            // See if the lower priority warning has sound.  If so, activate.
                            if (isCurSnd && nextWarning.soundId && this.soundCb) {
                                this.soundCb(this.warnings[i], true);
                                this.curSndIdx = i;
                                // We can stop looking for another sound.
                                isCurSnd = false;
                            }
                            // Now do the same sort of thing for text.
                            if (isCurTxt && this.warnings[i].hasText) {
                                this.textCb(this.warnings[i]);
                                this.curTxtIdx = i;
                                // We can stop looking for another text.
                                isCurTxt = false;
                            }
                        }
                    }
                    // Move to the next warning on the list.
                    i++;
                }
            }
            // If we haven't yet set new sound or text, just nullify them.
            if (isCurSnd && this.soundCb) {
                this.curSndIdx = null;
            }
            if (isCurTxt) {
                this.curTxtIdx = null;
            }
        }
    }
}

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** Create a list of system warnings. */
class XMLWarningFactory {
    /**
     * Create an XMLWarningFactory.
     * @param instrument The instrument that the warnings run in.
     */
    constructor(instrument) {
        this.instrument = instrument;
    }
    /**
     * Parse a panel.xml configuration to create a list of warnings.  The warning
     * priority is defined by their order in panel.xml, with higher priority
     * warnings coming sooner in the file.
     * @param document The configuration as an XML document.
     * @returns An array of Warnings
     */
    parseConfig(document) {
        const warnings = new Array();
        const configs = document.getElementsByTagName('VoicesAlerts');
        if (configs.length == 0) {
            return warnings;
        }
        const config = configs[0];
        for (const warn of config.children) {
            let type;
            const typeElem = warn.getElementsByTagName('Type');
            if (typeElem.length == 0) {
                continue;
            }
            switch (typeElem[0].textContent) {
                case 'Warning':
                    type = WarningType.Warning;
                    break;
                case 'Caution':
                    type = WarningType.Caution;
                    break;
                case 'Test':
                    type = WarningType.Test;
                    break;
                case 'SoundOnly':
                    type = WarningType.SoundOnly;
                    break;
                default:
                    continue;
            }
            let textElem = warn.getElementsByTagName('Condition');
            if (textElem.length == 0) {
                continue;
            }
            const condition = new CompositeLogicXMLElement(this.instrument, textElem[0]);
            textElem = warn.getElementsByTagName('ShortText');
            let shortText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                shortText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('LongText');
            let longText = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                longText = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('SoundEvent');
            let soundEvent = undefined;
            if (textElem.length > 0 && textElem[0].textContent !== null) {
                soundEvent = textElem[0].textContent;
            }
            textElem = warn.getElementsByTagName('Once');
            let once = false;
            if (textElem.length > 0 && textElem[0].textContent == 'True') {
                once = true;
            }
            warnings.push(new Warning(type, condition, shortText, longText, soundEvent, once));
        }
        return warnings;
    }
}

var APVerticalModes;
(function (APVerticalModes) {
    APVerticalModes[APVerticalModes["NONE"] = 0] = "NONE";
    APVerticalModes[APVerticalModes["PITCH"] = 1] = "PITCH";
    APVerticalModes[APVerticalModes["VS"] = 2] = "VS";
    APVerticalModes[APVerticalModes["FLC"] = 3] = "FLC";
    APVerticalModes[APVerticalModes["ALT"] = 4] = "ALT";
    APVerticalModes[APVerticalModes["PATH"] = 5] = "PATH";
    APVerticalModes[APVerticalModes["GP"] = 6] = "GP";
    APVerticalModes[APVerticalModes["GS"] = 7] = "GS";
    APVerticalModes[APVerticalModes["CAP"] = 8] = "CAP";
    APVerticalModes[APVerticalModes["TO"] = 9] = "TO";
    APVerticalModes[APVerticalModes["GA"] = 10] = "GA";
    APVerticalModes[APVerticalModes["FPA"] = 11] = "FPA";
    APVerticalModes[APVerticalModes["FLARE"] = 12] = "FLARE";
})(APVerticalModes || (APVerticalModes = {}));
var APLateralModes;
(function (APLateralModes) {
    APLateralModes[APLateralModes["NONE"] = 0] = "NONE";
    APLateralModes[APLateralModes["ROLL"] = 1] = "ROLL";
    APLateralModes[APLateralModes["LEVEL"] = 2] = "LEVEL";
    APLateralModes[APLateralModes["GPSS"] = 3] = "GPSS";
    APLateralModes[APLateralModes["HEADING"] = 4] = "HEADING";
    APLateralModes[APLateralModes["VOR"] = 5] = "VOR";
    APLateralModes[APLateralModes["LOC"] = 6] = "LOC";
    APLateralModes[APLateralModes["BC"] = 7] = "BC";
    APLateralModes[APLateralModes["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes[APLateralModes["NAV"] = 9] = "NAV";
    APLateralModes[APLateralModes["TO"] = 10] = "TO";
    APLateralModes[APLateralModes["GA"] = 11] = "GA";
    APLateralModes[APLateralModes["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes[APLateralModes["TRACK"] = 13] = "TRACK";
    APLateralModes[APLateralModes["TRACK_HOLD"] = 14] = "TRACK_HOLD";
    APLateralModes[APLateralModes["FMS_LOC"] = 15] = "FMS_LOC";
    APLateralModes[APLateralModes["TO_LOC"] = 16] = "TO_LOC";
})(APLateralModes || (APLateralModes = {}));
var APAltitudeModes;
(function (APAltitudeModes) {
    APAltitudeModes[APAltitudeModes["NONE"] = 0] = "NONE";
    APAltitudeModes[APAltitudeModes["ALTS"] = 1] = "ALTS";
    APAltitudeModes[APAltitudeModes["ALTV"] = 2] = "ALTV";
})(APAltitudeModes || (APAltitudeModes = {}));

/**
 * A Utility Class for VNAV
 */
class VNavUtils {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg) {
        if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc
            || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1
            || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
            return true;
        }
        return false;
    }
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
        const delta = targetAltitude - currentAltitude;
        const minutesToConstraint = distance / groundSpeed * 60;
        return delta / minutesToConstraint;
    }
    /**
     * Gets the vertical speed required to maintain a given flight path angle and groundspeed.
     * @param fpa The flight path angle, in degrees. Positive angles represent an ascending flight path.
     * @param groundspeed The groundspeed, in knots.
     * @returns The vertical speed required to maintain the specified flight path angle and groundspeed.
     */
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
        return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    /**
     * Gets the equivalent flight path angle for a given vertical speed and groundspeed. For this calculation, positive
     * flight path angles represent an ascending flight path.
     * @param vs The vertical speed, in feet per minute.
     * @param groundspeed The groundspeed, in knots.
     * @returns The flight path angle equivalent to the specified vertical speed and ground speed.
     */
    static getFpaFromVerticalSpeed(vs, groundspeed) {
        return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    /**
     * Gets the flight path angle required to travel a given lateral distance and altitude. Positive flight path angles
     * represent an ascending flight path. By convention, the flight path angle required to travel zero altitude equals
     * zero degrees for all distances.
     * @param distance The lateral distance to travel, in the same units as `altitude`.
     * @param altitude The altitude to travel, in the same units as `distance`.
     * @returns The flight path angle, in degrees, required to travel the specified altitude and distance.
     */
    static getFpa(distance, altitude) {
        if (altitude === 0) {
            return 0;
        }
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Gets the change in altitude along a flight path angle for a given lateral distance traveled.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param distance The lateral distance traveled.
     * @returns The change in altitude along the specified flight path angle for the specified lateral distance traveled,
     * expressed in the same units as `distance`.
     */
    static altitudeForDistance(fpa, distance) {
        return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    /**
     * Gets the lateral distance traveled along a flight path angle for a given change in altitude.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param altitude The change in the altitude.
     * @returns The lateral distance traveled along the specified flight path angle for the specified change in altitude,
     * expressed in the same units as `altitude`.
     */
    static distanceForAltitude(fpa, altitude) {
        return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    return l;
                }
            }
        }
        return Math.max(0, plan.length - 1);
    }
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan, iterator) {
        let fafIndex = -1;
        iterator.iterateReverse(lateralPlan, cursor => {
            if (fafIndex === -1 && cursor.legDefinition && (cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF)) {
                fafIndex = cursor.legIndex + cursor.segment.offset;
            }
        });
        fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
        return fafIndex;
    }
    /**
     * Gets the index of the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint that contains the specified flight plan leg, or `-1` if one could not
     * be found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
            if (verticalPlan.constraints[c].index >= globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint that contains the specified flight plan leg, or `undefined` if one could not be
     * found.
     */
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets the index of the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint immediately prior to the constraint that contains the specified flight
     * plan leg, or `-1` if one could nto be found.
     */
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            if (verticalPlan.constraints[c].index < globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint immediately prior to the constraint that contains the specified flight plan leg, or
     * `undefined` if one could nto be found.
     */
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan, globalLegIndex) {
        const constraintIndex = verticalPlan.constraints.findIndex(c => c.index === globalLegIndex);
        if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
            return true;
        }
        return false;
    }
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromConstraint(constraint) {
        let distance = 0;
        for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
            distance += constraint.legs[legIndex].distance;
        }
        return distance;
    }
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
        let distance = 0;
        const startGlobalIndex = previousConstraint !== undefined ? previousConstraint.index + 1 : 0;
        for (let i = startGlobalIndex; i <= constraint.index; i++) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
            distance += verticalLeg.distance;
        }
        return distance;
    }
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
        if (activeLegIndex > constraint.index) {
            return 0;
        }
        let distance = 0;
        let index = activeLegIndex;
        for (const leg of lateralPlan.legs(false, activeLegIndex)) {
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
                return Number.POSITIVE_INFINITY;
            }
            else if (leg.calculated !== undefined) {
                distance += leg.calculated.distanceWithTransitions;
            }
            if (++index > constraint.index) {
                break;
            }
        }
        distance -= distanceAlongLeg;
        return distance;
    }
    /**
     * Gets VNAV Constraint Details from a constraint.
     * @param constraint The constraint to get details from.
     * @param out The object to which write the results.
     * @returns The VNav Constraint Details.
     */
    static getConstraintDetails(constraint, out) {
        if (constraint.maxAltitude === constraint.minAltitude) {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
            switch (constraint.type) {
                case 'climb':
                case 'missed':
                    if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    break;
                default:
                    if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
            }
        }
        else {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        return out;
    }
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
        if (verticalPlan.constraints.length > 0) {
            if (selectedGlobalLegIndex < activeLegIndex) {
                return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
            }
            for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
                const constraint = verticalPlan.constraints[c];
                if (constraint.index === selectedGlobalLegIndex || (c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index)) {
                    return constraint;
                }
                else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
                    return verticalPlan.constraints[c + 1];
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the index of the next descent constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next descent constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextDescentConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next climb constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next climb constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextClimbConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'climb') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next missed approach constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next missed approach constraint at or after the specified flight plan leg, or `-1` if
     * one could not be found.
     */
    static getNextMaprConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the next descent constraint with a defined minimum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint with a defined minimum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if ((constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next descent constraint minimum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint defined minimum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.minAltitude : undefined;
    }
    /**
     * Gets the next climb constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint with a defined maximum altitude at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint) {
            if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return currentConstraint;
            }
            else if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
                const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== undefined ?
                    VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
                for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
                    const constraint = verticalPlan.constraints[c];
                    if (constraint.type === 'climb' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        return constraint;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the current climb constraint, if one exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The current climb constraint, or `undefined` if no such constraint exists.
     */
    static getCurrentClimbConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.type === 'climb') {
            return currentConstraint;
        }
        return undefined;
    }
    /**
     * Gets the next climb constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the next missed approach constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint with a defined maximum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next missed approach constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.targetAltitude;
        }
        const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan) {
        if (verticalPlan.fafLegIndex !== undefined) {
            return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
        }
        return undefined;
    }
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
        var _a;
        out.todLegIndex = -1;
        out.bodLegIndex = -1;
        out.todLegDistance = 0;
        out.distanceFromTod = 0;
        out.distanceFromBod = 0;
        out.currentConstraintLegIndex = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no TOD/BOD if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active constraint contains a VNAV-ineligible leg after the active leg.
            || ((activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== undefined && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex)) {
            return out;
        }
        out.currentConstraintLegIndex = activeConstraint.index;
        // Find the next BOD, which will be at the end of the earliest non-flat descent constraint subsequent to and
        // including the active constraint that ends in a level-off at a lower altitude than the aircraft's current
        // altitude. Note that we are guaranteed to not go through a VNAV discontinuity, since all constraints that end in
        // a discontinuity also end in a level-off.
        // lag altitude by ~3 seconds so that we aren't continuously pushing TOD in front of the plane while descending.
        const altitude = currentAltitude - currentVS / 20;
        let bodConstraintIndex, bodConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a climb constraint, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
                bodConstraintIndex = i;
                bodConstraint = constraint;
                break;
            }
        }
        if (!bodConstraint) {
            return out;
        }
        out.bodLegIndex = bodConstraint.index;
        // Find the TOD associated with the BOD. To do this, we need to first find the earliest non-flat descent constraint
        // between the active constraint and the BOD constraint (inclusive) that is connected to the BOD constraint with no
        // intervening flat constraints or VNAV path discontinuities and whose target altitude less than the aircraft's
        // current altitude.
        let todConstraintIndex = bodConstraintIndex;
        for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const prevConstraint = verticalPlan.constraints[i + 1];
            if (!prevConstraint
                || prevConstraint.index < activeLegIndex
                || prevConstraint.type === 'climb'
                || prevConstraint.type === 'missed'
                || prevConstraint.targetAltitude > altitude
                || prevConstraint.fpa <= 0
                || prevConstraint.isPathEnd) {
                todConstraintIndex = i;
                break;
            }
        }
        const todConstraint = verticalPlan.constraints[todConstraintIndex];
        // Now that we have found the TOD constraint, we need to find the TOD leg: the leg on which the TOD actually lies.
        // To do this, we calculate the along-track distance from the end of the TOD constraint to the TOD, then iterate
        // through the legs in the constraint backwards while keeping track of the total along-track distance covered by
        // each leg.
        let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
        let constraintIndex = todConstraintIndex;
        let todLegIndex = todConstraint.index;
        let todLegDistance = 0;
        let todLeg = todConstraint.legs[0];
        while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
            const constraint = verticalPlan.constraints[constraintIndex];
            // Remember that flight plan legs in a VNAV constraint appear in reverse order relative to how they are ordered
            // in the flight plan.
            for (let i = 0; i < constraint.legs.length; i++) {
                if (!constraint.legs[i].isEligible) {
                    // We've encounted a VNAV-ineligible leg. Since we cannot calculate a vertical path through this leg, we have
                    // to stop iterating now so that the TOD gets set to the most recent VNAV-eligible leg.
                    constraintIndex = verticalPlan.constraints.length;
                    break;
                }
                todLeg = constraint.legs[i];
                distance -= todLeg.distance;
                if (distance <= 0) {
                    todLegIndex = constraint.index - i;
                    todLegDistance = todLeg.distance + distance;
                    break;
                }
            }
            constraintIndex++;
        }
        if (distance > 0) {
            // If we still haven't found the TOD yet, set it to the beginning of the earliest VNAV leg that was iterated.
            todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
            todLegDistance = todLeg.distance;
        }
        out.todLegIndex = todLegIndex;
        out.todLegDistance = todLegDistance;
        // calculate distance to TOD/BOD
        let globalLegIndex = bodConstraint.index;
        let distanceToBOD = 0, distanceToTOD = 0;
        let hasReachedTOD = false;
        let isDone = false;
        for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const constraint = verticalPlan.constraints[i];
            for (let j = 0; j < constraint.legs.length; j++) {
                const leg = constraint.legs[j];
                if (globalLegIndex === todLegIndex) {
                    distanceToTOD -= todLegDistance;
                    hasReachedTOD = true;
                }
                if (globalLegIndex > activeLegIndex) {
                    distanceToBOD += leg.distance;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance;
                    }
                }
                else if (globalLegIndex === activeLegIndex) {
                    distanceToBOD += leg.distance - distanceAlongLeg;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance - distanceAlongLeg;
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= distanceAlongLeg;
                    }
                }
                else {
                    if (hasReachedTOD) {
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= leg.distance;
                    }
                }
                if (isDone) {
                    break;
                }
                else {
                    globalLegIndex--;
                }
            }
            if (isDone) {
                break;
            }
        }
        out.distanceFromBod = distanceToBOD;
        out.distanceFromTod = distanceToTOD;
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
        var _a, _b;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no BOC/TOC if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active VNAV constraint is not a climb-type constraint.
            || (activeConstraint.type !== 'climb' && activeConstraint.type !== 'missed')) {
            return out;
        }
        // Find the TOC. To do this, we need to first find the earliest climb constraint subsequent to and including the
        // active constraint that has a maximum altitude (i.e. is an AT, AT OR BELOW, or BETWEEN constraint). Additionally,
        // the TOC must not be separated from the active constraint by a descent-type constraint.
        let tocConstraintIndex, tocConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (isFinite(constraint.maxAltitude)) {
                tocConstraintIndex = i;
                tocConstraint = constraint;
                break;
            }
        }
        // If there is no next TOC, there also can be no next BOC since the next BOC must follow the next TOC.
        if (!tocConstraint) {
            return out;
        }
        out.tocConstraintIndex = tocConstraintIndex;
        out.tocAltitude = tocConstraint.maxAltitude;
        // Calculate distance to TOC.
        const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies.
        const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
        let tocLegIndex;
        let currentConstraintIndex = activeConstraintIndex;
        let currentConstraint;
        let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
        let currentLeg = activeLeg;
        const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
        if (distanceRemaining > activeLegDistanceRemaining) {
            distanceRemaining -= activeLegDistanceRemaining;
            if (currentConstraintLegIndex <= 0) {
                --currentConstraintIndex;
            }
            else {
                currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
            }
            while (currentConstraintIndex >= tocConstraintIndex) {
                currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                currentLeg = currentConstraint.legs[currentConstraintLegIndex];
                if (currentLeg !== undefined) {
                    if (distanceRemaining > currentLeg.distance) {
                        out.distanceFromToc += currentLeg.distance;
                        distanceRemaining -= currentLeg.distance;
                    }
                    else {
                        out.distanceFromToc += distanceRemaining;
                        tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
                        distanceRemaining -= currentLeg.distance;
                        break;
                    }
                }
                if (currentConstraintLegIndex <= 0) {
                    --currentConstraintIndex;
                }
                else {
                    currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
                }
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last leg of the TOC constraint.
            out.tocLegIndex = tocConstraint.index;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        // Find the next BOC, which is located at the beginning of the earliest climb constraint subsequent to (and not
        // including) the TOC constraint with a maximum altitude greater than the TOC constraint. Additionally, the BOC
        // must not be separated from the TOC constraint by a descent-type constraint.
        let lastClimbConstraintIndex = tocConstraintIndex;
        let bocConstraintIndex, bocConstraint;
        for (let i = tocConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (constraint.maxAltitude > tocConstraint.maxAltitude) {
                bocConstraintIndex = i;
                bocConstraint = constraint;
                break;
            }
            lastClimbConstraintIndex = i;
        }
        let bocDistanceStopConstraintIndex = undefined;
        if (bocConstraint) {
            out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
            bocDistanceStopConstraintIndex = bocConstraintIndex;
        }
        else {
            // If we did not find a climb constraint subsequent to the TOC constraint with a maximum altitude greater than the
            // the TOC constraint, then the BOC will be located at the last climb constraint.
            const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
            if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
                out.bocLegIndex = lastClimbConstraint.index + 1;
                bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
            }
        }
        // Calculate distance to BOC
        if (bocDistanceStopConstraintIndex !== undefined) {
            let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
            for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
                distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
            }
            out.distanceFromBoc = distanceToEndOfActiveConstraint;
            for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
                out.distanceFromBoc += verticalPlan.constraints[i].distance;
            }
        }
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC to cruise altitude details for a vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param cruiseAltitude The cruise altitude, in meters.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC to cruise altitude details.
     */
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        // Find the last climb constraint
        const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        // If the active leg is past the first descent constraint, both cruise BOC and cruise TOC are undefined.
        if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
            return out;
        }
        const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
        const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        // Cruise BOC will always be located at the beginning of the first leg after the last climb constraint. If there
        // are no climb constraints in the plan, then cruise BOC is undefined.
        if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
            const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
            out.bocLegIndex = lastClimbConstraint.index + 1;
            out.distanceFromBoc = activeLegDistanceRemaining
                + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
        // Calculate distance to TOC.
        const deltaAltitude = cruiseAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies. The TOC is restricted to legs prior to the first descent constraint.
        let tocLegIndex;
        const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
        if (distanceRemaining > activeLegDistanceRemaining) {
            let legIndex = activeLegIndex + 1;
            for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
                const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                if (distanceRemaining > legDistance) {
                    out.distanceFromToc += legDistance;
                    distanceRemaining -= legDistance;
                }
                else {
                    out.distanceFromToc += distanceRemaining;
                    tocLegIndex = legIndex;
                    distanceRemaining -= legDistance;
                    break;
                }
                legIndex++;
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last viable leg.
            out.tocLegIndex = lastLegIndex;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        out.tocAltitude = cruiseAltitude;
        return out;
    }
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset] !== undefined;
            }
        }
        return false;
    }
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset];
            }
        }
        throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
        const segment = verticalPlan.segments[segmentIndex];
        const leg = segment.legs[legIndex];
        if (segment && leg) {
            return leg;
        }
        else {
            throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
        }
    }
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
        return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan) {
        return verticalPlan.segments;
    }
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
        if (lateralLeg.leg !== undefined) {
            switch (lateralLeg.leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    return true;
            }
        }
        return false;
    }
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index, minAltitude, maxAltitude, name, type = 'descent') {
        return {
            index,
            minAltitude,
            maxAltitude,
            targetAltitude: 0,
            name,
            isTarget: false,
            isPathEnd: false,
            distance: 0,
            fpa: 0,
            legs: [],
            type,
            isBeyondFaf: false
        };
    }
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
        return {
            segmentIndex,
            legIndex,
            fpa: 0,
            altitude: 0,
            isUserDefined: false,
            isDirectToTarget: false,
            distance: distance,
            isEligible: true,
            isBod: false,
            isAdvisory: true,
            name
        };
    }
    /**
     * Finds the index of the first climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getFirstClimbConstraintIndex(verticalPlan) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the last climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getLastClimbConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the first descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getFirstDescentConstraintIndex(verticalPlan) {
        let index = -1;
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            const type = verticalPlan.constraints[c].type;
            if (type === 'descent' || type === 'manual') {
                index = c;
            }
            if (type === 'direct') {
                return c;
            }
        }
        return index;
    }
    /**
     * Finds the index of the last descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getLastDescentConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            const type = verticalPlan.constraints[i].type;
            if (type === 'descent' || type === 'direct' || type === 'manual') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Checks whether two speed constraints are equal.
     * @param a The first speed constraint.
     * @param b The second speed constraint.
     * @returns Whether the two speed constraints are equal.
     */
    static speedConstraintEquals(a, b) {
        return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    /**
     * Checks whether two altitude constraint details are equal.
     * @param a The first altitude constraint details.
     * @param b The second altitude constraint details.
     * @returns Whether the two altitude constraint details are equal.
     */
    static altitudeConstraintDetailsEquals(a, b) {
        return a.type === b.type && a.altitude === b.altitude;
    }
    /**
     * Checks whether two speed constraint details are equal.
     * @param a The first speed constraint details.
     * @param b The second speed constraint details.
     * @returns Whether the two speed constraint details are equal.
     */
    static speedConstraintDetailsEquals(a, b) {
        return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint
            && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint)
            && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    /**
     * Computes the path error distance that should be used given the groundspeed.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The path error distance to use.
     */
    static getPathErrorDistance(groundSpeed) {
        if (groundSpeed <= 190) {
            return 100;
        }
        else if (groundSpeed >= 210) {
            return 250;
        }
        else {
            return 100 + (((groundSpeed - 190) / 20) * 150);
        }
    }
}

/**
 * The current vertical navigation state.
 */
var VNavState;
(function (VNavState) {
    /** VNAV Disabled. */
    VNavState[VNavState["Disabled"] = 0] = "Disabled";
    /** VNAV Enabled and Inactive. */
    VNavState[VNavState["Enabled_Inactive"] = 1] = "Enabled_Inactive";
    /** VNAV Enabled and Active. */
    VNavState[VNavState["Enabled_Active"] = 2] = "Enabled_Active";
})(VNavState || (VNavState = {}));
/**
 * The current VNAV path mode.
 */
var VNavPathMode;
(function (VNavPathMode) {
    /** VNAV path is not active. */
    VNavPathMode[VNavPathMode["None"] = 0] = "None";
    /** VNAV path is armed for capture. */
    VNavPathMode[VNavPathMode["PathArmed"] = 1] = "PathArmed";
    /** VNAV path is actively navigating. */
    VNavPathMode[VNavPathMode["PathActive"] = 2] = "PathActive";
    /** The current VNAV path is not valid. */
    VNavPathMode[VNavPathMode["PathInvalid"] = 3] = "PathInvalid";
})(VNavPathMode || (VNavPathMode = {}));
/**
 * The current Approach Guidance Mode.
 */
var ApproachGuidanceMode;
(function (ApproachGuidanceMode) {
    /** VNAV is not currently following approach guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["None"] = 0] = "None";
    /** VNAV has armed ILS glideslope guidance for capture. */
    ApproachGuidanceMode[ApproachGuidanceMode["GSArmed"] = 1] = "GSArmed";
    /** VNAV is actively following ILS glideslope guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["GSActive"] = 2] = "GSActive";
    /** VNAV RNAV glidepath guidance is armed for capture. */
    ApproachGuidanceMode[ApproachGuidanceMode["GPArmed"] = 3] = "GPArmed";
    /** VNAV is actively follow RNAV glidepath guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["GPActive"] = 4] = "GPActive";
})(ApproachGuidanceMode || (ApproachGuidanceMode = {}));
/**
 * The current VNAV altitude capture type.
 */
var VNavAltCaptureType;
(function (VNavAltCaptureType) {
    /** Altitude capture is not armed. */
    VNavAltCaptureType[VNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    VNavAltCaptureType[VNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    VNavAltCaptureType[VNavAltCaptureType["VNAV"] = 2] = "VNAV";
})(VNavAltCaptureType || (VNavAltCaptureType = {}));
/**
 * The current state of VNAV availability from the director.
 */
var VNavAvailability;
(function (VNavAvailability) {
    VNavAvailability["Available"] = "Available";
    VNavAvailability["InvalidLegs"] = "InvalidLegs";
})(VNavAvailability || (VNavAvailability = {}));

/**
 * LNAV transition modes.
 */
var LNavTransitionMode;
(function (LNavTransitionMode) {
    /** LNAV is attempting to track a non-transition vector. */
    LNavTransitionMode[LNavTransitionMode["None"] = 0] = "None";
    /** LNAV is attempting to track an ingress vector. */
    LNavTransitionMode[LNavTransitionMode["Ingress"] = 1] = "Ingress";
    /** LNAV is attempting to track an egress vector. */
    LNavTransitionMode[LNavTransitionMode["Egress"] = 2] = "Egress";
    /**
     * LNAV is attempting to track a non-transition vector prior to where the ingress transition joins the base flight
     * path after deactivating suspend mode.
     */
    LNavTransitionMode[LNavTransitionMode["Unsuspend"] = 3] = "Unsuspend";
})(LNavTransitionMode || (LNavTransitionMode = {}));
/**
 * Sim var names for LNAV data.
 */
var LNavVars;
(function (LNavVars) {
    /** The current desired track, in degrees true. */
    LNavVars["DTK"] = "L:WTAP_LNav_DTK";
    /**
     * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavVars["XTK"] = "L:WTAP_LNav_XTK";
    /** Whether LNAV is tracking a path. */
    LNavVars["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    LNavVars["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    /** The currently active LNAV transition mode. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    LNavVars["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    /** The index of the vector LNAV is currently tracking. */
    LNavVars["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    /** The current course LNAV is attempting to steer, in degrees true. */
    LNavVars["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    /** Whether LNAV sequencing is suspended. */
    LNavVars["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
     * distance indicates the plane is before the start of the leg.
     */
    LNavVars["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
     * the end of the leg.
     */
    LNavVars["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position. A
     * negative distance indicates the plane is before the start of the vector.
     */
    LNavVars["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
     * past the end of the vector.
     */
    LNavVars["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    LNavVars["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    /** The current along-track ground speed of the airplane. */
    LNavVars["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
})(LNavVars || (LNavVars = {}));
/**
 * A publisher for LNAV sim var events.
 */
class LNavSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavSimVarPublisher.simvars, bus);
    }
}
LNavSimVarPublisher.simvars = new Map([
    ['lnav_dtk', { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ['lnav_xtk', { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ['lnav_is_tracking', { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ['lnav_tracked_leg_index', { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ['lnav_transition_mode', { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ['lnav_tracked_vector_index', { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ['lnav_course_to_steer', { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ['lnav_is_suspended', { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ['lnav_leg_distance_along', { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_leg_distance_remaining', { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_distance_along', { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_vector_distance_remaining', { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_anticipation_distance', { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ['lnav_along_track_speed', { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
]);

/**
 * Sim var names for VNAV data.
 */
var VNavVars;
(function (VNavVars) {
    /** The vertical deviation in feet. */
    VNavVars["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    /** The VNAV target altitude in feet. */
    VNavVars["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    /** The VNAV path mode. */
    VNavVars["PathMode"] = "L:WTAP_VNav_Path_Mode";
    /** The VNAV State. */
    VNavVars["VNAVState"] = "L:WTAP_VNav_State";
    /** Whether a VNAV Path Exists for the current leg. */
    VNavVars["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    /** The VNAV current altitude capture type. */
    VNavVars["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    /** The distance to the next TOD in meters, or -1 if one does not exist. */
    VNavVars["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    /** The distance to the next BOD in meters, or -1 if one does not exist. */
    VNavVars["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    /** The index of the leg for the next TOD. */
    VNavVars["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    /** The distance from the end of the TOD leg that the TOD is, in meters. */
    VNavVars["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    /** The index of the leg for the next BOD. */
    VNavVars["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    /** The distance to the next TOC in meters, or -1 if one does not exist. */
    VNavVars["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    /** The distance to the next BOC in meters, or -1 if one does not exist. */
    VNavVars["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    /** The index of the leg for the next TOC. */
    VNavVars["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    /** The distance from the end of the TOC leg that the TOC is, in meters. */
    VNavVars["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    /** The index of the leg for the next BOC. */
    VNavVars["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    /** The index of the leg for the next constraint. */
    VNavVars["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    /** The current constraint altitude, in feet. */
    VNavVars["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    /** The next constraint altitude, in feet. */
    VNavVars["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    /** The current required flight path angle, in degrees. */
    VNavVars["FPA"] = "L:WTAP_VNav_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    /** The VNAV approach guidance mode. */
    VNavVars["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    /** The current LPV vertical deviation in feet. */
    VNavVars["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    /** The current remaining LPV distance in meters. */
    VNavVars["GPDistance"] = "L:WTAP_GP_Distance";
    /** The current LPV FPA, in degrees. */
    VNavVars["GPFpa"] = "L:WTAP_GP_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    /** The approach glidepath service level. */
    VNavVars["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
})(VNavVars || (VNavVars = {}));
/** A publisher for VNAV sim var events. */
class VNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(VNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
VNavSimVarPublisher.simvars = new Map([
    ['vnav_vertical_deviation', { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ['vnav_target_altitude', { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ['vnav_path_mode', { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ['vnav_path_available', { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ['vnav_state', { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ['vnav_altitude_capture_type', { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ['vnav_tod_distance', { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_leg_distance', { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_bod_distance', { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_global_leg_index', { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ['vnav_bod_global_leg_index', { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ['vnav_toc_distance', { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_leg_distance', { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_boc_distance', { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_global_leg_index', { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_boc_global_leg_index', { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_global_leg_index', { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_altitude', { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_next_constraint_altitude', { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_fpa', { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ['vnav_required_vs', { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ['gp_approach_mode', { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ['gp_vertical_deviation', { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ['gp_distance', { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ['gp_fpa', { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ['gp_required_vs', { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ['gp_service_level', { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
]);

/**
 * Handles the calculation of the VNAV flight path for Path Smoothing VNAV Implementations.
 */
class SmoothingPathCalculator {
    /**
     * Creates an instance of SmoothingPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.primaryPlanIndex = primaryPlanIndex;
        /** The Vertical Flight Plans managed by this Path Calculator */
        this.verticalFlightPlans = [];
        /** @inheritdoc */
        this.planBuilt = new SubEvent();
        /** @inheritdoc */
        this.vnavCalculated = new SubEvent();
        this.legAltitudes = [0, 0];
        this.applyPathValuesResult = [undefined, 0];
        this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
        this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
        this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
        this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
        this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
        this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
        this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : (() => true);
        this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
        this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
        const fpl = this.bus.getSubscriber();
        fpl.on('fplCreated').handle(e => this.createVerticalPlan(e.planIndex));
        fpl.on('fplCopied').handle(e => this.onPlanChanged(e.targetPlanIndex));
        fpl.on('fplLoaded').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplLegChange').handle(e => this.onPlanChanged(e.planIndex, e));
        fpl.on('fplSegmentChange').handle(e => this.onPlanChanged(e.planIndex, undefined, e));
        fpl.on('fplIndexChanged').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplCalculated').handle(e => this.onPlanCalculated(e));
        bus.getSubscriber().on('vnav_set_default_fpa').handle(this.setDefaultFpa.bind(this));
        bus.getSubscriber().on('vnav_set_vnav_direct_to').handle(data => {
            if (data.globalLegIndex < 0) {
                this.cancelVerticalDirect(data.planIndex);
            }
            else {
                this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
            }
        });
    }
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex) {
        var _a;
        var _b;
        return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : (_b[planIndex] = this.createVerticalPlan(planIndex));
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /** @inheritdoc */
    requestPathCompute(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== undefined) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            this.computePathAndNotify(lateralPlan, verticalPlan);
            return true;
        }
        return false;
    }
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for a flight plan leg, or `-1` if one
     * could not be found.
     */
    getTargetConstraintIndex(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== undefined && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
                const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
                if (priorConstraint && priorConstraint.type !== 'climb' && priorConstraint.type !== 'missed') {
                    return priorConstraintIndex;
                }
                else {
                    return -1;
                }
            }
            let i = verticalPlan.constraints.length - 1;
            while (i >= 0) {
                const constraint = verticalPlan.constraints[i];
                if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== 'climb' && constraint.type !== 'missed') {
                    return i;
                }
                i--;
            }
        }
        else {
            const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraintIndex >= 0) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isMissed = currentConstraint.type === 'missed';
                for (let i = currentConstraintIndex; i >= 0; i--) {
                    const constraint = verticalPlan.constraints[i];
                    if (constraint.type === 'climb' || (isMissed && constraint.type === 'missed')) {
                        if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                            return i;
                        }
                    }
                    else {
                        return -1;
                    }
                }
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for a flight plan leg, or `undefined` if one could
     * not be found.
     */
    getTargetConstraint(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    /** @inheritdoc */
    getTargetAltitude(planIndex, globalLegIndex) {
        var _a, _b;
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
        }
        else {
            return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
        }
    }
    /** @inheritdoc */
    getFlightPhase(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex)) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
            if (globalLegIndex > -1) {
                const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
                switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
                    case 'climb':
                    case 'missed':
                        return VerticalFlightPhase.Climb;
                }
            }
        }
        return VerticalFlightPhase.Descent;
    }
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return undefined;
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
        }
        else {
            return currentConstraint.targetAltitude;
        }
    }
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            if (priorConstraint) {
                return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
            }
            else {
                return { type: AltitudeRestrictionType.Unused, altitude: 0 };
            }
        }
        else {
            return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        }
    }
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        // added check for climb or descent for smoothing path calc
        if (currentConstraint !== undefined) {
            if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    return currentConstraint.maxAltitude;
                }
                else {
                    return currentConstraint.minAltitude;
                }
            }
            else {
                if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
                    return currentConstraint.minAltitude;
                }
                else {
                    return currentConstraint.maxAltitude;
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
        if (currentConstraint) {
            const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
            if (currentConstraintIndex > -1) {
                if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'climb' || constraint.type === 'missed') {
                            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
                else {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
        if (constraintGlobalLegIndex < 0) {
            return;
        }
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
        verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Cancels the existing VNAV direct-to for a vertical flight plan.
     * @param planIndex The index of the vertical flight plan for which to cancel the VNAV direct-to.
     */
    cancelVerticalDirect(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex === undefined) {
            return;
        }
        verticalPlan.verticalDirectIndex = undefined;
        verticalPlan.verticalDirectFpa = undefined;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sets this calculator's default flight path angle.
     * @param fpa The new default flight path angle, in degrees. Increasingly positive values indicate steeper descents.
     */
    setDefaultFpa(fpa) {
        const newFpa = Math.max(0, fpa);
        if (newFpa !== this.flightPathAngle) {
            this.flightPathAngle = newFpa;
            for (let i = 0; i < this.verticalFlightPlans.length; i++) {
                const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : undefined;
                const verticalPlan = this.verticalFlightPlans[i];
                if (lateralPlan && verticalPlan) {
                    this.computePathAndNotify(lateralPlan, verticalPlan);
                }
            }
        }
    }
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex !== undefined) {
            if (legChangeEvent !== undefined) {
                const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
                if (globalIndex <= verticalPlan.verticalDirectIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
            else if (segmentChangeEvent !== undefined) {
                const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
                if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
        }
        verticalPlan.planChanged = true;
        verticalPlan.currentAlongLegDistance = undefined;
    }
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    onPlanCalculated(event) {
        this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
    }
    /**
     * Builds a vertical flight plan if its corresponding lateral flight plan has been changed since the last rebuild,
     * then computes the vertical path sends events notifying subscribers that the plan was built and calculated.
     * @param planIndex The index of the plan to build and compute.
     */
    buildVerticalFlightPlanAndComputeAndNotify(planIndex) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.planChanged) {
            this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        }
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    notifyBuilt(planIndex) {
        this.planBuilt.notify(this, planIndex);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    notifyCalculated(planIndex) {
        this.vnavCalculated.notify(this, planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan and sends an event notifying subscribers that the plan
     * was built.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
        this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.notifyBuilt(verticalPlan.planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
        SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
        verticalPlan.planChanged = false;
    }
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
        var _a, _b, _c, _d, _e, _f, _g;
        // Reset the constraints array.
        verticalPlan.constraints.length = 0;
        // Reset the segments array.
        verticalPlan.segments.length = 0;
        verticalPlan.destLegIndex = undefined;
        verticalPlan.firstDescentConstraintLegIndex = undefined;
        verticalPlan.lastDescentConstraintLegIndex = undefined;
        verticalPlan.missedApproachStartIndex = undefined;
        // Find the FAF in the lateral plan, if any.
        verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
        const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
        let firstApproachGlobalLegIndex;
        // Iterate forward through the lateral plan to build the constraints
        for (const segment of lateralPlan.segments()) {
            // Add the plan segments to the VNav Path Calculator Segments
            verticalPlan.segments[segment.segmentIndex] = {
                offset: segment.offset,
                legs: []
            };
            if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === undefined) {
                firstApproachGlobalLegIndex = segment.offset;
            }
            for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                const globalLegIndex = segment.offset + segmentLegIndex;
                const lateralLeg = segment.legs[segmentLegIndex];
                const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '', (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : undefined);
                // Check if the leg is part of the missed approach, and set the missed approach start index.
                if (verticalPlan.missedApproachStartIndex === undefined
                    && segment.segmentType === FlightPlanSegmentType.Approach
                    && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
                    verticalPlan.missedApproachStartIndex = globalLegIndex;
                }
                // Check if the leg contains a constraint
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
                verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                // Check if the leg precedes a defined vertical direct for this vertical flight plan.
                const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== undefined && globalLegIndex < verticalPlan.verticalDirectIndex;
                const legPrecedesDirectTo = directToTargetLegIndex !== undefined && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
                if (constraintAltitudes !== undefined
                    && !legPrecedesVerticalDirectIndex
                    && !legPrecedesDirectTo
                    && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
                    verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
                    const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    // Add the new vertical constraint to the array of constraints in reverse order.
                    verticalPlan.constraints.unshift(verticalConstraint);
                }
                // Add the new vertical leg to the vertical flight plan
                verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
            }
        }
        verticalPlan.length = lateralPlan.length;
        if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== undefined) {
            const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
            if (firstApproachConstraint && firstApproachConstraint.type !== 'climb' && firstApproachConstraint.type !== 'missed') {
                SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
            }
        }
        verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
        verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    /**
     * Builds a VNAV constraint for a lateral flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the lateral flight plan leg for which to build the constraint.
     * @param lateralLeg The lateral flight plan leg for which to build the constraint.
     * @param constraintAltitudes The constraint altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @param name The name of the new constraint.
     * @returns A new VNAV constraint for the specified lateral flight plan leg.
     */
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
        var _a;
        const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? 'missed' : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? 'descent' : 'climb');
        constraint.isBeyondFaf = verticalPlan.fafLegIndex === undefined ? false : globalLegIndex > verticalPlan.fafLegIndex;
        // Check if this constraint is a vertical direct.
        if (verticalPlan.verticalDirectIndex === globalLegIndex) {
            constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
            constraint.type = 'direct';
        }
        const userFpa = lateralLeg.verticalData.fpa;
        if (userFpa !== undefined && constraint.type !== 'climb' && constraint.type !== 'missed') {
            constraint.fpa = userFpa;
            constraint.type = 'manual';
        }
        return constraint;
    }
    /**
     * Computes the vertical path for a flight plan and sends an event notifying subscribers that the plan was
     * calculated.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePathAndNotify(lateralPlan, verticalPlan) {
        this.computePath(lateralPlan, verticalPlan);
        this.notifyCalculated(lateralPlan.planIndex);
    }
    /**
     * Computes the vertical path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePath(lateralPlan, verticalPlan) {
        this.computeDescentPath(lateralPlan, verticalPlan);
    }
    /**
     * Computes the descent path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computeDescentPath(lateralPlan, verticalPlan) {
        this.fillLegDistances(lateralPlan, verticalPlan);
        // Updated leg distances could cause some invalidated constraints to become valid, so we will re-insert all
        // invalidated constraints and filter them again.
        this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
        this.findAndRemoveInvalidConstraints(verticalPlan);
        if (verticalPlan.constraints.length < 1) {
            return;
        }
        this.populateConstraints(verticalPlan);
        if (this.computeFlightPathAngles(verticalPlan)) {
            for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
                const constraint = verticalPlan.constraints[constraintIndex];
                if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                    let altitude = constraint.targetAltitude;
                    let constraintIsBod = true;
                    if (constraintIndex > 0) {
                        const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
                        if (nextConstraint !== undefined && nextConstraint.type !== 'climb') {
                            const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                            if ((nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25) || constraint.fpa === 0) {
                                constraintIsBod = false;
                            }
                        }
                    }
                    if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
                        constraint.isPathEnd = true;
                        constraint.isTarget = true;
                        constraintIsBod = true;
                    }
                    for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
                        const leg = constraint.legs[legIndex];
                        leg.fpa = constraint.fpa;
                        leg.altitude = altitude;
                        altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
                        if (legIndex === 0) {
                            leg.isAdvisory = false;
                        }
                        else {
                            leg.isAdvisory = true;
                        }
                        if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                            leg.isBod = true;
                        }
                        else {
                            leg.isBod = false;
                        }
                    }
                }
            }
        }
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    fillLegDistances(lateralPlan, verticalPlan) {
        var _a, _b, _c;
        if (lateralPlan.length > 0) {
            for (const segment of lateralPlan.segments()) {
                if (segment) {
                    const vnavSegment = verticalPlan.segments[segment.segmentIndex];
                    for (let l = 0; l < segment.legs.length; l++) {
                        const leg = segment.legs[l];
                        if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                            vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
                        }
                        else if (leg && leg.calculated && leg.calculated.endLat !== undefined && leg.calculated.endLon !== undefined) {
                            let prevLeg;
                            for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                                if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== undefined && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== undefined) {
                                    prevLeg = checkLeg;
                                    break;
                                }
                            }
                            if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                                vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                            }
                        }
                        else {
                            vnavSegment.legs[l].distance = 0;
                        }
                    }
                }
            }
        }
    }
    /**
     * Finds and removes invalid constraints from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    findAndRemoveInvalidConstraints(verticalPlan) {
        var _a, _b, _c;
        let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all constraints prior to the
        // direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? firstDescentConstraintIndex
            : verticalPlan.constraints.length - 1;
        let phase = 'climb';
        let priorMinAltitude = -Infinity;
        let priorMaxAltitude = Infinity;
        let distanceFromPriorMinAltitude = 0;
        let requiredFpa = 0;
        for (let i = startIndex; i >= 0; i--) {
            const currentConstraint = verticalPlan.constraints[i];
            const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
            let currentPhase;
            switch (currentConstraint.type) {
                case 'climb':
                case 'missed':
                    currentPhase = currentConstraint.type;
                    break;
                default:
                    currentPhase = 'descent';
            }
            if (currentPhase !== phase) {
                // Reset prior altitudes when switching phases.
                phase = currentPhase;
                priorMinAltitude = -Infinity;
                priorMaxAltitude = Infinity;
                distanceFromPriorMinAltitude = currentConstraintDistance;
            }
            else {
                distanceFromPriorMinAltitude += currentConstraintDistance;
            }
            let isDescentConstraint;
            let shouldInvalidate;
            switch (phase) {
                case 'climb':
                case 'missed':
                    isDescentConstraint = false;
                    shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
                    break;
                default:
                    isDescentConstraint = true;
                    if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
                        requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
                    }
                    else {
                        requiredFpa = 0;
                    }
                    shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
            }
            const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
            if (shouldInvalidate) {
                constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
                verticalPlan.constraints.splice(i, 1);
                // Need to subtract current constraint distance because it will get added again at the beginning of the next iteration.
                // (The next constraint inherits the legs that belonged to the current constraint after it is removed.)
                distanceFromPriorMinAltitude -= currentConstraintDistance;
                // If we invalidated the first descent constraint, we need to find the new one.
                if (isDescentConstraint && i === firstDescentConstraintIndex) {
                    firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
                    verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
                }
            }
            else {
                constraintLeg.invalidConstraintAltitude = undefined;
                if (isFinite(currentConstraint.minAltitude)) {
                    priorMinAltitude = currentConstraint.minAltitude;
                    distanceFromPriorMinAltitude = 0;
                }
                if (isFinite(currentConstraint.maxAltitude)) {
                    priorMaxAltitude = currentConstraint.maxAltitude;
                }
            }
        }
        // Update last descent leg in case we invalidated some descent constraints
        verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    /**
     * Finds previously invalidated constraints and re-inserts them into the vertical flight plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
        var _a;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all legs prior to and including
        // the direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? (verticalPlan.firstDescentConstraintLegIndex + 1)
            : 0;
        let globalLegIndex = startIndex;
        for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
            if (verticalLeg.invalidConstraintAltitude !== undefined) {
                const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                if (constraintAltitudes !== undefined) {
                    const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
                    // If we re-validated a descent constraint, we need to update the first/last descent constraint when appropriate.
                    if (proposedConstraint.type === 'descent'
                        || proposedConstraint.type === 'manual'
                        || proposedConstraint.type === 'direct'
                        || proposedConstraint.type === 'dest') {
                        if (verticalPlan.firstDescentConstraintLegIndex === undefined || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
                        }
                        if (verticalPlan.lastDescentConstraintLegIndex === undefined || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                            verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
                        }
                    }
                }
            }
            globalLegIndex++;
        }
    }
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    populateConstraints(verticalPlan) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
            const constraint = verticalPlan.constraints[constraintIndex];
            const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
            constraint.legs.length = 0;
            constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
            let eligibleLegIndex;
            let ineligibleLegIndex;
            for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== undefined ? previousConstraint.index : -1); globalLegIndex--) {
                const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
                constraint.legs.push(verticalLeg);
                if (ineligibleLegIndex === undefined && verticalLeg.isEligible) {
                    eligibleLegIndex = globalLegIndex;
                }
                if (ineligibleLegIndex === undefined && !verticalLeg.isEligible) {
                    ineligibleLegIndex = globalLegIndex;
                }
            }
            if (ineligibleLegIndex !== undefined && eligibleLegIndex !== undefined) {
                constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
            }
        }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    computeFlightPathAngles(verticalPlan) {
        // Iterate through all descent constraints in reverse flight plan order and attempt to assign one as a "target"
        // constraint, which is a constraint that anchors a constant FPA path connecting it to one or more prior
        // constraints.
        // Once a target constraint is found, the iteration continues as we attempt to build a constant FPA path backwards
        // from the target constraint that meets all the iterated constraints. Once we reach a constraint that cannot be
        // met with a constant FPA path from the target constraint that also meets all intermediate constraints, we assign
        // a new target constraint at the point where the FPA must change. Certain constraints must also be designated as
        // target constraints regardless of whether a constant FPA path through them is possible. In any case, once we
        // designate a new target constraint, the process is repeated until we run out of descent constraints.
        let currentTargetConstraint;
        let currentPathSegmentDistance = 0;
        let currentPathSegmentMinFpa = this.minFlightPathAngle;
        let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        let currentTargetConstraintHasFixedFpa = false;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
            // There are no descent constraints, so no FPAs to be calculated
            return false;
        }
        for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
            const constraint = verticalPlan.constraints[targetConstraintIndex];
            // If the current constraint is climb or missed, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            // If we haven't found a target constraint yet, attempt to make the current constraint the target constraint,
            // if it defines either a minimum or maximum altitude. The target altitude is preferentially set to the minimum
            // altitude, if it exists. If the current constraint has neither a minimum nor maximum altitude (which should
            // technically never happen), skip it.
            if (!currentTargetConstraint) {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    currentTargetConstraint = constraint;
                    currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
                    currentTargetConstraint.isTarget = true;
                }
                else {
                    continue;
                }
            }
            // Reset the method variables
            currentPathSegmentMinFpa = this.minFlightPathAngle;
            currentPathSegmentMaxFpa = this.maxFlightPathAngle;
            currentPathSegmentDistance = currentTargetConstraint.distance;
            const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
            if (currentTargetConstraintIsFirstDescentConstraint) {
                if (currentTargetConstraint.type === 'descent') {
                    // If this is the first descent constraint and it is not a direct or manual, set the FPA to the default value.
                    currentTargetConstraint.fpa = this.flightPathAngle;
                }
                // If currentTargetConstraintIsFirstDescentConstraint is true, then after this logic, we're done with this method.
                return true;
            }
            // If the current target constraint is a manual or direct type, then honor the FPA by not allowing any other FPAs.
            if (currentTargetConstraint.type === 'manual') {
                currentPathSegmentMinFpa = currentTargetConstraint.fpa;
                currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
                currentTargetConstraintHasFixedFpa = true;
            }
            else {
                currentTargetConstraintHasFixedFpa = false;
            }
            let pathSegmentIsFlat = false;
            for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
                const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
                const isCurrentConstraintClimb = currentConstraint.type === 'climb' || currentConstraint.type === 'missed';
                const isCurrentConstraintManual = currentConstraint.type === 'manual';
                const isCurrentConstraintDirect = currentConstraint.type === 'direct';
                if (isCurrentConstraintClimb) {
                    // We have reached a climb constraint.
                    if (currentConstraintIndex - 1 > targetConstraintIndex) {
                        // There is at least one constraint between the existing target constraint and the current climb
                        // constraint. Attempt to extend the constant-FPA path through the constraint immediately following the
                        // current climb constraint (which is guaranteed to be a descent constraint).
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                        const maxAltitude = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
                        const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude, false);
                        if (terminatedIndex < currentConstraintIndex) {
                            // The path was terminated early, which means there is a new target constraint.
                            targetConstraintIndex = terminatedIndex - 1; // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                            break;
                        }
                    }
                    else {
                        // The existing target constraint immediately follows the current climb constraint. Treat the target
                        // constraint as if it were the first descent constraint and apply the default FPA. Note that we are
                        // guaranteed the target constraint is not a direct constraint.
                        currentTargetConstraint.fpa = this.flightPathAngle;
                    }
                    // Do not designate a new target constraint in order to allow the outer loop to find the new one.
                    targetConstraintIndex = currentConstraintIndex;
                    currentTargetConstraint = undefined;
                    break;
                }
                const minAltitude = currentConstraint.minAltitude;
                const maxAltitude = currentConstraint.maxAltitude;
                if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
                    // We are in a flat segment (all constraints with FPA = 0) and the current constraint would allow a
                    // non-zero FPA to the constraint immediately following it. Therefore, we set the new target constraint
                    // to the constraint immediately following the current one (because it is at the end of that constraint
                    // where the FPA can potentially change from non-zero to zero). Note that we are guaranteed that the
                    // new target constraint lies prior to the existing target constraint.
                    const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                    const newTargetConstraintIndex = currentConstraintIndex - 1;
                    SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, 
                    // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                    // constraints are equal to the flat segment altitude.
                    Infinity, this.applyPathValuesResult);
                    // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                    targetConstraintIndex = newTargetConstraintIndex - 1;
                    currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
                    currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                    currentTargetConstraint.isTarget = true;
                    break;
                }
                else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
                    // The current constraint does not allow a non-zero FPA to the target constraint, and the target constraint
                    // does not have a fixed FPA. We will mark the current segment as flat and set the target constraint FPA to 0.
                    pathSegmentIsFlat = true;
                    currentTargetConstraint.fpa = 0;
                    if (isCurrentConstraintFirstDescent) {
                        // If the current constraint is the first descent constraint, then we need to make it the new target
                        // constraint because the first descent constraint is never flat.
                        const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                        SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, 
                        // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                        // constraints are equal to the flat segment altitude.
                        Infinity, this.applyPathValuesResult);
                        // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                        targetConstraintIndex = currentConstraintIndex - 1;
                        currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
                        currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                        currentTargetConstraint.isTarget = true;
                        break;
                    }
                    continue;
                }
                // Get the min and max FPA from the current target constraint to the current constraint.
                const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
                const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
                const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
                // A new target constraint needs to be created under the following conditions:
                // - The current constraint cannot be met with a constant FPA path from the current target constraint within
                //   this calculator's FPA limits.
                // - The current constraint is the final approach fix.
                // - The current constraint is a vertical direct constraint.
                // - The current constraint is a manual constraint.
                if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
                    // We need to choose a FPA for the constant-FPA smoothed path.
                    if (isFpaOutOfBounds) {
                        // If we are creating a new target constraint because the current constraint can't be met with a
                        // constant-FPA path, then we set the FPA of the smoothed path to the value that brings the new
                        // target constraint's target altitude as close to meeting the current constraint as possible.
                        if (minFpa > currentPathSegmentMaxFpa) {
                            currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
                        }
                        else {
                            currentTargetConstraint.fpa = currentPathSegmentMinFpa;
                        }
                    }
                    else {
                        // If the new target constraint can be met with a constant-FPA path, then we choose a valid FPA that is
                        // as close to the calculator's default FPA as possible.
                        currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                        currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    }
                    // Find the next constraint with a max altitude
                    const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
                    // Attempt to extend a constant-FPA path from the existing target constraint to the current constraint and
                    // make the current constraint the new target constraint.
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
                    targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                    currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                    break;
                }
                else if (isCurrentConstraintFirstDescent) {
                    // We have reached the first descent constraint without needing to create a new target constraint, so
                    // attempt to extend the constant-FPA path from the existing target constraint through the first descent
                    // constraint.
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
                    if (terminatedIndex < currentConstraintIndex + 1) {
                        // The path was terminated early, which means there is a new target constraint.
                        targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                        currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                        break;
                    }
                    else {
                        // The path was not terminated early, so we are done.
                        return true;
                    }
                }
                else {
                    // Extend the current constant-FPA path and update the FPA limits
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentPathSegmentDistance += currentConstraint.distance;
                }
            }
        }
        return true;
    }
    /**
     * Attempts to extend and terminate a constant-FPA path from an existing target constraint at another constraint,
     * applying flight path angles and target altitudes to each constraint along the path. The target constraint defines
     * the FPA of the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param terminatingConstraintIndex The index of the constraint at which to terminate the path.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param terminatingConstraintIsTarget Whether to designate the terminating constraint as a target constraint if the
     * path is not terminated early. If the path is terminated early, this argument is ignored and the constraint at
     * which the path was terminated early is always designated as a target constraint.
     * @returns The index of the constraint at which the constant-FPA path was actually terminated.
     */
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
        const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
        if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== undefined) {
            // A constant-FPA path was not able to be extended from the existing target constraint to the first descent
            // constraint, so we need to designate a new target constraint where the path terminated.
            const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
            // Establish the proposed next target constraint target altitude
            const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
            const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
            // Set the new target constraint values
            const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            newTargetConstraint.isTarget = true;
            newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
        }
        return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.constraints.length > 0) {
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                const constraint = verticalPlan.constraints[i];
                if (constraint.type !== 'climb') {
                    return constraint.targetAltitude;
                }
            }
        }
        return undefined;
    }
    // Start of buildVerticalFlightPlan helper methods
    /**
     * Gets the constraint altitudes for a lateral flight plan leg.
     * @param leg A lateral flight plan leg.
     * @param out The tuple to which to write the altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @returns The constraint altitudes, in meters, for the specified flight plan leg, as
     * `[minimum_altitude, maximum_altitude]`, or `undefined` if the leg does not define any altitude constraints.
     */
    static getConstraintAltitudes(leg, out) {
        if (leg.verticalData !== undefined) {
            switch (leg.verticalData.altDesc) {
                case AltitudeRestrictionType.At:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.AtOrAbove:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = Number.POSITIVE_INFINITY;
                    return out;
                case AltitudeRestrictionType.AtOrBelow:
                    out[0] = Number.NEGATIVE_INFINITY;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.Between:
                    out[0] = leg.verticalData.altitude2;
                    out[1] = leg.verticalData.altitude1;
                    return out;
            }
        }
        return undefined;
    }
    /**
     * Forces a constraint to an AT constraint.
     * @param constraint The constraint to force to an AT constraint.
     */
    static forceAtConstraint(constraint) {
        if (constraint.minAltitude !== constraint.maxAltitude) {
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                constraint.maxAltitude = constraint.minAltitude;
            }
            else {
                constraint.minAltitude = constraint.maxAltitude;
            }
        }
    }
    /**
     * Gets the global index of a flight plan's lateral direct-to target leg.
     * @param lateralPlan A flight plan.
     * @returns The global index of the flight plan's lateral direct-to target leg, or `undefined` if the plan does not
     * have an existing lateral direct-to.
     */
    static getDirectToTargetLegIndex(lateralPlan) {
        const directToData = lateralPlan.directToData;
        if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
            const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
            if (segment !== null) {
                return segment.offset + directToData.segmentLegIndex;
            }
        }
        return undefined;
    }
    /**
     * Checks if there is a lateral direct-to leg in the flight plan and if so, flags the corresponding vertical flight
     * plan leg as such and marks the first descent constraint
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param directToLegOffset The offset of the lateral direct-to leg from the direct-to target leg.
     */
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
        // Check for a direct to in the lateral plan
        if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
            const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
            if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
                const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
                directVerticalLeg.isDirectToTarget = true;
                const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
                if (segment !== undefined) {
                    const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
                    for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type !== 'climb' && constraint.type !== 'missed' && constraint.index >= globalLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                            return;
                        }
                    }
                    verticalPlan.firstDescentConstraintLegIndex = undefined;
                }
            }
        }
    }
    /**
     * Checks whether a leg constraint is part of the missed approach.
     * @param lateralSegment The lateral flight plan segment to which the constraint's leg belongs.
     * @param lateralLeg The lateral flight plan leg to which the constraint belongs.
     * @returns Whether the leg constraint is part of the missed approach.
     */
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
        if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
        const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
        const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
        if (currentMinWithPrecision > priorMaxWithPrecision) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
        if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
            const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
            const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
            if (minFpaTempValue > maxFpa) {
                return true;
            }
        }
        return false;
    }
    /**
     * The default function which checks whether a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVnavEligible(lateralLeg) {
        switch (lateralLeg.leg.type) {
            case LegType.VM:
            case LegType.FM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * The default function which checks whether a climb constraint should be invalidated. This function always returns
     * `false`.
     * @returns Whether the specified climb constraint should be invalidated (always `false`).
     */
    static invalidateClimbConstraint() {
        return false;
    }
    /**
     * The default function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
        return (isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10)) || requiredFpa > maxFpa;
    }
    // Start of computeFlightPathAngles helper methods
    /**
     * Finds the maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to a
     * given constraint, among all constraints prior to and including (in flight plan order) the given constraint. If a
     * vertical direct constraint is among the candidates, its minimum altitude is used if it does not define a maximum
     * altitude.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the constraint for which to find the closest prior maximum altitude.
     * @param firstDescentConstraintIndex The index of the first descent constraint.
     * @returns The maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to the
     * specified constraint, among all constraints prior to and including (in flight plan order) the specified
     * constraint, or `Infinity` if there is no such altitude.
     */
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
        for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.maxAltitude < Infinity) {
                return constraint.maxAltitude;
            }
            if (i === firstDescentConstraintIndex && constraint.type === 'direct') {
                if (constraint.minAltitude > -Infinity) {
                    return constraint.minAltitude;
                }
            }
        }
        return Infinity;
    }
    /**
     * Applies flight path angle and target altitude values to a sequence of constraints connected to a target constraint
     * by a constant-FPA path extending backwards from the target constraint. The target constraint defines the FPA of
     * the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param endConstraintIndex The index of the constraint at which the constant-FPA path ends, exclusive.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param out The tuple to which to write the result of the operation.
     * @returns `[index, distance]`, where `index` is the index of the constraint at which the path was terminated due to
     * violation of the maximum target altitude, or `undefined` if no constraint violated the maximum altitude, and
     * `distance` is the total distance of the path, in meters.
     */
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        let distance = currentTargetConstraint.distance;
        for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
            const smoothedConstraint = verticalPlan.constraints[i];
            const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
            // The path can continue past the current constraint if the target altitude at the current constraint is less
            // than the maximum altitude.
            if (targetAltitude < maxAltitude) {
                smoothedConstraint.fpa = currentTargetConstraint.fpa;
                smoothedConstraint.targetAltitude = targetAltitude;
                distance += smoothedConstraint.distance;
            }
            else {
                out[0] = i;
                out[1] = distance;
                return out;
            }
        }
        out[0] = undefined;
        out[1] = distance;
        return out;
    }
}
SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;

/**
 * Sim var names for LNAV-related data.
 */
var LNavDataVars;
(function (LNavDataVars) {
    /** The current nominal desired track, in degrees true. */
    LNavDataVars["DTKTrue"] = "L:WT_LNavData_DTK_True";
    /** The current nominal desired track, in degrees magnetic. */
    LNavDataVars["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    /**
     * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavDataVars["XTK"] = "L:WT_LNavData_XTK";
    /** The current CDI scale. */
    LNavDataVars["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    LNavDataVars["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */
    LNavDataVars["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV. */
    LNavDataVars["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    /** The nominal distance remaining to the destination. */
    LNavDataVars["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
})(LNavDataVars || (LNavDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class LNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavDataSimVarPublisher.simvars, bus);
    }
}
LNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
]);

/**
 * Transports an alert state to the CAS via the event bus.
 */
class CasAlertTransporter {
    /**
     * Creates an instance of a CasAlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     */
    constructor(bus, uuid, priority, suffix) {
        this.bus = bus;
        this.uuid = uuid;
        this.priority = priority;
        this.suffix = suffix;
        this.currentValue = false;
        this.subs = [];
        this.updateEntries = [];
        this.isAlive = true;
        this.isPaused = false;
    }
    /**
     * Sets whether or not the alert is active.
     * @param active Whether or not the alert is active.
     * @throws Error if this transporter has been destroyed.
     */
    set(active) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot change an alert with a dead transporter');
        }
        if (this.currentValue !== active) {
            if (active) {
                this.bus.getPublisher().pub('cas_activate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            else {
                this.bus.getPublisher().pub('cas_deactivate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            this.currentValue = active;
        }
    }
    /**
     * Binds an alert state to a subscribable value.
     * @param toWatch The subscribable value to watch.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bind(toWatch, predicate) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        this.subs.push(toWatch.sub(v => this.set(predicate(v)), true, this.isPaused));
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindUpdate(predicate) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: false,
            func: (deltaTime) => this.set(predicate(deltaTime))
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @param state The optional state to pass into the predicate.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindStateUpdate(predicate, state) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: true,
            func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
            state
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Resumes this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also resumed. On resumption, the values of bound subscribables are evaluated
     * immediately, while the values of bound update loops will be evaluated during the next update cycle.
     * @returns This transporter, after it has been resumed.
     * @throws Error if this transporter has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot resume a dead transporter');
        }
        if (!this.isPaused) {
            return this;
        }
        this.isPaused = false;
        this.subs.forEach(sub => { sub.resume(true); });
        this.updateEntries.forEach(entry => { entry.isPaused = false; });
        return this;
    }
    /**
     * Pauses this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also paused.
     * @returns This transporter, after it has been paused.
     * @throws Error if this transporter has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot pause a dead transporter');
        }
        if (this.isPaused) {
            return this;
        }
        this.isPaused = true;
        this.subs.forEach(sub => { sub.pause(); });
        if (CasAlertTransporter.updateEntries) {
            this.updateEntries.forEach(entry => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const index = CasAlertTransporter.updateEntries.indexOf(entry);
                if (index >= 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    CasAlertTransporter.updateEntries.splice(index, 1);
                }
            });
        }
        return this;
    }
    /**
     * Destroys this transporter. This will destroy any subscribables or update loops used to bind the state of this
     * transporter's alert. Once this transporter has been destroyed, it cannot be used to change the state of its alert,
     * bind the state of its alert, or be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        this.subs.forEach(sub => { sub.destroy(); });
        this.updateEntries.forEach(entry => { entry.isPaused = true; });
    }
    /**
     * Creates an instance of an AlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     * @returns The created AlertTransporter.
     */
    static create(bus, uuid, priority, suffix) {
        return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    /**
     * Initializes the update functions.
     */
    initUpdateFuncs() {
        if (CasAlertTransporter.updateEntries === undefined) {
            CasAlertTransporter.updateEntries = [];
            this.bus.getSubscriber().on('simTime').handle((timestamp) => {
                if (CasAlertTransporter.previousTimestamp === -1) {
                    CasAlertTransporter.previousTimestamp = timestamp;
                }
                const deltaTime = MathUtils.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 10000);
                if (CasAlertTransporter.updateEntries !== undefined) {
                    for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
                        const entry = CasAlertTransporter.updateEntries[i];
                        if (entry.isPaused) {
                            continue;
                        }
                        if (entry.hasState) {
                            entry.func(deltaTime, entry.state);
                        }
                        else {
                            entry.func(deltaTime);
                        }
                    }
                }
                CasAlertTransporter.previousTimestamp = timestamp;
            });
        }
    }
}
CasAlertTransporter.previousTimestamp = -1;

/**
 * This is a convenience tool for publishing and republishing CAS alert registrations.  Code
 * that wants to implement its own alert publishing system can use the CasRegistrationManager
 * to avoid having to subscribe to and handle requests on the bus for republication of alert
 * registrations.
 */
class CasRegistrationManager {
    /**
     * Create a CasRegistrationManager
     * @param bus The event bus
     */
    constructor(bus) {
        this.registrations = new Map();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('cas_publish_registration').handle(uuid => this.publishRegistration(uuid));
        subscriber.on('cas_publish_all_registrations').handle(() => this.publishAllRegistrations());
    }
    /**
     * Register an alert for management.
     * @param definition The CasAlertDefinition for this alert.
     */
    register(definition) {
        this.registrations.set(definition.uuid, definition);
        this.publishRegistration(definition.uuid);
    }
    /**
     * Handle publishing information for a single alert.
     * @param uuid The UUID of the registation to publish.
     */
    publishRegistration(uuid) {
        const definition = this.registrations.get(uuid);
        if (definition) {
            this.publisher.pub('cas_register_alert', definition, true, false);
        }
    }
    /**
     * Publish all current registrations.
     */
    publishAllRegistrations() {
        for (const uuid of this.registrations.keys()) {
            this.publishRegistration(uuid);
        }
    }
}

/**
 * A class for caching images.
 * Do your own instrument specific implementation with an init() method
 * that will add images to cache on instrument load to prefill the cache.
 * @class ImageCache
 */
class ImageCache {
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key, url) {
        if (this.cache[key] === undefined) {
            const img = new Image();
            img.src = url;
            this.cache[key] = img;
        }
    }
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key) {
        return this.cache[key];
    }
}
ImageCache.cache = {};

/* eslint-disable jsdoc/check-indentation */
/**
 * A utility class for creating duration formatters.
 *
 * Each duration formatter is a function which generates output strings from input duration values. The formatting
 * behavior of a formatter is defined by its format template.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Sign fragment. In EBNF notation, these take the form `['+', ['[', x, ']']], ('-' , ['[', y, ']'])`, where
 * `x` and `y` are arbitrary strings. Each sign fragment is replaced with a string representing the sign of the input.
 * The negative sign string is defined by `y`. If `y` is not defined, the negative sign string defaults to `'-'`
 * (dash). The positive sign string is defined by `x`. If the positive sign token does not appear in the fragment
 * definition, the positive sign string defaults to `''` (the empty string), otherwise it defaults to `'+'`.
 * * Numeric fragment. In EBNF notation, these take the form
 * `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]`, where `x = 'H' | 'M' | 'S' | 'h' | 'm' | 's'`. Each numeric fragment is
 * replaced with the numeric value of the duration in hours, minutes, or seconds, depending on which character is used
 * for `x`. With uppercase letters, the entire portion of the input value is used. With lowercase letters, only the
 * portion of the input value that does not divide evenly into the next smallest unit is used (for hours, which is the
 * largest unit, there is no difference between using `'H'` and `'h'`).
 *   * The number of `x` characters to the left of the decimal point (including all characters if no decimal point is
 * present) in the definition controls the number of leading zeroes with which the output will be padded.
 *   * If the optional `'?'` character is present, the output will drop all digits to the left of the decimal point if
 * all such digits are equal to 0.
 *   * The total number of `x` characters to the right of the decimal point in the definition controls the decimal
 * precision of the output. Trailing zeroes to the right of the decimal point will be added to the output to a number
 * of decimal places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the
 * definition. If there are no `x` characters to the right of the decimal point in the definition, then the output will
 * have infinite decimal precision with no extraneous trailing zeroes.
 *   * Rounding behavior is always round down.
 *
 * @example <caption>Formatting to hours-minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss}', UnitType.SECOND);
 * formatter(3616);       // 1:00:16
 * formatter(36016.9);    // 10:00:16
 *
 * @example <caption>Formatting to hours-minutes-seconds with decimal precision</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss.s(s)}', UnitType.SECOND);
 * formatter(3600);       // 1:00:00.0
 * formatter(3600.55);    // 1:00:00.55
 *
 * @example <caption>Formatting to minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{MM}:{ss}', UnitType.SECOND);
 * formatter(600);        // 10:00
 * formatter(4200);       // 70:00
 *
 * @example <caption>Formatting with signs</caption>
 * const formatter = DurationFormatter.create('{-}{h}:{mm}', UnitType.SECOND);
 * formatter(3600);                   // 1:00
 * formatter(-3600);                  // -1:00
 *
 * const formatterWithPositiveSign = DurationFormatter.create('{+-}{h}:{mm}', UnitType.SECOND);
 * formatterWithPositiveSign(3600);   // +1:00
 *
 * const formatterWithRealMinusSign = DurationFormatter.create('{-[–]}{h}:{mm}', UnitType.SECOND);
 * formatterWithRealMinusSign(3600);  // –1:00
 */
class DurationFormatter {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(format, unit, precision, arg4) {
        const builder = DurationFormatter.createBuilder(format, precision, unit);
        const options = DurationFormatter.resolveOptions(typeof arg4 === 'string' ? { nanString: arg4 } : arg4);
        const built = Array.from(builder, () => '');
        if (options.cache) {
            let cachedInput = undefined;
            let cachedOutput = undefined;
            return (duration) => {
                if (isNaN(duration)) {
                    return options.nanString;
                }
                const roundedInput = MathUtils.round(duration, precision);
                if (cachedInput !== undefined && cachedOutput !== undefined && roundedInput === cachedInput) {
                    return cachedOutput;
                }
                cachedInput = roundedInput;
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration, unit);
                }
                return cachedOutput = built.join('');
            };
        }
        else {
            return (duration) => {
                if (isNaN(duration)) {
                    return options.nanString;
                }
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration, unit);
                }
                return built.join('');
            };
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createForNumberUnit(format, precision, arg3) {
        const builder = DurationFormatter.createBuilder(format, precision.number, precision.unit);
        const options = DurationFormatter.resolveOptions(typeof arg3 === 'string' ? { nanString: arg3 } : arg3);
        const built = Array.from(builder, () => '');
        if (options.cache) {
            let cachedInput = undefined;
            let cachedOutput = undefined;
            return (duration) => {
                if (duration.isNaN()) {
                    return options.nanString;
                }
                const roundedInput = MathUtils.round(duration.asUnit(precision.unit), precision.number);
                if (cachedInput !== undefined && cachedOutput !== undefined && roundedInput === cachedInput) {
                    return cachedOutput;
                }
                cachedInput = roundedInput;
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration.number, duration.unit);
                }
                return cachedOutput = built.join('');
            };
        }
        else {
            return (duration) => {
                if (duration.isNaN()) {
                    return options.nanString;
                }
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](duration.number, duration.unit);
                }
                return built.join('');
            };
        }
    }
    /**
     * Resolves a full set of options from a partial options object. Any option not explicitly defined by the partial
     * options object will revert to its default value.
     * @param options A partial options object.
     * @returns A new options object containing the full set of options resolved from the specified partial options
     * object.
     */
    static resolveOptions(options) {
        var _a;
        const resolved = Object.assign({}, options);
        for (const key in DurationFormatter.DEFAULT_OPTIONS) {
            (_a = resolved[key]) !== null && _a !== void 0 ? _a : (resolved[key] = DurationFormatter.DEFAULT_OPTIONS[key]);
        }
        return resolved;
    }
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns An output string builder which conforms to the specified format template.
     */
    static createBuilder(format, precision, precisionUnit) {
        const split = format.split(DurationFormatter.FORMAT_REGEXP);
        return split.map((string) => {
            if (string.match(DurationFormatter.FORMAT_REGEXP)) {
                return DurationFormatter.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
            }
            else {
                return () => string;
            }
        });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input duration according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns A function which generates a string from an input duration in milliseconds according to the rules defined
     * by the template fragment.
     */
    static parseFragment(fragment, precision, precisionUnit) {
        var _a, _b;
        const signMatch = fragment.match(DurationFormatter.SIGN_FRAGMENT_REGEX);
        if (signMatch) {
            const [, posCharMatch, // Matches the positive sign char ('+')
            posStringMatch, // Matches the string assigned to represent the positive sign
            negStringMatch // Matches the string assigned to represent the negative sign
            ] = signMatch;
            const posSign = posCharMatch === '+' ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : '+' : '';
            const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : '-';
            return (angle) => {
                return angle < 0 ? negSign : posSign;
            };
        }
        const numericMatch = fragment.match(DurationFormatter.NUM_FRAGMENT_REGEXP);
        if (!numericMatch) {
            console.warn(`DurationFormatter: discarding fragment due to invalid syntax: {${fragment}}`);
            return () => '';
        }
        const [, leftMatch, // Matches unit chars to the left of the decimal point
        unitMatch, // Matches the unit char ('H', 'M', 'S', etc)
        leftOptionalMatch, // Matches the question mark just to the left of the decimal point
        rightMatch, // Matches the decimal point and all chars to the right
        rightForcedMatch, // Matches unit chars to the right of the decimal point not surrounded by parens
        rightOptionalMatch // Matches unit chars to the right of the decimal point surrounded by parens
        ] = numericMatch;
        const unitInfo = DurationFormatter.NUM_FRAGMENT_UNIT_INFO[unitMatch];
        const pad = leftMatch.length;
        const dropZero = !!leftOptionalMatch;
        const step = precisionUnit.convertTo(precision, unitInfo.unit);
        const convertFunc = step <= 0
            ? ((duration, unit) => {
                return unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
            }) : ((duration, unit, epsilon) => {
            return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(duration), unit), step) + epsilon) % unitInfo.mod;
        });
        const formatLeftFunc = dropZero
            ? ((input) => {
                const rounded = Math.floor(input);
                return rounded === 0 ? '' : rounded.toString().padStart(pad, '0');
            })
            : ((input) => Math.floor(input).toString().padStart(pad, '0'));
        if (rightMatch) {
            if (rightMatch.length === 1) {
                // Unlimited decimal precision
                return (duration, unit) => {
                    const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
                    const decimal = converted % 1;
                    return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
                };
            }
            const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
            const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
            const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
            const factor = Math.pow(10, totalDecimalPlaces);
            const epsilon = Math.min(step / 2, 1 / (2 * factor));
            return (duration, unit) => {
                const converted = convertFunc(duration, unit, epsilon);
                const decimal = converted % 1;
                const decimalRounded = Math.floor(decimal * factor) / factor;
                return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, '0')}`;
            };
        }
        else {
            const epsilon = Math.min(step / 2, 0.5);
            return (duration, unit) => {
                return formatLeftFunc(convertFunc(duration, unit, epsilon));
            };
        }
    }
}
DurationFormatter.FORMAT_REGEXP = /({[^{}]*})/;
DurationFormatter.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
DurationFormatter.NUM_FRAGMENT_REGEXP = /^(([HMShms])\2*)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
DurationFormatter.NUM_FRAGMENT_UNIT_INFO = {
    ['h']: { unit: UnitType.HOUR, mod: Infinity },
    ['m']: { unit: UnitType.MINUTE, mod: 60 },
    ['s']: { unit: UnitType.SECOND, mod: 60 },
    ['H']: { unit: UnitType.HOUR, mod: Infinity },
    ['M']: { unit: UnitType.MINUTE, mod: Infinity },
    ['S']: { unit: UnitType.SECOND, mod: Infinity }
};
/** The default options for duration formatters. */
DurationFormatter.DEFAULT_OPTIONS = {
    nanString: 'NaN',
    cache: false
};

/* eslint-disable max-len */
/**
 * A utility class for creating time formatters.
 *
 * Each time formatter is a function which generates output strings from input time values, expressed as UNIX
 * timestamps in milliseconds. The formatting behavior of a formatter is defined by its format template and options.
 *
 * Please refer to the {@link DateTimeFormatterOptions} type documentation for more information on individual
 * formatting options.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Integer fragment. In EBNF notation, these take the form `{x}` where `x = 'M' | 'd' | 'w'`. Each numeric fragment
 * is replaced with an integer representation of the month (`M`), day of month (`d`), or day of week (`w`) part of the
 * input time. The number of `x` characters in the definition controls the number of leading zeroes with which the
 * output will be padded.
 * * Numeric fragment. In EBNF notation, these take the form `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]` where
 * `x = 'H' | 'h' | 'm' | 's'`. Each numeric fragment is replaced with a numeric representation of the hour-24 (`H`),
 * hour-12 (`h`), minute (`m`), or second (`s`) part of the input time. The number of `x` characters in the definition
 * controls the number of leading zeroes with which the output will be padded. If the optional `'?'` character is
 * present, the output will drop all digits to the left of the decimal point if all such digits are equal to 0. The
 * total number of `x` characters to the right of the decimal point in the definition controls the decimal precision of
 * the output. Trailing zeroes to the right of the decimal point will be added to the output to a number of decimal
 * places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the definition.
 * If there are no `x` characters to the right of the decimal point in the definition, then the output will have
 * infinite decimal precision with no extraneous trailing zeroes. Rounding behavior is always round down.
 * * Year fragment. In EBNF notation, these take the form `'YY' | 'YYYY'`. Each year fragment is replaced with either
 * the two-digit (`YY`) or unlimited-digit (`YYYY`) year of the input time.
 * * Month fragment. In EBNF notation, these take the form `('mon', ['.']) | ('MON', ['.']) | 'month' | 'MONTH'`. Each
 * month fragment is replaced with the name of the month of the input time. The case of the definition determines the
 * case of the output. `mon` will use abbreviated names. The presence of the optional `'.'` character will add a period
 * to the end of the abbreviated names.
 * * Day-of-week fragment. In EBNF notation, these take the form `('dy', ['.']) | ('DY', ['.']) | 'day' | 'DAY'`. Each
 * day-of-week fragment is replaced with the name of the day-of-week of the input time. The case of the definition
 * determines the case of the output. `dy` will use abbreviated names. The presence of the optional `'.'` character
 * will add a period to the end of the abbreviated names.
 * * AM/PM fragment. In EBNF notation, these take the form `'am' | 'a.m.' | 'AM' | 'A.M.'`. Each AM/PM fragment is
 * replaced with an AM/PM string depending on the time of day of the input. The case of the definition determines the
 * case of the output. Use of periods in the definition will add periods to the output.
 *
 * @example <caption>Formatting to a date</caption>
 * const formatter = DateTimeFormatter.create('{dd}-{MM}-{YY}');
 * formatter(0);              // 01-01-70
 * formatter(1597723200000);  // 18-08-20
 *
 * @example <caption>Formatting to a time (24-hr)</caption>
 * const formatter = DateTimeFormatter.create('{HH}:{mm}:{ss}');
 * formatter(0);              // 00:00:00
 * formatter(5145000);        // 01:25:45
 * formatter(57600000);       // 16:00:00
 *
 * @example <caption>Formatting to a time (12-hr)</caption>
 * const formatter = DateTimeFormatter.create('{hh}:{mm}:{ss} {am}');
 * formatter(0);              // 12:00:00 am
 * formatter(5145000);        // 01:25:45 am
 * formatter(57600000);       // 04:00:00 pm
 *
 * @example <caption>Formatting to a time with decimals</caption>
 * const formatter = DateTimeFormatter.create('{H}:{mm.m(m)}');
 * formatter(0);              // 0:00.0
 * formatter(5145000);        // 1:25.75
 *
 * @example <caption>Formatting to ISO 8601</caption>
 * const formatter = DateTimeFormatter.create('{YYYY}-{MM}-{dd}T{HH}:{mm}:{ss}');
 * formatter(0);              // 1970-01-01T00:00:00
 * formatter(1597723200000);  // 2020-08-18T04:00:00
 */
class DateTimeFormatter {
    /**
     * Creates a function which formats times, expressed as UNIX timestamps in milliseconds, to strings. The formatting
     * behavior of the function is defined by a specified format template and options. For more information on format
     * templates and their syntax, please refer to the {@link DateTimeFormatter} class documentation. For more
     * information on individual formatting options, please refer to the {@link DateTimeFormatterOptions} type
     * documentation.
     * @param format A template defining how the function formats durations.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']`
     * * `monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']`
     * * `dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`
     * * `dayNamesShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']`
     * * `nanString = 'NaN'`
     * @returns A function which formats times, expressed as UNIX timestamps in milliseconds, to strings.
     */
    static create(format, options) {
        const optsToUse = this.resolveOptions(options);
        const builder = DateTimeFormatter.createBuilder(format, optsToUse);
        const date = new Date();
        const built = Array.from(builder, () => '');
        if (optsToUse.cache) {
            let cachedInput = undefined;
            let cachedOutput = undefined;
            return (time) => {
                if (isNaN(time)) {
                    return optsToUse.nanString;
                }
                const roundedInput = Math.floor(time);
                if (cachedInput !== undefined && cachedOutput !== undefined && roundedInput === cachedInput) {
                    return cachedOutput;
                }
                cachedInput = roundedInput;
                date.setTime(roundedInput);
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](date);
                }
                return cachedOutput = built.join('');
            };
        }
        else {
            return (time) => {
                if (isNaN(time)) {
                    return optsToUse.nanString;
                }
                date.setTime(Math.floor(time));
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](date);
                }
                return built.join('');
            };
        }
    }
    /**
     * Resolves a full set of options from a partial options object. Any option not explicitly defined by the partial
     * options object will revert to its default value.
     * @param options A partial options object.
     * @returns A new options object containing the full set of options resolved from the specified partial options
     * object.
     */
    static resolveOptions(options) {
        var _a;
        const resolved = Object.assign({}, options);
        for (const key in DateTimeFormatter.DEFAULT_OPTIONS) {
            (_a = resolved[key]) !== null && _a !== void 0 ? _a : (resolved[key] = DateTimeFormatter.DEFAULT_OPTIONS[key]);
        }
        return resolved;
    }
    /**
     * Creates an output string builder from a format template and options.
     * @param format A format template.
     * @param options Formatting options.
     * @returns An output string builder which conforms to the specified format template and options.
     */
    static createBuilder(format, options) {
        const split = format.split(DateTimeFormatter.FORMAT_REGEXP);
        return split.map((string) => {
            if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
                return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
            }
            else {
                return () => string;
            }
        });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the template fragment.
     */
    static parseFragment(fragment, options) {
        const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
        if (match) {
            if (match[1]) {
                return DateTimeFormatter.parseIntFragment(match);
            }
            else if (match[3]) {
                return DateTimeFormatter.parseNumFragment(match);
            }
            else if (match[10]) {
                return DateTimeFormatter.parseYearFragment(match);
            }
            else if (match[11]) {
                return DateTimeFormatter.parseMonthFragment(match, options);
            }
            else if (match[12]) {
                return DateTimeFormatter.parseDayFragment(match, options);
            }
            else if (match[13]) {
                return DateTimeFormatter.parseAMPMFragment(match);
            }
        }
        console.warn(`DateTimeFormatter: discarding fragment due to invalid syntax: {${fragment}}`);
        return () => '';
    }
    /**
     * Parses an integer template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An integer template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the integer template fragment.
     */
    static parseIntFragment(match) {
        const [
        /* 0 */ , fragmentMatch, // Matches the full fragment
        unitMatch // Matches the unit char ('M', 'd', 'w')
        ] = match;
        const intGetter = DateTimeFormatter.INT_GETTERS[unitMatch];
        const pad = fragmentMatch.length;
        return (date) => {
            return intGetter(date).toString().padStart(pad, '0');
        };
    }
    /**
     * Parses a numeric template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A numeric template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the numeric template fragment.
     */
    static parseNumFragment(match) {
        var _a, _b;
        const [
        /* 0 */ , /* 1 */ , /* 2 */ , /* 3 */ , leftMatch, // Matches unit chars to the left of the decimal point
        unitMatch, // Matches the unit char ('h', 'm', 's', etc)
        leftOptionalMatch, // Matches the question mark just to the left of the decimal point
        rightMatch, // Matches the decimal point and all chars to the right
        rightForcedMatch, // Matches unit chars to the right of the decimal point not surrounded by parens
        rightOptionalMatch // Matches unit chars to the right of the decimal point surrounded by parens
        ] = match;
        const numGetter = DateTimeFormatter.NUM_GETTERS[unitMatch];
        const numFractionGetter = DateTimeFormatter.NUM_FRACTION_GETTERS[unitMatch];
        const pad = leftMatch.length;
        const dropZero = !!leftOptionalMatch;
        const formatLeftFunc = dropZero
            ? ((date) => {
                const num = numGetter(date);
                return num === 0 ? '' : num.toString().padStart(pad, '0');
            }) : ((date) => numGetter(date).toString().padStart(pad, '0'));
        if (rightMatch) {
            if (rightMatch.length === 1) {
                // Unlimited decimal precision
                return (date) => {
                    return `${formatLeftFunc(date)}${numFractionGetter(date).toString().substring(1)}`;
                };
            }
            const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
            const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
            const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
            const factor = Math.pow(10, totalDecimalPlaces);
            return (date) => {
                const decimal = numFractionGetter(date);
                const decimalRounded = Math.floor(decimal * factor) / factor;
                return `${formatLeftFunc(date)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, '0')}`;
            };
        }
        else {
            return formatLeftFunc;
        }
    }
    /**
     * Parses a year template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A year template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the year template fragment.
     */
    static parseYearFragment(match) {
        if (match[10].length === 2) {
            // YY
            return (date) => (date.getUTCFullYear() % 100).toString();
        }
        else {
            // YYYY
            return (date) => date.getUTCFullYear().toString();
        }
    }
    /**
     * Parses a month template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A month template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the month template fragment.
     */
    static parseMonthFragment(match, options) {
        const fragmentMatch = match[11];
        const isUpperCase = fragmentMatch[0] === 'M';
        if (fragmentMatch.length === 3) {
            // mon
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => text[date.getUTCMonth()];
        }
        else if (fragmentMatch.length === 4) {
            // mon.
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => {
                const month = date.getUTCMonth();
                return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? '' : '.'}`;
            };
        }
        else {
            // month
            const text = isUpperCase ? options.monthNames.map(str => str.toUpperCase()) : options.monthNames;
            return (date) => text[date.getUTCMonth()];
        }
    }
    /**
     * Parses a day-of-week template fragment and returns a function which generates a string from an input time
     * according to the rules defined by the fragment.
     * @param match A day-of-week template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the day-of-week template fragment.
     */
    static parseDayFragment(match, options) {
        const fragmentMatch = match[12];
        const isUpperCase = fragmentMatch[0] === 'D';
        if (fragmentMatch === 'dy') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => text[date.getUTCDay()];
        }
        else if (fragmentMatch === 'dy.') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => {
                const day = date.getUTCDay();
                return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? '' : '.'}`;
            };
        }
        else {
            // day
            const text = isUpperCase ? options.dayNames.map(str => str.toUpperCase()) : options.dayNames;
            return (date) => text[date.getUTCDay()];
        }
    }
    /**
     * Parses an am/pm template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An am/pm template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the am/pm template fragment.
     */
    static parseAMPMFragment(match) {
        const fragmentMatch = match[13];
        const isUpperCase = fragmentMatch[0] === 'A';
        const usePeriod = fragmentMatch.length > 2;
        let text = usePeriod ? ['a.m.', 'p.m.'] : ['am', 'pm'];
        if (isUpperCase) {
            text = text.map(str => str.toUpperCase());
        }
        return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
}
DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
DateTimeFormatter.FRAGMENT_REGEXP = /^(?:(([Mdw])\2*)|((([Hhms])\5*)(\?)?(?:(\.(\5*)(?:\((\5+)\))?)?))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
DateTimeFormatter.INT_GETTERS = {
    ['w']: (date) => date.getUTCDay() + 1,
    ['d']: (date) => date.getUTCDate(),
    ['M']: (date) => date.getUTCMonth() + 1
};
DateTimeFormatter.NUM_GETTERS = {
    ['s']: (date) => date.getUTCSeconds(),
    ['m']: (date) => date.getUTCMinutes(),
    ['h']: (date) => 12 - (24 - date.getUTCHours()) % 12,
    ['H']: (date) => date.getUTCHours()
};
DateTimeFormatter.NUM_FRACTION_GETTERS = {
    ['s']: (date) => (date.getTime() % 1000) / 1000,
    ['m']: (date) => (date.getTime() % 60000) / 60000,
    ['h']: (date) => (date.getTime() % 3600000) / 3600000,
    ['H']: (date) => (date.getTime() % 3600000) / 3600000
};
DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    nanString: 'NaN',
    cache: false
};

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     * @param keepLocal If present and true, values will be kept local to the instrument on which they're set.
     */
    constructor(bus, settingDefs, keepLocal = false) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.subscriber = this.bus.getSubscriber();
        this.syncPublisher = this.bus.getPublisher();
        this.syncSubscriber = this.bus.getSubscriber();
        this.keepLocal = keepLocal;
        this.settings = new Map(settingDefs.map(def => {
            const initTopic = `usersetting_init_${def.name}`;
            const syncTopic = `usersetting_sync_${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0,
                initUid: Math.round(Math.random() * Number.MAX_SAFE_INTEGER)
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            entry.initSub = this.syncSubscriber.on(initTopic).handle(data => {
                // Do not respond to our own initialization sync.
                if (data.uid === entry.initUid) {
                    return;
                }
                // If we receive an initialization sync event for a setting, that means a manager on another instrument tried
                // to initialize the same setting to its default value. However, since the setting already exists here, we will
                // send a response to override the initialized value with the existing value.
                this.syncPublisher.pub(entry.syncTopic, { value: entry.setting.value, syncTime: entry.syncTime, initUid: data.uid }, !this.keepLocal, true);
            }, true);
            // Because sync events are cached, the initial subscriptions to the sync topic below will grab the synced value
            // of the new setting if it exists on the local instrument (e.g. if the value was synced from another instrument
            // after the local instrument was created but before this manager and local setting were created).
            this.syncSubscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            if (entry.syncTime === 0) {
                // If the new setting has no synced value on the local instrument, we will try to grab an initialization value
                // instead. If one exists, we will use it, but keep the local sync time at 0. If there is a pending response
                // to this initialization value, we want to be ready to accept the response when it arrives, which we can't do
                // if the local sync time is non-zero).
                const sub = this.syncSubscriber.on(initTopic).handle(data => {
                    this.onSettingValueSynced(entry, { value: data.value, syncTime: 0 });
                });
                sub.destroy();
            }
            if (entry.syncTime === 0) {
                // An existing synced value does not exist for the new setting on the local instrument, so we will go ahead
                // and initialize the new setting value to its default and send an initialization sync event. If the setting
                // exists on other instruments, their managers will send an initialization response to override our initialized
                // value.
                this.syncPublisher.pub(initTopic, { value: entry.setting.value, syncTime: Date.now(), uid: entry.initUid }, !this.keepLocal, true);
                this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
            }
            entry.initSub.resume();
            return [def.name, entry];
        }));
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        return (_a = this.settings.get(name)) === null || _a === void 0 ? void 0 : _a.setting;
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.syncPublisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, !this.keepLocal, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // If the sync event is an initialization response, ignore it if the local setting value has already been synced.
        // Otherwise, protect against race conditions by not responding to sync events older than the last time this
        // manager synced the setting.
        if ((data.initUid !== undefined && entry.syncTime !== 0)
            || (data.initUid === undefined && data.syncTime < entry.syncTime)) {
            return;
        }
        this.syncSettingFromEvent(entry, data);
    }
    /**
     * Syncs a setting using data received from a sync event.
     * @param entry The entry for the setting to sync.
     * @param data The sync event data.
     */
    syncSettingFromEvent(entry, data) {
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // Publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
    }
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.tryGetSetting(mappedName);
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
    /** @inheritdoc */
    getAllSettings() {
        return this.parent.getAllSettings();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        super();
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isMutableSubscribable = true;
        this._value = definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this._value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.valueChangedCallback(v);
        this.notify();
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        if (this._value === value) {
            return;
        }
        this._value = value;
        this.notify();
    }
    /** @inheritdoc */
    get() {
        return this._value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * An aliased user setting manager which can dynamically (re)define the settings from which its aliased settings are
 * sourced.
 */
class AliasedUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings. The definitions should
     * define the settings' aliased names.
     */
    constructor(bus, settingDefs) {
        this.bus = bus;
        this.aliasedSettings = new Map(settingDefs.map(def => [def.name, new AliasedUserSetting(def)]));
    }
    /**
     * Defines the mappings from this manager's aliased settings to their source settings. Once the mappings are defined,
     * each aliased setting will take the value of its source setting, and setting the value of the aliased setting will
     * also set the value of the source setting. If a source setting cannot be defined for an aliased setting, the
     * aliased setting's value will be fixed to its default value and cannot be changed.
     * @param masterManager The manager hosting the settings from which this manager's aliased settings will be sourced.
     * @param map The mappings for this manager's aliased settings, as a set of key-value pairs where the keys are the
     * aliased setting names and the values are the source setting names. For any aliased setting whose name does not
     * appear as a key in the mapping, its source setting is assumed to have the same name.
     */
    useAliases(masterManager, map) {
        this.manager = masterManager.mapTo(map);
        for (const aliasedSetting of this.aliasedSettings.values()) {
            aliasedSetting.useSource(this.manager.tryGetSetting(aliasedSetting.definition.name));
        }
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        return this.aliasedSettings.get(name);
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.aliasedSettings.get(name);
        if (!setting) {
            throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
        }
        return new BasicConsumer((handler, paused) => {
            return setting.sub(handler, true, paused);
        }).whenChanged();
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.aliasedSettings.values());
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * A user setting with a value which is sourced from another setting. While the setting has no source, its value is
 * fixed to its default value and cannot be changed.
 */
class AliasedUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     */
    constructor(definition) {
        super();
        this.definition = definition;
        this.isMutableSubscribable = true;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        var _a, _b;
        return (_b = (_a = this.setting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        this.setting && (this.setting.value = v);
    }
    /**
     * Sets this setting's source.
     * @param setting The user setting to use as the new source, or `undefined` to leave this setting without a source.
     */
    useSource(setting) {
        var _a;
        const oldValue = this.value;
        (_a = this.settingSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.setting = setting;
        if (setting !== undefined) {
            this.settingSub = setting.sub(() => { this.notify(); });
        }
        else {
            this.settingSub = undefined;
        }
        if (oldValue !== this.value) {
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * The state of an avionics system.
 */
var AvionicsSystemState;
(function (AvionicsSystemState) {
    AvionicsSystemState["Off"] = "Off";
    AvionicsSystemState["Initializing"] = "Initializing";
    AvionicsSystemState["On"] = "On";
    AvionicsSystemState["Failed"] = "Failed";
})(AvionicsSystemState || (AvionicsSystemState = {}));

/**
 * A basic avionics system with a fixed initialization time and logic.
 */
class BasicAvionicsSystem {
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index, bus, stateEvent) {
        this.index = index;
        this.bus = bus;
        this.stateEvent = stateEvent;
        /** The time it takes in milliseconds for the system to initialize. */
        this.initializationTime = 0;
        /** A timeout after which initialization will be complete. */
        this.initializationTimer = new DebounceTimer();
        this.publisher = this.bus.getPublisher();
        /** Whether power data consumed by this system is valid. */
        this.isPowerValid = false;
        this.bus.pub(this.stateEvent, { previous: undefined, current: undefined });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            var _a;
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.isPowerValid = true;
                (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    get state() {
        return this._state;
    }
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic, electricity logic element, or
     * {@link Subscribable}.
     * @param source The source to which to connect this system's power state.
     */
    connectToPower(source) {
        var _a;
        (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.electricalPowerSub = undefined;
        this.electricalPowerLogic = undefined;
        if (typeof source === 'string') {
            this.electricalPowerSub = this.bus.getSubscriber()
                .on(source)
                .whenChanged()
                .handle(this.onPowerChanged.bind(this), !this.isPowerValid);
        }
        else if (SubscribableUtils.isSubscribable(source)) {
            this.electricalPowerSub = source.sub(this.onPowerChanged.bind(this), true, !this.isPowerValid);
        }
        else {
            this.electricalPowerLogic = source;
            this.updatePowerFromLogic();
        }
    }
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    setState(state) {
        if (this._state !== state) {
            const previous = this._state;
            this._state = state;
            this.onStateChanged(previous, state);
            this.bus.pub(this.stateEvent, { previous, current: state });
        }
    }
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        // noop
    }
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Off);
            }
        }
        else {
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(() => this.setState(AvionicsSystemState.On), this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        this.updatePowerFromLogic();
    }
    /**
     * Updates this system's power state from an electricity logic element.
     */
    updatePowerFromLogic() {
        if (!this.isPowerValid || this.electricalPowerLogic === undefined) {
            return;
        }
        const isPowered = this.electricalPowerLogic.getValue() !== 0;
        if (isPowered !== this.isPowered) {
            this.onPowerChanged(isPowered);
        }
    }
}

/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
class FsBaseInstrument extends BaseInstrument {
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.fsInstrument = this.constructInstrument();
    }
    /**
     * Update method called by BaseInstrument
     */
    Update() {
        super.Update();
        if (this.fsInstrument) {
            this.fsInstrument.Update();
        }
    }
    /** @inheritdoc */
    onInteractionEvent(_args) {
        if (this.fsInstrument) {
            this.fsInstrument.onInteractionEvent(_args);
        }
    }
    /** @inheritdoc */
    onGameStateChanged(oldState, newState) {
        super.onGameStateChanged(oldState, newState);
        if (this.fsInstrument) {
            this.fsInstrument.onGameStateChanged(oldState, newState);
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
        if (this.fsInstrument) {
            this.fsInstrument.onFlightStart();
        }
    }
    /** @inheritdoc */
    onSoundEnd(soundEventId) {
        super.onSoundEnd(soundEventId);
        if (this.fsInstrument) {
            this.fsInstrument.onSoundEnd(soundEventId);
        }
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return false;
    }
}

/**
 * A configuration object which defines options related to various aircraft sensors.
 */
class SensorsConfig {
    /**
     * Creates a new SensorsConfig from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     */
    constructor(baseInstrument, element) {
        if (element === undefined) {
            this.adcCount = 1;
            this.ahrsCount = 1;
            this.radarAltimeterCount = 1;
            this.gpsCount = 1;
            this.adcDefinitions = [undefined, { altimeterIndex: 1, airspeedIndicatorIndex: 1 }];
            this.ahrsDefinitions = [undefined, { attitudeIndicatorIndex: 1, directionIndicatorIndex: 1 }];
            this.radarAltimeterDefinitions = [undefined, {}];
            this.gpsDefinitions = [undefined, {}];
        }
        else {
            if (element.tagName !== 'Sensors') {
                throw new Error(`Invalid SensorsConfig definition: expected tag name 'Sensors' but was '${element.tagName}'`);
            }
            const adcCount = Number(element.getAttribute('adc-count'));
            if (!Number.isInteger(adcCount) || adcCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC count (must be a positive integer)');
                this.adcCount = 1;
            }
            else {
                this.adcCount = adcCount;
            }
            const ahrsCount = Number(element.getAttribute('ahrs-count'));
            if (!Number.isInteger(ahrsCount) || ahrsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS count (must be a positive integer)');
                this.ahrsCount = 1;
            }
            else {
                this.ahrsCount = ahrsCount;
            }
            const radarAltimeterCount = Number(element.getAttribute('radar-altimeter-count'));
            if (!Number.isInteger(radarAltimeterCount) || radarAltimeterCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized RA count (must be a positive integer)');
                this.radarAltimeterCount = 1;
            }
            else {
                this.radarAltimeterCount = radarAltimeterCount;
            }
            const gpsCount = Number(element.getAttribute('gps-count'));
            if (!Number.isInteger(gpsCount) || gpsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS count (must be a positive integer)');
                this.gpsCount = 1;
            }
            else {
                this.gpsCount = gpsCount;
            }
            this.adcDefinitions = this.parseAdcDefinitions(baseInstrument, element);
            this.ahrsDefinitions = this.parseAhrsDefinitions(baseInstrument, element);
            this.radarAltimeterDefinitions = this.parseRadarAltimeterDefinitions(baseInstrument, element);
            this.gpsDefinitions = this.parseGpsDefinitions(baseInstrument, element);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this configuration defines a radar altimeter. */
    get hasRadarAltimeter() {
        return this.radarAltimeterDefinitions.length > 1;
    }
    /**
     * Parses ADC definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of ADC definitions defined by the configuration document element.
     */
    parseAdcDefinitions(baseInstrument, element) {
        const adcElements = element.querySelectorAll(':scope>Adc');
        const defs = [];
        for (const adcElement of adcElements) {
            const index = Number(adcElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.adcCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC index (must be an integer between 1 and the number of supported ADCs)');
                continue;
            }
            const altimeterIndex = Number(adcElement.getAttribute('altimeter'));
            if (!Number.isInteger(altimeterIndex) || altimeterIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized altimeter index (must be a positive integer)');
                continue;
            }
            const airspeedIndicatorIndex = Number(adcElement.getAttribute('airspeed-indicator'));
            if (!Number.isInteger(airspeedIndicatorIndex) || airspeedIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized airspeed indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = adcElement.querySelector(':scope>Electric');
            defs[index] = {
                altimeterIndex,
                airspeedIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    altimeterIndex: i,
                    airspeedIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses AHRS definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of AHRS definitions defined by the configuration document element.
     */
    parseAhrsDefinitions(baseInstrument, element) {
        const ahrsElements = element.querySelectorAll(':scope>Ahrs');
        const defs = [];
        for (const ahrsElement of ahrsElements) {
            const index = Number(ahrsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.ahrsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const attitudeIndicatorIndex = Number(ahrsElement.getAttribute('attitude-indicator'));
            if (!Number.isInteger(attitudeIndicatorIndex) || attitudeIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized attitude indicator index (must be a positive integer)');
                continue;
            }
            const directionIndicatorIndex = Number(ahrsElement.getAttribute('direction-indicator'));
            if (!Number.isInteger(directionIndicatorIndex) || directionIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized direction indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = ahrsElement.querySelector(':scope>Electric');
            defs[index] = {
                attitudeIndicatorIndex,
                directionIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    attitudeIndicatorIndex: i,
                    directionIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses a radar altimeter definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of RA definitions defined by the configuration document element.
     */
    parseRadarAltimeterDefinitions(baseInstrument, element) {
        const radarAltimeterElements = element.querySelectorAll(':scope>RadarAltimeter');
        const defs = [];
        for (const radarAltimeterElement of radarAltimeterElements) {
            const index = Number(radarAltimeterElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.radarAltimeterCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const electricLogicElement = radarAltimeterElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.radarAltimeterCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
    /**
     * Parses a GPS receiver definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of GPS definitions defined by the configuration document element.
     */
    parseGpsDefinitions(baseInstrument, element) {
        const gpsElements = element.querySelectorAll(':scope>Gps');
        const defs = [];
        for (const gpsElement of gpsElements) {
            const index = Number(gpsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.gpsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS index (must be an integer between 1 and the number of supported GPS)');
                continue;
            }
            const electricLogicElement = gpsElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.gpsCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
}

/**
 * A configuration object which defines options for G3000/5000 avionics systems.
 */
class AvionicsConfig {
    /**
     * Creates an AvionicsConfig from an XML configuration document.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param xmlConfig An XML configuration document.
     */
    constructor(baseInstrument, xmlConfig) {
        const root = xmlConfig.getElementsByTagName('PlaneHTMLConfig')[0];
        this.sensors = this.parseSensorsConfig(baseInstrument, root.querySelector(':scope>Sensors'));
    }
    /**
     * Parses a sensors configuration object from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns The sensors configuration defined by the configuration document element.
     */
    parseSensorsConfig(baseInstrument, element) {
        if (element !== null) {
            try {
                return new SensorsConfig(baseInstrument, element);
            }
            catch (e) {
                console.warn(e);
            }
        }
        return new SensorsConfig(baseInstrument, undefined);
    }
}

/** Takeoff thrust modes. */
var OptimumRequest;
(function (OptimumRequest) {
    OptimumRequest["OPTIMUM"] = "OPTIMUM";
})(OptimumRequest || (OptimumRequest = {}));
/** Takeoff thrust modes. To be used in the FMC */
var TakeoffThrustMode;
(function (TakeoffThrustMode) {
    TakeoffThrustMode["TO"] = "TO";
    TakeoffThrustMode["TO1"] = "TO 1";
    TakeoffThrustMode["TO2"] = "TO 2";
    TakeoffThrustMode["DTO"] = "D-TO";
    TakeoffThrustMode["DTO1"] = "D-TO 1";
    TakeoffThrustMode["DTO2"] = "D-TO 2";
})(TakeoffThrustMode || (TakeoffThrustMode = {}));
/** Possible takeoff thrust ratings for selection in the EFB. */
var EFBTakeoffThrustMode;
(function (EFBTakeoffThrustMode) {
    EFBTakeoffThrustMode["OPTIMUM"] = "OPTIMUM";
    EFBTakeoffThrustMode["TO"] = "TO";
    EFBTakeoffThrustMode["TO1"] = "TO 1 -10";
    EFBTakeoffThrustMode["TO2"] = "TO 2 -20";
    EFBTakeoffThrustMode["WINDSHEAR"] = "WINDSHEAR";
})(EFBTakeoffThrustMode || (EFBTakeoffThrustMode = {}));
/** Climb thrust modes. */
var ClimbThrustMode;
(function (ClimbThrustMode) {
    ClimbThrustMode["CLB"] = "CLB";
    ClimbThrustMode["CLB1"] = "CLB 1";
    ClimbThrustMode["CLB2"] = "CLB 2";
})(ClimbThrustMode || (ClimbThrustMode = {}));
/** Airborne thrust modes. */
var AirborneThrustMode;
(function (AirborneThrustMode) {
    /** Go-around thrust limit. */
    AirborneThrustMode["GA"] = "GA";
    /** Maximum continuous thrust limit. */
    AirborneThrustMode["CON"] = "CON";
    /** Cruise thrust limit. */
    AirborneThrustMode["CRZ"] = "CRZ";
})(AirborneThrustMode || (AirborneThrustMode = {}));
var GlideslopeStatus;
(function (GlideslopeStatus) {
    GlideslopeStatus[GlideslopeStatus["ON"] = 0] = "ON";
    GlideslopeStatus[GlideslopeStatus["OFF"] = 1] = "OFF";
})(GlideslopeStatus || (GlideslopeStatus = {}));
/** Speed modes. */
var SpeedMode;
(function (SpeedMode) {
    /** Economy speed. */
    SpeedMode["ECON"] = "ECON SPD";
    /** Select speed. Manually entered speed on the CDU or the VNAV speed target is the maneuvering speed for flaps zero. */
    SpeedMode["SEL"] = "SEL SPD";
    /** Long-range cruise speed. */
    SpeedMode["LRC"] = "LRC SPD";
    /** Engine-out long-range cruise speed. */
    SpeedMode["EOLRC"] = "EO LRC";
    /** Engine-out speed. */
    SpeedMode["EO"] = "EO SPD";
    /** Engine-out operations at airline specified engine out company speed. */
    SpeedMode["CO"] = "CO SPD";
    /** Speed is limited by VMO, MMO, flap limit, or buffet limit. */
    SpeedMode["LIM"] = "LIM SPD";
    /** Speed intervention entered on the MCP IAS/MACH indicator. */
    SpeedMode["MCP"] = "MCP SPD";
    /** Required time of arrival speed. */
    SpeedMode["RTA"] = "RTA";
})(SpeedMode || (SpeedMode = {}));
/** Runway conditions, the short list is for the FMC */
var RunwayCondition;
(function (RunwayCondition) {
    /** Dry */
    RunwayCondition["DRY"] = "DRY";
    /** Wet */
    RunwayCondition["WET"] = "WET";
    /** Wet, skid resistant */
    RunwayCondition["WET_SKID_RES"] = "WET SK-R";
})(RunwayCondition || (RunwayCondition = {}));
/** Runway conditions, longer list for the EFB takeoff performance calculation */
var EfbRunwayCondition;
(function (EfbRunwayCondition) {
    /** Dry */
    EfbRunwayCondition["DRY"] = "DRY";
    /** Wet */
    EfbRunwayCondition["WET"] = "WET";
    /** Standing water */
    EfbRunwayCondition["STNDNG_WTR"] = "STNDNG WTR";
    /** Slush */
    EfbRunwayCondition["SLUSH"] = "SLUSH WTR";
    /** Compact snow */
    EfbRunwayCondition["CMPCT_SNOW"] = "CMPCT SNOW";
    /** Dry snow */
    EfbRunwayCondition["DRY_SNOW"] = "DRY SNOW";
    /** Ice */
    EfbRunwayCondition["ICE"] = "Ice";
    /** Breaking action good */
    EfbRunwayCondition["GOOD"] = "GOOD";
    /** Breaking action Medium */
    EfbRunwayCondition["MEDIUM"] = "MEDIUM";
    /** Breaking action Poor */
    EfbRunwayCondition["POOR"] = "POOR";
})(EfbRunwayCondition || (EfbRunwayCondition = {}));
var EFBAntiIceSetting;
(function (EFBAntiIceSetting) {
    /** OFF */
    EFBAntiIceSetting["OFF"] = "OFF";
    /** ENGINE */
    EFBAntiIceSetting["ENGINE"] = "ENGINE";
    /** ENG AUTO */
    EFBAntiIceSetting["ENGINE_AUTO"] = "ENG AUTO";
})(EFBAntiIceSetting || (EFBAntiIceSetting = {}));

/**
 * Types of vertical flight path vectors.
 */
var VerticalFlightPathVectorType;
(function (VerticalFlightPathVectorType) {
    VerticalFlightPathVectorType["Climb"] = "Climb";
    VerticalFlightPathVectorType["ClimbLevel"] = "ClimbLevel";
    VerticalFlightPathVectorType["ClimbAcceleration"] = "ClimbAcceleration";
    VerticalFlightPathVectorType["ClimbLevelAcceleration"] = "ClimbLevelAcceleration";
    VerticalFlightPathVectorType["Cruise"] = "Cruise";
    VerticalFlightPathVectorType["CruiseAcceleration"] = "CruiseAcceleration";
    VerticalFlightPathVectorType["CruiseDeceleration"] = "CruiseDeceleration";
    VerticalFlightPathVectorType["LevelDeceleration"] = "LevelDeceleration";
    VerticalFlightPathVectorType["IdleDescent"] = "IdleDescent";
    VerticalFlightPathVectorType["IdleDescentDeceleration"] = "IdleDescentDeceleration";
    VerticalFlightPathVectorType["GeometricDescent"] = "GeometricDescent";
    VerticalFlightPathVectorType["GeometricDescentDeceleration"] = "GeometricDescentDeceleration";
})(VerticalFlightPathVectorType || (VerticalFlightPathVectorType = {}));
/**
 * Sources from which a flight path vector's target speed is derived.
 */
var VerticalFlightPathVectorSpeedSource;
(function (VerticalFlightPathVectorSpeedSource) {
    VerticalFlightPathVectorSpeedSource["None"] = "None";
    VerticalFlightPathVectorSpeedSource["Schedule"] = "Schedule";
    VerticalFlightPathVectorSpeedSource["FlightPlan"] = "FlightPlan";
    VerticalFlightPathVectorSpeedSource["Transition"] = "Transition";
    VerticalFlightPathVectorSpeedSource["Restriction"] = "Restriction";
})(VerticalFlightPathVectorSpeedSource || (VerticalFlightPathVectorSpeedSource = {}));
/**
 * The current VNAV altitude capture type.
 */
var BoeingVNavAltCaptureType;
(function (BoeingVNavAltCaptureType) {
    /** Altitude capture is not armed. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["VNAV"] = 2] = "VNAV";
    /** Altitude will capture the cruise altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Cruise"] = 3] = "Cruise";
})(BoeingVNavAltCaptureType || (BoeingVNavAltCaptureType = {}));
/**
 * Boeing VNAV tracking phases.
 */
var BoeingVNavTrackingPhase;
(function (BoeingVNavTrackingPhase) {
    BoeingVNavTrackingPhase["None"] = "None";
    BoeingVNavTrackingPhase["Climb"] = "Climb";
    BoeingVNavTrackingPhase["Cruise"] = "Cruise";
    BoeingVNavTrackingPhase["Descent"] = "Descent";
    BoeingVNavTrackingPhase["MissedApproach"] = "MissedApproach";
})(BoeingVNavTrackingPhase || (BoeingVNavTrackingPhase = {}));
/** This enum begins at 100 so that it can be used in combination with APVerticalModes in BoeingFmaData for display on the FMA. */
var BoeingVNavModes;
(function (BoeingVNavModes) {
    BoeingVNavModes[BoeingVNavModes["NONE"] = 100] = "NONE";
    BoeingVNavModes[BoeingVNavModes["ARMED"] = 101] = "ARMED";
    BoeingVNavModes[BoeingVNavModes["SPD_CLIMB"] = 102] = "SPD_CLIMB";
    BoeingVNavModes[BoeingVNavModes["SPD_DESCENT"] = 103] = "SPD_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_DESCENT"] = 104] = "PATH_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_IDLE"] = 105] = "PATH_IDLE";
    BoeingVNavModes[BoeingVNavModes["PATH_LEVEL"] = 106] = "PATH_LEVEL";
    BoeingVNavModes[BoeingVNavModes["ALT"] = 107] = "ALT";
    BoeingVNavModes[BoeingVNavModes["THR_DESCENT"] = 108] = "THR_DESCENT";
})(BoeingVNavModes || (BoeingVNavModes = {}));
/** Path Deviation Mode for the Boeing Vnav Manager. */
var PathDeviationMode;
(function (PathDeviationMode) {
    PathDeviationMode[PathDeviationMode["NONE"] = 0] = "NONE";
    PathDeviationMode[PathDeviationMode["BELOW"] = 1] = "BELOW";
    PathDeviationMode[PathDeviationMode["ABOVE"] = 2] = "ABOVE";
})(PathDeviationMode || (PathDeviationMode = {}));
var BoeingVnavDescentPendingType;
(function (BoeingVnavDescentPendingType) {
    BoeingVnavDescentPendingType["DesDir"] = "des-dir";
    BoeingVnavDescentPendingType["DesNow"] = "des-now";
})(BoeingVnavDescentPendingType || (BoeingVnavDescentPendingType = {}));

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A manager and calculator for vertical flight plans for Boeing avionics systems.
 */
class BoeingPathCalculator extends SmoothingPathCalculator {
    /**
     * Creates an instance of BoeingPathCalculator.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param perfProvider A provider of airplane performance data.
     * @param engineDataProvider A provider of airplane engine data.
     * @param perfPlanRepository The performance plan repository.
     * @param windPlanner The wind planner.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, perfProvider, engineDataProvider, perfPlanRepository, windPlanner, options) {
        var _a, _b, _c;
        super(bus, flightPlanner, primaryPlanIndex, options);
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.perfPlanRepository = perfPlanRepository;
        this.windPlanner = windPlanner;
        this.speedConstraintLists = [];
        this.verticalFlightPathEntries = [];
        this.perfPlanSubscriptions = [];
        this.accelerationResult = Vec2Math.create();
        this.enablePathCalc = (_a = options === null || options === void 0 ? void 0 : options.enablePathCalc) !== null && _a !== void 0 ? _a : false;
        this.engineCount = Math.max((_b = options === null || options === void 0 ? void 0 : options.engineCount) !== null && _b !== void 0 ? _b : 2, 1);
        this.performanceDescentIdleN1Offset = Math.max((_c = options === null || options === void 0 ? void 0 : options.performanceDescentIdleN1Offset) !== null && _c !== void 0 ? _c : 10, 0);
        if (this.enablePathCalc) {
            const sub = bus.getSubscriber();
            // TODO: Maybe support ADC system?
            this.indicatedAltitude = ConsumerValue.create(sub.on('indicated_alt'), 0);
            this.lnavIsAwaitingCalc = ConsumerSubject.create(sub.on('lnav_is_awaiting_calc'), false);
            this.lnavTrackedLegIndex = ConsumerSubject.create(sub.on('lnav_tracked_leg_index'), 0);
            this.lnavLegDistanceRemaining = ConsumerValue.create(sub.on('lnav_leg_distance_remaining'), 0);
            this.fob = ConsumerValue.create(sub.on('fuel_usable_total_weight'), 0);
            // TODO: This is a massive hack that relies on LNAV's awaiting calculate logic as well as the fact that the only
            // way the active plan can change in the Boeings is through a plan copy. This needs to be replaced with a more
            // robust solution at some point and **UNDER NO CIRCUMSTANCES SHOULD IT BE REPLICATED ELSEWHERE**.
            const primaryPlanActiveLegIndex = Subject.create(0);
            sub.on('fplActiveLegChange').handle(event => {
                if (event.type === ActiveLegType.Lateral && event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(event.index);
                }
            });
            sub.on('fplCopied').handle(event => {
                if (event.targetPlanIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            sub.on('fplLoaded').handle(event => {
                if (event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            this.canUpdatePrimaryPlan = MappedSubject.create(([isAwaitingCalc, trackedLegIndex, planActiveLegIndex]) => !isAwaitingCalc && trackedLegIndex === planActiveLegIndex, this.lnavIsAwaitingCalc, this.lnavTrackedLegIndex, primaryPlanActiveLegIndex);
            // We need to update pending vertical plans on an update loop in order to guarantee that we don't perform the
            // update using an intermediate state from LNAV (specifically when the tracked leg index has been updated before
            // the remaining leg distance).
            sub.on('realTime').handle(this.update.bind(this));
        }
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /**
     * Gets the speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The speed constraint list for the specified flight plan.
     */
    getSpeedConstraintList(planIndex) {
        var _a;
        return (_a = this.speedConstraintLists[planIndex]) !== null && _a !== void 0 ? _a : this.createSpeedConstraintList(planIndex);
    }
    /**
     * Gets the calculated vertical flight path for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The calculated vertical flight path for the specified flight plan.
     */
    getVerticalFlightPath(planIndex) {
        return this.getVerticalFlightPathEntry(planIndex).path;
    }
    /**
     * Gets the vertical flight path entry for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The vertical flight path entry for the specified flight plan.
     */
    getVerticalFlightPathEntry(planIndex) {
        var _a;
        return (_a = this.verticalFlightPathEntries[planIndex]) !== null && _a !== void 0 ? _a : this.createVerticalFlightPathEntry(planIndex);
    }
    /**
     * Gets the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The speed constraint in effect for the specified flight plan leg and vertical flight phase, or
     * `undefined` if there is no speed constraint in effect.
     */
    getCurrentSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        return speedConstraints[this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach)];
    }
    /**
     * Gets the next speed constraint to take effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The next speed constraint to take effect for the specified flight plan leg and vertical flight phase,
     * or `undefined` if there is no speed constraint in effect.
     */
    getNextSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        const currentIndex = this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach);
        if (currentIndex < 0) {
            if (flightPhase === VerticalFlightPhase.Climb) {
                // If there is no current constraint in effect during climb, there can be no next climb constraint because
                // either we have sequenced all climb constraints or there is at least one non-climb constraint to sequence
                // before the next climb constraint.
                return undefined;
            }
            else {
                // If there is no current constraint in effect during descent, it is still possible that the next upcoming
                // constraint to be sequenced is the next descent constraint. This constraint, if it exists, is located at the
                // index where the current constraint would be located if it existed, so we need to check if the constraint at
                // that index is a descent constraint and has yet to be sequenced.
                const constraint = speedConstraints[-currentIndex - 1];
                if (constraint !== undefined && flightPhase === constraint.flightPhase && constraint.globalLegIndex >= globalLegIndex) {
                    return constraint;
                }
                else {
                    return undefined;
                }
            }
        }
        const isMapr = speedConstraints[currentIndex].isMissedApproach;
        const constraint = speedConstraints[currentIndex + 1];
        if (constraint !== undefined && flightPhase === constraint.flightPhase && isMapr === constraint.isMissedApproach) {
            return constraint;
        }
        return undefined;
    }
    /**
     * Gets the index of the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param speedConstraintList The speed constraint list for the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The index of the speed constraint in effect for the specified flight plan leg and vertical flight phase.
     * If there is no speed constraint in effect, `-(i + 1)` is returned instead, where `i` is the index at which the
     * constraint would be located if it existed.
     */
    getCurrentSpeedConstraintIndex(planIndex, speedConstraintList, globalLegIndex, flightPhase, isMissedApproach) {
        var _a, _b;
        if (flightPhase === VerticalFlightPhase.Climb) {
            const inMissedApproach = isMissedApproach !== null && isMissedApproach !== void 0 ? isMissedApproach : (this.flightPlanner.hasFlightPlan(planIndex)
                && BitFlags.isAll((_b = (_a = this.flightPlanner.getFlightPlan(planIndex).tryGetLeg(globalLegIndex)) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, LegDefinitionFlags.MissedApproach));
            // During climb, the next upcoming climb speed constraint to be sequenced is in effect.
            for (let i = 0; i < speedConstraintList.length; i++) {
                const constraint = speedConstraintList[i];
                // Speed constraints in the missed approach are not active until we are in the missed approach.
                if (constraint.isMissedApproach && !inMissedApproach) {
                    return -(i + 1);
                }
                if (constraint.globalLegIndex >= globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 1);
                }
            }
            return -(speedConstraintList.length + 1);
        }
        else {
            // During descent, the last sequenced descent speed constraint is in effect.
            for (let i = speedConstraintList.length - 1; i >= 0; i--) {
                const constraint = speedConstraintList[i];
                if (constraint.globalLegIndex < globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 2);
                }
            }
            return -1;
        }
    }
    /**
     * Creates a new, empty speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created speed constraint list.
     */
    createSpeedConstraintList(planIndex) {
        return this.speedConstraintLists[planIndex] = [];
    }
    /**
     * Creates a new vertical path entry for a flight plan. The new entry will be initialized with an empty vertical
     * path.
     * @param planIndex The index of the flight plan.
     * @returns The created vertical path entry.
     */
    createVerticalFlightPathEntry(planIndex) {
        const entry = {
            path: BoeingPathCalculator.createVerticalPath(planIndex),
            perfDescentWorkingPath: BoeingPathCalculator.createVerticalPath(planIndex),
            geoDescentCoarsePath: BoeingPathCalculator.createGeometricDescentCoarsePath(),
            needsRebuild: false
        };
        this.verticalFlightPathEntries[planIndex] = entry;
        return entry;
    }
    /** @inheritdoc */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        if (!this.enablePathCalc) {
            return;
        }
        super.onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent);
        const verticalPath = this.getVerticalFlightPath(planIndex);
        verticalPath.isPending = true;
    }
    /** @inheritdoc */
    onPlanCalculated(event) {
        if (!this.enablePathCalc) {
            return;
        }
        if (event.planIndex !== this.primaryPlanIndex || this.canUpdatePrimaryPlan.get()) {
            this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
        }
    }
    /**
     * Updates this calculator.
     */
    update() {
        if (this.canUpdatePrimaryPlan.get()
            && this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)
            && this.getVerticalFlightPath(this.primaryPlanIndex).isPending) {
            this.buildVerticalFlightPlanAndComputeAndNotify(this.primaryPlanIndex);
        }
    }
    /** @inheritdoc */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        super.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.buildSpeedConstraints(lateralPlan, this.getSpeedConstraintList(verticalPlan.planIndex));
        this.buildVerticalFlightPath(lateralPlan, this.getVerticalFlightPathEntry(verticalPlan.planIndex));
    }
    /**
     * Builds a speed constraint list from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param speedConstraints The speed constraint list to build.
     */
    buildSpeedConstraints(lateralPlan, speedConstraints) {
        var _a, _b;
        let speedConstraintIndex = 0;
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(lateralPlan.planIndex);
        for (let segmentIndex = 0; segmentIndex < lateralPlan.segmentCount; segmentIndex++) {
            const segment = lateralPlan.tryGetSegment(segmentIndex);
            if (segment) {
                for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                    const leg = segment.legs[segmentLegIndex];
                    const isDirectToLeg = BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo)
                        && lateralPlan.directToData.segmentIndex === segmentIndex
                        && lateralPlan.directToData.segmentLegIndex === segmentLegIndex - this.directToLegOffset;
                    const approachSpeed = (_a = perfPlan.approachFlapSpeed.get()) === null || _a === void 0 ? void 0 : _a[1];
                    const windCorrection = perfPlan.approachWindCorrection.get();
                    const hasAutoApproachSpeed = leg.verticalData.speedDesc === SpeedRestrictionType.Unused
                        && BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF)
                        && approachSpeed !== undefined;
                    // If the leg is a direct-to leg with an associated direct-to target leg, skip it since its constraint is
                    // duplicated from that of the target leg.
                    if ((leg.verticalData.speedDesc !== SpeedRestrictionType.Unused || hasAutoApproachSpeed) && !isDirectToLeg) {
                        const isMissedApproach = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
                        const isCursorDepartureOrMissedApproach = segment.segmentType === FlightPlanSegmentType.Departure || isMissedApproach;
                        // If the constraint leg is a direct-to target, shift the leg index to that of the direct-to leg.
                        const isDirectToTarget = lateralPlan.directToData.segmentIndex === segmentIndex
                            && lateralPlan.directToData.segmentLegIndex === segmentLegIndex;
                        const constraint = (_b = speedConstraints[speedConstraintIndex]) !== null && _b !== void 0 ? _b : (speedConstraints[speedConstraintIndex] = BoeingPathCalculator.createSpeedConstraintListItem());
                        constraint.globalLegIndex = segment.offset + segmentLegIndex + (isDirectToTarget ? this.directToLegOffset : 0);
                        constraint.flightPhase = isCursorDepartureOrMissedApproach ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent;
                        constraint.speedConstraint.speedDesc = hasAutoApproachSpeed ? SpeedRestrictionType.At : leg.verticalData.speedDesc;
                        constraint.speedConstraint.speed = hasAutoApproachSpeed ? (approachSpeed + windCorrection) : leg.verticalData.speed;
                        constraint.speedConstraint.speedUnit = hasAutoApproachSpeed ? SpeedUnit.IAS : leg.verticalData.speedUnit;
                        constraint.isMissedApproach = hasAutoApproachSpeed ? false : isMissedApproach;
                        let useMin = false;
                        let useMax = false;
                        switch (constraint.speedConstraint.speedDesc) {
                            case SpeedRestrictionType.At:
                            case SpeedRestrictionType.Between:
                                useMin = true;
                                useMax = true;
                                break;
                            case SpeedRestrictionType.AtOrAbove:
                                useMin = true;
                                break;
                            case SpeedRestrictionType.AtOrBelow:
                                useMax = true;
                                break;
                        }
                        constraint.minCas = -Infinity;
                        constraint.maxCas = Infinity;
                        constraint.minMach = -Infinity;
                        constraint.maxMach = Infinity;
                        if (useMin) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.minMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.minCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        if (useMax) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.maxMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.maxCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        speedConstraintIndex++;
                    }
                }
            }
        }
        speedConstraints.length = speedConstraintIndex;
    }
    /**
     * Builds an empty vertical flight path from a lateral flight plan. After the path is built, it will contain one
     * leg (containing zero vectors) for each leg in the lateral flight plan, and all TOC/TOD data will be undefined.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to build.
     */
    buildVerticalFlightPath(lateralPlan, verticalPathEntry) {
        verticalPathEntry.needsRebuild = false;
        const verticalPath = verticalPathEntry.path;
        verticalPath.legs.length = lateralPlan.length;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            if (leg) {
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
            else {
                verticalPath.legs[i] = BoeingPathCalculator.createVerticalPathLeg();
            }
        }
        verticalPath.isPending = true;
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Initializes performance plan subscriptions for an indexed flight plan. Once these subscriptions are initialized,
     * the vertical path for the flight plan will be flagged to be rebuilt during the next flight plan calculation cycle
     * whenever certain performance plan values change. If subscriptions are already initialized for the specified flight
     * plan, then this method does nothing.
     * @param planIndex The index of the flight plan for which to initialize performance plan subscriptions.
     */
    initPerfPlanSubscriptions(planIndex) {
        if (this.perfPlanSubscriptions[planIndex]) {
            return;
        }
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(planIndex);
        const entry = this.getVerticalFlightPathEntry(planIndex);
        const handler = () => { entry.needsRebuild = true; };
        const speedHandler = (mode, activeMode) => {
            if (mode.get() === activeMode) {
                entry.needsRebuild = true;
            }
        };
        const approachSpeedHandler = () => {
            const verticalPlan = this.verticalFlightPlans[planIndex];
            verticalPlan && (verticalPlan.planChanged = true);
        };
        const climbSelSpeedHandler = speedHandler.bind(this, perfPlan.speedClimbMode, SpeedMode.SEL);
        const cruiseSelSpeedHandler = speedHandler.bind(this, perfPlan.speedCruiseMode, SpeedMode.SEL);
        const descentSelSpeedHandler = speedHandler.bind(this, perfPlan.speedDescentMode, SpeedMode.SEL);
        this.perfPlanSubscriptions[planIndex] = [
            perfPlan.speedClimbMode.sub(handler),
            perfPlan.speedClimbSelectCas.sub(climbSelSpeedHandler),
            perfPlan.speedClimbSelectMach.sub(climbSelSpeedHandler),
            perfPlan.speedCruiseMode.sub(handler),
            perfPlan.speedCruiseSelectCas.sub(cruiseSelSpeedHandler),
            perfPlan.speedCruiseSelectMach.sub(cruiseSelSpeedHandler),
            perfPlan.speedDescentMode.sub(handler),
            perfPlan.speedDescentSelectCas.sub(descentSelSpeedHandler),
            perfPlan.speedDescentSelectMach.sub(descentSelSpeedHandler),
            perfPlan.cruiseAltitude.sub(handler),
            perfPlan.climbSpeedLimitAltitude.sub(handler),
            perfPlan.climbSpeedLimitCas.sub(handler),
            perfPlan.climbSpeedRestrAltitude.sub(handler),
            perfPlan.climbSpeedRestrCas.sub(handler),
            perfPlan.descentSpeedLimitAltitude.sub(handler),
            perfPlan.descentSpeedLimitCas.sub(handler),
            perfPlan.descentSpeedRestrAltitude.sub(handler),
            perfPlan.descentSpeedRestrCas.sub(handler),
            perfPlan.approachFlapSpeed.sub(approachSpeedHandler),
            perfPlan.approachWindCorrection.sub(approachSpeedHandler)
        ];
    }
    /** @inheritdoc */
    computePath(lateralPlan, verticalPlan) {
        var _a, _b;
        const verticalPathEntry = this.getVerticalFlightPathEntry(verticalPlan.planIndex);
        this.initPerfPlanSubscriptions(verticalPlan.planIndex);
        if (verticalPathEntry.needsRebuild) {
            this.buildVerticalFlightPath(lateralPlan, verticalPathEntry);
        }
        const verticalPath = verticalPathEntry.path;
        verticalPath.isPending = false;
        if (verticalPlan.constraints.length < 1) {
            return;
        }
        const activeLegIndex = this.lnavTrackedLegIndex.get();
        const activeDistanceToLegEnd = Math.max(0, UnitType.NMILE.convertTo(this.lnavLegDistanceRemaining.get(), UnitType.METER));
        // TODO: Support engine-out ops.
        const engineCount = this.engineCount;
        // Compute FPAs for geometric descent segment.
        this.computeDescentPath(lateralPlan, verticalPlan);
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(verticalPlan.planIndex);
        const climbSpeedMode = perfPlan.speedClimbMode.get();
        const cruiseSpeedMode = perfPlan.speedCruiseMode.get();
        const descentSpeedMode = perfPlan.speedDescentMode.get();
        let cruiseAltitude = perfPlan.cruiseAltitude.get();
        const zfw = perfPlan.manualZfw.get();
        let climbCas, climbMach;
        let cruiseCas, cruiseMach;
        let descentCas, descentMach;
        if (climbSpeedMode === SpeedMode.SEL) {
            climbCas = perfPlan.speedClimbSelectCas.get();
            climbMach = perfPlan.speedClimbSelectMach.get();
        }
        else {
            climbCas = perfPlan.speedClimbEconCas.get();
            climbMach = perfPlan.speedClimbEconMach.get();
        }
        if (cruiseSpeedMode === SpeedMode.SEL) {
            cruiseCas = perfPlan.speedCruiseSelectCas.get();
            cruiseMach = perfPlan.speedCruiseSelectMach.get();
        }
        else {
            cruiseCas = perfPlan.speedCruiseEconCas.get();
            cruiseMach = perfPlan.speedCruiseEconMach.get();
        }
        if (descentSpeedMode === SpeedMode.SEL) {
            descentCas = perfPlan.speedDescentSelectCas.get();
            descentMach = perfPlan.speedDescentSelectMach.get();
        }
        else {
            descentCas = perfPlan.speedDescentEconCas.get();
            descentMach = perfPlan.speedDescentEconMach.get();
        }
        if (cruiseAltitude === null
            || zfw === null
            || (climbCas === null && climbMach === null)
            || (cruiseCas === null && cruiseMach === null)
            || (descentCas === null && descentMach === null)) {
            this.clearVerticalPath(verticalPathEntry);
            return;
        }
        const maprStartLegIndex = (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : -1;
        const firstDescentConstraintLegIndex = (_b = verticalPlan.firstDescentConstraintLegIndex) !== null && _b !== void 0 ? _b : -1;
        const lastSimulatedLegIndex = maprStartLegIndex < 0 ? lateralPlan.length : maprStartLegIndex;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const isPastCalculatedTod = verticalPath.todLegIndex !== undefined && verticalPath.todDistanceToLegEnd !== undefined
            && (activeLegIndex > verticalPath.todLegIndex
                || (activeLegIndex === verticalPath.todLegIndex && activeDistanceToLegEnd <= verticalPath.todDistanceToLegEnd));
        climbCas !== null && climbCas !== void 0 ? climbCas : (climbCas = Infinity);
        climbMach !== null && climbMach !== void 0 ? climbMach : (climbMach = Infinity);
        cruiseCas !== null && cruiseCas !== void 0 ? cruiseCas : (cruiseCas = Infinity);
        cruiseMach !== null && cruiseMach !== void 0 ? cruiseMach : (cruiseMach = Infinity);
        descentCas !== null && descentCas !== void 0 ? descentCas : (descentCas = Infinity);
        descentMach !== null && descentMach !== void 0 ? descentMach : (descentMach = Infinity);
        cruiseAltitude = UnitType.FOOT.convertTo(cruiseAltitude, UnitType.METER);
        climbCas = UnitType.KNOT.convertTo(climbCas, UnitType.MPS);
        cruiseCas = UnitType.KNOT.convertTo(cruiseCas, UnitType.MPS);
        descentCas = UnitType.KNOT.convertTo(descentCas, UnitType.MPS);
        const currentAltitude = UnitType.FOOT.convertTo(this.indicatedAltitude.get(), UnitType.METER);
        const currentWeight = zfw + this.fob.get();
        let climbTransitionAltitude = perfPlan.climbSpeedLimitAltitude.get();
        if (climbTransitionAltitude !== null) {
            climbTransitionAltitude = UnitType.FOOT.convertTo(climbTransitionAltitude, UnitType.METER);
        }
        let climbTransitionCas = perfPlan.climbSpeedLimitCas.get();
        if (climbTransitionCas !== null) {
            climbTransitionCas = UnitType.KNOT.convertTo(climbTransitionCas, UnitType.MPS);
        }
        let climbRestrictionAltitude = perfPlan.climbSpeedRestrAltitude.get();
        if (climbRestrictionAltitude !== null) {
            climbRestrictionAltitude = UnitType.FOOT.convertTo(climbRestrictionAltitude, UnitType.METER);
        }
        let climbRestrictionCas = perfPlan.climbSpeedRestrCas.get();
        if (climbRestrictionCas !== null) {
            climbRestrictionCas = UnitType.KNOT.convertTo(climbRestrictionCas, UnitType.MPS);
        }
        let descentTransitionAltitude = perfPlan.descentSpeedLimitAltitude.get();
        if (descentTransitionAltitude !== null) {
            descentTransitionAltitude = UnitType.FOOT.convertTo(descentTransitionAltitude, UnitType.METER);
        }
        let descentTransitionCas = perfPlan.descentSpeedLimitCas.get();
        if (descentTransitionCas !== null) {
            descentTransitionCas = UnitType.KNOT.convertTo(descentTransitionCas, UnitType.MPS);
        }
        let descentRestrictionAltitude = perfPlan.descentSpeedRestrAltitude.get();
        if (descentRestrictionAltitude !== null) {
            descentRestrictionAltitude = UnitType.FOOT.convertTo(descentRestrictionAltitude, UnitType.METER);
        }
        let descentRestrictionCas = perfPlan.descentSpeedRestrCas.get();
        if (descentRestrictionCas !== null) {
            descentRestrictionCas = UnitType.KNOT.convertTo(descentRestrictionCas, UnitType.MPS);
        }
        const lateralLegs = [...lateralPlan.legs()];
        if (!isPastCalculatedTod) {
            const clearEndIndex = Math.min(verticalPath.legs.length, activeLegIndex);
            for (let i = 0; i < clearEndIndex; i++) {
                verticalPath.legs[i].vectors.length = 0;
                verticalPath.legs[i].simDistance = 0;
            }
            verticalPath.tocLegIndex = undefined;
            verticalPath.tocDistanceToLegEnd = undefined;
            verticalPath.tocWeight = undefined;
            // Only simulate the climb if we have not yet sequenced the first descent constraint (if one exists).
            if (firstDescentConstraintLegIndex < 0 || activeLegIndex <= firstDescentConstraintLegIndex) {
                this.simulateClimb(lateralLegs, verticalPlan, verticalPath, perfPlan.climbThrustMode.get(), climbCas, climbMach, climbTransitionAltitude, climbTransitionCas, climbRestrictionAltitude, climbRestrictionCas, cruiseAltitude, activeLegIndex, activeDistanceToLegEnd, currentAltitude, currentWeight, lastSimulatedLegIndex, false, engineCount);
            }
            this.simulateCruise(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, cruiseCas, cruiseMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, lastSimulatedLegIndex, engineCount);
            // If there exists at least one descent constraint and we have not yet sequenced it, then we need to simulate
            // the descent, beginning with the performance descent.
            if (firstDescentConstraintIndex >= 0 && activeLegIndex <= firstDescentConstraintLegIndex) {
                const firstDescentConstraintAltitude = firstDescentConstraint.legs[0].altitude;
                if (isFinite(firstDescentConstraintAltitude)) {
                    if (cruiseAltitude > firstDescentConstraintAltitude) {
                        // Cruise altitude is above the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist of a level deceleration segment + an idle descent segment that intercepts
                        // the geometric descent path at the first descent constraint.
                        this.computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount);
                    }
                    else {
                        // Cruise altitude is at or below the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist only of a level deceleration segment that intercepts the geometric
                        // descent path at some point past the first descent constraint. Alternatively, if the geometric descent
                        // path never descends below the cruise altitude, there will be no descent.
                        this.computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount);
                    }
                }
            }
        }
        else {
            // We are past the calculated TOD. In this case, we will not recalculate the TOD. However, if we are still in
            // the performance descent segment, we need to adjust the vertical path vectors to account for any changes in
            // lateral leg distances.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && (activeLegIndex < verticalPath.geoDescentSimInterceptLegIndex
                    || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex
                        && activeDistanceToLegEnd > verticalPath.geoDescentSimInterceptDistanceToLegEnd))) {
                this.adjustPerformanceDescent(lateralLegs, verticalPath);
            }
        }
        if (maprStartLegIndex < 0 || activeLegIndex < maprStartLegIndex) {
            // We are not in the missed approach.
            // If a geometric descent intercept was calculated, simulate the geometric descent.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptVectorIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && verticalPath.geoDescentInterceptWeight !== undefined) {
                this.simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
            }
        }
    }
    /**
     * Clears a vertical flight path of all vectors and resets all computed TOC, TOD, and performance descent data.
     * @param verticalPathEntry The entry for the vertical flight path to clear.
     */
    clearVerticalPath(verticalPathEntry) {
        const verticalPath = verticalPathEntry.path;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            leg.vectors.length = 0;
            leg.simDistance = 0;
        }
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptVectorIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Calculates the top of descent and simulates the performance (off-idle) descent phase for a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param engineCount The number of operational engines to simulate.
     */
    computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount) {
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const firstDescentConstraintLegIndex = firstDescentConstraint.index;
        const targetAltitude = firstDescentConstraint.legs[0].altitude;
        if (cruiseAltitude <= targetAltitude) {
            // Cruise altitude is below the target altitude, so there is no path to be calculated (we will transition
            // immediately from cruise to geometric descent when we intercept the first descent path).
            return;
        }
        const geoInterceptLegIndex = firstDescentConstraintLegIndex + 1;
        const geoInterceptConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, geoInterceptLegIndex);
        const geoInterceptConstraintTargetAltitude = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.targetAltitude;
        const geoInterceptLeg = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.legs[geoInterceptLegIndex - geoInterceptConstraint.index];
        const doesGeoInterceptLegStartLevel = geoInterceptLeg === undefined
            || geoInterceptLeg.fpa === 0
            || firstDescentConstraint.targetAltitude + 1 < geoInterceptLeg.altitude + VNavUtils.altitudeForDistance(geoInterceptLeg.fpa, geoInterceptLeg.distance);
        // Now we will iteratively solve for the TOD. In each iteration, we will choose a TOD along the flight path,
        // then simulate the entire performance descent segment down to the first descent constraint. If the lateral
        // distance covered brings us to within tolerance to the constraint fix, we are done. Otherwise, we adjust
        // the TOD by a lateral distance equal to the difference between the simulated lateral distance and the required
        // lateral distance and run another iteration.
        // TODO: Support speed restriction
        // If the performance descent was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use a crude estimate based on constant FPA.
        const verticalPath = verticalPathEntry.path;
        let estimatedTodDistanceFromFirstConstraint;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromFirstConstraint = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromFirstConstraint = VNavUtils.distanceForAltitude(-3, targetAltitude - cruiseAltitude);
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDescentDistance = estimatedTodDistanceFromFirstConstraint;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the first descent constraint fix to find the lateral position of the TOD
            // -----------------------------
            let todLeg = undefined;
            let todLegIndex = firstDescentConstraintLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDescentDistance;
            while (todLegIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[todLegIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLeg = leg;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        todDistanceToLegEnd = distanceToGo;
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                todLegIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs before the first descent constraint.
                return;
            }
            // In case we hit the FROM leg or the beginning of the flight plan before reaching the TOD, add any remaining
            // distance to the last iterated leg
            todDistanceToLegEnd += distanceToGo;
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, doesGeoInterceptLegStartLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDescentDistance, todLegIndex, todDistanceToLegEnd, firstDescentConstraintLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDescentDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDescentDistance, prevEstimate);
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = firstDescentConstraintLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = 0;
    }
    /**
     * Calculates the top of descent and simulates the level deceleration segment for a flight plan in which the cruise
     * altitude intercepts the geometric descent path after the first descent altitude constraint.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param engineCount The number of operational engines to simulate.
     */
    computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount) {
        // Find the constraint that defines the vertical path we will intercept. This must be a non-flat constraint with a
        // target altitude lower than the cruise altitude.
        let constraintToIntercept = undefined;
        for (let i = firstDescentConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                break;
            }
            if (constraint.targetAltitude <= cruiseAltitude && constraint.fpa > 0) {
                constraintToIntercept = constraint;
                break;
            }
        }
        // If there is no constraint to intercept, then we will remain in cruise until the end of the flight plan.
        if (!constraintToIntercept) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        // Find the point along the flight plan at which the cruise altitude intercepts the geometric descent path.
        let distanceToIntercept = VNavUtils.distanceForAltitude(constraintToIntercept.fpa, cruiseAltitude - constraintToIntercept.targetAltitude);
        let interceptLegIndex = constraintToIntercept.index;
        let interceptDistanceToLegEnd = 0;
        let interceptLeg = lateralLegs[interceptLegIndex];
        while (interceptLeg && distanceToIntercept > 0) {
            const legDistance = interceptLeg.calculated ? interceptLeg.calculated.distanceWithTransitions : 0;
            if (legDistance > distanceToIntercept) {
                interceptDistanceToLegEnd = distanceToIntercept;
                break;
            }
            else {
                distanceToIntercept -= legDistance;
                interceptLeg = lateralLegs[--interceptLegIndex];
            }
        }
        // Now we will iteratively solve for the TOD, which in this context is the beginning of level deceleration.
        // If the level deceleration was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use an arbitrary estimate of 10km.
        let estimatedTodDistanceFromIntercept;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromIntercept = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromIntercept = 10000;
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDecelerationDistance = estimatedTodDistanceFromIntercept;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the intercept point to find the lateral position of the TOD
            // -----------------------------
            let todLeg = undefined;
            let todLegIndex = interceptLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDecelerationDistance + interceptDistanceToLegEnd;
            while (todLegIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[todLegIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLeg = leg;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        todDistanceToLegEnd = distanceToGo;
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                todLegIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs before the intercept point.
                return;
            }
            // In case we hit the FROM leg or the beginning of the flight plan before reaching the TOD, add any remaining
            // distance to the last iterated leg
            todDistanceToLegEnd += distanceToGo;
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, cruiseAltitude, constraintToIntercept.targetAltitude, false, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDecelerationDistance, todLegIndex, todDistanceToLegEnd, interceptLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDecelerationDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDecelerationDistance, prevEstimate);
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = interceptLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = interceptDistanceToLegEnd;
    }
    /**
     * Adjusts the vertical flight path vectors in the performance (off-idle) descent to account for changes in lateral
     * flight plan leg distances since the vectors were simulated.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPath The vertical flight path containing the vectors to adjust.
     */
    adjustPerformanceDescent(lateralLegs, verticalPath) {
        var _a, _b, _c;
        if (verticalPath.todLegIndex === undefined
            || verticalPath.todDistanceToLegEnd === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined) {
            return;
        }
        let distanceCovered = verticalPath.todDistanceToLegEnd;
        const endLegIndex = Math.min(verticalPath.legs.length, verticalPath.geoDescentSimInterceptLegIndex + 1);
        for (let i = verticalPath.todLegIndex + 1; i < endLegIndex; i++) {
            const leg = verticalPath.legs[i];
            if (leg.vectors.length === 0) {
                continue;
            }
            const isInterceptLeg = i === verticalPath.geoDescentSimInterceptLegIndex;
            const endDistanceToLegEnd = isInterceptLeg ? verticalPath.geoDescentSimInterceptDistanceToLegEnd : 0;
            const lerpEndDistanceToLegEnd = Math.max(0, endDistanceToLegEnd);
            const newLegDistance = (_c = (_b = (_a = lateralLegs[i]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            for (let j = 0; j < leg.vectors.length; j++) {
                const vector = leg.vectors[j];
                if (isInterceptLeg && vector.simStartDistanceToLegEnd <= endDistanceToLegEnd) {
                    break;
                }
                vector.startDistanceToLegEnd = MathUtils.lerp(vector.simStartDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
                vector.endDistanceToLegEnd = MathUtils.lerp(vector.simEndDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
            }
            distanceCovered += newLegDistance - endDistanceToLegEnd;
        }
        verticalPath.perfDescentTodDistance = distanceCovered;
    }
    /**
     * Simulates the VNAV climb phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param climbThrustMode The thrust mode to use during the climb phase.
     * @param climbCas The climb calibrated airspeed to use, in meters per second.
     * @param climbMach The climb mach number to use.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param bocLegIndex The global index of the flight plan leg containing the start of the climb.
     * @param bocDistanceToLegEnd The lateral distance, in meters, from the start of the climb to the end of its
     * containing leg.
     * @param bocAltitude The altitude, in meters above MSL, of the start of the climb.
     * @param bocWeight The airplane weight, in pounds, at the start of the climb.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the climb, exclusive. If the
     * climb is simulated to end past the last eligible leg, then the simulation will proceed along the last eligible leg
     * as if it were infinitely extended until the top of climb is reached.
     * @param isMissedApproach Whether the simulated climb is part of the missed approach.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateClimb(lateralLegs, verticalPlan, verticalPath, climbThrustMode, climbCas, climbMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, cruiseAltitude, bocLegIndex, bocDistanceToLegEnd, bocAltitude, bocWeight, endLegIndex, isMissedApproach, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var _k, _l;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        if (bocAltitude >= cruiseAltitude - 100 || bocLegIndex >= endLegIndex) {
            return;
        }
        let climbN1MethodName;
        switch (climbThrustMode) {
            case ClimbThrustMode.CLB1:
                climbN1MethodName = 'getClb1N1';
                break;
            case ClimbThrustMode.CLB2:
                climbN1MethodName = 'getClb2N1';
                break;
            default:
                climbN1MethodName = 'getClbMaxN1';
        }
        const wingArea = this.perfProvider.getWingArea();
        let currentVerticalPathLegIndex = bocLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        // Simulate climb steps. Each step covers the distance to the end of the next lateral leg, the next AT OR BELOW
        // climb altitude restriction to be sequenced, the next speed restriction or speed transition to be sequenced, or
        // 1000 feet of climb, whichever is shorter.
        let currentAltitude = bocAltitude;
        let currentLegIndex = bocLegIndex;
        let currentLeg = lateralLegs[bocLegIndex];
        let distanceToLegEnd = bocDistanceToLegEnd;
        let currentWeight = bocWeight;
        const getNextTargetConstraint = isMissedApproach ? VNavUtils.getNextMaprTargetConstraint : VNavUtils.getNextClimbTargetConstraint;
        let currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, bocLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = climbCas;
        const defaultTargetCasSource = isFinite(climbCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = climbMach;
        const defaultTargetMachSource = isFinite(climbMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let casToUse = Infinity;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude < cruiseAltitude) {
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedClimbWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_a = this.windPlanner.getInterpolatedClimbIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (currentTargetAltitudeConstraint && currentLegIndex > currentTargetAltitudeConstraint.index) {
                // We passed the current target altitude constraint that we were tracking, so we need to get the new current
                // target altitude constraint.
                currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
            }
            // Do not apply flight plan leg altitude restriction if we are past the end of the last eligible leg to be
            // simulated. Otherwise we might get stuck below the cruise altitude forever.
            const targetAltitude = currentTargetAltitudeConstraint && (currentLegIndex < endLegIndex - 1 || distanceToLegEnd > 0)
                ? Math.min(cruiseAltitude, currentTargetAltitudeConstraint.maxAltitude)
                : cruiseAltitude;
            if (currentSpeedConstraint && currentLegIndex > currentSpeedConstraint.globalLegIndex) {
                // We passed the current speed constraint that we were tracking, so we need to get the new current speed
                // constraint.
                currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
                // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed constraint
                // increased our target speed.
                if (!isAccelerating) {
                    isAccelerating = true;
                    accelerationCas = casToUse;
                }
            }
            if (useTransitionCas) {
                if (currentAltitude >= transitionAltitude) {
                    useTransitionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed transition
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            if (useRestrictionCas) {
                if (currentAltitude >= restrictionAltitude) {
                    useRestrictionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed restriction
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
            let distanceStep;
            let timeStep;
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
                altitudeStep = Math.min(altitudeStep, restrictionAltitude - currentAltitude);
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
                altitudeStep = Math.min(altitudeStep, transitionAltitude - currentAltitude);
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = casToTarget);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || casToTarget <= accelerationCas + 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            casToUse = isAccelerating ? accelerationCas : casToTarget;
            // If we are on the last eligible leg to be simulated, we will run the simulation even if the leg does not have
            // a non-zero calculated distance in order to guarantee that the simulation eventually reaches cruise altitude.
            if (currentLegIndex === endLegIndex - 1 || (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0)) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let vs;
                let engineFuelFlow;
                if (altitudeStep <= 0) {
                    // The current altitude is at or above the current target climb altitude (if it were at or above the cruise
                    // altitude we would have exited the while loop already). In this case, we will hold the current altitude
                    // until we sequence the altitude constraint.
                    altitudeStep = 0;
                    vs = 0;
                    const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0);
                    if (isAccelerating) {
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                        const targetNetThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, targetCl, 0);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(targetNetThrustRequired, currentWeight, cl, tas, 0, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        timeStep = tasStep / acceleration;
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                        timeStep = distanceStep / gs;
                    }
                    const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                }
                else {
                    // The current altitude is below the current target climb altitude, so we will climb using the selected climb
                    // climb thrust rating.
                    const temperatureK = temperature + 273.15;
                    const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(currentAltitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                    const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                    const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                    const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                    if (isAccelerating) {
                        vs = BoeingPathCalculator.CLIMB_ACCEL_VS_MPS;
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, vs, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        const accelTimeStep = tasStep / acceleration;
                        const accelAltitudeStep = vs * accelTimeStep;
                        // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the current climb target altitude).
                        if (accelAltitudeStep > altitudeStep) {
                            // vs cannot be 0 here
                            timeStep = altitudeStep / vs;
                        }
                        else {
                            altitudeStep = accelAltitudeStep;
                            timeStep = accelTimeStep;
                        }
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), 1);
                        timeStep = altitudeStep / vs;
                        distanceStep = timeStep * gs;
                    }
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd && currentLegIndex < endLegIndex - 1) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined || (currentLegIndex === endLegIndex - 1 && distanceToLegEnd > 0 && distanceStep > distanceToLegEnd)) {
                    // We are either advancing legs or we are about to cross the end of the last eligible leg to be simulated.
                    // Either way we need to end the current step at the end of the current leg.
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * vs;
                    if (advanceLegIndexTo !== undefined) {
                        currentLegIndex = advanceLegIndexTo;
                        currentLeg = lateralLegs[currentLegIndex];
                        distanceToLegEnd = (_e = (_d = currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                    }
                    else {
                        distanceToLegEnd = 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentAltitude += altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.ClimbLevelAcceleration;
                    }
                    else {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.Climb : VerticalFlightPathVectorType.ClimbLevel;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from a level acceleration into a climb
                        // acceleration or vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_f = (_k = pathLeg.vectors)[vectorIndex]) !== null && _f !== void 0 ? _f : (_k[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_g = (_l = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_l[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = isAccelerating ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.Climb;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
        verticalPath.tocLegIndex = currentLegIndex;
        verticalPath.tocDistanceToLegEnd = distanceToLegEnd;
        verticalPath.tocWeight = currentWeight;
    }
    /**
     * Simulates the VNAV cruise phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param cruiseCas The cruise calibrated airspeed to use, in meters per second.
     * @param cruiseMach The cruise mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the cruise, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCruise(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, cruiseCas, cruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        endLegIndex = Math.min(endLegIndex, lateralLegs.length);
        let tocLegIndex;
        let tocDistanceToLegEnd;
        let tocWeight = activeWeight;
        let currentVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let tocCasToUse;
        // If a TOC is defined in the vertical flight path, then we need to make sure we start writing cruise vectors after
        // the TOC. Otherwise, the simulation starts in the cruise phase at the airplane's current along-track position, so
        // we will start writing vectors at index 0 for the active leg.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            // Check if the TOC lies past the end of its containing leg. If it does, then we need to start our simulation at
            // the beginning of the next leg.
            if (verticalPath.tocDistanceToLegEnd < 0) {
                tocLegIndex = verticalPath.tocLegIndex + 1;
                tocDistanceToLegEnd = (_c = (_b = (_a = lateralLegs[tocLegIndex]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
            }
            else {
                tocLegIndex = verticalPath.tocLegIndex;
                tocDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
                const tocPathLeg = verticalPath.legs[tocLegIndex];
                for (let i = 0; i < tocPathLeg.vectors.length; i++) {
                    const vector = tocPathLeg.vectors[i];
                    if (vector.startDistanceToLegEnd <= tocDistanceToLegEnd) {
                        // The current vector starts at or after the TOC -> start inserting cruise vectors at this index.
                        currentVerticalPathVectorIndex = i;
                        tocCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                        break;
                    }
                    if (vector.endDistanceToLegEnd <= tocDistanceToLegEnd) {
                        // The current vector ends at or after the TOC -> change the vector to end at the TOC if necessary and start
                        // inserting cruise vectors at the next index.
                        if (vector.endDistanceToLegEnd < tocDistanceToLegEnd) {
                            vector.endAltitude = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                            vector.endWeight = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                            // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                            // vector will be. For non-acceleration vectors, the end speed stays the same.
                            if (vector.endCas !== vector.startCas) {
                                // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                                // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                                // stays constant.
                                vector.endMach = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                                vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                            }
                            // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                            // vectors, but the absolute magnitude of the error should still be acceptable.
                            vector.duration = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                            vector.simStartDistanceToLegEnd = tocDistanceToLegEnd;
                            vector.endDistanceToLegEnd = tocDistanceToLegEnd;
                        }
                        currentVerticalPathVectorIndex = i + 1;
                        currentVerticalPathLegDuration += vector.duration;
                        tocCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                        break;
                    }
                    currentVerticalPathVectorIndex = i + 1;
                    currentVerticalPathLegDuration += vector.duration;
                    tocCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                }
            }
        }
        else {
            tocLegIndex = activeLegIndex;
            tocDistanceToLegEnd = activeDistanceToLegEnd;
            currentVerticalPathLegIndex = tocLegIndex;
        }
        if (tocLegIndex >= endLegIndex) {
            return;
        }
        const wingArea = this.perfProvider.getWingArea();
        const pressure = AeroMath.isaPressure(cruiseAltitude);
        const isaTemperature = AeroMath.isaTemperature(cruiseAltitude);
        const cruiseAltitudeFeet = UnitType.METER.convertTo(cruiseAltitude, UnitType.FOOT);
        // Simulate cruise steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction, or 100 NM, whichever is shorter.
        let currentLegIndex = tocLegIndex;
        let currentLeg = lateralLegs[tocLegIndex];
        let distanceToLegEnd = tocDistanceToLegEnd;
        let currentWeight = tocWeight;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        let defaultTargetCas = cruiseCas;
        let defaultTargetCasSource = isFinite(cruiseCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        if (restrictionAltitude !== null && restrictionCas !== null && cruiseAltitude < restrictionAltitude && restrictionCas < defaultTargetCas) {
            defaultTargetCas = restrictionCas;
            defaultTargetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
        }
        if (transitionAltitude !== null && transitionCas !== null && cruiseAltitude < transitionAltitude && transitionCas < defaultTargetCas) {
            defaultTargetCas = transitionCas;
            defaultTargetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
        }
        const defaultTargetMach = cruiseMach;
        const defaultTargetMachSource = isFinite(cruiseMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        while (currentLegIndex < endLegIndex) {
            // Check if we need to update winds and delta ISA offset.
            if (currentLegIndex !== lastWeatherLegIndex) {
                const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_d = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg)) !== null && _d !== void 0 ? _d : 0;
                lastWeatherLegIndex = currentLegIndex;
            }
            const temperature = isaTemperature + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            const useSpeedConstraint = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            if (useSpeedConstraint) {
                // Speed transition and restriction have higher priority than flight plan speed constraints
                if (useSpeedConstraint.minCas > targetCas && targetCasSource === VerticalFlightPathVectorSpeedSource.Schedule) {
                    targetCas = useSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxCas < targetCas) {
                    targetCas = useSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.minMach > targetMach) {
                    targetMach = useSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxMach < targetMach) {
                    targetMach = useSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            tocCasToUse !== null && tocCasToUse !== void 0 ? tocCasToUse : (tocCasToUse = casToTarget);
            let distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
            let timeStep;
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = tocCasToUse);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || Math.abs(casToTarget - accelerationCas) <= 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            const casToUse = isAccelerating ? accelerationCas : casToTarget;
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (windVector && windVector[1] > 0 && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0);
                if (isAccelerating) {
                    const accelerationSign = casToTarget - accelerationCas >= 0 ? 1 : -1;
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    // Assume that the airplane decelerates as quickly as possible by using idle thrust.
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                    let tasStep;
                    if (accelerationSign === 1) {
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0));
                        tasStep = Math.min(targetTas - tas, 3);
                    }
                    else {
                        acceleration = Math.min(-0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0));
                        tasStep = Math.max(targetTas - tas, -3);
                    }
                    timeStep = tasStep / acceleration;
                    distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                }
                else {
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 150 NM. This threshold is
                            // chosen because it guarantees that we don't overshoot any anticipated distance less than or equal to
                            // 50 NM (50 NM + 100 NM maximum step distance).
                            if (distanceToNextSpeedConstraint <= BoeingPathCalculator.MAX_DISTANCE_STEP + 92600) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                // Assume that the airplane decelerates as quickly as possible by using idle thrust.
                                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                                const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, 0, engineNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // distance step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters before the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isAccelerating = true;
                                    accelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    distanceStep = Math.min(distanceStep, distanceToNextSpeedConstraint - distanceToDecel - 500);
                                }
                            }
                        }
                    }
                }
                const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = distanceStep / gs);
                // Check if we reach the end of the current leg before the end of the distance step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceToLegEnd <= distanceStep) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = currentLeg.calculated.distanceWithTransitions;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    distanceStep = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[advanceLegIndexTo];
                    distanceToLegEnd = (_f = (_e = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepEndDistanceToLegEnd = distanceToLegEnd - distanceStep;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - distanceStep / gs * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = acceleration >= 0 ? VerticalFlightPathVectorType.CruiseAcceleration : VerticalFlightPathVectorType.CruiseDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.Cruise;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from an acceleration to a deceleration or
                        // vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = cruiseAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = cruiseAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isAccelerating) {
                    vectorType = acceleration >= 0 ? VerticalFlightPathVectorType.CruiseAcceleration : VerticalFlightPathVectorType.CruiseDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.Cruise;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
    }
    /**
     * Simulates the VNAV performance (off-idle) descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param targetAltitude The altitude to target, in meters above MSL, at the end of the performance descent phase.
     * @param geoInterceptConstraintTargetAltitude The target altitude of the descent altitude constraint containing the
     * point where the performance descent intercepts the geometric descent path, or `undefined` if there is no such
     * constraint.
     * @param isGeoInterceptPathLevel Whether the geometric descent path is level at the point where the performance
     * descent intercepts it.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param estimatedTodDistance The lateral distance, in meters, from the top of descent to the first descent altitude
     * constraint along the flight plan.
     * @param todLegIndex The global index of the flight plan leg containing the top of descent.
     * @param todDistanceToLegEnd The lateral distance, in meters, from the top of descent to the end of its containing
     * leg.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the descent, exclusive.
     * @param engineCount The number of operational engines to simulate.
     * @returns The total simulated distance, in meters, of the performance descent phase.
     */
    simulatePerformanceDescent(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, isGeoInterceptPathLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedTodDistance, todLegIndex, todDistanceToLegEnd, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        if (todLegIndex >= lateralLegs.length) {
            verticalPath.todLegIndex = todLegIndex;
            verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
            verticalPath.perfDescentTodDistance = estimatedTodDistance;
            verticalPath.perfDescentSimDistance = 0;
            return 0;
        }
        const wingArea = this.perfProvider.getWingArea();
        // Find the vertical path vector
        let currentVerticalPathLegIndex = todLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let todCasToUse;
        let todWeight = 0;
        const todPathLeg = verticalPath.legs[todLegIndex];
        for (let i = 0; i < todPathLeg.vectors.length; i++) {
            const vector = todPathLeg.vectors[i];
            if (vector.startDistanceToLegEnd <= todDistanceToLegEnd) {
                // The current vector starts at or after the TOD -> start inserting descent vectors at this index.
                currentVerticalPathVectorIndex = i;
                todCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                todWeight = vector.startWeight;
                break;
            }
            if (vector.endDistanceToLegEnd < todDistanceToLegEnd) {
                // The current vector ends after the TOD -> change the vector to end at the TOD and start inserting descent
                // vectors at the next index.
                vector.endAltitude = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                vector.endWeight = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                // vector will be. For non-acceleration vectors, the end speed stays the same.
                if (vector.endCas !== vector.startCas) {
                    // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                    // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                    // stays constant.
                    vector.endMach = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                    vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                }
                // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                // vectors, but the absolute magnitude of the error should still be acceptable.
                vector.duration = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                vector.simEndDistanceToLegEnd = todDistanceToLegEnd;
                vector.endDistanceToLegEnd = todDistanceToLegEnd;
                currentVerticalPathVectorIndex = i + 1;
                currentVerticalPathLegDuration += vector.duration;
                todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                todWeight = vector.endWeight;
                break;
            }
            currentVerticalPathVectorIndex = i + 1;
            currentVerticalPathLegDuration += vector.duration;
            todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
            todWeight = vector.endWeight;
        }
        // If a TOC is defined, then check if the TOD lies before the TOC. If it does, then use the TOC weight as the weight
        // at TOD instead of the estimated weight at the TOD.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            if (todLegIndex < verticalPath.tocLegIndex
                || (todLegIndex === verticalPath.tocLegIndex && todDistanceToLegEnd > verticalPath.tocDistanceToLegEnd)) {
                todWeight = verticalPath.tocWeight;
            }
        }
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction or speed transition, or 1000 feet of descent, whichever is shorter.
        let currentAltitude = cruiseAltitude;
        let currentLegIndex = todLegIndex;
        let currentLeg = lateralLegs[todLegIndex];
        let distanceToLegEnd = todDistanceToLegEnd;
        let advanceLegIndexTo = undefined;
        let lastVerticalPathLegIndex = currentVerticalPathLegIndex;
        let lastVerticalPathVectorIndex = currentVerticalPathVectorIndex - 1;
        let lastDistanceToLegEnd = todDistanceToLegEnd;
        let currentWeight = todWeight;
        let totalDistanceCovered = 0;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        // Only apply transition and restriction speed limits if they are defined and the either we are intercepting the
        // geometric descent below the threshold altitudes or the intercept is at the threshold altitude and the geometric
        // descent path at the point of intercept descends past the threshold altitude (i.e. we will not level off at the
        // intercept).
        const canUseTransitionCas = transitionAltitude !== null
            && transitionCas !== null
            && (targetAltitude < transitionAltitude - 0.3048
                || (targetAltitude < transitionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < transitionAltitude - 0.3048)));
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        const canUseRestrictionCas = restrictionAltitude !== null
            && restrictionCas !== null
            && (targetAltitude < restrictionAltitude - 0.3048
                || (targetAltitude < restrictionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < restrictionAltitude - 0.3048)));
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = descentCas;
        const defaultTargetCasSource = isFinite(descentCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = descentMach;
        const defaultTargetMachSource = isFinite(descentMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        let isInLevelDecelerationPhase = true;
        let isDecelerating = true;
        let decelerationCas = undefined;
        let decelerationAccel = 0;
        let decelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude > targetAltitude || isInLevelDecelerationPhase) {
            // If the current leg is the leg that we want to advance to, reset the advance leg index so that we don't skip
            // the current leg.
            if (advanceLegIndexTo === currentLegIndex) {
                advanceLegIndexTo = undefined;
            }
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                // If we are still at cruise altitude (i.e. level deceleration), then use cruise winds. Otherwise use descent
                // winds.
                if (currentAltitude === cruiseAltitude) {
                    const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_a = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg)) !== null && _a !== void 0 ? _a : 0;
                }
                else {
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                }
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, currentAltitude - targetAltitude);
            let distanceStep;
            let timeStep;
            let mach;
            let tas;
            let gs;
            let cl;
            let n1;
            let vs;
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            useTransitionCas || (useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude);
            useRestrictionCas || (useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude);
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            const useSpeedConstraint = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            if (useSpeedConstraint) {
                if (useSpeedConstraint.minCas > targetCas) {
                    targetCas = useSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxCas < targetCas) {
                    targetCas = useSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.minMach > targetMach) {
                    targetMach = useSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxMach < targetMach) {
                    targetMach = useSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            todCasToUse !== null && todCasToUse !== void 0 ? todCasToUse : (todCasToUse = casToTarget);
            decelerationCas !== null && decelerationCas !== void 0 ? decelerationCas : (decelerationCas = todCasToUse);
            // Check if we need to continue to decelerate
            if (isDecelerating && (!isFinite(decelerationCas) || casToTarget >= decelerationCas - 0.1)) {
                isDecelerating = false;
                isInLevelDecelerationPhase = false;
                decelerationCas = casToTarget;
                // If we were only simulating the level deceleration phase, then end the simulation now that we are no longer
                // in it.
                if (currentAltitude <= targetAltitude) {
                    break;
                }
            }
            if (advanceLegIndexTo === undefined) {
                // We are not skipping the current leg.
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                let casToUse;
                if (isDecelerating) {
                    vs = isInLevelDecelerationPhase ? 0 : BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                    casToUse = decelerationCas;
                    mach = AeroMath.casToMach(decelerationCas, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    decelerationAccel = Math.min(-0.1, this.perfProvider.getAcceleration(this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) * engineCount, currentWeight, cl, tas, vs, 0));
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    const tasStep = Math.min(tas - targetTas, 3);
                    const accelTimeStep = tasStep / -decelerationAccel;
                    const accelAltitudeStep = -vs * accelTimeStep;
                    // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the first descent constraint).
                    if (accelAltitudeStep > altitudeStep) {
                        // vs cannot be 0 here
                        timeStep = altitudeStep / -vs;
                    }
                    else {
                        altitudeStep = accelAltitudeStep;
                        timeStep = accelTimeStep;
                    }
                    distanceStep = gs * timeStep + decelerationAccel / 2 * timeStep * timeStep;
                }
                else {
                    altitudeStep = Math.min(304.8, currentAltitude - targetAltitude);
                    casToUse = casToTarget;
                    mach = AeroMath.casToMach(casToUse, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    n1 = idleN1 + this.performanceDescentIdleN1Offset;
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 100 NM.
                            if (distanceToNextSpeedConstraint <= 185200) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // altitude step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters prior to the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isDecelerating = true;
                                    decelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature);
                                    vs = Math.min(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), -1);
                                    altitudeStep = Math.min(altitudeStep, (distanceToNextSpeedConstraint - distanceToDecel - 500) / gs * -vs);
                                }
                            }
                        }
                    }
                    // If we are not yet using the speed restriction limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the restriction altitude, check if we need to start anticipating the speed restriction.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseRestrictionCas
                        && !useRestrictionCas
                        && restrictionCas < casToUse
                        && (targetAltitude < restrictionAltitude - 1)
                        && currentAltitude - restrictionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(restrictionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToRestriction = currentAltitude - restrictionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the restriction altitude.
                        if (altitudeToDecel >= altitudeToRestriction - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToRestriction - altitudeToDecel - 100);
                        }
                    }
                    // If we are not yet using the speed transition limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the transition altitude, check if we need to start anticipating the speed transition.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseTransitionCas
                        && !useTransitionCas
                        && transitionCas < casToUse
                        && currentAltitude - transitionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(transitionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToTransition = currentAltitude - transitionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // transition, immediately start decelerating towards the transition speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the transition altitude.
                        if (altitudeToDecel >= altitudeToTransition - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToTransition - altitudeToDecel - 100);
                        }
                    }
                }
                const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                vs !== null && vs !== void 0 ? vs : (vs = Math.min(this.perfProvider.getVerticalSpeed((engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature)) * engineCount, currentWeight, cl, tas, 0), -1));
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = altitudeStep / -vs);
                distanceStep !== null && distanceStep !== void 0 ? distanceStep : (distanceStep = timeStep * gs);
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                if (distanceStep >= distanceToLegEnd) {
                    // Search forward in the lateral plan for a leg with a non-zero calculated distance until we are past the
                    // last eligible leg.
                    let searchLegIndex = currentLegIndex;
                    while (++searchLegIndex < endLegIndex) {
                        const searchLeg = lateralLegs[searchLegIndex];
                        if (searchLeg.calculated && searchLeg.calculated.distanceWithTransitions > 0) {
                            advanceLegIndexTo = searchLegIndex;
                            break;
                        }
                    }
                }
                const currentLegDistance = (_d = (_c = currentLeg.calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isDecelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, decelerationAccel);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * -vs;
                    currentLegIndex++;
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_f = (_e = currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isDecelerating) {
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                }
                totalDistanceCovered += stepDistance;
                currentVerticalPathLegDuration += timeStep;
                currentAltitude -= altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isInLevelDecelerationPhase) {
                        vectorType = VerticalFlightPathVectorType.LevelDeceleration;
                    }
                    else if (isDecelerating) {
                        vectorType = VerticalFlightPathVectorType.IdleDescentDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.IdleDescent;
                    }
                    if (isDecelerating) {
                        // If we are decelerating, we need to check if we went straight from a level deceleration into a descent
                        // deceleration. If so, we need to insert a new vector.
                        if (!decelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            decelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not decelerating, we need to check if the current vector is a deceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = decelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        decelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isDecelerating || !decelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        decelerationVectorStarted = isDecelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isDecelerating) {
                        vector.endCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(decelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                    lastVerticalPathVectorIndex = currentVerticalPathVectorIndex;
                    lastDistanceToLegEnd = stepEndDistanceToLegEnd;
                    if (!isDecelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex++;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    decelerationVectorStarted = false;
                }
            }
            else {
                // The current leg is being skipped, which can only happen if it has no calculated lateral path or the lateral
                // path has a distance of zero. Therefore we insert one zero-length vector into the vertical path for the leg
                // and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isDecelerating) {
                    vectorType = isInLevelDecelerationPhase ? VerticalFlightPathVectorType.LevelDeceleration : VerticalFlightPathVectorType.IdleDescentDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.IdleDescent;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isDecelerating) {
                    vector.startCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(decelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                lastVerticalPathVectorIndex = 0;
                lastDistanceToLegEnd = 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                decelerationVectorStarted = false;
            }
        }
        verticalPath.todLegIndex = todLegIndex;
        verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
        verticalPath.perfDescentTodDistance = estimatedTodDistance;
        verticalPath.perfDescentSimDistance = totalDistanceCovered;
        verticalPath.geoDescentSimInterceptLegIndex = lastVerticalPathLegIndex;
        verticalPath.geoDescentSimInterceptVectorIndex = lastVerticalPathVectorIndex;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = lastDistanceToLegEnd;
        verticalPath.geoDescentInterceptWeight = currentWeight;
        return totalDistanceCovered;
    }
    /**
     * Simulates the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        var _a, _b, _c;
        const verticalPath = verticalPathEntry.path;
        if (verticalPlan.firstDescentConstraintLegIndex === undefined
            || verticalPlan.lastDescentConstraintLegIndex === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptVectorIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptLegIndex === undefined
            || verticalPath.geoDescentInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptWeight === undefined) {
            return;
        }
        const firstDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const lastDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        if (!firstDescentConstraint || !lastDescentConstraint) {
            return;
        }
        // Start simulation at the active leg, or the start of the geometric descent, whichever one comes later.
        const startAtActive = activeLegIndex > verticalPath.geoDescentSimInterceptLegIndex
            || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex && activeDistanceToLegEnd < verticalPath.geoDescentSimInterceptDistanceToLegEnd);
        let startLegIndex = startAtActive ? activeLegIndex : verticalPath.geoDescentSimInterceptLegIndex;
        // Simulate until the MAP or the end of the flight plan, whichever one comes first.
        const endLegIndex = Math.min(lateralLegs.length, (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : Infinity);
        if (startLegIndex >= endLegIndex) {
            return;
        }
        let startDistanceToLegEnd;
        let startWeight;
        let startVerticalPathLegIndex = startLegIndex;
        let startVerticalPathVectorIndex = 0;
        let startVerticalPathLegDuration = 0;
        if (startAtActive) {
            startDistanceToLegEnd = activeDistanceToLegEnd;
            startWeight = activeWeight;
        }
        else {
            startDistanceToLegEnd = verticalPath.geoDescentSimInterceptDistanceToLegEnd;
            startWeight = verticalPath.geoDescentInterceptWeight;
            startVerticalPathVectorIndex = verticalPath.geoDescentSimInterceptVectorIndex + 1;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            for (let i = 0; i < startVerticalPathVectorIndex; i++) {
                startVerticalPathLegDuration += pathLeg.vectors[i].duration;
            }
        }
        let startLeg = lateralLegs[startLegIndex];
        // If the current leg is not calculated, we are already at or past the end of the leg, or we are initially
        // intercepting the geometric descent at the first descent constraint, advance to the next leg.
        if (!startLeg.calculated
            || startDistanceToLegEnd <= 0
            || (startLegIndex === verticalPath.geoDescentInterceptLegIndex
                && verticalPath.geoDescentInterceptLegIndex === verticalPlan.constraints[firstDescentConstraintIndex].index
                && verticalPath.geoDescentInterceptDistanceToLegEnd === 0)) {
            startLegIndex++;
            startLeg = lateralLegs[startLegIndex];
            startDistanceToLegEnd = (_c = (_b = startLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            pathLeg.vectors.length = startVerticalPathVectorIndex;
            pathLeg.simDuration = startVerticalPathLegDuration;
            startVerticalPathLegIndex = startLegIndex;
            startVerticalPathVectorIndex = 0;
            startVerticalPathLegDuration = 0;
        }
        if (startAtActive) {
            // If we are starting at the active leg, then we need to clear all vectors prior to the starting leg
            for (let i = 0; i < startLegIndex; i++) {
                const leg = verticalPath.legs[i];
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
        }
        this.simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount);
        this.simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount);
    }
    /**
     * Performs a coarse simulation of the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param lastDescentConstraintIndex The index of the last descent altitude constraint in the flight plan.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param endLegIndex The global index of the flight plan leg at which to end the simulation, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount) {
        // Simulate coarse descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, or the next change in target airspeed, whichever is shorter.
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var _m, _o, _p, _q;
        const verticalPath = verticalPathEntry.path;
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legIndexOffset = startLegIndex;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentLeg = lateralLegs[currentLegIndex];
        let currentCoarsePathLegIndex = 0;
        let currentCoarsePathVectorIndex = 0;
        let currentWeight = startWeight;
        let currentAltitudeConstraintIndex = -1;
        let priorAltitudeConstraintIndex = -1;
        let currentAltitudeConstraint = undefined;
        let priorAltitudeConstraint = undefined;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        let useTransitionCas = false;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useRestrictionCas = false;
        const defaultTargetCas = descentCas;
        const defaultTargetCasSource = isFinite(descentCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = descentMach;
        const defaultTargetMachSource = isFinite(descentMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let legCourse = undefined;
        let lastLegCourseIndex = undefined;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentLegIndex < endLegIndex) {
            // Update the current and prior altitude constraints for the current leg.
            if (currentLegIndex <= lastDescentConstraint.index) {
                if (!currentAltitudeConstraint || currentLegIndex > currentAltitudeConstraint.index) {
                    currentAltitudeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, currentLegIndex);
                    priorAltitudeConstraintIndex = currentAltitudeConstraintIndex + 1;
                }
            }
            else {
                currentAltitudeConstraintIndex = -1;
                priorAltitudeConstraintIndex = -1;
            }
            currentAltitudeConstraint = verticalPlan.constraints[currentAltitudeConstraintIndex];
            priorAltitudeConstraint = verticalPlan.constraints[priorAltitudeConstraintIndex];
            let distanceStep = distanceToLegEnd;
            let startAltitude;
            let endAltitude;
            let fpa; // Negative = descending path.
            // Calculate the current vector's start and end altitude and FPA.
            if (currentAltitudeConstraint && priorAltitudeConstraint) {
                // We are not past the last descent constraint.
                const verticalLeg = currentAltitudeConstraint.legs[currentAltitudeConstraint.index - currentLegIndex];
                const desiredAltitude = VNavUtils.altitudeForDistance(verticalLeg.fpa, distanceToLegEnd) + verticalLeg.altitude;
                if (desiredAltitude > priorAltitudeConstraint.targetAltitude + 1) {
                    // The desired altitude on the current leg's vertical path exceeds the prior constraint's target altitude
                    // (with tolerance to guard against floating point error and generating very short vectors when the vertical
                    // path doesn't quite line up with the lateral leg distance). Therefore we will hold the prior constraint's
                    // target altitude until we intercept the vertical path.
                    startAltitude = priorAltitudeConstraint.targetAltitude;
                    endAltitude = startAltitude;
                    fpa = 0;
                    if (verticalLeg.fpa > 0 && verticalLeg.altitude < priorAltitudeConstraint.targetAltitude) {
                        distanceStep = MathUtils.lerp(startAltitude, verticalLeg.altitude, desiredAltitude, distanceToLegEnd, 0);
                    }
                }
                else {
                    endAltitude = verticalLeg.altitude;
                    startAltitude = desiredAltitude;
                    fpa = -verticalLeg.fpa;
                }
            }
            else {
                // We are past the last descent constraint. Therefore we will hold the target altitude of the last constraint.
                startAltitude = lastDescentConstraint.targetAltitude;
                endAltitude = startAltitude;
                fpa = 0;
            }
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (!useTransitionCas && canUseTransitionCas) {
                if (startAltitude < transitionAltitude - 0.3048 || (startAltitude < transitionAltitude + 0.3048 && endAltitude < transitionAltitude - 0.3048)) {
                    useTransitionCas = true;
                }
            }
            if (!useRestrictionCas && canUseRestrictionCas) {
                if (startAltitude < restrictionAltitude - 0.3048 || (startAltitude < restrictionAltitude + 0.3048 && endAltitude < restrictionAltitude - 0.3048)) {
                    useRestrictionCas = true;
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
            }
            // If the vector didn't start below the transition altitude but will end below it, then we will end the vector
            // at the transition altitude.
            if (!useTransitionCas && canUseTransitionCas && endAltitude < transitionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(transitionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = transitionAltitude;
            }
            // If the vector didn't start below the restriction altitude but will end below it, then we will end the vector
            // at the restriction altitude.
            if (!useRestrictionCas && canUseRestrictionCas && endAltitude < restrictionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(restrictionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = restrictionAltitude;
            }
            // Check if we need to update winds and delta ISA offset.
            if (startAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(startAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = startAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(startAltitude);
            const temperature = AeroMath.isaTemperature(startAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                if (currentLegIndex !== lastLegCourseIndex) {
                    if (currentLeg.calculated.startLat !== undefined
                        && currentLeg.calculated.startLon !== undefined
                        && currentLeg.calculated.endLat !== undefined
                        && currentLeg.calculated.endLon !== undefined) {
                        legCourse = GeoPoint.finalBearing(currentLeg.calculated.startLat, currentLeg.calculated.startLon, currentLeg.calculated.endLat, currentLeg.calculated.endLon);
                        if (!isFinite(legCourse)) {
                            legCourse = undefined;
                        }
                    }
                    else {
                        legCourse = undefined;
                    }
                    lastLegCourseIndex = currentLegIndex;
                }
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windVector && windVector[1] > 0 && legCourse !== undefined) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(legCourse, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                const mach = AeroMath.casToMach(casToTarget, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const vs = gs * Math.tan(fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                if (distanceStep >= distanceToLegEnd - 1e-3) {
                    distanceStep = distanceToLegEnd;
                }
                const timeStep = distanceStep / gs;
                const netThrustRequired = vs === 0
                    ? this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0)
                    : this.perfProvider.getRequiredThrust(currentWeight, cl, tas, vs, 0);
                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                const idleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature) * engineCount;
                // If the net thrust required to fly the vertical path is less than the net thrust provided with engines at
                // idle, then use idle fuel flow since engines can't go below idle.
                const engineGrossThrust = netThrustRequired <= idleNetThrust
                    ? this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach)
                    : this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = currentLeg.calculated.distanceWithTransitions;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = startAltitude;
                const stepStartWeight = currentWeight;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    currentLegIndex = advanceLegIndexTo;
                    if (currentLegIndex < endLegIndex) {
                        currentLeg = lateralLegs[advanceLegIndexTo];
                        distanceToLegEnd = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                }
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentCoarsePathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = (_d = (_m = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _d !== void 0 ? _d : (_m[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                    const vector = (_e = (_o = pathLeg.vectors)[currentCoarsePathVectorIndex]) !== null && _e !== void 0 ? _e : (_o[currentCoarsePathVectorIndex] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    vector.targetCas = targetCas;
                    vector.targetCasSource = targetCasSource;
                    vector.targetMach = targetMach;
                    vector.targetMachSource = targetMachSource;
                    vector.fpa = fpa;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentCoarsePathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const pathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    pathLeg.vectors.length = currentCoarsePathVectorIndex;
                    pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                    pathLeg.distance = currentLegDistance;
                    pathLeg.course = legCourse;
                    currentCoarsePathLegIndex = advanceLegIndexTo - startLegIndex;
                    currentCoarsePathVectorIndex = 0;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = (_f = (_p = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _f !== void 0 ? _f : (_p[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                const vector = (_g = (_q = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_q[0] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = startAltitude;
                vector.endAltitude = endAltitude;
                vector.targetCas = targetCas;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = targetMach;
                vector.targetMachSource = targetMachSource;
                vector.fpa = 0;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                pathLeg.vectors.length = 1;
                pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                pathLeg.distance = 0;
                pathLeg.course = undefined;
                currentLegIndex++;
                if (currentLegIndex < endLegIndex) {
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                }
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
            }
        }
        // Delete all coarse path legs after the last simulated leg.
        coarsePath.legs.length = currentCoarsePathLegIndex;
        if (coarsePath.legs.length === 0) {
            return;
        }
        // Compute estimated deceleration times and distances.
        // Get the speed constraint in effect after sequencing the last leg.
        const endSpeedConstraint = nextSpeedConstraint && endLegIndex > nextSpeedConstraint.globalLegIndex ? nextSpeedConstraint : undefined;
        let endTargetCas = defaultTargetCas;
        let endTargetCasSource = defaultTargetCasSource;
        let endTargetMach = defaultTargetMach;
        let endTargetMachSource = defaultTargetMachSource;
        if (endSpeedConstraint) {
            if (endSpeedConstraint.minCas > endTargetCas) {
                endTargetCas = endSpeedConstraint.minCas;
                endTargetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (endSpeedConstraint.maxCas < endTargetCas) {
                endTargetCas = endSpeedConstraint.maxCas;
                endTargetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (endSpeedConstraint.minMach > endTargetMach) {
                endTargetMach = endSpeedConstraint.minCas;
                endTargetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (endSpeedConstraint.maxMach < endTargetMach) {
                endTargetMach = endSpeedConstraint.maxMach;
                endTargetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
        }
        if (useRestrictionCas && restrictionCas < endTargetCas) {
            endTargetCas = restrictionCas;
            endTargetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
        }
        if (useTransitionCas && transitionCas < endTargetMach) {
            endTargetCas = transitionCas;
            endTargetMachSource = VerticalFlightPathVectorSpeedSource.Transition;
        }
        let distanceToEnd = 0;
        let nextVector;
        let nextCasToTarget;
        let anticipatedTargetCas = Infinity;
        let anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
        let anticipatedTargetMach = Infinity;
        let anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
        for (let i = coarsePath.legs.length - 1; i >= 0; i--) {
            const leg = coarsePath.legs[i];
            for (let j = leg.vectors.length - 1; j >= 0; j--) {
                const vector = leg.vectors[j];
                // Check if we need to update winds and delta ISA offset.
                if (lastWeatherAltitude === undefined || Math.abs(vector.endAltitude - lastWeatherAltitude) > 1) {
                    const currentAltitudeFeet = UnitType.METER.convertTo(vector.endAltitude, UnitType.FOOT);
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_k = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _k !== void 0 ? _k : 0;
                    lastWeatherAltitude = vector.endAltitude;
                }
                const pressure = AeroMath.isaPressure(vector.endAltitude);
                const casToTarget = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, pressure));
                if (nextCasToTarget === undefined) {
                    // If nextCasToTarget is undefined, then we are not extending deceleration from the succeeding vector (the
                    // previous one to be iterated) into the current vector. Therefore, we will set the anticipated speed values to
                    // be equal to the target speed at the beginning of the succeeding vector.
                    if (nextVector) {
                        nextCasToTarget = Math.min(nextVector.targetCas, AeroMath.machToCas(nextVector.targetMach, pressure));
                        anticipatedTargetCas = nextVector.targetCas;
                        anticipatedTargetCasSource = nextVector.targetCasSource;
                        anticipatedTargetMach = nextVector.targetMach;
                        anticipatedTargetMachSource = nextVector.targetMachSource;
                    }
                    else {
                        nextCasToTarget = Math.min(endTargetCas, AeroMath.machToCas(endTargetMach, pressure));
                        anticipatedTargetCas = endTargetCas;
                        anticipatedTargetCasSource = endTargetCasSource;
                        anticipatedTargetMach = endTargetMach;
                        anticipatedTargetMachSource = endTargetMachSource;
                    }
                }
                if (isFinite(casToTarget) && isFinite(nextCasToTarget) && nextCasToTarget < casToTarget - 0.5) {
                    // We need to decelerate.
                    const initialMach = AeroMath.casToMach(casToTarget, pressure);
                    const finalMach = AeroMath.casToMach(nextCasToTarget, pressure);
                    const temperature = AeroMath.isaTemperature(vector.endAltitude) + deltaIsa;
                    const density = AeroMath.densityAir(pressure, temperature);
                    const soundSpeed = AeroMath.soundSpeedAir(temperature);
                    const initialTas = AeroMath.machToTas(initialMach, soundSpeed);
                    const finalTas = AeroMath.machToTas(finalMach, soundSpeed);
                    // Find the wind component along the leg's course.
                    let wind = 0;
                    if (leg.course !== undefined && windVector && windVector[0] > 0) {
                        wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(leg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                    }
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(initialTas, finalTas));
                    const initialGs = initialTas + wind;
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, initialMach);
                    const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, initialMach, pressure, temperature);
                    const vs = VNavUtils.altitudeForDistance(vector.fpa, initialGs);
                    const [timeToDecel, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineIdleNetThrust, engineCount, wingArea, 0, vector.endWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_DESCENT_ACCELERATION);
                    vector.estimatedDecelTime = timeToDecel;
                    vector.estimatedDecelDistance = distanceToDecel + wind * timeToDecel;
                    vector.estimatedDecelStartTas = initialTas;
                    vector.estimatedDecelEndTas = finalTas;
                    vector.estimatedDecelWind = wind;
                    vector.anticipatedTargetCas = anticipatedTargetCas;
                    vector.anticipatedTargetCasSource = anticipatedTargetCasSource;
                    vector.anticipatedTargetMach = anticipatedTargetMach;
                    vector.anticipatedTargetMachSource = anticipatedTargetMachSource;
                    const vectorDistance = vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
                    if (vector.estimatedDecelDistance > vectorDistance) {
                        // The distance required to decelerate is longer than the vector. Therefore, we need to determine the
                        // speed at the start of the vector such that a deceleration starting at that speed will reach the
                        // anticipated target speed at the end of the vector.
                        const acceleration = (finalTas - initialTas) / timeToDecel;
                        vector.estimatedDecelTime = BoeingPathCalculator.timeToDistance(vectorDistance, initialTas + wind, acceleration);
                        vector.estimatedDecelDistance = vectorDistance;
                        // Check if we need to get updated weather data for the altitude at the start of the vector.
                        if (lastWeatherAltitude === undefined || Math.abs(vector.startAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(vector.startAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                            deltaIsa = (_l = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _l !== void 0 ? _l : 0;
                            lastWeatherAltitude = vector.startAltitude;
                        }
                        const vectorStartPressure = AeroMath.isaPressure(vector.startAltitude);
                        const vectorStartSoundSpeed = AeroMath.soundSpeedIsa(vector.startAltitude, deltaIsa);
                        let vectorStartTas = finalTas - acceleration * vector.estimatedDecelTime;
                        let vectorStartCas = AeroMath.machToCas(AeroMath.tasToMach(vectorStartTas, vectorStartSoundSpeed), vectorStartPressure);
                        // If the altitude is different between the start and end of the vector, then we need to make sure that the
                        // different airspeed conversions don't result in the estimated CAS at the start of the vector being less
                        // than the anticipated CAS at the end of the vector.
                        if (vectorStartCas < nextCasToTarget) {
                            vectorStartCas = nextCasToTarget;
                            vectorStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartCas, vectorStartPressure), vectorStartSoundSpeed);
                        }
                        // Check if the estimated CAS at the start of the vector is less than the (non-anticipated) target CAS at
                        // the start of the vector. If it is, then we need to extend the deceleration into the preceding vector
                        // (the next one to be iterated). If it is not, then we will have the deceleration start at the beginning
                        // of the vector at the non-anticipated target speed.
                        const vectorStartTargetCas = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, vectorStartPressure));
                        if (vectorStartCas < vectorStartTargetCas) {
                            vector.estimatedDecelStartTas = vectorStartTas;
                            // Set nextCasToTarget so that the preceding vector (the next one to be iterated) will anticipate the
                            // speed at the start of this vector required to meet this vector's anticipated speed target instead of
                            // this vector's target speed.
                            nextCasToTarget = vectorStartCas;
                        }
                        else {
                            vector.estimatedDecelStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartTargetCas, vectorStartPressure), vectorStartSoundSpeed);
                            nextCasToTarget = undefined;
                        }
                    }
                    else {
                        nextCasToTarget = undefined;
                    }
                }
                else {
                    vector.estimatedDecelTime = 0;
                    vector.estimatedDecelDistance = 0;
                    vector.estimatedDecelStartTas = 0;
                    vector.estimatedDecelEndTas = 0;
                    vector.estimatedDecelWind = 0;
                    vector.anticipatedTargetCas = Infinity;
                    vector.anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
                    vector.anticipatedTargetMach = Infinity;
                    vector.anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
                    nextCasToTarget = undefined;
                }
                nextVector = vector;
            }
            leg.endDistanceToEnd = distanceToEnd;
            distanceToEnd += leg.distance;
        }
    }
    /**
     * Performs a detailed simulation of the VNAV geometric descent phase of a flight plan.
     * @param verticalPathEntry The entry for the vertical flight path.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startVerticalPathLegIndex The index of the vertical path leg at which to start the simulation.
     * @param startVerticalPathVectorIndex The within-leg index of the vertical path vector at which to start the
     * simulation.
     * @param startVerticalPathLegDuration The total duration, in seconds, of all vertical path vectors in the leg
     * containing the start of the simulation that are situated prior to the start point.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount) {
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, the next change in target airspeed, or 1000 feet of descent, whichever is shorter.
        var _a, _b, _c, _d, _e;
        var _f, _g;
        const verticalPath = verticalPathEntry.path;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentVerticalPathLegIndex = startVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = startVerticalPathVectorIndex;
        let currentVerticalPathLegDuration = startVerticalPathLegDuration;
        let currentWeight = startWeight;
        let currentCoarsePathLegIndex = startLegIndex - coarsePath.legIndexOffset;
        let currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
        let currentCoarsePathVectorIndex = 0;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentCoarsePathLegIndex < coarsePath.legs.length) {
            // Find the coarse path vector containing the current position in the simulation.
            let coarsePathVector = currentCoarsePathLeg.vectors[currentCoarsePathVectorIndex];
            while (currentCoarsePathVectorIndex < currentCoarsePathLeg.vectors.length - 1 && coarsePathVector.endDistanceToLegEnd > distanceToLegEnd) {
                coarsePathVector = currentCoarsePathLeg.vectors[++currentCoarsePathVectorIndex];
            }
            // If the current coarse path vector has zero length, then currentAltitude will be set to the start altitude
            // because lerp() defaults to y0 when x0 and x1 are equal.
            const currentAltitude = MathUtils.lerp(distanceToLegEnd, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude, true, true);
            let altitudeStep;
            let distanceStep;
            // Check if we need to update winds and delta ISA offset.
            if (lastWeatherAltitude === undefined || Math.abs(currentAltitude - lastWeatherAltitude) > 1) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, pressure));
            if (currentCoarsePathLeg.distance > 0) {
                // Find the wind component along the leg's course.
                let wind = 0;
                if (currentCoarsePathLeg.course !== undefined && windVector && windVector[0] > 0) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS)
                        * Math.cos(MathUtils.diffAngleDeg(currentCoarsePathLeg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                let maxDistanceStep;
                let isDecelerating;
                let acceleration;
                if (coarsePathVector.estimatedDecelTime > 0) {
                    // The current coarse path vector ends with a deceleration to an anticipated target speed.
                    const decelStartDistanceToLegEnd = coarsePathVector.estimatedDecelDistance + coarsePathVector.endDistanceToLegEnd;
                    if (decelStartDistanceToLegEnd > distanceToLegEnd - 1e-3) {
                        // We are currently decelerating.
                        maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                        isDecelerating = true;
                        acceleration = (coarsePathVector.estimatedDecelEndTas - coarsePathVector.estimatedDecelStartTas) / coarsePathVector.estimatedDecelTime;
                    }
                    else {
                        // We have not yet reached the point where deceleration starts. We need to ensure that the current vector
                        // does not extend beyond the deceleration start point.
                        maxDistanceStep = distanceToLegEnd - decelStartDistanceToLegEnd;
                        isDecelerating = false;
                        acceleration = 0;
                    }
                }
                else {
                    // The current coarse path vector does not end with a deceleration.
                    maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    isDecelerating = false;
                    acceleration = 0;
                }
                if (coarsePathVector.fpa < 0) {
                    const maxAltitudeStep = currentAltitude - MathUtils.lerp(distanceToLegEnd - maxDistanceStep, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude);
                    if (maxAltitudeStep > BoeingPathCalculator.MAX_ALTITUDE_STEP + BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_ALTITUDE_STEP / maxAltitudeStep * maxDistanceStep;
                        altitudeStep = BoeingPathCalculator.MAX_ALTITUDE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                        altitudeStep = maxAltitudeStep;
                    }
                }
                else {
                    if (maxDistanceStep > BoeingPathCalculator.MAX_DISTANCE_STEP + BoeingPathCalculator.MAX_DISTANCE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                    }
                    altitudeStep = 0;
                }
                let endDistanceToLegEnd;
                let endAltitude;
                let shouldAdvanceVector;
                // Check if we need to advance to the next coarse path vector after the current step, with tolerance for
                // floating point errors.
                if (distanceToLegEnd - distanceStep < coarsePathVector.endDistanceToLegEnd + 1e-3) {
                    distanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    endDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd;
                    endAltitude = coarsePathVector.endAltitude;
                    shouldAdvanceVector = true;
                }
                else {
                    endDistanceToLegEnd = distanceToLegEnd - distanceStep;
                    endAltitude = currentAltitude - altitudeStep;
                    shouldAdvanceVector = false;
                }
                let startCas;
                let startMach;
                let endCas;
                let endMach;
                let mach;
                let tas;
                let gs;
                let timeStep;
                if (isDecelerating) {
                    const decelStartDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd + coarsePathVector.estimatedDecelDistance;
                    const startTimeToDecelEnd = distanceToLegEnd >= decelStartDistanceToLegEnd - 1
                        ? coarsePathVector.estimatedDecelTime
                        : BoeingPathCalculator.timeToDistance(distanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const endTimeToDecelEnd = endDistanceToLegEnd <= coarsePathVector.endDistanceToLegEnd + 1
                        ? 0
                        : BoeingPathCalculator.timeToDistance(endDistanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const startTas = coarsePathVector.estimatedDecelEndTas - acceleration * startTimeToDecelEnd;
                    const endTas = coarsePathVector.estimatedDecelEndTas - acceleration * endTimeToDecelEnd;
                    tas = startTas;
                    mach = AeroMath.tasToMach(tas, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(startTas, endTas));
                    gs = tas + wind;
                    timeStep = BoeingPathCalculator.timeToDistance(distanceStep, gs, acceleration);
                    if (!isFinite(timeStep)) {
                        timeStep = distanceStep / ((startTas + endTas) / 2 + wind);
                    }
                    if (altitudeStep > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                            deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                            lastWeatherAltitude = endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(endAltitude, deltaIsa);
                        endMach = AeroMath.tasToMach(endTas, endSoundSpeed);
                        endCas = AeroMath.machToCas(endMach, endPressure);
                    }
                    else {
                        endMach = AeroMath.tasToMach(endTas, soundSpeed);
                        endCas = AeroMath.machToCas(endMach, pressure);
                    }
                    startMach = AeroMath.tasToMach(startTas, soundSpeed);
                    startCas = AeroMath.machToCas(startMach, pressure);
                    if (startCas < endCas) {
                        startCas = endCas;
                        startMach = AeroMath.casToMach(startCas, pressure);
                    }
                }
                else {
                    mach = AeroMath.casToMach(casToTarget, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                    gs = tas + wind;
                    timeStep = distanceStep / gs;
                    startCas = casToTarget;
                    startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (altitudeStep > 1) {
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endCasToTarget = coarsePathVector.targetCas;
                        const endMachCasToTarget = AeroMath.machToCas(coarsePathVector.targetMach, endPressure);
                        if (endMachCasToTarget <= endCasToTarget) {
                            endCas = endMachCasToTarget;
                            endMach = coarsePathVector.targetMach;
                        }
                        else {
                            endCas = endCasToTarget;
                            endMach = AeroMath.casToMach(casToTarget, endPressure);
                        }
                    }
                    else {
                        endCas = startCas;
                        endMach = startMach;
                    }
                }
                const vs = gs * Math.tan(coarsePathVector.fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let engineGrossThrust;
                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                if (isDecelerating) {
                    // Assume engines are at idle if we are decelerating.
                    engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                }
                else {
                    const netThrustRequired = vs === 0
                        ? this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0)
                        : this.perfProvider.getRequiredThrust(currentWeight, cl, tas, vs, 0);
                    const idleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature) * engineCount;
                    // If the net thrust required to fly the vertical path is less than the net thrust provided with engines at
                    // idle, then use idle fuel flow since engines can't go below idle.
                    engineGrossThrust = netThrustRequired <= idleNetThrust
                        ? this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach)
                        : this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                }
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg at the end of the step. If so, advance to the next leg.
                let advanceLegIndexTo = undefined;
                if (shouldAdvanceVector && currentCoarsePathVectorIndex + 1 >= currentCoarsePathLeg.vectors.length) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                distanceToLegEnd = endDistanceToLegEnd;
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    const vector = (_c = (_f = pathLeg.vectors)[currentVerticalPathVectorIndex]) !== null && _c !== void 0 ? _c : (_f[currentVerticalPathVectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                    vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    if (isDecelerating) {
                        vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                        vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    }
                    else {
                        vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.targetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                        vector.targetMachSource = coarsePathVector.targetMachSource;
                    }
                    vector.startCas = UnitType.MPS.convertTo(startCas, UnitType.KNOT);
                    vector.startMach = startMach;
                    vector.endCas = UnitType.MPS.convertTo(endCas, UnitType.KNOT);
                    vector.endMach = endMach;
                    vector.duration = timeStep;
                    vector.simEndDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentVerticalPathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentCoarsePathLeg.distance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentLegIndex = advanceLegIndexTo;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    currentCoarsePathLegIndex = advanceLegIndexTo - coarsePath.legIndexOffset;
                    currentCoarsePathVectorIndex = 0;
                    if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                        currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                        distanceToLegEnd = currentCoarsePathLeg.distance;
                    }
                }
                else if (shouldAdvanceVector) {
                    currentCoarsePathVectorIndex++;
                }
            }
            else {
                // The current leg has a distance of zero. Therefore we insert one zero-length vector into the vertical path
                // for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_d = (_g = pathLeg.vectors)[0]) !== null && _d !== void 0 ? _d : (_g[0] = BoeingPathCalculator.createVerticalPathVector());
                const isDecelerating = coarsePathVector.anticipatedTargetCasSource !== VerticalFlightPathVectorSpeedSource.None
                    || coarsePathVector.anticipatedTargetMachSource !== VerticalFlightPathVectorSpeedSource.None;
                vector.gs = AeroMath.casToTas(casToTarget, pressure, temperature);
                vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = coarsePathVector.startAltitude;
                vector.endAltitude = coarsePathVector.endAltitude;
                if (isDecelerating) {
                    vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                    vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    vector.startMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelStartTas, soundSpeed);
                    vector.startCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.startMach, pressure), UnitType.KNOT);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(coarsePathVector.endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(coarsePathVector.endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                            deltaIsa = (_e = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _e !== void 0 ? _e : 0;
                            lastWeatherAltitude = coarsePathVector.endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(coarsePathVector.endAltitude, deltaIsa);
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, endSoundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, endPressure), UnitType.KNOT);
                    }
                    else {
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, soundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, pressure), UnitType.KNOT);
                    }
                }
                else {
                    vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.targetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                    vector.targetMachSource = coarsePathVector.targetMachSource;
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endCasToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, endPressure));
                        vector.endMach = UnitType.MPS.convertTo(endCasToTarget, UnitType.KNOT);
                        vector.endCas = AeroMath.casToMach(endCasToTarget, endPressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    vector.endCas = vector.startCas;
                    vector.endMach = vector.startMach;
                }
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
                if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                    currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    distanceToLegEnd = currentCoarsePathLeg.distance;
                }
            }
        }
    }
    /**
     * Gets the time required to travel a given distance with constant acceleration.
     * @param distance The distance to travel.
     * @param v0 The initial velocity. The value should be expressed in units of `distance` per unit time.
     * @param acceleration The acceleration. The value should be expressed in units of `distance` per unit time squared.
     * @returns The time required to travel the specified distance given the specified constant acceleration from the
     * initial velocity. The value is expressed in the unit of time chosen for `v0` and `acceleration`.
     */
    static timeToDistance(distance, v0, acceleration) {
        if (acceleration === 0) {
            return distance / v0;
        }
        const a = acceleration / 2;
        const b = v0;
        const c = -distance;
        return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    /**
     * Creates a new speed constraint list item.
     * @returns A new speed constraint list item.
     */
    static createSpeedConstraintListItem() {
        return {
            globalLegIndex: 0,
            flightPhase: VerticalFlightPhase.Climb,
            speedConstraint: {
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS
            },
            isMissedApproach: false,
            minCas: -Infinity,
            maxCas: Infinity,
            minMach: -Infinity,
            maxMach: Infinity
        };
    }
    /**
     * Creates a new vertical flight path.
     * @param planIndex The index of the path's associated flight plan. Defaults to `0`.
     * @returns A new vertical flight path.
     */
    static createVerticalPath(planIndex = 0) {
        return {
            planIndex,
            legs: [],
            isPending: false,
            tocLegIndex: undefined,
            tocDistanceToLegEnd: undefined,
            tocWeight: undefined,
            todLegIndex: undefined,
            todDistanceToLegEnd: undefined,
            perfDescentTodDistance: undefined,
            perfDescentSimDistance: undefined,
            geoDescentInterceptLegIndex: undefined,
            geoDescentInterceptDistanceToLegEnd: undefined,
            geoDescentSimInterceptLegIndex: undefined,
            geoDescentSimInterceptVectorIndex: undefined,
            geoDescentSimInterceptDistanceToLegEnd: undefined,
            geoDescentInterceptWeight: undefined
        };
    }
    /**
     * Creates a new vertical flight path leg.
     * @returns A new vertical flight path leg.
     */
    static createVerticalPathLeg() {
        return {
            vectors: [],
            simDistance: 0,
            simDuration: 0
        };
    }
    /**
     * Creates a new vertical flight path vector.
     * @returns A new vertical flight path vector.
     */
    static createVerticalPathVector() {
        return {
            type: VerticalFlightPathVectorType.Climb,
            simStartDistanceToLegEnd: 0,
            simEndDistanceToLegEnd: 0,
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: NaN,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: NaN,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            startCas: 0,
            startMach: 0,
            endCas: 0,
            endMach: 0,
            gs: 0,
            startWeight: 0,
            endWeight: 0,
            duration: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path.
     * @returns A new geometric descent coarse vertical flight path.
     */
    static createGeometricDescentCoarsePath() {
        return {
            legs: [],
            legIndexOffset: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path leg.
     * @returns A new geometric descent coarse vertical flight path leg.
     */
    static createGeometricDescentCoarseLeg() {
        return {
            vectors: [],
            altitudeConstraintIndex: -1,
            distance: 0,
            endDistanceToEnd: 0,
            course: undefined
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path vector.
     * @returns A new geometric descent coarse vertical flight path vector.
     */
    static createGeometricDescentCoarseVector() {
        return {
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: Infinity,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: Infinity,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            fpa: 0,
            anticipatedTargetCas: Infinity,
            anticipatedTargetCasSource: VerticalFlightPathVectorSpeedSource.None,
            anticipatedTargetMach: Infinity,
            anticipatedTargetMachSource: VerticalFlightPathVectorSpeedSource.None,
            estimatedDecelTime: 0,
            estimatedDecelDistance: 0,
            estimatedDecelStartTas: 0,
            estimatedDecelEndTas: 0,
            estimatedDecelWind: 0,
            startWeight: 0,
            endWeight: 0
        };
    }
    /**
     * Copies a vertical flight path.
     * @param source The path to copy from.
     * @param target The path to copy to. If not defined, a new vertical flight path will be created.
     * @returns The vertical flight path that was copied to.
     */
    static copyVerticalPath(source, target) {
        if (!target) {
            target = BoeingPathCalculator.createVerticalPath(source.planIndex);
        }
        target.legs.length = source.legs.length;
        for (let i = 0; i < source.legs.length; i++) {
            target.legs[i] = BoeingPathCalculator.copyVerticalPathLeg(source.legs[i], target.legs[i]);
        }
        target.tocLegIndex = source.tocLegIndex;
        target.tocDistanceToLegEnd = source.tocDistanceToLegEnd;
        target.tocWeight = source.tocWeight;
        target.todLegIndex = source.todLegIndex;
        target.todDistanceToLegEnd = source.todDistanceToLegEnd;
        target.perfDescentTodDistance = source.perfDescentTodDistance;
        target.perfDescentSimDistance = source.perfDescentSimDistance;
        target.geoDescentInterceptLegIndex = source.geoDescentInterceptLegIndex;
        target.geoDescentInterceptDistanceToLegEnd = source.geoDescentInterceptDistanceToLegEnd;
        target.geoDescentSimInterceptLegIndex = source.geoDescentSimInterceptLegIndex;
        target.geoDescentSimInterceptVectorIndex = source.geoDescentSimInterceptVectorIndex;
        target.geoDescentSimInterceptDistanceToLegEnd = source.geoDescentSimInterceptDistanceToLegEnd;
        target.geoDescentInterceptWeight = source.geoDescentInterceptWeight;
        return target;
    }
    /**
     * Copies a vertical flight path leg.
     * @param source The leg to copy from.
     * @param target The leg to copy to. If not defined, a new vertical flight path leg will be created.
     * @returns The vertical flight path leg that was copied to.
     */
    static copyVerticalPathLeg(source, target) {
        var _a;
        if (!target) {
            target = BoeingPathCalculator.createVerticalPathLeg();
        }
        target.vectors.length = source.vectors.length;
        for (let i = 0; i < source.vectors.length; i++) {
            target.vectors[i] = Object.assign((_a = target.vectors[i]) !== null && _a !== void 0 ? _a : {}, source.vectors[i]);
        }
        target.simDistance = source.simDistance;
        target.simDuration = source.simDuration;
        return target;
    }
    /**
     * Gets the lateral distance, in meters, from a given query point along a flight plan to a speed constraint in the
     * same flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param speedConstraint The speed constraint to get the distance to.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of its containing leg.
     * @returns The lateral distance, in meters, from the specified query point to the specified speed constraint.
     * @throws RangeError if `globalLegIndex` is out of bounds.
     */
    static getDistanceToSpeedConstraint(lateralLegs, speedConstraint, globalLegIndex, distanceToLegEnd) {
        var _a, _b, _c, _d, _e, _f;
        if (globalLegIndex < 0 || globalLegIndex >= lateralLegs.length) {
            throw new RangeError();
        }
        if (globalLegIndex <= speedConstraint.globalLegIndex) {
            let distance = distanceToLegEnd;
            const end = Math.min(speedConstraint.globalLegIndex + 1, lateralLegs.length);
            for (let i = globalLegIndex + 1; i < end; i++) {
                distance += (_b = (_a = lateralLegs[i].calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
            }
            return distance;
        }
        else {
            let distance = distanceToLegEnd - ((_d = (_c = lateralLegs[globalLegIndex].calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0);
            const end = Math.max(speedConstraint.globalLegIndex, 0);
            for (let i = globalLegIndex - 1; i > end; i--) {
                distance -= (_f = (_e = lateralLegs[i].calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            }
            return distance;
        }
    }
    /**
     * Gets the geo circle representation of the course at and the position vector of a point along a flight plan leg's
     * lateral flight path.
     * @param legCalc The lateral flight path calculations for a flight plan leg.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of the flight plan leg.
     * @param courseOut The geo circle to which write the flight path course at the query point.
     * @param positionOut The 3D vector to which to write the position vector of the query point.
     * @returns Whether a course and position vector were successfully found for the query point.
     */
    static getCourseAndPositionAlongLeg(legCalc, distanceToLegEnd, courseOut, positionOut) {
        // Iterate over all vectors (including transitions) in the leg in forward order until we reach the query point.
        let distanceToGo = legCalc.distanceWithTransitions - distanceToLegEnd;
        let vectors = legCalc.ingress;
        let vectorIndex = 0;
        let vector = vectors[vectorIndex];
        let lastVector = undefined;
        // ingress vectors
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // ingress to egress vectors
        vectors = legCalc.ingressToEgress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // egress vectors
        vectors = legCalc.egress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // If we have exhausted all vectors on the leg without reaching the query point, advance past the end of the last
        // vector (if it exists).
        if (lastVector) {
            FlightPathUtils.setGeoCircleFromVector(lastVector, courseOut);
            courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(lastVector.endLat, lastVector.endLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
            return true;
        }
        return false;
    }
}
BoeingPathCalculator.MAX_DISTANCE_STEP = 185200; // meters (100 nautical miles)
BoeingPathCalculator.MAX_DISTANCE_STEP_TOL = 18520; // meters (10 nautical miles)
BoeingPathCalculator.MAX_ALTITUDE_STEP = 304.8; // meters (1000 feet)
BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL = 30.48; // meters (100 feet)
BoeingPathCalculator.CLIMB_ACCEL_VS_MPS = UnitType.FPM.convertTo(500, UnitType.MPS);
BoeingPathCalculator.DESCENT_DECEL_VS_MPS = UnitType.FPM.convertTo(-500, UnitType.MPS);
BoeingPathCalculator.MIN_GROUND_SPEED = 25.722; // meters per second (50 knots)
BoeingPathCalculator.MIN_DESCENT_ACCELERATION = 0.2572; // meters per second squared (0.5 knots per second)
BoeingPathCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingPathCalculator.vec3Cache = [Vec3Math.create()];
BoeingPathCalculator.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
BoeingPathCalculator.windCache = [Vec2Math.create()];
BoeingPathCalculator.getCourseAndPositionAlongLegCache = {
    geoPoint: [new GeoPoint(0, 0)]
};

var BoeingVNavVars;
(function (BoeingVNavVars) {
    BoeingVNavVars["VNAVDesiredState"] = "L:WTAP_Boeing_VNav_Desired_State";
    BoeingVNavVars["RNP"] = "L:WTAP_Boeing_VNav_RNP";
    BoeingVNavVars["PerformanceTODDistance"] = "L:WTAP_VNav_Distance_To_Performance_TOD";
    BoeingVNavVars["PerformanceTODLegIndex"] = "L:WTAP_VNav_Performance_TOD_Leg_Index";
    BoeingVNavVars["PerformanceTODDistanceInLeg"] = "L:WTAP_VNav_Performance_TOD_Distance_In_Leg";
})(BoeingVNavVars || (BoeingVNavVars = {}));
/** A publisher for Boeing VNAV sim var events. */
class BoeingVNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(BoeingVNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
BoeingVNavSimVarPublisher.simvars = new Map([
    ['boeingvnav_desired_state', { name: BoeingVNavVars.VNAVDesiredState, type: SimVarValueType.Enum }],
    ['boeingvnav_rnp', { name: BoeingVNavVars.RNP, type: SimVarValueType.Number }],
    ['boeingvnav_performance_tod_distance', { name: BoeingVNavVars.PerformanceTODDistance, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_leg_distance', { name: BoeingVNavVars.PerformanceTODDistanceInLeg, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_global_leg_index', { name: BoeingVNavVars.PerformanceTODLegIndex, type: SimVarValueType.Number }],
]);

/** Utils for BoeingFmaData. */
class BoeingFmaDataUtils {
    /**
     * Creates a new BoeingFmaData object.
     * @returns a new BoeingFmaData object.
     */
    static createBoeingFmaData() {
        return {
            verticalActive: APVerticalModes.NONE,
            verticalArmed: APVerticalModes.NONE,
            verticalDegraded: false,
            lateralActive: APLateralModes.NONE,
            lateralArmed: APLateralModes.NONE,
            lateralDegraded: false,
        };
    }
}

/**
 * Valid CDI scale labels for the LVar scale enum.
 */
var CDIScaleLabel;
(function (CDIScaleLabel) {
    CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
    CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
    CDIScaleLabel[CDIScaleLabel["TerminalDeparture"] = 2] = "TerminalDeparture";
    CDIScaleLabel[CDIScaleLabel["TerminalArrival"] = 3] = "TerminalArrival";
    CDIScaleLabel[CDIScaleLabel["Enroute"] = 4] = "Enroute";
    CDIScaleLabel[CDIScaleLabel["Oceanic"] = 5] = "Oceanic";
    CDIScaleLabel[CDIScaleLabel["Approach"] = 6] = "Approach";
    CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 7] = "MissedApproach";
})(CDIScaleLabel || (CDIScaleLabel = {}));
/**
 * Sim var names for Boeing LNAV-related data.
 */
var BoeingLNavDataVars;
(function (BoeingLNavDataVars) {
    /** The global leg index of the flight plan leg that is nominally being tracked by LNAV. */
    BoeingLNavDataVars["NominalLegIndex"] = "L:WTBoeing_LNavData_Nominal_Leg_Index";
    /** The current CDI scale label. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    BoeingLNavDataVars["CDIScaleLabel"] = "L:WTBoeing_LNavData_CDI_Scale_Label";
    /** The current lateral RNP in nautical miles */
    BoeingLNavDataVars["RNP"] = "L:WTBoeing_LNavData_RNP";
    /** The nominal distance remaining to the end of the currently tracked flight plan leg. */
    BoeingLNavDataVars["TrackedLegEndDistance"] = "L:WTBoeing_LNavData_Tracked_Leg_End_Distance";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Distance_Direct";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationRunwayDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Runway_Distance_Direct";
    /** The flight plan distance to the final approach fix, in nautical miles. */
    BoeingLNavDataVars["FafDistance"] = "L:WTBoeing_LNavData_Faf_Distance";
    /** The direct distance to the missed approach point fix, in nautical miles, or -1 if invalid. */
    BoeingLNavDataVars["MapDistanceDirect"] = "L:WTBoeing_LNavData_Map_Distance";
    /** The total direct distance in nautical miles, or 0 when invalid. */
    BoeingLNavDataVars["TotalDistanceDirect"] = "L:WTBoeing_LNavData_Total_Distance_Direct";
})(BoeingLNavDataVars || (BoeingLNavDataVars = {}));
/**
 * A publisher for Boeing LNAV-related data sim var events.
 */
class BoeingLNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(BoeingLNavDataSimVarPublisher.simvars, bus);
    }
}
BoeingLNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale_label', { name: BoeingLNavDataVars.CDIScaleLabel, type: SimVarValueType.Number }],
    ['lnavdata_rnp', { name: BoeingLNavDataVars.RNP, type: SimVarValueType.Number }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }],
    ['lnavdata_total_distance_direct', { name: BoeingLNavDataVars.TotalDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_nominal_leg_index', { name: BoeingLNavDataVars.NominalLegIndex, type: SimVarValueType.Number }],
    ['lnavdata_tracked_leg_end_distance', { name: BoeingLNavDataVars.TrackedLegEndDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance_direct', { name: BoeingLNavDataVars.DestinationDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_destination_runway_distance_direct', { name: BoeingLNavDataVars.DestinationRunwayDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_faf', { name: BoeingLNavDataVars.FafDistance, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_map_direct', { name: BoeingLNavDataVars.MapDistanceDirect, type: SimVarValueType.NM }],
]);

/** base publisher for simvars */
class BoeingAPSimVarPublisher extends SimVarPublisher {
    /**
     * Create a BoeingAPSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(BoeingAPSimVarPublisher.simvars, bus, pacer);
    }
}
BoeingAPSimVarPublisher.simvars = new Map([
    ['ap_boeing_disconnected', { name: 'L:WT_Boeing_Autopilot_Disconnected', type: SimVarValueType.Bool }],
    ['ap_boeing_selected_ias', { name: 'AUTOPILOT AIRSPEED HOLD VAR:1', type: SimVarValueType.Knots }],
    ['ap_boeing_selected_mach', { name: 'AUTOPILOT MACH HOLD VAR:1', type: SimVarValueType.Number }],
    ['ap_boeing_mcp_speed_is_mach', { name: 'L:XMLVAR_AirSpeedIsInMach', type: SimVarValueType.Bool }],
    ['ap_boeing_track_mode_active', { name: 'L:XMLVAR_TRK_MODE_ACTIVE', type: SimVarValueType.Bool }],
    ['ap_boeing_approach_mode_armed', { name: 'L:AP_APR_ARMED', type: SimVarValueType.Bool }],
    ['ap_boeing_autothrottle_armed', { name: 'L:AS01B_AUTO_THROTTLE_ARM_STATE', type: SimVarValueType.Bool }],
]);

/**
 * Statuses for a Boeing autothrottle.
 */
var BoeingAutothrottleStatus;
(function (BoeingAutothrottleStatus) {
    BoeingAutothrottleStatus["Off"] = "Off";
    BoeingAutothrottleStatus["Disconnected"] = "Disconnected";
    BoeingAutothrottleStatus["Armed"] = "Armed";
    BoeingAutothrottleStatus["On"] = "On";
})(BoeingAutothrottleStatus || (BoeingAutothrottleStatus = {}));
/**
 * Boeing autothrottle system modes.
 */
var BoeingAutothrottleModes;
(function (BoeingAutothrottleModes) {
    /** Null mode. */
    BoeingAutothrottleModes["NONE"] = "";
    /** Autothrottle servos are disabled to allow throttle to be held in place during takeoff and climb while below 400 feet AGL. */
    BoeingAutothrottleModes["TAKEOFF_HOLD"] = "TO HOLD";
    /** Autothrottle servos are disabled to allow throttle to be manipulated in FLC/VNAV SPD descent. */
    BoeingAutothrottleModes["DESCENT_HOLD"] = "DES HOLD";
    /** Autothrottle targets thrust to descent at -1250 fpm. */
    BoeingAutothrottleModes["DESCENT_THR"] = "DES THR";
    /** Autothrottle hold protection has failed. */
    BoeingAutothrottleModes["HOLD_FAIL"] = "HOLD FAIL";
    /** Autothrottle targets takeoff thrust. */
    BoeingAutothrottleModes["TO"] = "TO";
    /** Autothrottle targets CLB thrust. */
    BoeingAutothrottleModes["CLIMB"] = "CLIMB";
    /** Autothrottle targets Max Continuous thrust. */
    BoeingAutothrottleModes["CON"] = "CON";
    /** Autothrottle targets GA thrust. */
    BoeingAutothrottleModes["GA"] = "GA";
    /** Autothrottle targets thrust to climb at minimum 2000 fpm, up to GA thrust limit. */
    BoeingAutothrottleModes["GA_THR"] = "GA THR";
    /** Autothrottle targets a set airspeed. */
    BoeingAutothrottleModes["SPD"] = "SPD";
    /** Autothrottle targets idle thrust. */
    BoeingAutothrottleModes["IDLE"] = "IDLE";
    /** Autothrottle reduces throttles to idle during landing once below 40 AGL. */
    BoeingAutothrottleModes["RETARD"] = "RETARD";
})(BoeingAutothrottleModes || (BoeingAutothrottleModes = {}));

/**
 * Message categories for Boeing FMC messages
 */
var BoeingFmcErrorCategories;
(function (BoeingFmcErrorCategories) {
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["EntryErrorAdvisory"] = 0] = "EntryErrorAdvisory";
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["Advisory"] = 1] = "Advisory";
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["Communications"] = 2] = "Communications";
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["Alert"] = 3] = "Alert";
})(BoeingFmcErrorCategories || (BoeingFmcErrorCategories = {}));

/**
 * Help window message definitions - those are associated with pre-made {@link HelpWindowMessage} objects in
 * the {@link DefinedHelpWindowMessages} object. They can be thrown in CDU LSK handlers to show the associated message on the
 * help window.
 */
var BoeingFmcErrorKeys;
(function (BoeingFmcErrorKeys) {
    BoeingFmcErrorKeys["AppTuneInhibitedMcp"] = "AppTuneInhibitedMcp";
    BoeingFmcErrorKeys["DragRequired"] = "DragRequired";
    BoeingFmcErrorKeys["FmcAppModeUavailGp"] = "FmcAppModeUavailGp";
    BoeingFmcErrorKeys["FmcAppModeUavailQfe"] = "FmcAppModeUavailQfe";
    BoeingFmcErrorKeys["FmcAppTuneDisagree"] = "FmcAppTuneDisagree";
    BoeingFmcErrorKeys["InertialOriginDisagree"] = "InertialOriginDisagree";
    BoeingFmcErrorKeys["InvalidDelete"] = "InvalidDelete";
    BoeingFmcErrorKeys["GenericInvalidEntry"] = "GenericInvalidEntry";
    BoeingFmcErrorKeys["InvalidEntryRouteAirway"] = "InvalidEntryRouteAirway";
    BoeingFmcErrorKeys["InvalidEntryRouteTermination"] = "InvalidEntryRouteTermination";
    BoeingFmcErrorKeys["InvalidEntryWindDirSpdInitial"] = "InvalidEntryWindDirSpdInitial";
    BoeingFmcErrorKeys["InvalidEntryBearingDistance"] = "InvalidEntryBearingDistance";
    BoeingFmcErrorKeys["InvalidEntryAltitudeOrTime"] = "InvalidEntryAltitudeOrTime";
    BoeingFmcErrorKeys["NotInDataBase"] = "NotInDataBase";
    BoeingFmcErrorKeys["ResetMcpAlt"] = "ResetMcpAlt";
    BoeingFmcErrorKeys["RunwayNaForSid"] = "RunwayNaForSid";
    BoeingFmcErrorKeys["TakeoffFlapsDeleted"] = "TakeoffFlapsDeleted";
    BoeingFmcErrorKeys["TakeoffSpeedsDeleted"] = "TakeoffSpeedsDeleted";
    BoeingFmcErrorKeys["ThrustRequired"] = "ThrustRequired";
    BoeingFmcErrorKeys["TakeoffDataUplink"] = "TakeoffDataUplink";
    BoeingFmcErrorKeys["Generic"] = "Generic";
})(BoeingFmcErrorKeys || (BoeingFmcErrorKeys = {}));
({
    [BoeingFmcErrorKeys.AppTuneInhibitedMcp]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.DragRequired]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.FmcAppModeUavailGp]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.FmcAppModeUavailQfe]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.FmcAppTuneDisagree]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.InertialOriginDisagree]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.InvalidDelete]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.GenericInvalidEntry]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryRouteAirway]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryRouteTermination]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryWindDirSpdInitial]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryBearingDistance]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryAltitudeOrTime]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.NotInDataBase]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.ResetMcpAlt]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.RunwayNaForSid]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.TakeoffFlapsDeleted]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.TakeoffSpeedsDeleted]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.ThrustRequired]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.TakeoffDataUplink]: BoeingFmcErrorCategories.Communications,
    [BoeingFmcErrorKeys.Generic]: BoeingFmcErrorCategories.Advisory,
});

/** The state of the altitude alerter. */
var AltAlertState;
(function (AltAlertState) {
    /** Disabled Mode */
    AltAlertState[AltAlertState["DISABLED"] = 0] = "DISABLED";
    /** Armed Mode. */
    AltAlertState[AltAlertState["ARMED"] = 1] = "ARMED";
    /** Within 900 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_900"] = 2] = "WITHIN_900";
    /** Within 300 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_300"] = 3] = "WITHIN_300";
    /** Within 200 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_200"] = 4] = "WITHIN_200";
    /** Captured the preselected altitude. */
    AltAlertState[AltAlertState["CAPTURED"] = 5] = "CAPTURED";
    /** Outside of the 200ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_200"] = 6] = "DEVIATION_200";
    /** Outside of the 300ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_300"] = 7] = "DEVIATION_300";
    /** Outside of the 900ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_900"] = 8] = "DEVIATION_900";
})(AltAlertState || (AltAlertState = {}));
/** Navigation sources for lateral and vertical guidance */
var NavigationSource;
(function (NavigationSource) {
    NavigationSource[NavigationSource["NONE"] = 0] = "NONE";
    /** FMC/non-precision source i.e. LNAV or VNAV */
    NavigationSource[NavigationSource["NPS"] = 1] = "NPS";
    NavigationSource[NavigationSource["IAN"] = 2] = "IAN";
    NavigationSource[NavigationSource["ILS"] = 3] = "ILS";
    NavigationSource[NavigationSource["GLS"] = 4] = "GLS";
})(NavigationSource || (NavigationSource = {}));
/** Approach frequency tuning mode for the ILS radio */
var ApproachTuningMode;
(function (ApproachTuningMode) {
    ApproachTuningMode[ApproachTuningMode["Park"] = 0] = "Park";
    ApproachTuningMode[ApproachTuningMode["ParkTuned"] = 1] = "ParkTuned";
    ApproachTuningMode[ApproachTuningMode["Autotuned"] = 2] = "Autotuned";
    ApproachTuningMode[ApproachTuningMode["ManuallyTuned"] = 3] = "ManuallyTuned";
})(ApproachTuningMode || (ApproachTuningMode = {}));
var VorTuningMode;
(function (VorTuningMode) {
    /** The FMC isn't currently tuning a VOR */
    VorTuningMode[VorTuningMode["None"] = 0] = "None";
    /** The FMC is tuning the VOR manually entered on the CDU by the pilots */
    VorTuningMode[VorTuningMode["ManuallyTuned"] = 1] = "ManuallyTuned";
    /** The FMC is tuning a VOR required by the current procedure */
    VorTuningMode[VorTuningMode["ProcedureTuned"] = 2] = "ProcedureTuned";
    /** The FMC is tuning a VOR that features as a waypoint on the current route */
    VorTuningMode[VorTuningMode["RouteTuned"] = 3] = "RouteTuned";
    /** The FMC is tuning a suitable nearby VOR */
    VorTuningMode[VorTuningMode["AutoTuned"] = 4] = "AutoTuned";
})(VorTuningMode || (VorTuningMode = {}));
var AutolandCapability;
(function (AutolandCapability) {
    AutolandCapability[AutolandCapability["None"] = 0] = "None";
    AutolandCapability[AutolandCapability["FailPassive"] = 1] = "FailPassive";
    AutolandCapability[AutolandCapability["FailOperational"] = 2] = "FailOperational";
})(AutolandCapability || (AutolandCapability = {}));

/** Type for whether ND is in HDG up or TRK up mode. */
var BoeingNdHdgTrkUpMode;
(function (BoeingNdHdgTrkUpMode) {
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["HDG"] = 0] = "HDG";
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["TRK"] = 1] = "TRK";
})(BoeingNdHdgTrkUpMode || (BoeingNdHdgTrkUpMode = {}));
/**
 * IRS alignment time modes.
 */
var BoeingIrsAlignTimeMode;
(function (BoeingIrsAlignTimeMode) {
    /** IRS aligns instantly. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Instant"] = 0] = "Instant";
    /** IRS attitude alignment finishes in 30 seconds and full alignment finishes in 60 seconds. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Accelerated"] = 1] = "Accelerated";
    /**
     * IRS attitude alignment finishes in 30 seconds and full alignment finishes in an amount of time approximating the
     * real unit (5 minutes at the equator to 17 minutes near the poles).
     */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Realistic"] = 2] = "Realistic";
})(BoeingIrsAlignTimeMode || (BoeingIrsAlignTimeMode = {}));
const boeingMsfsUserSettings = [
    {
        name: 'boeingMsfsNdHdgTrkUpMode',
        defaultValue: BoeingNdHdgTrkUpMode.TRK,
    },
    {
        name: 'boeingMsfsIrsAlignTime',
        defaultValue: BoeingIrsAlignTimeMode.Accelerated,
    },
    {
        name: 'boeingMsfsSelcal',
        defaultValue: 'DM-ES',
    },
];
/**
 * Utility class for retrieving boeing msfs user setting managers.
 * These are user settings for Boeing aircraft and are meant to be persistent.
 */
class BoeingMsfsUserSettings {
    /**
     * Retrieves a manager for boeing msfs user settings.
     * @param bus The event bus.
     * @returns a manager for boeing msfs user settings.
     */
    static getManager(bus) {
        if (BoeingMsfsUserSettings.INSTANCE === undefined) {
            BoeingMsfsUserSettings.INSTANCE = new DefaultUserSettingManager(bus, boeingMsfsUserSettings);
        }
        return BoeingMsfsUserSettings.INSTANCE;
    }
}

const refsSettings = [
    {
        name: 'minimumsMode',
        defaultValue: MinimumsMode.OFF,
    },
    {
        name: 'decisionHeightFeet',
        defaultValue: 0,
    },
    {
        name: 'decisionAltitudeFeet',
        defaultValue: 0,
    },
    {
        name: 'metricAltitudeDisplay',
        defaultValue: false,
    },
    {
        name: 'fltNumber',
        defaultValue: '',
    },
    {
        name: 'fpvActive',
        defaultValue: false,
    },
    /** The EICAS page secondary engine indicators display state. */
    {
        name: 'eicasSecondaryEngineIndicatorsOn',
        defaultValue: false,
    }
];
/** Utility class for retrieving Refs user setting managers. */
class CockpitUserSettings {
    /**
     * Retrieves a manager for Refs user settings.
     * @param bus The event bus.
     * @returns a manager for Refs user settings.
     */
    static getManager(bus) {
        if (CockpitUserSettings.INSTANCE === undefined) {
            CockpitUserSettings.INSTANCE = new DefaultUserSettingManager(bus, refsSettings);
            CockpitUserSettings.wireSettings(CockpitUserSettings.INSTANCE);
        }
        return CockpitUserSettings.INSTANCE;
    }
    /**
     * Wires up any special setttings handlers.
     * @param settingsManager The settings manager.
     */
    static wireSettings(settingsManager) {
        CockpitUserSettings.subs.push(settingsManager.getSetting('fltNumber').sub(fltNumber => {
            // strip the first 1-3 letters from the callsign to get only the numbers to feed to the default ATC
            const justTheNumber = fltNumber.includes('-') || fltNumber.length === 0
                ? '0'
                : fltNumber.replace(/^([A-Z]{1,3})/, '');
            SimVar.SetSimVarValue('ATC FLIGHT NUMBER', SimVarValueType.String, justTheNumber);
        }));
    }
}
CockpitUserSettings.subs = [];

/**
 * TCAS operating mode setting values.
 */
var TcasOperatingModeSetting;
(function (TcasOperatingModeSetting) {
    TcasOperatingModeSetting["TA_RA"] = "TA_RA";
    TcasOperatingModeSetting["TAOnly"] = "TAOnly";
    TcasOperatingModeSetting["Standby"] = "Standby";
})(TcasOperatingModeSetting || (TcasOperatingModeSetting = {}));
const trafficSettings = [
    {
        name: 'trafficOperatingMode',
        defaultValue: TcasOperatingModeSetting.TAOnly
    },
    {
        name: 'trafficShowOther',
        defaultValue: true
    },
    {
        name: 'trafficAltitudeRelative',
        defaultValue: true
    },
    {
        name: 'trafficShowAbove',
        defaultValue: false
    },
    {
        name: 'trafficShowBelow',
        defaultValue: false
    }
];
/**
 * Utility class for retrieving the traffic user setting manager.
 */
class TrafficUserSettings {
    /**
     * Retrieves a setting manager with traffic user settings.
     * @param bus The event bus.
     * @returns A setting manager with traffic user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, trafficSettings));
    }
}

var VSpeedType;
(function (VSpeedType) {
    VSpeedType["V1"] = "V1";
    VSpeedType["Vr"] = "Vr";
    VSpeedType["V2"] = "V2";
    // Venr = 'Venr',
    // Vapp = 'Vapp',
    VSpeedType["Vref"] = "Vref";
})(VSpeedType || (VSpeedType = {}));
/** Utility class for retrieving the vspeeds user setting manager. */
class VSpeedUserSettings {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        const settingDefs = [];
        for (const vspeed in VSpeedType) {
            settingDefs.push({
                name: `vspeed_value_${vspeed}`,
                defaultValue: 0
            });
        }
        this.manager = new DefaultUserSettingManager(bus, settingDefs);
    }
    /**
     * Get an instance of VSpeedUserSettings.
     * @param bus The event bus.
     * @returns An instance of VSpeedUserSettings.
     */
    static getManager(bus) {
        if (VSpeedUserSettings.INSTANCE === undefined) {
            VSpeedUserSettings.INSTANCE = new VSpeedUserSettings(bus);
        }
        return VSpeedUserSettings.INSTANCE;
    }
    /** @inheritdoc */
    getSettings(type) {
        return {
            value: this.manager.getSetting(`vspeed_value_${type}`)
        };
    }
}

// TODO consider getting limits from game vars
// add game var to get slat angles for each handle position => no config needed?
/**
 * Flap Position Computer
 * @deprecated Needs refactored into BoeingFlapSystem
 */
class FlapComputer {
    /**
     * Constructor a new FlapComputer
     * @param bus Event bus
     * @param config Flap Computer configuration
     */
    constructor(bus, config) {
        this.bus = bus;
        this.flapsLeftAngle = ConsumerSubject.create(null, 0);
        this.flapsRightAngle = ConsumerSubject.create(null, 0);
        this.slatsLeftAngle = ConsumerSubject.create(null, 0);
        this.slatsRightAngle = ConsumerSubject.create(null, 0);
        /** total gross weight in lbs */
        this.grossWeight = ConsumerSubject.create(null, 0);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.flapInterpolatedPosition = Subject.create(0);
        this.flapInterpolatedLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapLimitIndex = Subject.create(0);
        this.flapLimitPosition = Subject.create(0);
        this.flapLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapManeuverSpeed = Subject.create(0);
        this.holdingSpeed = Subject.create(0);
        this.needUpdate = true;
        this.flapPositionConfig = [...config.flap_positions].sort((a, b) => a.flapAngle === b.flapAngle ? a.slatAngle - b.slatAngle : a.flapAngle - b.flapAngle);
        this.flapSpeedLimitLookup = new LerpLookupTable(this.flapPositionConfig.filter((c) => isFinite(c.speedLimit)).map((c) => [c.speedLimit, c.label]));
        this.speedData = config.speed_data;
        const pub = this.bus.getPublisher();
        this.flapInterpolatedPosition.sub((pos) => pub.pub('flap_computer_interpolated_position', pos));
        this.flapInterpolatedLimitSpeed.sub((pos) => pub.pub('flap_computer_interpolated_limit_speed', pos));
        this.flapLimitIndex.sub((index) => pub.pub('flap_computer_limit_index', index));
        this.flapLimitPosition.sub((pos) => pub.pub('flap_computer_limit_position', pos));
        this.flapLimitSpeed.sub((speed) => pub.pub('flap_computer_limit_speed', speed));
        this.flapManeuverSpeed.sub((speed) => pub.pub('flap_computer_maneuver_speed', speed));
        this.holdingSpeed.sub((speed) => pub.pub('flap_computer_holding_speed', speed));
        this.listenToEvents();
    }
    /** Update the flap setting from the flap and slat angles */
    updateFlapPosition() {
        if (!this.needUpdate) {
            return;
        }
        this.needUpdate = false;
        // we consider the highest out of the two sides
        const actualFlapAngle = Math.max(this.flapsLeftAngle.get(), this.flapsRightAngle.get());
        const actualSlatAngle = Math.max(this.slatsLeftAngle.get(), this.slatsRightAngle.get());
        // find the flap position used for speed limit calculation (increments just after passing each position)
        let flapLimitIndex = this.flapPositionConfig.findIndex((p) => actualFlapAngle <= p.flapAngle + FlapComputer.ANGLE_TOLERANCE);
        const firstFlapPos = this.flapPositionConfig[flapLimitIndex];
        for (; flapLimitIndex < this.flapPositionConfig.length - 1; flapLimitIndex++) {
            const nextLimitPos = this.flapPositionConfig[flapLimitIndex + 1];
            if (nextLimitPos.flapAngle !== firstFlapPos.flapAngle) {
                break;
            }
            const limitPos = this.flapPositionConfig[flapLimitIndex];
            if (actualSlatAngle <= limitPos.slatAngle + FlapComputer.ANGLE_TOLERANCE) {
                break;
            }
        }
        const flapLimitPosition = this.flapPositionConfig[flapLimitIndex];
        this.flapLimitIndex.set(flapLimitIndex);
        this.flapLimitPosition.set(flapLimitPosition.label);
        this.flapLimitSpeed.set(isFinite(flapLimitPosition.speedLimit) ? flapLimitPosition.speedLimit : -1);
        this.flapManeuverSpeed.set(this.speedData.getFlapManeuverSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        this.holdingSpeed.set(this.speedData.getHoldingSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        // interpolate a position for display on the EICAS
        let interpolatedLabel = 0;
        // if we're clean, no need for interpolation
        if (flapLimitIndex > 0) {
            // choose the next index (lower flap position/angle)
            const nextLowerFlapPosition = this.flapPositionConfig[flapLimitIndex - 1];
            let k;
            if ((flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle) < FlapComputer.ANGLE_TOLERANCE) {
                // flap position doesn't change... interpolate slat angle
                k = (flapLimitPosition.slatAngle - actualSlatAngle) / (flapLimitPosition.slatAngle - nextLowerFlapPosition.slatAngle);
            }
            else {
                k = (flapLimitPosition.flapAngle - actualFlapAngle) / (flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle);
            }
            interpolatedLabel = MathUtils.clamp(Avionics.Utils.lerpAngle(flapLimitPosition.label, nextLowerFlapPosition.label, k), nextLowerFlapPosition.label, flapLimitPosition.label);
        }
        this.flapInterpolatedPosition.set(interpolatedLabel);
        if (interpolatedLabel > 0) {
            this.flapInterpolatedLimitSpeed.set(this.flapSpeedLimitLookup.get(interpolatedLabel));
        }
        else {
            this.flapInterpolatedLimitSpeed.set(-1);
        }
    }
    /** Setup event listeners */
    listenToEvents() {
        const sub = this.bus.getSubscriber();
        this.flapsLeftAngle.setConsumer(sub.on('flaps_left_angle').withPrecision(2));
        this.flapsRightAngle.setConsumer(sub.on('flaps_right_angle').withPrecision(2));
        this.slatsLeftAngle.setConsumer(sub.on('slats_left_angle').withPrecision(2));
        this.slatsRightAngle.setConsumer(sub.on('slats_right_angle').withPrecision(2));
        this.grossWeight.setConsumer(sub.on('total_weight').withPrecision(-3));
        this.pressureAlt.setConsumer(sub.on('pressure_alt').withPrecision(-3));
        sub.on('realTime').atFrequency(5).handle(this.updateFlapPosition.bind(this));
        MappedSubject.create(() => this.needUpdate = true, this.flapsLeftAngle, this.flapsRightAngle, this.slatsLeftAngle, this.slatsRightAngle, this.grossWeight, this.pressureAlt);
    }
}
FlapComputer.ANGLE_TOLERANCE = 0.25;

/**
 * Standard Boeing 787-10 names for backplane instruments and publishers.
 */
var InstrumentBackplaneNames;
(function (InstrumentBackplaneNames) {
    InstrumentBackplaneNames["Adc"] = "Adc";
    InstrumentBackplaneNames["Ahrs"] = "Ahrs";
    InstrumentBackplaneNames["Ai"] = "AI";
    InstrumentBackplaneNames["Alert"] = "Alert";
    InstrumentBackplaneNames["Ambient"] = "Ambient";
    InstrumentBackplaneNames["AntiIce"] = "AntiIce";
    InstrumentBackplaneNames["Autopilot"] = "Autopilot";
    InstrumentBackplaneNames["AutopilotRadioNav"] = "AutopilotRadioNav";
    InstrumentBackplaneNames["B78Apu"] = "B78Apu";
    InstrumentBackplaneNames["B78Door"] = "B78Door";
    InstrumentBackplaneNames["B78Gear"] = "B78Gear";
    InstrumentBackplaneNames["B78Hydraulics"] = "B78Hydraulics";
    InstrumentBackplaneNames["Base"] = "Base";
    InstrumentBackplaneNames["BoeingAutopilot"] = "BoeingAutopilot";
    InstrumentBackplaneNames["Brakes"] = "Brakes";
    InstrumentBackplaneNames["Clock"] = "Clock";
    InstrumentBackplaneNames["ControlSurfaces"] = "ControlSurfaces";
    InstrumentBackplaneNames["CockpitVars"] = "CockpitVars";
    InstrumentBackplaneNames["Eis"] = "Eis";
    InstrumentBackplaneNames["Electrical"] = "Electrical";
    InstrumentBackplaneNames["Engine"] = "Engine";
    InstrumentBackplaneNames["Fadec"] = "Fadec";
    InstrumentBackplaneNames["FuelSystem"] = "FuelSystem";
    InstrumentBackplaneNames["FuelTotalizer"] = "FuelTotalizer";
    InstrumentBackplaneNames["FmsOperatingPhase"] = "FmsOperatingPhase";
    InstrumentBackplaneNames["Gnss"] = "Gnss";
    InstrumentBackplaneNames["HEvents"] = "HEvents";
    InstrumentBackplaneNames["Hydraulics"] = "Hydraulics";
    InstrumentBackplaneNames["LNav"] = "LNav";
    InstrumentBackplaneNames["LNavData"] = "LNavData";
    InstrumentBackplaneNames["Minimums"] = "Minimums";
    InstrumentBackplaneNames["NavCom"] = "NavCom";
    InstrumentBackplaneNames["NavEvents"] = "NavEvents";
    InstrumentBackplaneNames["NavProc"] = "NavProc";
    InstrumentBackplaneNames["Pressurization"] = "Pressurization";
    InstrumentBackplaneNames["SpeedLimit"] = "SpeedLimit";
    InstrumentBackplaneNames["Sound"] = "Sound";
    InstrumentBackplaneNames["Timer"] = "Timer";
    InstrumentBackplaneNames["Traffic"] = "Traffic";
    InstrumentBackplaneNames["VNav"] = "VNav";
    InstrumentBackplaneNames["BoeingVNav"] = "BoeingVNav";
    InstrumentBackplaneNames["WeightFuel"] = "WeightFuel";
    InstrumentBackplaneNames["Xpdr"] = "Xpdr";
    InstrumentBackplaneNames["WeightAndBalance"] = "WeightAndBalance";
    InstrumentBackplaneNames["Units"] = "Units";
})(InstrumentBackplaneNames || (InstrumentBackplaneNames = {}));

/**
 * A default implementation of {@link MarkerBeaconDataProvider}.
 */
class MarkerBeaconDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param markerBeaconIndex The index of the AoA computer that is the source of this provider's data.
     */
    constructor(bus, markerBeaconIndex) {
        this.bus = bus;
        this._markerBeaconState = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.markerBeaconState = this._markerBeaconState;
        this._isDataFailed = Subject.create(false);
        /** @inheritdoc */
        this.isDataFailed = this._isDataFailed;
        this.markerSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = false;
        this.markerBeaconIndex = SubscribableUtils.toSubscribable(markerBeaconIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultMarkerBeaconDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.isPaused = paused;
        const sub = this.bus.getSubscriber();
        this.markerBeaconIndexSub = this.markerBeaconIndex.sub(index => {
            this._markerBeaconState.setConsumer(sub.on(`marker_mkr_bcn_state_${index}`));
            this.markerSystemState.setConsumer(sub.on(`marker_state_${index}`));
        }, true);
        if (paused) {
            this.pause();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultMarkerBeaconDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        this._markerBeaconState.resume();
        this.markerSystemState.resume();
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultMarkerBeaconDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        this._markerBeaconState.pause();
        this.markerSystemState.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        this._markerBeaconState.destroy();
        this.markerSystemState.destroy();
        (_a = this.markerBeaconIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/**
 * A Garmin marker beacon receiver system.
 */
class MarkerBeaconSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a marker beacon system.
     * @param index The index of the marker beacon system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `marker_state_${index}`);
        const radioAltTopic = `marker_mkr_bcn_state_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's marker beacon state data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `marker_mkr_bcn_state_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.beaconStateSub = this.bus.getSubscriber().on('marker_beacon_state').handle(val => {
            this.publisher.pub(topic, val);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.beaconStateSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.beaconStateSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

const SHORT_LLA_FORMAT_REGEX = /^([NS])(\d{2})([WE])(\d{3})$/;
const LONG_LLA_FORMAT_REGEX = /^([NS])(\d{4}(?:\.\d)?)([WE])(\d{5}(?:\.\d)?)$/;
/**
 * Utilities for parsing coordinates in the WT21 supported formats
 */
class BoeingCoordinatesUtils {
    /**
     * Parses a string according to the LAT LONG format
     *
     * @param str             the string to parse
     * @param acceptShortForm whether to accept the short (XYYZUU/XYYUUZ) formats
     *
     * @returns a {@link LatLongInterface} object if a valid LL definition and `null` otherwise
     */
    static parseLatLong(str, acceptShortForm = true) {
        if (acceptShortForm) {
            const shortMatch = SHORT_LLA_FORMAT_REGEX.exec(str);
            if (shortMatch) {
                const latDir = shortMatch[1];
                const latNum = shortMatch[2];
                const lonDir = shortMatch[3];
                const lonNum = shortMatch[4];
                const parsedLat = this.parseLatitude(latDir, latNum);
                const parsedLon = this.parseLongitude(lonDir, lonNum);
                if (!parsedLat || !parsedLon) {
                    return null;
                }
                return { lat: parsedLat, long: parsedLon };
            }
        }
        const fullMatch = LONG_LLA_FORMAT_REGEX.exec(str);
        if (!fullMatch) {
            return null;
        }
        const latDir = fullMatch[1];
        const latNum = fullMatch[2];
        const lonDir = fullMatch[3];
        const lonNum = fullMatch[4];
        // if either has a decimal, both must
        if (latNum.includes('.') !== lonNum.includes('.')) {
            return null;
        }
        const parsedLat = this.parseLatitude(latDir, latNum);
        const parsedLon = this.parseLongitude(lonDir, lonNum);
        if (!parsedLat || !parsedLon) {
            return null;
        }
        return { lat: parsedLat, long: parsedLon };
    }
    /**
     * Parses a latitude string
     *
     * @param dirStr the N or S string part
     * @param numStr the numerical string part
     *
     * @returns the latitude in degrees
     */
    static parseLatitude(dirStr, numStr) {
        let lat;
        const splitLatNum = numStr.split('.');
        const latLeft = splitLatNum[0];
        const latRight = splitLatNum[1];
        // Parse latitude degrees + minutes
        if (latLeft.length > 2) {
            const deg = parseInt(latLeft.substring(0, 2));
            const min = parseInt(latLeft.substring(2));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lat = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lat = parseInt(latLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (latRight) {
            const secs = parseFloat(`0.${latRight}`);
            const add = secs / 60;
            lat += add;
        }
        // If direction is S, negate latitude
        if (dirStr === 'S') {
            lat *= -1;
        }
        if (Math.abs(lat) > 90) {
            return null;
        }
        return lat;
    }
    /**
     * Parses a longitude string
     *
     * @param dirStr the W or E string part
     * @param numStr the numerical string part
     *
     * @returns the longitude in degrees
     */
    static parseLongitude(dirStr, numStr) {
        let lon;
        const splitLonNum = numStr.split('.');
        const lonLeft = splitLonNum[0];
        const lonRight = splitLonNum[1];
        // Parse longitude degrees + minutes
        if (lonLeft.length > 3) {
            const deg = parseInt(lonLeft.substring(0, 3));
            const min = parseInt(lonLeft.substring(3));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lon = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lon = parseInt(lonLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (lonRight) {
            const secs = parseFloat(`0.${lonRight}`);
            const add = secs / 60;
            lon += add;
        }
        // If direction is W, negate longitude
        if (dirStr === 'W') {
            lon *= -1;
        }
        if (Math.abs(lon) > 180) {
            return null;
        }
        return lon;
    }
}

/** Example match would be: `DEN270/22.5` */
const PBD_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
/** Example match would be: `DEN090/DVV180` */
const PBPB_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\w+)(\d{3}(?:\.\d)?)(?:\/(\w+))?$/;
const ATO_REGEX = /^(\w+)\/([+-]?\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
// This should technically be only TF, but that doesn't make much sense and seems like a mistake
const ATO_VALID_PREVIOUS_LEG_TYPES = [LegType.CF, LegType.DF, LegType.IF, LegType.TF, LegType.RF];
const ATO_VALID_NEXT_LEG_TYPES = [LegType.IF, LegType.TF];
/**
 * Error that can occur when creating an ATO waypoint
 */
var AlongTrackOffsetError;
(function (AlongTrackOffsetError) {
    AlongTrackOffsetError[AlongTrackOffsetError["NotAvailable"] = 0] = "NotAvailable";
    AlongTrackOffsetError[AlongTrackOffsetError["DistanceTooLarge"] = 1] = "DistanceTooLarge";
})(AlongTrackOffsetError || (AlongTrackOffsetError = {}));
/**
 * Utilities for Boeing pilot defined waypoints
 */
class BoeingPilotWaypointUtils {
    /**
     * Returns whether the limit number of pilot defined waypoints is reached
     *
     * @param facilities the existing user facilities
     *
     * @returns a boolean
     */
    static isLimitReached(facilities) {
        return facilities.length >= 50; // TODO 50 for RTE 1, 50 for RTE 2
    }
    /**
     * Returns the next available auto-generated name, given existing user facilities and an ident
     *
     * @param facilities the existing user facilities
     * @param ident      the ident of the facility
     *
     * @returns a string to be used as an ident for a user facility
     */
    static nextAutoGeneratedName(facilities, ident) {
        let suffix = 1;
        for (const facility of facilities) {
            const facIdent = ICAO.getIdent(facility.icao);
            if (facIdent.match(`${ident.substring(0, 3)}\\d\\d`)) {
                suffix++;
            }
        }
        return `${ident.substring(0, 3)}${suffix.toString().padStart(2, '0')}`;
    }
    /**
     * Returns the name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(0).padStart(2, '0');
        const longitudeSign = coordinates.lon > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.lon).toFixed(0).padStart(3, '0');
        return `${latitudeSign}${latitudeStr}${longitudeSign}${longitudeStr}`;
    }
    /**
     * Returns the internal name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongInternalIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(3);
        const longitudeSign = coordinates.long > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.long).toFixed(3);
        return `${latitudeSign}${latitudeStr}|${longitudeSign}${longitudeStr}`;
    }
    /**
     * Converts a scratchpad entry to a {@link UserFacility} if applicable
     *
     * @param fms                  the {@link BoeingFms} instance
     * @param selectWptFromIdent   the function called to select a facility
     * @param scratchpadContents   the scratchpad contents
     * @param targetGlobalLegIndex the target global leg index, if applicable
     *
     * @returns a user facility, or null if none is parsed
     */
    static async createFromScratchpadEntry(fms, selectWptFromIdent, scratchpadContents, targetGlobalLegIndex) {
        var _a, _b, _c, _d;
        const pbdMatch = BoeingPilotWaypointUtils.parsePlaceBearingDistance(scratchpadContents);
        if (pbdMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facility = await selectWptFromIdent(pbdMatch.placeIdent, fms.ppos);
            if (facility) {
                const ident = (_a = pbdMatch.newIdent) !== null && _a !== void 0 ? _a : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facility.icao));
                const usrFacility = UserFacilityUtils.createFromRadialDistance(`U      ${ident}`, facility, pbdMatch.bearing, pbdMatch.distance);
                return [usrFacility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const pbpbMatch = BoeingPilotWaypointUtils.parsePlaceBearingPlaceBearing(scratchpadContents);
        if (pbpbMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facilityA = await selectWptFromIdent(pbpbMatch.placeAIdent, fms.ppos);
            const facilityB = await selectWptFromIdent(pbpbMatch.placeBIdent, fms.ppos);
            if (facilityA && facilityB) {
                const ident = (_b = pbpbMatch.newIdent) !== null && _b !== void 0 ? _b : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facilityA.icao));
                const facility = UserFacilityUtils.createFromRadialRadial(`U      ${ident}`, facilityA, pbpbMatch.bearingA, facilityB, pbpbMatch.bearingB);
                if (!facility) {
                    return Promise.reject('NO INTERSECTION');
                }
                return [facility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const atoMatch = BoeingPilotWaypointUtils.parseAlongTrackOffset(scratchpadContents);
        if (atoMatch) {
            if (targetGlobalLegIndex === undefined) {
                throw new Error('Along-track offset can only be created by createFromScratchpadEntry is a target global leg index is specified');
            }
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const plan = fms.getPlanForFmcRender();
            const lnavActiveLegIndex = SimVar.GetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number);
            const lnavActiveLegDistanceAlong = SimVar.GetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM);
            const result = await BoeingPilotWaypointUtils.createAlongTrackOffset(fms.facLoader, plan, targetGlobalLegIndex, lnavActiveLegIndex, lnavActiveLegDistanceAlong, atoMatch.distance);
            if (!Array.isArray(result)) {
                if (result === AlongTrackOffsetError.DistanceTooLarge) {
                    return Promise.reject('DISTANCE TOO LARGE');
                }
                else {
                    return Promise.reject('ALONG TRK WPT N/A');
                }
            }
            const [usrPos, insertAfter] = result;
            const leg = plan.getLeg(targetGlobalLegIndex);
            const ident = (_c = atoMatch.newIdent) !== null && _c !== void 0 ? _c : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, (_d = leg.name) !== null && _d !== void 0 ? _d : 'USR');
            return [UserFacilityUtils.createFromLatLon(`U      ${ident}`, usrPos.lat, usrPos.lon), insertAfter];
        }
        const coordinatesMatch = BoeingCoordinatesUtils.parseLatLong(scratchpadContents);
        if (coordinatesMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
            // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
            // needed - in BoeingFmsUtils.buildBoeingLegName, we extract the values to reconstruct the short name
            const ident = BoeingPilotWaypointUtils.latLongInternalIdent(coordinatesMatch);
            return [UserFacilityUtils.createFromLatLon(`ULL    ${ident}`, coordinatesMatch.lat, coordinatesMatch.long), false];
        }
        return null;
    }
    /**
     * Parses a string according to the PB/D format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingDistanceInput} object if a valid PBD definition and `null` otherwise
     */
    static parsePlaceBearingDistance(str) {
        const match = str.match(PBD_REGEX);
        if (!match) {
            return null;
        }
        const bearing = parseFloat(match[2]);
        if (bearing < 0 || bearing > 360) {
            return null;
        }
        return {
            placeIdent: match[1],
            bearing,
            distance: parseFloat(match[3]),
            newIdent: match[4],
        };
    }
    /**
     * Parses a string according to the PB/PB format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingPlaceBearingInput} object if a valid PBPB definition and `null` otherwise
     */
    static parsePlaceBearingPlaceBearing(str) {
        const match = str.match(PBPB_REGEX);
        if (!match) {
            return null;
        }
        const bearingA = parseFloat(match[2]);
        const bearingB = parseFloat(match[4]);
        if (bearingA < 0 || bearingA > 360 || bearingA < 0 || bearingB > 360) {
            return null;
        }
        return {
            placeAIdent: match[1],
            bearingA,
            placeBIdent: match[3],
            bearingB,
            newIdent: match[5],
        };
    }
    /**
     * Parses a string according to the along-track offset format
     *
     * @param str the string to parse
     *
     * @returns a {@link AlongTrackOffsetInput} object if a valid ATO definition and `null` otherwise
     */
    static parseAlongTrackOffset(str) {
        const match = str.match(ATO_REGEX);
        if (!match) {
            return null;
        }
        return {
            placeIdent: match[1],
            distance: parseFloat(match[2]),
            newIdent: match[3],
        };
    }
    /**
     * Creates an along-track offset position with input data
     *
     * @param facLoader                  the facility loader
     * @param plan                       the flight plan the ATO is being created from
     * @param globalLegIndex             the global leg index in the plan the ATO is being created from (WT21: LSK position)
     * @param lnavActiveLegIndex         the active lnav leg index (not nominal)
     * @param lnavDistanceAlongActiveLeg the distance flown along the active lnav leg
     * @param distance                   the distance input
     *
     * @returns a {@link GeoPoint}
     */
    static async createAlongTrackOffset(facLoader, plan, globalLegIndex, lnavActiveLegIndex, lnavDistanceAlongActiveLeg, distance) {
        const planLeg = plan.tryGetLeg(globalLegIndex);
        if (planLeg) {
            const distanceNegative = distance < 0;
            // Check for the previous leg type being valid if the distance is negative
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    if (!ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType)) {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
                else {
                    return AlongTrackOffsetError.NotAvailable;
                }
            }
            let fixIcao1 = undefined;
            let fixIcao2 = undefined;
            let facility1 = undefined;
            let facility2 = undefined;
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    const legType = planLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType) && ATO_VALID_NEXT_LEG_TYPES.includes(legType)) {
                        let maxDistance = planLeg.calculated ? UnitType.NMILE.convertFrom(planLeg.calculated.distance, UnitType.METER) : -1;
                        if (lnavActiveLegIndex === globalLegIndex) {
                            maxDistance -= lnavDistanceAlongActiveLeg;
                            maxDistance = Math.max(0, maxDistance);
                        }
                        if (Math.abs(distance) < maxDistance) {
                            fixIcao1 = previousPlanLeg.leg.fixIcao;
                            fixIcao2 = planLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                }
            }
            else {
                const nextPlanLeg = plan.tryGetLeg(globalLegIndex + 1);
                if (nextPlanLeg) {
                    const legType = planLeg.leg.type;
                    const nextLegType = nextPlanLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(legType) && ATO_VALID_NEXT_LEG_TYPES.includes(nextLegType)) {
                        const maxDistance = nextPlanLeg.calculated ? UnitType.NMILE.convertFrom(nextPlanLeg.calculated.distance, UnitType.METER) : -1;
                        let minDistance = 0;
                        if (lnavActiveLegIndex === globalLegIndex + 1) {
                            minDistance = lnavDistanceAlongActiveLeg;
                        }
                        if (distance > minDistance && distance < maxDistance) {
                            fixIcao1 = planLeg.leg.fixIcao;
                            fixIcao2 = nextPlanLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                    else {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
            }
            if (fixIcao1 && fixIcao1 !== ICAO.emptyIcao && fixIcao2 && fixIcao2 !== ICAO.emptyIcao) {
                facility1 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao1), fixIcao1);
                facility2 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao2), fixIcao2);
                if (facility1 && facility2) {
                    const circle = GeoCircle.createGreatCircle(facility1, facility2);
                    const offsetOut = new Float64Array(3);
                    circle.offsetDistanceAlong(distanceNegative ? facility2 : facility1, UnitType.GA_RADIAN.convertFrom(distance, UnitType.NMILE), offsetOut);
                    const geoPoint = new GeoPoint(0, 0);
                    geoPoint.setFromCartesian(offsetOut);
                    return [geoPoint, !distanceNegative];
                }
            }
        }
        return AlongTrackOffsetError.NotAvailable;
    }
}

/**
 * Utility Methods for the Boeing FMS.
 */
class BoeingFmsUtils {
    /**
     * Gets the active segment in the Lateral Flight Plan.
     * @param plan The Lateral Flight Plan.
     * @returns The Active Flight Plan Segment or undefined.
     */
    static getActiveSegment(plan) {
        if (plan.length > 0 && plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            return plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
        }
        return undefined;
    }
    /**
     * Checks whether a leg exists in a segment with the specified ICAO and, if so, returns the leg index of that leg.
     * @param segment The segment to check for the icao.
     * @param icao The ICAO to check for in the segment.
     * @returns The segment leg index of the leg with the matching icao, or -1.
     */
    static findIcaoInSegment(segment, icao) {
        if (icao !== undefined) {
            for (let l = 0; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                if (leg !== undefined && leg.leg !== undefined && leg.leg.fixIcao && leg.leg.fixIcao === icao) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        return FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: isOriginRunway
                ? oneWayRunway.elevation
                : oneWayRunway.elevation + UnitType.METER.convertFrom(50, UnitType.FOOT) // Arrival runway leg altitude should be 50 feet above threshold
        });
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param facRepo is a facility repository in which to store the created faf leg facility
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param finalLegVpa is the vertical path angle selected for the final approach, or undefined if not applicable.
     * @returns an approach procedure.
     */
    static buildVisualApproach(facRepo, airport, runway, finalLegDistance, finalLegVpa) {
        const runwayVec = GeoPoint.sphericalToCartesian(runway.latitude, runway.longitude, BoeingFmsUtils.vec3Cache[0]);
        const approachPath = BoeingFmsUtils.geoCircleCache[0].setAsGreatCircle(runwayVec, runway.course);
        const runwayCode = RunwayUtils.getRunwayCode(runway.direction);
        const runwayLetter = RunwayUtils.getDesignatorLetter(runway.runwayDesignator).padStart(1, ' ');
        const fafLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(-finalLegDistance, UnitType.GA_RADIAN), BoeingFmsUtils.geoPointCache[0]);
        const runwayIdent = RunwayUtils.getRunwayNameString(runway.direction, runway.runwayDesignator);
        const finalLegIdent = `${finalLegVpa !== undefined ? 'FA' : 'RX'}${runwayIdent}`;
        const icao = `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`;
        // Add facility to facRepo
        const fafFacility = UserFacilityUtils.createFromLatLon(icao, fafLatLon.lat, fafLatLon.lon);
        facRepo.add(fafFacility);
        const fafLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: icao,
            course: MagVar.trueToMagnetic(approachPath.bearingAt(fafLatLon), fafLatLon),
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + (Math.tan(UnitType.DEGREE.convertTo(finalLegVpa !== null && finalLegVpa !== void 0 ? finalLegVpa : 3, UnitType.RADIAN)) * UnitType.NMILE.convertTo(finalLegDistance, UnitType.METER)),
        });
        const runwayLeg = BoeingFmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.verticalAngle = finalLegVpa !== undefined ? 360 - Math.abs(finalLegVpa) : 0;
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        return {
            name: `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [],
            finalLegs: finalLegs,
            missedLegs: [],
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approachType The approach type.
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a tunable localizer.
     * @param approachType The approach type.
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets the procedure index and transition index from procedure details of the lateral plan based on segment type.
     * @param segmentType The segment type.
     * @param lateralPlan The lateral flight plan.
     * @returns an array of procedureIndex, transitionIndex.
     */
    static getProcedureIndexAndTransitionIndexFromSegmentType(segmentType, lateralPlan) {
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return [lateralPlan.procedureDetails.departureIndex, lateralPlan.procedureDetails.departureTransitionIndex];
            case FlightPlanSegmentType.Arrival:
                return [lateralPlan.procedureDetails.arrivalIndex, lateralPlan.procedureDetails.arrivalTransitionIndex];
            case FlightPlanSegmentType.Approach:
                return [lateralPlan.procedureDetails.approachIndex, lateralPlan.procedureDetails.approachTransitionIndex];
        }
        return [-1, -1];
    }
    /**
     * Combiner method to get a procedure name as a string for the FPLN Page.
     * @param segmentType The segment type.
     * @param facility The facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The transition index.
     * @returns the name as a string.
     */
    static getProcedureNameAsString(segmentType, facility, procedureIndex, transitionIndex) {
        if (facility === undefined) {
            return 'NO FACILITY';
        }
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return this.getDepartureNameAsString(facility, procedureIndex);
            case FlightPlanSegmentType.Arrival:
                if (transitionIndex !== undefined) {
                    return this.getArrivalNameAsString(facility, procedureIndex, transitionIndex);
                }
                break;
            case FlightPlanSegmentType.Approach:
                if (procedureIndex === -1 && transitionIndex === -1) {
                    // must be visual
                    return 'VISUAL';
                }
                else if (transitionIndex !== undefined) {
                    return this.getApproachNameAsString(facility, procedureIndex, transitionIndex);
                }
        }
        return 'PROC NAME ERROR';
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @returns The name of the departure procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getDepartureNameAsString(facility, procedureIndex) {
        // let name = '';
        const departure = facility.departures[procedureIndex];
        // if (runway) {
        //   name += `RW${runway.designation}.`;
        // }
        // const transition = departure.enRouteTransitions[transitionIndex];
        // if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        // } else if (departure.commonLegs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        // } else {
        //   name += `${departure.name}`;
        // }
        return `${departure.name}`;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param facility The airport to which the arrival belongs.
     * @param procedureIndex An arrival procedure index.
     * @param transitionIndex The index of the arrival enroute transition.
     * @returns The name of the arrival procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getArrivalNameAsString(facility, procedureIndex, transitionIndex) {
        const arrival = facility.arrivals[procedureIndex];
        // TODO We may need to add back the transition name
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            return `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            return `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        // else if (arrival.commonLegs.length > 0) {
        //   name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival?.name}`;
        // }
        // if (runway) {
        //   name += `.RW${runway.designation}`;
        // }
        // return `${arrival?.name}`;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @param transitionIndex The transition index.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc, transitionIndex) {
        let type;
        // let subtype: string | undefined;
        // let rnavType: string | undefined;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNV';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'BCS';
                break; // no idea if this is the real format
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        let transition = undefined;
        if (transitionIndex > -1 && proc.transitions.length > 0) {
            transition = proc.transitions[transitionIndex].name;
        }
        return {
            type: type,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            transition: transition
        };
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    /**
     * Utility method that gets an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param facility The Facility.
     * @param procedureIndex The approach index.
     * @param transitionIndex The index of the approach transition.
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(facility, procedureIndex, transitionIndex) {
        const approach = facility.approaches[procedureIndex];
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, transitionIndex);
        let name = parts.transition ? parts.transition + '.' + parts.type : parts.type;
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        // parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Get the name of an approach in the format used on the EFIS
     * @param facilityOrApproach Either an airport facility (if combined with a procedure as the second arg) or an approach procedure
     * @param procedureIndex Index of the desired approach if the first arg is an airport facility
     * @returns formatted approach name ready for EFIS display
     */
    static getApproachNameAsEfisString(facilityOrApproach, procedureIndex) {
        var _a, _b;
        const approach = 'airportPrivateType' in facilityOrApproach ? facilityOrApproach.approaches[procedureIndex !== null && procedureIndex !== void 0 ? procedureIndex : -1] : facilityOrApproach;
        if (!approach) {
            return '???';
        }
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, -1);
        if (parts.runway) {
            return `${parts.type}${(_a = parts.suffix) !== null && _a !== void 0 ? _a : ''} ${parts.runway}`;
        }
        else {
            return `${parts.type}${(_b = parts.suffix) !== null && _b !== void 0 ? _b : ''}`;
        }
    }
    /**
     * Checks whether an approach has a primary NAV frequency based on its type. Only approaches of the following types
     * have primary NAV frequencies: ILS, LOC (BC), LDA, SDF, VOR(DME).
     * @param approach The approach to check.
     * @returns Whether the specified approach has a primary NAV frequency based on its type.
     */
    static approachHasNavFrequency(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
     * which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLeg(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return undefined;
        }
        for (leg of plan.legs(true, plan.getLegIndexFromLeg(leg))) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
     * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return -1;
        }
        let index = plan.getLegIndexFromLeg(leg);
        for (leg of plan.legs(true, index)) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return index;
            }
            index--;
        }
        return -1;
    }
    /**
     * Gets an altitude for display with padding, Flight Level Handling
     * @param altitudeMeters the altitude IN METERS to evaluate
     * @param transitionAltitudeFeet the transition altitude IN FEET to evaluate
     * @returns A display string
     */
    static parseAltitudeForDisplay(altitudeMeters, transitionAltitudeFeet) {
        const altitudeFeet = Math.round(UnitType.METER.convertTo(altitudeMeters, UnitType.FOOT));
        transitionAltitudeFeet = Math.round(transitionAltitudeFeet);
        if (altitudeFeet >= transitionAltitudeFeet) {
            return 'FL' + (altitudeFeet / 100).toFixed(0).padStart(3, '0');
        }
        return altitudeFeet.toFixed(0).padStart(5, ' ');
    }
    /**
     * Checks if leg type is an "arc" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isArcLeg(legType) {
        return arcLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "heading to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return headingToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "hold at" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "hold at" leg type.
     */
    static isHoldAtLeg(legType) {
        return holdAtLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is an "to altitude" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return altitudeLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "course to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "course to" leg type.
     */
    static isCourseToLeg(legType) {
        return courseToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "discontinuity" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "discontinuity" leg type.
     */
    static isDiscontinuityLeg(legType) {
        return discontinuityLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "vectors" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "vectors" leg type.
     */
    static isVectorsLeg(legType) {
        return vectorsTypes.includes(legType);
    }
    /**
     * Gets the direct to magnetic course from the leg vectors.
     * @param leg The Leg Definition
     * @returns the magnetic course.
     */
    static getDirectToCourse(leg) {
        let course = 360;
        if (leg.leg.type === LegType.DF && leg.calculated !== undefined) {
            const vector = leg.calculated.flightPath[leg.calculated.flightPath.length - 1];
            if (vector !== undefined) {
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                // If it is a great circle, then it's basically the "straight" part of the path, so we want to get the bearing at the start,
                // otherwise it's the turn, so we want the bearing from the end of the turn.
                const point = circle.isGreatCircle()
                    ? BoeingFmsUtils.geoPointCache[0].set(vector.startLat, vector.startLon)
                    : BoeingFmsUtils.geoPointCache[0].set(vector.endLat, vector.endLon);
                course = circle.bearingAt(point, Math.PI);
                course = MagVar.trueToMagnetic(course, MagVar.get(point));
            }
        }
        else if (leg.leg.type === LegType.CF && leg.calculated !== undefined) {
            course = leg.leg.course;
        }
        return course;
    }
    /**
     * Checks for an airway at a leg and returns the airway or undefined
     * @param facLoader The facility loader.
     * @param icao The icao of the entry to check.
     * @param airwayName The airway to search for.
     * @returns The airway object or undefined
     */
    static async isAirwayAtLeg(facLoader, icao, airwayName) {
        const facility = await facLoader.getFacility(FacilityType.Intersection, icao);
        if (facility) {
            const matchedRoute = facility.routes.find((r) => r.name === airwayName);
            if (matchedRoute) {
                const airway = await facLoader.getAirway(matchedRoute.name, matchedRoute.type, icao);
                return airway;
            }
        }
        return undefined;
    }
    /**
     * Looks for an airway with name {@link airwayBName} crossing one of the fixes of airway {@link airwayA}
     *
     * @param facLoader the facility loader
     * @param airwayA the airway to look for intersections in
     * @param airwayBName the name of the second airway
     *
     * @returns a tuple of the found airway and the fix ICAO where the two airways cross
     */
    static async findAirwayCrossingAirway(facLoader, airwayA, airwayBName) {
        for (const fac of airwayA.waypoints) {
            const airwayBFacRoute = fac.routes.find((it) => it.name === airwayBName);
            if (airwayBFacRoute) {
                const airway = await facLoader.getAirway(airwayBFacRoute.name, airwayBFacRoute.type, fac.icao);
                return [airway, fac.icao];
            }
        }
    }
    /**
     * Checks for an airway exit at a given icao.
     * @param airway The Airway Object.
     * @param icao The icao of the entry to check.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static isLegValidAirwayExit(airway, icao) {
        return airway.waypoints.find((w) => w.icao === icao);
    }
    /**
     * Checks for an airway exit matching an input ident
     * @param airway The AirwayObject.
     * @param ident The Ident to search for.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static matchIdentToAirway(airway, ident) {
        return airway.waypoints.find((w) => ICAO.getIdent(w.icao) === ident);
    }
    /**
     * Checks whether a leg should appear on the Direct To Page based on leg type.
     * @param leg The FlightPlanLeg to evaluate.
     * @returns whether or not the leg should appear on the Direct To page.
     */
    static canLegBeSelectedOnDirectPage(leg) {
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
            case LegType.PI:
            case LegType.CI:
            case LegType.VI:
            case LegType.CR:
            case LegType.VR:
                return false;
            default:
                return true;
        }
    }
    /**
     * Checks whether a leg with a given type being active should cause LNAV to be auto unsuspended
     * @param legType the leg type
     * @returns a boolean
     */
    static canLegBeAutoUnsuspended(legType) {
        switch (legType) {
            case LegType.HM:
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * Builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildBoeingLegName(leg) {
        // Name for PPOS hold leg
        if (leg.fixIcao === ICAO.emptyIcao && BoeingFmsUtils.isHoldAtLeg(leg.type)) {
            return 'PPOS';
        }
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `(${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0).padEnd(5, ' ')})`;
            case LegType.FM:
            case LegType.VM:
                return 'VECTORS';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
            case LegType.PI:
                return '(INTC)';
            default:
                if (leg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(leg.fixIcao) === FacilityType.USR) {
                    const regionStr = ICAO.getRegionCode(leg.fixIcao);
                    // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
                    // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
                    // needed - here, we extract the values to reconstruct the short name
                    if (regionStr === 'LL') {
                        const ident = ICAO.getIdent(leg.fixIcao);
                        const [latStr, longStr] = ident.split('|');
                        const lat = parseFloat(latStr.replace('N', '').replace('S', '-'));
                        const long = parseFloat(longStr.replace('E', '').replace('W', '-'));
                        return BoeingPilotWaypointUtils.latLongIdent(BoeingFmsUtils.geoPointCache[1].set(lat, long));
                    }
                }
                return ICAO.getIdent(leg.fixIcao);
        }
    }
    /**
     * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
     * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
     * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
     * @param plan A flight plan.
     */
    static reconcileDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.directToData.segmentIndex = i;
                    plan.directToData.segmentLegIndex = j - 1;
                    return;
                }
            }
        }
        plan.directToData.segmentIndex = -1;
        plan.directToData.segmentLegIndex = -1;
    }
    /**
     * Removes all of a flight plan's Direct-To data, but from the DirectToData object and from any legs in the plan.
     * Scans the legs of the flight plan for Direct-To legs and removes them.
     * @param plan A flight plan.
     */
    static removeAllDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
        plan.setDirectToData(-1, true);
    }
    /**
     * Removes all of a flight plan's Displaced Active Legs,
     * which are flagged when a procedure is added and the active leg array is moved to enroute.
     * @param plan A flight plan.
     */
    static removeDisplacedActiveLegs(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
    }
    /**
     * Writes the calculated end coordinates of a leg to {@link out}, if the necessary calculated data exists
     *
     * @param leg the leg to find the end point for
     * @param out the {@link GeoPoint} to write the result to
     *
     * @returns whether anything was written
     */
    static writeLegCalculatedEndPoint(leg, out) {
        if (leg.calculated && leg.calculated.endLat && leg.calculated.endLon) {
            out.set(leg.calculated.endLat, leg.calculated.endLon);
            return true;
        }
        return false;
    }
    /**
     * Returns true if a leg is a vector of discontinuity.
     * @param leg The FlightPlanLeg
     * @returns Whether the leg is a vector of discontinuity
     */
    static isLegVectOrDisco(leg) {
        switch (leg.type) {
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return true;
            default:
                return false;
        }
    }
    /**
     * Returns hold legs in the flight plan. Used to determine and show appropriate HOLD pages.
     *
     * @param plan     the flight plan in question
     * @param inMissed whether to only include missed approach holds
     *
     * @returns the result
     */
    static getPlanHolds(plan, inMissed = false) {
        var _a;
        const holdLegs = [];
        for (const leg of plan.legs()) {
            const legSegment = (_a = plan.getSegmentFromLeg(leg)) === null || _a === void 0 ? void 0 : _a.segmentType;
            if (!inMissed && legSegment === FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (inMissed && legSegment !== FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (this.isHoldAtLeg(leg.leg.type)) {
                holdLegs.push(leg);
            }
        }
        return holdLegs;
    }
    /**
     * Returns the first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`.
     * @param plan The flight plan.
     * @param fixIcao The fix's ICAO.
     * @returns The first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`, or -1 if not found.
     * */
    static findHoldInPlan(plan, fixIcao) {
        let index = -1;
        for (const leg of plan.legs()) {
            if (leg.leg.type !== LegType.HM) {
                continue;
            }
            if (leg.leg.fixIcao === fixIcao) {
                index = plan.getLegIndexFromLeg(leg);
                break;
            }
        }
        return index;
    }
    /**
     * Calculates time in seconds to fly a certain distance at a ground speed
     *
     * @param distance distance to fly
     * @param groundSpeed GS to predict with
     *
     * @returns time in number of seconds
     */
    static estimateSecondsForDistance(distance, groundSpeed) {
        return (distance / groundSpeed) * 3600;
    }
    /**
     * Calculates distance flown for a number of seconds at a ground speed
     *
     * @param seconds time flown in number of seconds
     * @param groundSpeed GS to predict with
     *
     * @returns distance in nautical miles
     */
    static estimateDistanceForSeconds(seconds, groundSpeed) {
        return (seconds / 3600) * groundSpeed;
    }
    /**
     * Returns the index of the last non-missed approach leg in the flight plan
     *
     * @param plan the plan to use for lookup
     *
     * @returns array of index and ident, or undefined if no approach segment
     */
    static getLastNonMissedApproachLeg(plan) {
        if (plan.length === 0) {
            return -1;
        }
        let legIndex = plan.length - 1;
        while (BitFlags.isAll(plan.getLeg(legIndex).flags, LegDefinitionFlags.MissedApproach)) {
            legIndex--;
        }
        return legIndex;
    }
    /**
     * Returns the distance between the end of a leg before a discontinuity and the start of the leg after that discontinuity
     *
     * @param prevLeg the leg before the discontinuity
     * @param nextLeg the leg after the discontinuity
     *
     * @returns the great circle distance between the end of the previous leg and the start of the next leg, in metres
     */
    static distanceBetweenDiscontinuedLegs(prevLeg, nextLeg) {
        var _a, _b;
        let distance;
        if (prevLeg && nextLeg && ((_a = prevLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) && prevLeg.calculated.endLon && ((_b = nextLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLat) && nextLeg.calculated.endLon) {
            const term = new GeoPoint(prevLeg.calculated.endLat, prevLeg.calculated.endLon);
            const start = new GeoPoint(nextLeg.calculated.endLat, nextLeg.calculated.endLon);
            distance = UnitType.GA_RADIAN.convertTo(term.distance(start), UnitType.METER);
        }
        else {
            distance = 0;
        }
        return distance;
    }
    /**
     * Formats a facility frequency's type for display on the FMC
     *
     * @param frequency  the frequency
     * @param noneString (optional) the string to return when the type is "None"
     *
     * @returns a string
     */
    static formatFacilityFrequencyType(frequency, noneString = 'UNKNOWN') {
        switch (frequency.type) {
            case FacilityFrequencyType.ASOS:
                return 'ASOS';
            case FacilityFrequencyType.ATIS:
                return 'ATIS';
            case FacilityFrequencyType.AWOS:
                return 'AWOS';
            case FacilityFrequencyType.Approach:
                return 'APR';
            case FacilityFrequencyType.CPT:
            case FacilityFrequencyType.Clearance:
                return 'CLEARANCE';
            case FacilityFrequencyType.CTAF:
                return 'CTAF';
            case FacilityFrequencyType.Center:
                return 'CTR';
            case FacilityFrequencyType.Departure:
                return 'DEP';
            case FacilityFrequencyType.FSS:
                return 'FSS';
            case FacilityFrequencyType.GCO:
                return 'GCO';
            case FacilityFrequencyType.Ground:
                return 'GND';
            case FacilityFrequencyType.Multicom:
                return 'MULTICOM';
            case FacilityFrequencyType.Tower:
                return 'TWR';
            case FacilityFrequencyType.Unicom:
                return 'UNICOM';
            default:
                return noneString;
        }
    }
    /**
     * Formats a facility type (and, if applicable, VOR type) into a string
     *
     * Used on the SELECT DESIRED XXX page
     *
     * @param facility the facility
     *
     * @returns a string
     */
    static formatFacilityType(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            switch (facility.type) {
                default:
                case VorType.VOR:
                    return 'VOR';
                case VorType.VORDME:
                    return 'VORDME';
                case VorType.VORTAC:
                    return 'VORTAC';
                case VorType.TACAN:
                    return 'TACAN';
                case VorType.ILS:
                    return 'ILS';
                case VorType.DME:
                    return 'DME';
            }
        }
        else {
            switch (ICAO.getFacilityType(facility.icao)) {
                case FacilityType.Airport:
                    return 'APRT';
                case FacilityType.NDB:
                    return 'NDB';
                case FacilityType.Intersection:
                    return 'WAYPOINT';
                case FacilityType.RWY:
                    return 'RUNWAY';
                case FacilityType.USR:
                    return 'PILOT';
                case FacilityType.VIS:
                    return 'VISUAL';
                default:
                    return 'UNKNOWN';
            }
        }
    }
    /**
     * Returns the distance from PPOS to the end of a leg, given a lateral plan and a global leg index
     * @param lateralPlan the lateral plan
     * @param globalLegIndex the global leg index
     * @returns the distance, in metres
     */
    static getDistanceFromPposToLegEnd(lateralPlan, globalLegIndex) {
        var _a, _b;
        const legDistanceRemaining = SimVar.GetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM);
        const legDistanceRemainingMetres = UnitType.METER.convertFrom(legDistanceRemaining, UnitType.NMILE);
        const currentLeg = lateralPlan.getLeg(lateralPlan.activeLateralLeg);
        const targetLeg = lateralPlan.getLeg(globalLegIndex);
        if (currentLeg.calculated && targetLeg.calculated) {
            const cumulativeDistanceToCurrentLeg = (_a = currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTransitions;
            const cumulativeDistanceToTargetLeg = (_b = targetLeg.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions;
            const distanceBetweenLegs = cumulativeDistanceToTargetLeg - cumulativeDistanceToCurrentLeg;
            return legDistanceRemainingMetres + distanceBetweenLegs;
        }
        return undefined;
    }
    /**
     * Toggle assumed temp takeoff derate.
     * @param mode The takeoff thrust mode.
     * @returns The opposite derate mode of the passed fixed thrust mode.
     */
    static toggleAssumedTempDerate(mode) {
        switch (mode) {
            case TakeoffThrustMode.TO: return TakeoffThrustMode.DTO;
            case TakeoffThrustMode.TO1: return TakeoffThrustMode.DTO1;
            case TakeoffThrustMode.TO2: return TakeoffThrustMode.DTO2;
            case TakeoffThrustMode.DTO: return TakeoffThrustMode.TO;
            case TakeoffThrustMode.DTO1: return TakeoffThrustMode.TO1;
            case TakeoffThrustMode.DTO2: return TakeoffThrustMode.TO2;
        }
    }
    /**
     * Returns whether the passed takeoff thrust mode is an assumed temperature derate mode.
     * @param mode The takeoff thrust mode.
     * @returns Whether the passed takeoff thrust mode is an assumed temperature derate mode.
     */
    static thrustModeIsAssumedTemp(mode) {
        return (mode === TakeoffThrustMode.DTO ||
            mode === TakeoffThrustMode.DTO1 ||
            mode === TakeoffThrustMode.DTO2);
    }
    /**
     * Checks if two VHF frequencies are equal
     * @param frequencyA The first frequency to compare
     * @param frequencyB The second frequency to compare
     * @returns true if the frequencies are equal
     */
    static vhfFrequenciesEqual(frequencyA, frequencyB) {
        return Math.abs(frequencyA - frequencyB) < 0.0025;
    }
    /**
     * Check if a leg can contain wind data
     * @param legType Leg Type
     * @returns true if the leg is eligible for wind data
     */
    static legTypeCanHaveWind(legType) {
        switch (legType) {
            case LegType.AF:
            case LegType.CF:
            case LegType.DF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.IF:
            case LegType.RF:
            case LegType.TF:
                return true;
            default:
                return false;
        }
    }
    /**
     * Get a basic facility with only the properties of {@link Facility} from any facility.
     * @param facility The facility.
     * @returns A facility instance with only the basic subset of properties.
     */
    static getBaseFacility(facility) {
        return {
            icao: facility.icao,
            name: facility.name,
            lat: facility.lat,
            lon: facility.lon,
            region: facility.region,
            city: facility.city,
            magvar: facility.magvar,
        };
    }
}
BoeingFmsUtils.vec3Cache = [new Float64Array(3)];
BoeingFmsUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingFmsUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
BoeingFmsUtils.DTO_LEG_OFFSET = 3;
/**
 * Utility method to return a single RnavTypeFlag from multiple possible flags.
 * @param rnavTypeFlags The input RnavTypeFlags.
 * @returns A single RnavTypeFlag
 */
BoeingFmsUtils.getBestRnavType = ApproachUtils.getBestRnavType;
/**
 * Additional Bitflags describing a leg definition specific to the Boeing FMS
 */
var BoeingExtraLegDefinitionFlags;
(function (BoeingExtraLegDefinitionFlags) {
    /**
     * A leg that was part of the active leg pair in a procedure when the procedure was removed, and was subsequently
     * moved to another segment in the plan.
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DisplacedActiveLeg"] = 536870912] = "DisplacedActiveLeg";
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["ProcedureLeg"] = 1073741824] = "ProcedureLeg";
    /**
     * Applied to the target leg of a direct to
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DirectToTarget"] = -2147483648] = "DirectToTarget";
})(BoeingExtraLegDefinitionFlags || (BoeingExtraLegDefinitionFlags = {}));
/** Array of "arc" leg types. */
const arcLegTypes = [LegType.AF, LegType.RF];
/** Array of "heading to" leg types. */
const headingToLegTypes = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold at" leg types. */
const holdAtLegTypes = [LegType.HA, LegType.HF, LegType.HM];
/** Array of "to altitude" leg types. */
const altitudeLegTypes = [LegType.CA, LegType.FA, LegType.VA, LegType.HA];
/** Array of "course to" leg types. */
const courseToLegTypes = [LegType.CA, LegType.CF, LegType.CI];
/**
 * Array of "discontinuity" leg types
 */
const discontinuityLegTypes = [LegType.Discontinuity, LegType.ThruDiscontinuity];
/** Array of "vectors" leg types */
const vectorsTypes = [LegType.FM, LegType.VM];

/* eslint-disable max-len */
/**
 * A class for syncing a flight plan with the game
 * HINT: This class always needs to run on an instrument that has bound bing maps
 * Otherwise the GET_IS_BUSHTRIP coherent call won't return
 */
class FlightPlanAsoboSync {
    /**
     * Inits flight plan asobo sync
     */
    static async init() {
        return new Promise((resolve) => {
            if (!FlightPlanAsoboSync.fpListenerInitialized) {
                RegisterViewListener('JS_LISTENER_FLIGHTPLAN', () => {
                    FlightPlanAsoboSync.fpListenerInitialized = true;
                    resolve();
                });
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Loads the flight plan from the sim.
     * @param fms an instance of the fms
     */
    static async loadFromGame(fms) {
        await FlightPlanAsoboSync.init();
        Coherent.call('LOAD_CURRENT_ATC_FLIGHTPLAN');
        // Coherent.call('LOAD_CURRENT_GAME_FLIGHT');
        await Wait.awaitDelay(3000);
        const data = await Coherent.call('GET_FLIGHTPLAN');
        const isDirectTo = data.isDirectTo;
        let lastEnrouteSegment = 1;
        if (isDirectTo) {
            return false;
        }
        if (data.waypoints.length === 0) {
            return false;
        }
        await fms.emptyFlightPlan();
        const plan = fms.getPlanToModify();
        let originFacilityType = undefined;
        if (ICAO.isFacility(data.waypoints[0].icao)) {
            originFacilityType = ICAO.getFacilityType(data.waypoints[0].icao);
        }
        if (originFacilityType === FacilityType.Airport) {
            const originFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[0].icao), data.waypoints[0].icao);
            if (originFac !== undefined) {
                FlightPlanAsoboSync.setDeparture(originFac, data, fms);
            }
        }
        else if (originFacilityType !== undefined) {
            FlightPlanAsoboSync.buildNonAirportOriginLeg(data, plan, fms);
        }
        const destIndex = data.waypoints.length - 1;
        let destFacilityType = undefined;
        if (ICAO.isFacility(data.waypoints[destIndex].icao)) {
            destFacilityType = ICAO.getFacilityType(data.waypoints[destIndex].icao);
        }
        if (destFacilityType === FacilityType.Airport) {
            const destFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[destIndex].icao), data.waypoints[destIndex].icao);
            if (destFac !== undefined) {
                await FlightPlanAsoboSync.setDestination(destFac, data, fms);
            }
        }
        lastEnrouteSegment = FlightPlanAsoboSync.setEnroute(data, plan, fms);
        if (destFacilityType !== FacilityType.Airport && destFacilityType !== undefined) {
            FlightPlanAsoboSync.buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment);
        }
        plan.calculate(0).then(() => {
            plan.setLateralLeg(0);
        });
        return true;
    }
    /**
     * Syncs the plan back to the sim as best as possible
     * @param fms an instance of FMS
     */
    static async SaveToGame(fms) {
        var _a, _b;
        try {
            await FlightPlanAsoboSync.init();
            const plan = fms.getPrimaryFlightPlan();
            // TODO: Disable until GET_IS_BUSHTRIP is not dependent on having a bound bing map
            // const isBushtrip = await Coherent.call('GET_IS_BUSHTRIP');
            // if (isBushtrip) {
            //   return;
            // }
            await Coherent.call('SET_CURRENT_FLIGHTPLAN_INDEX', 0).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('CLEAR_CURRENT_FLIGHT_PLAN').catch((err) => console.log(JSON.stringify(err)));
            if (fms.facilityInfo.originFacility) {
                await Coherent.call('SET_ORIGIN', fms.facilityInfo.originFacility.icao, false).catch((err) => console.log(JSON.stringify(err)));
            }
            if (fms.facilityInfo.destinationFacility) {
                await Coherent.call('SET_DESTINATION', fms.facilityInfo.destinationFacility.icao, false).catch((err) => console.log(JSON.stringify(err)));
            }
            if (plan.procedureDetails.originRunway) {
                await Coherent.call('SET_ORIGIN_RUNWAY_INDEX', (_a = plan.procedureDetails.originRunway) === null || _a === void 0 ? void 0 : _a.parentRunwayIndex).catch((err) => console.log(JSON.stringify(err)));
            }
            await Coherent.call('SET_DEPARTURE_RUNWAY_INDEX', plan.procedureDetails.departureRunwayIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_DEPARTURE_PROC_INDEX', plan.procedureDetails.departureIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_DEPARTURE_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.departureTransitionIndex === -1 ? 0 : plan.procedureDetails.departureTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            // Put in the enroute waypoints
            const enrouteSegments = plan.segmentsOfType(FlightPlanSegmentType.Enroute);
            const legsToAdd = [];
            for (const segment of enrouteSegments) {
                // get legs in segment and put them into a temp array of legs to sync
                for (const leg of segment.legs) {
                    if (FlightPlanAsoboSync.isSyncableLeg(leg.leg)) {
                        legsToAdd.push(leg);
                    }
                }
            }
            // check if the last leg to sync is the destination airport and, if so, remove that leg from the array of legs to sync.
            if (legsToAdd.length > 0 && legsToAdd[legsToAdd.length - 1].leg.fixIcao === plan.destinationAirport) {
                legsToAdd.pop();
            }
            let globalIndex = 1;
            // sync the array of legs to sync to the sim flight plan
            for (const leg of legsToAdd) {
                try {
                    const facType = ICAO.getFacilityType(leg.leg.fixIcao);
                    if (facType === FacilityType.USR) {
                        const usrFac = await fms.facLoader.getFacility(facType, leg.leg.fixIcao);
                        await Coherent.call('ADD_CUSTOM_WAYPOINT', (_b = leg.name) !== null && _b !== void 0 ? _b : leg.leg.fixIcao, globalIndex, usrFac.lat, usrFac.lon, false);
                    }
                    else {
                        await Coherent.call('ADD_WAYPOINT', leg.leg.fixIcao, globalIndex, false);
                    }
                    globalIndex++;
                }
                catch (error) {
                    console.warn(`Error during fp sync: ${JSON.stringify(error)}`);
                }
            }
            await Coherent.call('SET_ARRIVAL_RUNWAY_INDEX', plan.procedureDetails.arrivalRunwayTransitionIndex === -1 ? 0 : plan.procedureDetails.arrivalRunwayTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_ARRIVAL_PROC_INDEX', plan.procedureDetails.arrivalIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_ARRIVAL_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.arrivalTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_APPROACH_INDEX', plan.procedureDetails.approachIndex).then(() => {
                Coherent.call('SET_APPROACH_TRANSITION_INDEX', plan.procedureDetails.approachTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            }).catch((err) => console.log(JSON.stringify(err)));
            const activeSegment = BoeingFmsUtils.getActiveSegment(plan);
            if ((activeSegment === null || activeSegment === void 0 ? void 0 : activeSegment.segmentType) === FlightPlanSegmentType.Approach) {
                await Coherent.call('TRY_AUTOACTIVATE_APPROACH').catch((err) => console.log(JSON.stringify(err)));
            }
            Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX').catch((err) => console.log(JSON.stringify(err)));
        }
        catch (error) {
            console.error(`Error during fp sync: ${error}`);
        }
    }
    /**
     * Checks if a leg is syncable to the stock flight plan system.
     * @param leg the leg to check
     * @returns true if the leg is syncable, false otherwise
     */
    static isSyncableLeg(leg) {
        return FlightPlanAsoboSync.nonSyncableLegTypes.indexOf(leg.type) === -1;
    }
    /**
     * Sets the departure procedure or facility if specified
     * @param facility is the origin airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns whether a departure was set.
     */
    static setDeparture(facility, data, fms) {
        let originOneWayRunway = undefined;
        if (data.originRunwayIndex > -1) {
            const oneWayRunways = [];
            let index = 0;
            facility.runways.forEach((runway) => {
                for (const rw of RunwayUtils.getOneWayRunways(runway, index)) {
                    oneWayRunways.push(rw);
                }
                index++;
            });
            oneWayRunways.sort(RunwayUtils.sortRunways);
            originOneWayRunway = oneWayRunways[data.originRunwayIndex];
        }
        if (data.departureProcIndex >= 0 && data.departureProcIndex < facility.departures.length) {
            // Runway and enroute transition indexes default to 0 even when the departure has no runway or enroute
            // transitions, so we have to do the OOB checks ourselves.
            const departure = facility.departures[data.departureProcIndex];
            if (data.departureRunwayIndex >= 0 && data.departureRunwayIndex < departure.runwayTransitions.length) {
                const runwayTransition = departure.runwayTransitions[data.departureRunwayIndex];
                const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                originOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
            }
            const enrouteTransitionIndex = data.departureEnRouteTransitionIndex < 0 || data.departureEnRouteTransitionIndex >= departure.enRouteTransitions.length
                ? -1
                : data.departureEnRouteTransitionIndex;
            fms.insertDeparture(facility, data.departureProcIndex, data.departureRunwayIndex, enrouteTransitionIndex, originOneWayRunway);
            return true;
        }
        else if (facility !== undefined) {
            fms.setOrigin(facility, originOneWayRunway);
            return true;
        }
        return false;
    }
    /**
     * Sets the destination airport
     * @param facility is the destination airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns A Promise which is fulfilled with whether a destination was set.
     */
    static async setDestination(facility, data, fms) {
        let destOneWayRunway = undefined;
        let setDestination = false;
        if (data.arrivalProcIndex >= 0 && data.arrivalProcIndex < facility.arrivals.length) {
            // Runway and enroute transition indexes default to 0 even when the departure has no runway or enroute
            // transitions, so we have to do the OOB checks ourselves.
            const arrival = facility.arrivals[data.arrivalProcIndex];
            if (data.arrivalRunwayIndex >= 0 && data.arrivalRunwayIndex < arrival.runwayTransitions.length) {
                const runwayTransition = arrival.runwayTransitions[data.arrivalRunwayIndex];
                if (runwayTransition !== undefined) {
                    const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                    destOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
                }
            }
            const enrouteTransitionIndex = data.arrivalEnRouteTransitionIndex < 0 || data.arrivalEnRouteTransitionIndex >= arrival.enRouteTransitions.length
                ? -1
                : data.arrivalEnRouteTransitionIndex;
            fms.insertArrival(facility, data.arrivalProcIndex, data.arrivalRunwayIndex, enrouteTransitionIndex, destOneWayRunway);
            setDestination = true;
        }
        if (data.approachIndex !== -1) {
            const approachTransitionIndex = data.approachTransitionIndex === 0 &&
                facility.approaches[data.approachIndex].transitions.length < 1 ? -1 : data.approachTransitionIndex;
            await fms.insertApproach({ facility, approachIndex: data.approachIndex, approachTransitionIndex });
            setDestination = true;
        }
        if (facility !== undefined && data.arrivalProcIndex === -1 && data.approachIndex === -1) {
            fms.setDestination(facility);
            setDestination = true;
        }
        return setDestination;
    }
    /**
     * Sets the enroute portion of the flight plan
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of the fms
     * @returns the last enroute segment
     */
    static setEnroute(data, plan, fms) {
        const enrouteStart = (data.departureWaypointsSize == -1) ? 1 : data.departureWaypointsSize;
        const enroute = data.waypoints.slice(enrouteStart, -(Math.max(0, data.arrivalWaypointsSize) + 1));
        let custIdx = 1;
        let currentSegment = 1;
        let lastDepartureLegIcao = undefined;
        let lastLegWasAirway = false;
        if (data.departureProcIndex > -1) {
            const depSegment = plan.getSegment(0);
            if (depSegment.legs.length > 1) {
                lastDepartureLegIcao = depSegment.legs[depSegment.legs.length - 1].leg.fixIcao;
            }
        }
        for (let i = 0; i < enroute.length; i++) {
            const wpt = enroute[i];
            const segment = plan.getSegment(currentSegment);
            if (wpt.airwayIdent) {
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) ;
                else {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airwayIdent);
                        currentSegment += 1;
                        // plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                    }
                }
                for (let j = i + 1; j < enroute.length; j++) {
                    i++;
                    const airwayLeg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: enroute[j].icao
                    });
                    plan.addLeg(currentSegment, airwayLeg);
                    if (enroute[j].airwayIdent !== wpt.airwayIdent) {
                        lastLegWasAirway = enroute[j].airwayIdent ? true : false;
                        break;
                    }
                }
                plan.setAirway(currentSegment, wpt.airwayIdent + '.' + enroute[i].ident);
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? enroute[i].airwayIdent : undefined);
            }
            else {
                let skip = false;
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) {
                    skip = true;
                }
                let leg = undefined;
                if (!skip && wpt.icao.trim() == '') {
                    const re = /(?:[D][\d])|(?:DLast)|(?:TIMEVERT)|(?:TIMECLIMB)|(?:TIMECRUIS)|(?:TIMEDSCNT)|(?:TIMEAPPROACH)/;
                    skip = wpt.ident.match(re) !== null;
                }
                if (!skip && (wpt.ident === 'Custom' || wpt.icao.trim() == '')) {
                    const userFacility = UserFacilityUtils.createFromLatLon(`U      USR${custIdx.toString().padStart(2, '0')}`, wpt.lla.lat, wpt.lla.long, true, wpt.icao.trim() === '' ? wpt.ident : `Custom ${custIdx.toString().padStart(2, '0')}`);
                    fms.addUserFacility(userFacility);
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: userFacility.icao,
                        lat: wpt.lla.lat,
                        lon: wpt.lla.long
                    });
                    custIdx++;
                }
                else if (!skip && wpt.icao.trim() !== '') {
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                }
                if (leg) {
                    plan.addLeg(currentSegment, leg);
                    if (lastLegWasAirway) {
                        plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                        currentSegment += 1;
                        plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                    }
                    lastLegWasAirway = false;
                }
            }
        }
        if (plan.getSegment(currentSegment).airway) {
            currentSegment += 1;
            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
        }
        return currentSegment;
    }
    /**
     * Sets the first leg of the enroute plan as the first leg in the world map plan, but as an IF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     */
    static buildNonAirportOriginLeg(data, plan, fms) {
        const wpt = data.waypoints[0];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTD', wpt.lla.lat, wpt.lla.long, true, 'Custom Origin');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: 'U      CUSTD',
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(1, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: wpt.icao
            });
            plan.addLeg(1, leg);
        }
    }
    /**
     * Sets the last leg of the enroute plan as the last leg in the world map plan, but as an TF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     * @param lastEnrouteSegment is the last enroute segment
     */
    static buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment) {
        const wpt = data.waypoints[data.waypoints.length - 1];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTA', wpt.lla.lat, wpt.lla.long, true, 'Custom Destination');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: userFacility.icao,
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: wpt.icao
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
    }
}
// public static fpChecksum = 0;
FlightPlanAsoboSync.fpListenerInitialized = false;
FlightPlanAsoboSync.nonSyncableLegTypes = [
    LegType.Discontinuity,
    LegType.ThruDiscontinuity,
    LegType.Unknown,
    LegType.HM,
    LegType.HA,
    LegType.HF,
];

const definitions = {
    'manualZfw': {
        defaultValue: null,
    },
    'manualGw': {
        defaultValue: null,
    },
    'takeoffGw': {
        defaultValue: null,
    },
    'cruiseCg': {
        defaultValue: null,
    },
    'manualLateralRnp': {
        defaultValue: null,
    },
    'manualVerticalRnp': {
        defaultValue: null,
    },
    'takeoffFlaps': {
        defaultValue: null,
    },
    'takeoffCg': {
        defaultValue: null,
    },
    'takeoffAssumedTemp': {
        defaultValue: null,
    },
    'takeoffThrustMode': {
        defaultValue: TakeoffThrustMode.TO,
    },
    'takeoffThrustReductionPoint': {
        defaultValue: 1500,
    },
    'takeoffAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffEoAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffTemp': {
        defaultValue: null,
    },
    'takeoffWind': {
        defaultValue: null,
    },
    'takeoffRunwayWind': {
        defaultValue: null,
    },
    'takeoffRunwaySlope': {
        defaultValue: 0,
    },
    'takeoffRunwayCondition': {
        defaultValue: RunwayCondition.DRY,
    },
    'climbSpeedMaxAngle': {
        defaultValue: 215, // TODO Replace with actual value
    },
    'climbThrustMode': {
        defaultValue: ClimbThrustMode.CLB,
    },
    'climbSegmentExists': {
        defaultValue: false,
    },
    'cruiseRequiredTpr': {
        defaultValue: 0, // TODO Replace with actual value
    },
    'takeoffAirportIcao': {
        defaultValue: null,
    },
    'originRunway': {
        defaultValue: null,
    },
    'takeoffRunway': {
        defaultValue: null,
    },
    'takeoffRunwayPositionShift': {
        defaultValue: null,
    },
    'approachAirportIcao': {
        defaultValue: null,
    },
    'approachRunway': {
        defaultValue: null,
    },
    'approachLandingRef': {
        defaultValue: 1,
    },
    'glideSlope': {
        defaultValue: GlideslopeStatus.ON,
        differentiateInModPlan: true,
    },
    'approachWindCorrection': {
        defaultValue: 5,
    },
    'approachFlapSpeed': {
        defaultValue: null,
    },
    'cruiseAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedLimitCas': {
        defaultValue: 250,
    },
    'climbSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'climbSpeedRestrCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedRestrAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'descentSpeedLimitCas': {
        defaultValue: 240,
    },
    'descentSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'descentSpeedRestrCas': {
        defaultValue: null,
    },
    'descentSpeedRestrAltitude': {
        defaultValue: null,
    },
    'transitionAltitude': {
        defaultValue: 18000,
    },
    'transitionLevel': {
        defaultValue: 18000,
    },
    'stepSize': {
        defaultValue: 'ICAO',
    },
    'reserveFuel': {
        defaultValue: null,
    },
    'costIndex': {
        defaultValue: null,
    },
    'currentThrustMode': {
        defaultValue: null,
    },
    'speedMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbEconCas': {
        defaultValue: 310,
    },
    'speedClimbEconMach': {
        defaultValue: .85,
    },
    'speedClimbSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedClimbSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedCruiseEconCas': {
        defaultValue: 310,
    },
    'speedCruiseEconMach': {
        defaultValue: .850,
    },
    'speedCruiseEconUnit': {
        defaultValue: 'cas',
    },
    'speedCruiseSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedDescentEconCas': {
        defaultValue: 290,
    },
    'speedDescentEconMach': {
        defaultValue: .850,
    },
    'speedDescentSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'thermalAntiIceAltitude': {
        defaultValue: null,
    },
    'alternateCruiseAltitude': {
        defaultValue: 37000,
    },
    'alternateSpeedValue': {
        defaultValue: 250,
    },
    'alternateSpeedIsMach': {
        defaultValue: false,
    },
};

/**
 * Proxied `MutableSubscribable` that mirrors a property desired to be accessed by {@link PerformancePlanProxy}
 */
class ProxiedPerformancePlanProperty extends AbstractSubscribable {
    /**
     * Ctor
     *
     * @param key property key
     * @param proxy the proxy this property belongs to
     * @param editInPlace whether the property can be edited without a new flight plan being created
     */
    constructor(key, proxy, editInPlace = false) {
        super();
        this.key = key;
        this.proxy = proxy;
        this.editInPlace = editInPlace;
        this.targetPlan = null;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subject = Subject.create(null);
        this.backSubjectSubscription = undefined;
    }
    /**
     * Switches the target plan
     *
     * @param plan the new target plan
     */
    switchToPlan(plan) {
        var _a;
        this.targetPlan = plan;
        (_a = this.backSubjectSubscription) === null || _a === void 0 ? void 0 : _a.destroy();
        this.backSubjectSubscription = this.backingSubject().sub((it) => {
            this.subject.set(it);
        }, true);
    }
    /**
     * Returns the backing subject in the target plan for the property
     *
     * @returns the subject
     *
     * @throws if no target plan exists
     */
    backingSubject() {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        return this.targetPlan[this.key];
    }
    /**
     * Resets the property to its default value according to the default values performance plan
     */
    resetToDefault() {
        const defaultValue = this.proxy.defaultValuesPlan[this.key];
        this.proxy.onBeforeEdit(this, defaultValue);
        this.backingSubject().set(defaultValue.get());
        this.proxy.onAfterEdit(this, defaultValue);
    }
    /** @inheritDoc */
    get() {
        if (!this.targetPlan) {
            return null;
        }
        return this.backingSubject().get();
    }
    /** @inheritDoc */
    set(value) {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        this.proxy.onBeforeEdit(this, value);
        this.backingSubject().set(value);
        this.proxy.onAfterEdit(this, value);
    }
    /** @inheritDoc */
    sub(handler, initialNotify, paused) {
        return this.subject.sub(handler, initialNotify, paused);
    }
    /** @inheritDoc */
    unsub(handler) {
        return this.subject.unsub(handler);
    }
}

/**
 * Utils for performance plans
 */
class PerformancePlanUtils {
    /**
     * Serializes a plan
     *
     * @param plan the plan to serialize
     *
     * @returns the serialized JSON string
     */
    static serialize(plan) {
        const tmpObj = {};
        Object.keys(plan).forEach((key) => {
            tmpObj[key] = plan[key].get();
        });
        return JSON.stringify(tmpObj);
    }
    /**
     * Deserializes a serialized performance plan into a plan
     *
     * @param data the serialized data string
     * @param plan the plan to deserialize into
     */
    static deserializeInto(data, plan) {
        const customData = JSON.parse(data);
        Object.keys(customData).forEach((key) => {
            const value = customData[key];
            if (value !== undefined) {
                plan[key].set(value);
            }
        });
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @returns a performance plan with default values filled
     */
    static createPlanFromDefinitions() {
        const plan = {};
        for (const [key, definition] of Object.entries(definitions)) {
            plan[key] = Subject.create(definition.defaultValue);
        }
        return plan;
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @param partialProxy an object containing the callbacks to attach to the proxy
     *
     * @returns a performance plan with default values filled
     */
    static createProxyFromDefinitions(partialProxy) {
        const proxy = {
            defaultValuesPlan: partialProxy.defaultValuesPlan,
            /** @inheritDoc */
            switchToPlan(plan, initial) {
                for (const [key, definition] of Object.entries(definitions)) {
                    if (initial || definition.differentiateInModPlan) {
                        this[key].switchToPlan(plan);
                    }
                }
            },
            /** @inheritDoc */
            onBeforeEdit(property, newValue) {
                partialProxy.onBeforeEdit(property, newValue);
            },
            /** @inheritDoc */
            onAfterEdit(property, newValue) {
                partialProxy.onAfterEdit(property, newValue);
            },
        };
        for (const [key, definition] of Object.entries(definitions)) {
            const property = new ProxiedPerformancePlanProperty(key, proxy, !definition.differentiateInModPlan);
            proxy[key] = property;
        }
        return proxy;
    }
}

var AlternateDiversionMode;
(function (AlternateDiversionMode) {
    AlternateDiversionMode[AlternateDiversionMode["Direct"] = 0] = "Direct";
    AlternateDiversionMode[AlternateDiversionMode["Offset"] = 1] = "Offset";
    AlternateDiversionMode[AlternateDiversionMode["Overhead"] = 2] = "Overhead";
})(AlternateDiversionMode || (AlternateDiversionMode = {}));
var AlternateSpeedScheduleMode;
(function (AlternateSpeedScheduleMode) {
    AlternateSpeedScheduleMode["Econ"] = "ECON";
    AlternateSpeedScheduleMode["Lrc"] = "LRC";
    AlternateSpeedScheduleMode["EO"] = "EO";
    AlternateSpeedScheduleMode["EOLrc"] = "EOLRC";
    AlternateSpeedScheduleMode["CO"] = "CO";
})(AlternateSpeedScheduleMode || (AlternateSpeedScheduleMode = {}));
/**
 * Boeing alternates
 */
class BoeingAlternates {
    /**
     * Ctor
     *
     * @param bus the event bus
     * @param fms the fns
     * @param isOnPrimaryFms whether this is on the primary FMS
     */
    constructor(bus, fms, isOnPrimaryFms) {
        this.bus = bus;
        this.fms = fms;
        this.isOnPrimaryFms = isOnPrimaryFms;
        this.ignoreSync = false;
        this._alternateSub = new Map();
        this._alternatePredictionsSub = new Map();
        this.alternatesPredictionsEntries = new Map();
        this.alternatesPredictionsForcedUpdates = new Map();
        this.alternates = ArraySubject.create([null, null, null, null]);
        this.activeLeg = Subject.create(null);
        this.alternates.sub((index, type, item) => {
            var _a, _b;
            if (type === SubscribableArrayEventType.Added) {
                if (Array.isArray(item)) {
                    const arr = item;
                    for (let i = 0; i < arr.length; i++) {
                        if (this._alternateSub.has(index + i)) {
                            (_a = this._alternateSub.get(index + i)) === null || _a === void 0 ? void 0 : _a.set(item[i]);
                        }
                    }
                }
                else {
                    const sub = this._alternateSub.get(index);
                    sub === null || sub === void 0 ? void 0 : sub.set(item);
                }
            }
            else if (type === SubscribableArrayEventType.Removed || type === SubscribableArrayEventType.Cleared) {
                if (Array.isArray(item)) {
                    const arr = item;
                    for (let i = 0; i < arr.length; i++) {
                        if (this._alternateSub.has(index + i)) {
                            (_b = this._alternateSub.get(index + i)) === null || _b === void 0 ? void 0 : _b.set(null);
                        }
                    }
                }
                else {
                    const sub = this._alternateSub.get(index);
                    sub === null || sub === void 0 ? void 0 : sub.set(null);
                }
            }
        });
        const sub = this.bus.getSubscriber();
        sub.on('realTime').whenChangedBy(1000 * 60 * 5).handle(() => this.handleUpdatePredictions());
        sub.on('fplLoaded').handle((event) => this.handleFlightPlanLoaded(event));
        sub.on('fplUserDataSet').handle((event) => this.handleFlightPlanUserDataChanged(event));
        sub.on('fplActiveLegChange').handle(() => this.handleUpdateActiveLeg());
        sub.on('fplCopied').handle(() => this.handleUpdateActiveLeg());
        this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => {
            this.tryForceUpdatePredictions();
        });
    }
    /**
     * Tries to force update predictions.
     */
    tryForceUpdatePredictions() {
        var _a;
        const alternates = this.alternates.getArray();
        for (let i = 0; i < alternates.length; i++) {
            const predictions = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(this.facilityTrackingID(i));
            const sub = this._alternatePredictionsSub.get(i);
            if (!sub) {
                continue;
            }
            if (this.alternatesPredictionsForcedUpdates.get(i) || (predictions === null || predictions === void 0 ? void 0 : predictions.valid) !== ((_a = sub.get()) === null || _a === void 0 ? void 0 : _a.fob)) {
                this.alternatesPredictionsForcedUpdates.set(i, false);
                sub.set(predictions !== null && predictions !== void 0 ? predictions : null);
                sub.notify();
            }
        }
    }
    /**
     * Handles updating alternate predictions
     */
    handleUpdatePredictions() {
        const alternates = this.alternates.getArray();
        for (let i = 0; i < alternates.length; i++) {
            const predictions = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(this.facilityTrackingID(i));
            const sub = this._alternatePredictionsSub.get(i);
            if (!sub) {
                continue;
            }
            sub.set(predictions !== null && predictions !== void 0 ? predictions : null);
            sub.notify();
        }
    }
    /**
     * Handles `fplLoaded` events
     *
     * @param event the event
     */
    handleFlightPlanLoaded(event) {
        if (event.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX) {
            return;
        }
        this.readPlanAlternates();
    }
    /**
     * Handles `fplUserDataSet` events
     *
     * @param event the event
     */
    handleFlightPlanUserDataChanged(event) {
        if (this.ignoreSync) {
            return;
        }
        if (event.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX) {
            return;
        }
        if (event.key !== BoeingFms.USER_DATA_KEY_ALTN) {
            return;
        }
        this.readPlanAlternates();
    }
    /**
     * Handles updating the active leg
     */
    handleUpdateActiveLeg() {
        const plan = this.fms.getPrimaryFlightPlan();
        const leg = plan.tryGetLeg(plan.activeLateralLeg);
        this.activeLeg.set(leg);
    }
    /**
     * Returns whether an alternate exists for the specified index
     *
     * @param index the index
     *
     * @returns a boolean
     */
    hasAlternate(index) {
        return !!this.alternates.getArray()[index];
    }
    /**
     * Returns the index of an alternate from an ICAO, or -1 if the facility is not entered as an alternate
     *
     * @param fixIcao the airport ICAO
     *
     * @returns a number
     */
    getAlternateIndexByIcao(fixIcao) {
        return this.alternates.getArray().findIndex((it) => (it === null || it === void 0 ? void 0 : it.facilityIcao) === fixIcao);
    }
    /**
     * Returns a {@link Subscribable} for a position in the alternates array
     *
     * @param index the index for which to return a subscribable
     * @param initialNotify whether to initially notify
     *
     * @returns a subscribable
     */
    alternateSub(index, initialNotify = false) {
        let sub = this._alternateSub.get(index);
        if (!sub) {
            const subject = Subject.create(this.alternates.length > index ? this.alternates.get(index) : null);
            this._alternateSub.set(index, subject);
            if (initialNotify) {
                subject.set(this.alternates.length > index ? this.alternates.get(index) : null);
            }
            sub = subject;
        }
        return sub;
    }
    /**
     * Returns a {@link Subscribable} for predictions of a position in the alternates array
     *
     * @param index the index for which to return a subscribable
     *
     * @returns a subscribable
     */
    alternatePredictionsSub(index) {
        var _a;
        let sub = this._alternatePredictionsSub.get(index);
        if (!sub) {
            const trackingEntry = this.getFacilityTrackingEntryForAlternate(index);
            const subject = Subject.create(this.alternates.length > index && trackingEntry ?
                (_a = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(this.facilityTrackingID(index))) !== null && _a !== void 0 ? _a : null
                : null);
            this._alternatePredictionsSub.set(index, subject);
            sub = subject;
        }
        return sub;
    }
    /**
     * Sets the alternate in a position
     *
     * @param index the position
     * @param data the alternate data
     * @param notify whether to sync this change
     */
    setAlternate(index, data, notify = true) {
        const existing = this.alternates.get(index);
        if (this.alternates.length > index) {
            this.alternates.removeAt(index);
        }
        if (existing) {
            if (this.isOnPrimaryFms) {
                this.fms.activeRoutePredictor.stopTrackingFacility(this.facilityTrackingID(index));
            }
        }
        if (data) {
            const entry = {};
            this.createPredictionsTrackingEntryFromAlternateData(entry, data);
            this.alternatesPredictionsEntries.set(index, entry);
            this.alternatesPredictionsForcedUpdates.set(index, true);
            if (this.isOnPrimaryFms) {
                this.fms.activeRoutePredictor.startTrackingFacility(this.facilityTrackingID(index), entry);
            }
        }
        this.alternates.insert(data, index);
        if (notify) {
            this.writePlanAlternates();
        }
    }
    /**
     * Modifies the alternate in a position
     *
     * @param index the position
     * @param data the alternate data
     * @param notify whether to sync this change
     */
    modifyAlternate(index, data, notify = true) {
        const existing = this.alternates.get(index);
        Object.assign(existing, data);
        this.alternates.removeAt(index);
        this.alternates.insert(existing, index);
        const predictionsTrackingEntry = this.alternatesPredictionsEntries.get(index);
        if (predictionsTrackingEntry) {
            this.updatePredictionsTrackingEntryFromAlternateData(predictionsTrackingEntry, data);
            setTimeout(() => this.handleUpdatePredictions(), 1100);
        }
        if (notify) {
            this.writePlanAlternates();
        }
    }
    /**
     * Returns the facility predictions tracking entry, if applicable, for the given alternate index
     *
     * @param index the position
     *
     * @returns a {@link FacilityPredictionsTrackingEntry} object
     */
    getFacilityTrackingEntryForAlternate(index) {
        return this.alternatesPredictionsEntries.get(index);
    }
    /**
     * Creates a facility predictions tracking entry's values from alternate data
     *
     * @param entry the tracking entry
     * @param data the alternate data
     */
    createPredictionsTrackingEntryFromAlternateData(entry, data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const alternateSpeedMode = this.fms.activePerformancePlan.alternateSpeedValue.get();
        const alternateSpeedIsMach = this.fms.activePerformancePlan.alternateSpeedIsMach.get();
        const alternateCruiseAltitude = this.fms.activePerformancePlan.alternateCruiseAltitude.get();
        if (data.facilityIcao) {
            entry.facIcao = data.facilityIcao;
        }
        entry.predictionSpeed = alternateSpeedMode;
        entry.predictionSpeedIsMach = alternateSpeedIsMach;
        entry.predictionsAltitude = UnitType.METER.convertFrom(alternateCruiseAltitude !== null && alternateCruiseAltitude !== void 0 ? alternateCruiseAltitude : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        entry.predictionsOatAltitude = UnitType.METER.convertFrom((_a = data.oatAltitude) !== null && _a !== void 0 ? _a : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        entry.predictionsOatTemperature = (_b = data.oatTemperature) !== null && _b !== void 0 ? _b : -50; // TODO investigate proper placeholder value
        entry.predictionsWind = { direction: (_d = (_c = data.wind) === null || _c === void 0 ? void 0 : _c.direction) !== null && _d !== void 0 ? _d : 0, speed: (_f = (_e = data.wind) === null || _e === void 0 ? void 0 : _e.speed) !== null && _f !== void 0 ? _f : 0, trueDegrees: (_h = (_g = data.wind) === null || _g === void 0 ? void 0 : _g.trueDegrees) !== null && _h !== void 0 ? _h : false };
        switch (data.diversion.mode) {
            case AlternateDiversionMode.Overhead: {
                entry.startAfterFlightPlanLeg = data.diversion.legIndex;
                break;
            }
            default:
            case AlternateDiversionMode.Offset:
                entry.startAfterFlightPlanLeg = 'direct';
                break;
        }
    }
    /**
     * Update a facility predictions tracking entry's values from alternate data
     *
     * @param entry the tracking entry
     * @param data the alternate data
     */
    updatePredictionsTrackingEntryFromAlternateData(entry, data) {
        var _a, _b, _c;
        const alternateSpeedMode = this.fms.activePerformancePlan.alternateSpeedValue.get();
        const alternateSpeedIsMach = this.fms.activePerformancePlan.alternateSpeedIsMach.get();
        const alternateCruiseAltitude = this.fms.activePerformancePlan.alternateCruiseAltitude.get();
        if (data.facilityIcao) {
            entry.facIcao = data.facilityIcao;
        }
        entry.predictionSpeed = alternateSpeedMode;
        entry.predictionSpeedIsMach = alternateSpeedIsMach;
        entry.predictionsAltitude = UnitType.METER.convertFrom(alternateCruiseAltitude !== null && alternateCruiseAltitude !== void 0 ? alternateCruiseAltitude : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        if (data.oatAltitude) {
            entry.predictionsOatAltitude = UnitType.METER.convertFrom((_a = data.oatAltitude) !== null && _a !== void 0 ? _a : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        }
        if (data.oatTemperature) {
            entry.predictionsOatTemperature = (_b = data.oatTemperature) !== null && _b !== void 0 ? _b : -50; // TODO investigate proper placeholder value
        }
        if (data.wind) {
            Object.assign(entry.predictionsWind, data.wind);
        }
        if (data.diversion) {
            switch ((_c = data.diversion) === null || _c === void 0 ? void 0 : _c.mode) {
                case AlternateDiversionMode.Overhead: {
                    entry.startAfterFlightPlanLeg = data.diversion.legIndex;
                    break;
                }
                default:
                case AlternateDiversionMode.Offset:
                    entry.startAfterFlightPlanLeg = 'direct';
                    break;
            }
        }
    }
    /**
     * Reads the alternates from the RTE 1 primary flight plan
     */
    readPlanAlternates() {
        const alternates = this.fms.getFlightPlanAlternates(BoeingFms.ACT_RTE_PLAN_INDEX);
        if (!alternates) {
            return;
        }
        for (let i = 0; i < alternates.length; i++) {
            const alternate = alternates[i];
            this.setAlternate(i, alternate !== null && alternate !== void 0 ? alternate : null, false);
        }
    }
    /**
     * Writes the alternates to the RTE 1 primary flight plan
     */
    writePlanAlternates() {
        this.ignoreSync = true;
        this.fms.setFlightPlanAlternates(BoeingFms.ACT_RTE_PLAN_INDEX, this.alternates.getArray());
        this.ignoreSync = false;
    }
    /**
     * Returns a facility tracking ID from an alternate index
     * @param alternateIndex the alternate index
     * @returns a string
     */
    facilityTrackingID(alternateIndex) {
        return `altn-${alternateIndex}`;
    }
}

/** FMS Operating Phases of flight */
var FmsOperatingPhase;
(function (FmsOperatingPhase) {
    FmsOperatingPhase[FmsOperatingPhase["PREFLIGHT"] = 0] = "PREFLIGHT";
    FmsOperatingPhase[FmsOperatingPhase["TAKEOFF"] = 1] = "TAKEOFF";
    FmsOperatingPhase[FmsOperatingPhase["CLIMB"] = 2] = "CLIMB";
    FmsOperatingPhase[FmsOperatingPhase["CRUISE"] = 3] = "CRUISE";
    FmsOperatingPhase[FmsOperatingPhase["DESCENT"] = 4] = "DESCENT";
    FmsOperatingPhase[FmsOperatingPhase["APPROACH"] = 5] = "APPROACH";
    FmsOperatingPhase[FmsOperatingPhase["COMPLETE"] = 6] = "COMPLETE";
})(FmsOperatingPhase || (FmsOperatingPhase = {}));
/**
 * L Var names for FMS phase-related data.
 */
var FmsOperatingPhaseDataVars;
(function (FmsOperatingPhaseDataVars) {
    /** The current nominal desired track, in degrees true. */
    FmsOperatingPhaseDataVars["FmsOperatingPhaseVar"] = "L:WT_Boeing_Fms_Operating_Phase";
})(FmsOperatingPhaseDataVars || (FmsOperatingPhaseDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class FmsOperatingPhasePublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(FmsOperatingPhasePublisher.simvars, bus);
    }
}
FmsOperatingPhasePublisher.simvars = new Map([
    ['fms_operating_phase', { name: FmsOperatingPhaseDataVars.FmsOperatingPhaseVar, type: SimVarValueType.Enum }],
]);

/**
 * A utility class for working with Boeing flight path calculations.
 */
class BoeingFlightPathUtils {
}
/** The flight path calculator plans turns at these bank angles */
BoeingFlightPathUtils.flightPathBankAngleTable = [
    [15, 0],
    [25, 100],
    [25, 375],
    [19, 450],
];

/**
 * Sources of FMS-computed speed targets.
 */
var FmsSpeedTargetSource;
(function (FmsSpeedTargetSource) {
    /** No source. Used when FMS has no computed speed target. */
    FmsSpeedTargetSource["None"] = "None";
    /** Speed target is derived from aircraft configuration limits (flaps, gear, etc). */
    FmsSpeedTargetSource["Configuration"] = "Configuration";
    /** Speed target is derived from takeoff/go-around target */
    FmsSpeedTargetSource["ToGa"] = "ToGa";
    /** Speed target is derived from user-defined altitude speed limits (e.g. 250 knots below 10000 feet). */
    FmsSpeedTargetSource["Altitude"] = "Altitude";
    /** Speed target is derived from speed constraints in the flight plan. */
    FmsSpeedTargetSource["Constraint"] = "Constraint";
    /** Speed target is derived from VNAV climb schedule. */
    FmsSpeedTargetSource["ClimbSchedule"] = "ClimbSchedule";
    /** Speed target is derived from VNAV cruise. */
    FmsSpeedTargetSource["CruiseSchedule"] = "CruiseSchedule";
    /** Speed target is derived from VNAV descent schedule. */
    FmsSpeedTargetSource["DescentSchedule"] = "DescentSchedule";
})(FmsSpeedTargetSource || (FmsSpeedTargetSource = {}));

const TARGET_IAS_COMMANDED_TOLERANCE = 1;
const TARGET_MACH_COMMANDED_TOLERANCE = 0.01;
var BoeingAltitudeEntryType;
(function (BoeingAltitudeEntryType) {
    BoeingAltitudeEntryType["At"] = "At";
    BoeingAltitudeEntryType["Above"] = "Above";
    BoeingAltitudeEntryType["Below"] = "Below";
    BoeingAltitudeEntryType["Step"] = "Step";
})(BoeingAltitudeEntryType || (BoeingAltitudeEntryType = {}));
/**
 * Utilities for input/output of vertical leg data
 */
class BoeingVerticalIOUtils {
    /**
     * Generates vertical display data for a leg
     *
     * @param lateralLeg the lateral flight plan leg
     * @param predictions the Boeing vertical leg
     * @param transitionAltitude the currently used transition altitude
     * @param transitionLevel the currently used transition level
     * @param commandedFmcAlt the currently commanded FMC altitude
     * @param commandedFmcSpeed the currently commanded FMC speed
     * @param commandedFmcSpeedIsMach whether the currently commanded FMC speed is a Mach value
     * @param commandedFmcSpeedSource the currently commanded FMC speed source
     *
     * @returns a {@link BoeingVerticalDisplayData}
     */
    static getDisplayDataForLeg(lateralLeg, predictions, transitionAltitude, transitionLevel, commandedFmcAlt, commandedFmcSpeed, commandedFmcSpeedIsMach, commandedFmcSpeedSource) {
        let speed = undefined;
        let speedIsMach = false;
        let speedIsPredicted = false;
        if (lateralLeg.verticalData.speed > 0) {
            speed = lateralLeg.verticalData.speed;
            speedIsMach = lateralLeg.verticalData.speedUnit === SpeedUnit.MACH;
            speedIsPredicted = lateralLeg.verticalData.speedDesc === SpeedRestrictionType.Unused;
        }
        else if (predictions !== undefined && isFinite(predictions.speed)) {
            speed = predictions.speed;
            speedIsMach = predictions.isSpeedMach;
            speedIsPredicted = true;
        }
        // TODO ECON/LRC/RTA
        let speedIsCommanded = false;
        if (speed !== undefined && !speedIsPredicted && commandedFmcSpeedSource === FmsSpeedTargetSource.Constraint) {
            if (commandedFmcSpeedIsMach && speedIsMach) {
                const targetMachValid = commandedFmcSpeed > 0;
                if (targetMachValid && Math.abs(speed - commandedFmcSpeed) < TARGET_MACH_COMMANDED_TOLERANCE) {
                    speedIsCommanded = true;
                }
            }
            else if (!commandedFmcSpeedIsMach && !speedIsMach) {
                const targetIasValid = commandedFmcSpeed > 0;
                if (targetIasValid && Math.abs(speed - commandedFmcSpeed) < TARGET_IAS_COMMANDED_TOLERANCE) {
                    speedIsCommanded = true;
                }
            }
        }
        const altitudes = [];
        const altitudeSuffixes = [];
        const altitudesAreFlightLevels = [];
        let altitudesArePredicted = false;
        const phase = lateralLeg.verticalData.phase;
        const alt1Feet = UnitType.FOOT.convertFrom(lateralLeg.verticalData.altitude1, UnitType.METER);
        const alt2Feet = UnitType.FOOT.convertFrom(lateralLeg.verticalData.altitude2, UnitType.METER);
        switch (lateralLeg.verticalData.altDesc) {
            case AltitudeRestrictionType.At: {
                altitudes.push(alt1Feet);
                altitudeSuffixes.push(' ');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            }
            case AltitudeRestrictionType.AtOrAbove:
                altitudes.push(alt1Feet);
                altitudeSuffixes.push('A');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            case AltitudeRestrictionType.AtOrBelow:
                altitudes.push(alt1Feet);
                altitudeSuffixes.push('B');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            case AltitudeRestrictionType.Between:
                if (lateralLeg.verticalData.phase === VerticalFlightPhase.Climb) {
                    altitudes.push(alt2Feet);
                    altitudeSuffixes.push('A');
                    altitudesAreFlightLevels.push(alt2Feet > transitionAltitude);
                    altitudes.push(alt1Feet);
                    altitudeSuffixes.push('B');
                    altitudesAreFlightLevels.push(alt1Feet > transitionAltitude);
                }
                else {
                    altitudes.push(alt1Feet);
                    altitudeSuffixes.push('B');
                    altitudesAreFlightLevels.push(alt1Feet > transitionLevel);
                    altitudes.push(alt2Feet);
                    altitudeSuffixes.push('A');
                    altitudesAreFlightLevels.push(alt2Feet > transitionLevel);
                }
                break;
            case AltitudeRestrictionType.Unused: {
                if (predictions !== undefined && isFinite(predictions.altitude)) {
                    const endAltitudeFeet = UnitType.FOOT.convertFrom(predictions.altitude, UnitType.METER);
                    altitudes.push(endAltitudeFeet);
                    altitudeSuffixes.push(' ');
                    altitudesAreFlightLevels.push(endAltitudeFeet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                    altitudesArePredicted = true;
                }
                break;
            }
        }
        const alt1WholeFeet = MathUtils.round(alt1Feet);
        const alt2WholeFeet = MathUtils.round(alt2Feet);
        const altitudeIsCommanded = alt2Feet
            ? Math.min(alt1WholeFeet, alt2WholeFeet) <= commandedFmcAlt && commandedFmcAlt <= Math.max(alt1WholeFeet, alt2WholeFeet)
            : alt1WholeFeet === commandedFmcAlt;
        // TODO step climbs
        return {
            speed,
            speedIsMach,
            speedIsPredicted,
            speedIsCommanded,
            altitudes,
            altitudeSuffixes,
            altitudesAreFlightLevels,
            altitudesArePredicted,
            altitudeIsCommanded,
        };
    }
    /**
     * Applies a parsed modification to vertical display data to a vertical data object
     *
     * @param verticalData the vertical data object to modify
     * @param modification the modification to apply
     */
    static applyDisplayModificationToVerticalData(verticalData, modification) {
        // Handle speed modification
        if (modification.setSpeed) {
            if (typeof modification.setSpeed === 'string') ;
            else {
                verticalData.speed = modification.setSpeed;
                verticalData.speedUnit = modification.setSpeedIsMach ? SpeedUnit.MACH : SpeedUnit.IAS;
                verticalData.speedDesc = SpeedRestrictionType.At;
            }
        }
        // Handle altitude modification
        if (modification.setAltitudes.length > 0) {
            const firstEntryType = modification.setAltitudeTypes[0];
            if (firstEntryType === BoeingAltitudeEntryType.Step) ;
            else if (firstEntryType === BoeingAltitudeEntryType.At) {
                verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                verticalData.altDesc = AltitudeRestrictionType.At;
            }
            else if (firstEntryType === BoeingAltitudeEntryType.Above) {
                const secondEntryType = modification.setAltitudeTypes[1];
                // We know this must be Below
                if (secondEntryType) {
                    verticalData.altitude2 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[1], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.Between;
                }
                else {
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.AtOrAbove;
                }
            }
            else if (firstEntryType === BoeingAltitudeEntryType.Below) {
                const secondEntryType = modification.setAltitudeTypes[1];
                // We know this must be Above
                if (secondEntryType) {
                    verticalData.altitude2 = UnitType.METER.convertFrom(modification.setAltitudes[1], UnitType.FOOT);
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.Between;
                }
                else {
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.AtOrBelow;
                }
            }
        }
    }
    /**
     * Renders vertical display data for copying into the scratchpad of an FMC
     *
     * @param data the vertical display data
     *
     * @returns a string
     */
    static renderDataForScratchpad(data) {
        let str = '';
        if (data.speed !== undefined) {
            if (typeof data.speed === 'string') {
                str += data.speed.toUpperCase();
            }
            else if (data.speedIsMach) {
                str += data.speed.toFixed(3).substring(1);
            }
            else {
                str += data.speed.toFixed(0);
            }
        }
        str += '/';
        if (data.altitudes.length > 0) {
            for (let i = 0; i < data.altitudes.length; i++) {
                const altitude = data.altitudes[i];
                const isFlightLevel = data.altitudesAreFlightLevels[i];
                if (isFlightLevel) {
                    str += `FL${(altitude / 100).toFixed(0)}`;
                }
                else {
                    str += altitude.toFixed(0);
                }
                const suffix = data.altitudeSuffixes[i];
                if (suffix !== ' ') {
                    str += suffix;
                }
            }
        }
        return str;
    }
}

const VNAV_ETA_CALCS_DEBOUNCE = 750;
var CurrentFmsSpeedMode;
(function (CurrentFmsSpeedMode) {
    CurrentFmsSpeedMode["ECON"] = "ECON";
    CurrentFmsSpeedMode["LIM_SPD"] = "LIM SPD";
    CurrentFmsSpeedMode["MCP_SPD"] = "MCP SPD";
    CurrentFmsSpeedMode["EO"] = "EO";
    CurrentFmsSpeedMode["CAS"] = "CAS";
    CurrentFmsSpeedMode["MACH"] = "MACH";
})(CurrentFmsSpeedMode || (CurrentFmsSpeedMode = {}));
/**
 * Data provider for various vnav related data for the FMS VNAV Pages.
 */
class BoeingFmsVNavDataProvider {
    /**
     * CTOR
     * @param bus The event bus
     * @param fms The BoeingFms
     * @param useSyncData Whether or not to use ETA and constraint data sync'd from the event bus.
     */
    constructor(bus, fms, useSyncData) {
        this.bus = bus;
        this.fms = fms;
        this.useSyncData = useSyncData;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.simTimeValue = ConsumerValue.create(this.bus.getSubscriber().on('simTime'), -1);
        this.lateralLegIndex = ConsumerSubject.create(null, -1);
        // private readonly nominalLegIndex = ConsumerSubject.create(this.bus.getSubscriber<BoeingLNavDataEvents>()
        //   .on('lnavdata_nominal_leg_index'), -1);
        // private readonly distRemainingInLeg = ConsumerSubject.create(this.bus.getSubscriber<LNavEvents>()
        //   .on('lnav_vector_distance_remaining'), -1);
        // private readonly groundSpeed = ConsumerSubject.create(this.bus.getSubscriber<GNSSEvents>()
        //   .on('ground_speed'), -1);
        this.fmsTargetType = ConsumerSubject.create(null, FmsSpeedTargetSource.None);
        this.fmsTargetIsMach = ConsumerSubject.create(null, false);
        this.mcpSpeedActive = ConsumerSubject.create(null, false);
        this._distanceDest = ConsumerSubject.create(null, -1);
        this._distanceToc = ConsumerSubject.create(null, -1);
        this._distanceTod = ConsumerSubject.create(null, -1);
        this._distanceBod = ConsumerSubject.create(null, -1);
        this._tocLegIndex = ConsumerSubject.create(null, -1);
        this._todLegIndex = ConsumerSubject.create(null, -1);
        this._eodLegIndex = ConsumerSubject.create(null, -1);
        this._distanceTodLeg = ConsumerSubject.create(null, -1);
        this.distanceDest = this._distanceDest;
        this.distanceToc = this._distanceToc;
        this.distanceTod = this._distanceTod;
        this.distanceBod = this._distanceBod;
        this.tocLegIndex = this._tocLegIndex;
        this.todLegIndex = this._todLegIndex;
        this.bodLegIndex = this._eodLegIndex;
        this.distanceTodLeg = this._distanceTodLeg;
        this.commandedFmsAlt = ConsumerSubject.create(this.bus.getSubscriber()
            .on('vnav_next_constraint_altitude').whenChanged(), 0);
        this.speedSub = this.bus.getSubscriber();
        this.commandedFmsSpeedIas = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_ias'), -1);
        this.commandedFmsSpeedMach = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_mach'), -1);
        this.commandedFmsSpeedIsMach = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_is_mach'), false);
        this.commandedFmsSpeedSource = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_source'), FmsSpeedTargetSource.None);
        this._currentFmsClimbSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsClimbMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.ClimbSchedule:
                    if (fmsClimbMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                case FmsSpeedTargetSource.ToGa:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    return CurrentFmsSpeedMode.ECON;
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedClimbMode, this.fmsTargetIsMach);
        this.currentFmsClimbSpeedMode = this._currentFmsClimbSpeedMode;
        this._currentFmsDescentSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsDescentMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.DescentSchedule:
                    if (fmsDescentMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                case FmsSpeedTargetSource.ToGa:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    return CurrentFmsSpeedMode.ECON;
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedDescentMode, this.fmsTargetIsMach);
        this.currentFmsDescentSpeedMode = this._currentFmsDescentSpeedMode;
        this._currentFmsCruiseSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsCruiseMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.ToGa:
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    if (fmsCruiseMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedCruiseMode, this.fmsTargetIsMach);
        this.currentFmsCruiseSpeedMode = this._currentFmsCruiseSpeedMode;
        this._destinationPredictions = Subject.create(null);
        this.destinationPredictions = this._destinationPredictions;
        this._currentClimbConstraint = Subject.create(null);
        this.currentClimbConstraint = this._currentClimbConstraint;
        this._currentClimbConstraintLegDef = Subject.create(null);
        this.currentClimbConstraintLegDef = this._currentClimbConstraintLegDef;
        this._currentClimbConstraintDisplayData = Subject.create(null);
        this.currentClimbConstraintDisplayData = this._currentClimbConstraintDisplayData;
        this._currentDescentConstraint = Subject.create(null);
        this.currentDescentConstraint = this._currentDescentConstraint;
        this._currentDescentConstraintLegDef = Subject.create(null);
        this.currentDescentConstraintLegDef = this._currentDescentConstraintLegDef;
        this._currentDescentConstraintDisplayData = Subject.create(null);
        this.currentDescentConstraintDisplayData = this._currentDescentConstraintDisplayData;
        this.fmsOperatingPhaseEvents = this.bus.getSubscriber();
        this._fmsOperatingPhase = ConsumerSubject.create(this.fmsOperatingPhaseEvents.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.fmsOperatingPhase = this._fmsOperatingPhase;
        this.nextConstraintLegDef = MappedSubject.create(([climbConstraint, descentConstraint, phase]) => {
            return BoeingFmsVNavDataProvider.phasesBeforeCruise.includes(phase)
                ? climbConstraint
                : descentConstraint;
        }, this.currentClimbConstraintLegDef, this.currentDescentConstraintLegDef, this.fmsOperatingPhase);
        this._destAirportFacility = Subject.create(null);
        this.destAirportFacility = this._destAirportFacility;
        this.planChanged = false;
        this._tocEta = Subject.create(null);
        this._todEta = Subject.create(null);
        this._eodEta = Subject.create(null);
        this.tocEta = this._tocEta;
        this.todEta = this._todEta;
        this.eodEta = this._eodEta;
        this.etaTimer = new DebounceTimer();
        const fmsSpeedEventsEventSubscriber = bus.getSubscriber();
        this.fmsTargetType.setConsumer(fmsSpeedEventsEventSubscriber.on('fms_speed_computed_target_source'));
        this.fmsTargetIsMach.setConsumer(fmsSpeedEventsEventSubscriber.on('fms_speed_active_target_is_mach'));
        const vnavSub = bus.getSubscriber();
        this._distanceDest.setConsumer(vnavSub.on('lnavdata_destination_distance'));
        this._distanceToc.setConsumer(vnavSub.on('vnav_toc_distance'));
        this._distanceTod.setConsumer(vnavSub.on('vnav_tod_distance'));
        this._distanceBod.setConsumer(vnavSub.on('vnav_bod_distance'));
        this._tocLegIndex.setConsumer(vnavSub.on('vnav_toc_global_leg_index'));
        this._todLegIndex.setConsumer(vnavSub.on('vnav_tod_global_leg_index'));
        this._eodLegIndex.setConsumer(vnavSub.on('vnav_bod_global_leg_index'));
        this._distanceTodLeg.setConsumer(vnavSub.on('vnav_tod_leg_distance'));
        this.mcpSpeedActive.setConsumer(bus.getSubscriber().on('ap_selected_speed_is_manual'));
        this.lateralLegIndex.setConsumer(bus.getSubscriber().on('lnav_tracked_leg_index'));
        this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => {
            var _a;
            this._destinationPredictions.set((_a = this.fms.activeRoutePredictor.getDestinationPredictions()) !== null && _a !== void 0 ? _a : null);
            this._destinationPredictions.notify();
        });
        const fpSub = bus.getSubscriber();
        fpSub.on('fplLegChange').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplLoaded').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplCopied').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplOriginDestChanged').handle(({ planIndex, type, airport }) => {
            if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                switch (type) {
                    case OriginDestChangeType.DestinationAdded:
                        airport && this._destAirportFacility.set(airport);
                        break;
                    case OriginDestChangeType.DestinationRemoved:
                        this._destAirportFacility.set(null);
                        break;
                }
            }
        });
        this.lateralLegIndex.sub(() => {
            if (!this.fms.hasPrimaryFlightPlan()) {
                return;
            }
            this.onPlanChanged(BoeingFms.ACT_RTE_PLAN_INDEX);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, BoeingFms.ACT_RTE_PLAN_INDEX), VNAV_ETA_CALCS_DEBOUNCE);
        });
        MappedSubject.create(this.commandedFmsSpeedIas, this.commandedFmsSpeedMach, this.commandedFmsSpeedIsMach, this.commandedFmsSpeedSource, this.commandedFmsAlt).sub(() => {
            this.planChanged = true;
            this.setCurrentConstraint();
        });
        // Update the current constraints each time the path is recalculated, every three seconds
        vnavSub.on('vnav_path_calculated').handle((planIndex) => {
            this.setCurrentConstraint();
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        if (this.useSyncData) {
            this.bus.getSubscriber().on('boeing_vnav_data_constraints').handle(this.syncCurrentConstraint.bind(this));
            this.bus.getSubscriber().on('boeing_vnav_data_etas').handle(this.syncEtas.bind(this));
        }
        this.setCurrentConstraint();
        this.calculateEtasForPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Handler for flight plan changing
     *
     * @param planIndex the index of the flight plan
     */
    onPlanChanged(planIndex) {
        var _a;
        this.planChanged = true;
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            const plan = this.fms.getFlightPlan(planIndex);
            this._destAirportFacility.set((_a = plan.destinationAirport) !== null && _a !== void 0 ? _a : null);
        }
    }
    /**
     * Sets the current constraints shown by VNAV pages
     */
    setCurrentConstraint() {
        var _a, _b;
        if (this.useSyncData) {
            return;
        }
        // Only do the lookup if the flight plan has changed since the last lookup
        if (this.planChanged && this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const lateralPlan = this.fms.getFlightPlan(this.fms.getPlanIndexForFmcPage());
            const verticalPlan = this.fms.verticalPathCalculator.getVerticalFlightPlan(this.fms.getPlanIndexForFmcPage());
            const climbConstraint = VNavUtils.getCurrentClimbConstraint(verticalPlan, this.lateralLegIndex.get());
            this._currentClimbConstraint.set(climbConstraint ? climbConstraint : null);
            this._currentClimbConstraintLegDef.set(climbConstraint ? lateralPlan.tryGetLeg(climbConstraint.index) : null);
            this._currentClimbConstraintDisplayData.set(climbConstraint ? this.getVerticalDisplayData(climbConstraint.index) : null);
            const descentConstraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, this.lateralLegIndex.get());
            this._currentDescentConstraint.set(descentConstraint ? descentConstraint : null);
            this._currentDescentConstraintLegDef.set(descentConstraint ? lateralPlan.tryGetLeg(descentConstraint.index) : null);
            this._currentDescentConstraintDisplayData.set(descentConstraint ? this.getVerticalDisplayData(descentConstraint.index) : null);
            this.planChanged = false;
            this.bus.getPublisher().pub('boeing_vnav_data_constraints', {
                currentClimbConstraint: this._currentClimbConstraint.get(),
                currentClimbConstraintLegDef: (_a = climbConstraint === null || climbConstraint === void 0 ? void 0 : climbConstraint.index) !== null && _a !== void 0 ? _a : null,
                currentClimbConstraintDisplayData: this._currentClimbConstraintDisplayData.get(),
                currentDescentConstraint: this._currentDescentConstraint.get(),
                currentDescentConstraintLegDef: (_b = descentConstraint === null || descentConstraint === void 0 ? void 0 : descentConstraint.index) !== null && _b !== void 0 ? _b : null,
                currentDescentConstraintDisplayData: this._currentClimbConstraintDisplayData.get()
            }, true);
        }
    }
    /**
     * Handles sync'ing constraints from the bus.
     * @param data The constraint data to sync.
     */
    syncCurrentConstraint(data) {
        if (this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const lateralPlan = this.fms.getFlightPlan(this.fms.getPlanIndexForFmcPage());
            this._currentClimbConstraint.set(data.currentClimbConstraint);
            this._currentClimbConstraintDisplayData.set(data.currentClimbConstraintDisplayData);
            if (data.currentClimbConstraintLegDef !== null) {
                this._currentClimbConstraintLegDef.set(lateralPlan.tryGetLeg(data.currentClimbConstraintLegDef));
            }
            else {
                this._currentClimbConstraintLegDef.set(null);
            }
            this._currentDescentConstraint.set(data.currentDescentConstraint);
            this._currentDescentConstraintDisplayData.set(data.currentDescentConstraintDisplayData);
            if (data.currentDescentConstraintLegDef !== null) {
                this._currentDescentConstraintLegDef.set(lateralPlan.tryGetLeg(data.currentDescentConstraintLegDef));
            }
            else {
                this._currentDescentConstraintLegDef.set(null);
            }
        }
    }
    /**
     * Handles sync'ing ETAs from the bus.
     * @param data The ETA data to sync.
     */
    syncEtas(data) {
        this._tocEta.set(data.toc);
        this._todEta.set(data.tod);
        this._eodEta.set(data.eod);
    }
    /**
     * Calculates display data for a constraint.
     * @param globalLegIndex The global leg index of the VNAV constraint.
     * @returns An object used for rendering constraint data.
     */
    getVerticalDisplayData(globalLegIndex) {
        const legDefinition = this.fms.getPlanForFmcRender().tryGetLeg(globalLegIndex);
        const predictions = this.fms.activeRoutePredictor.getPredictionsForLeg(globalLegIndex);
        if (legDefinition) {
            const fmsCommandedSpeedValue = this.commandedFmsSpeedIsMach.get() ?
                this.commandedFmsSpeedMach.get() : this.commandedFmsSpeedIas.get();
            return BoeingVerticalIOUtils.getDisplayDataForLeg(legDefinition, predictions, this.fms.activePerformancePlan.transitionAltitude.get(), this.fms.activePerformancePlan.transitionLevel.get(), this.commandedFmsAlt.get(), fmsCommandedSpeedValue, this.commandedFmsSpeedIsMach.get(), this.commandedFmsSpeedSource.get());
        }
        else {
            return null;
        }
    }
    /**
     * Calculates leg and T/D ETAs for a plan at a given index
     *
     * @param planIndex the index of the flight plan
     */
    calculateEtasForPlan(planIndex) {
        if (this.useSyncData) {
            return;
        }
        if (!this.fms.hasFlightPlan(planIndex)) {
            return;
        }
        const lateralPlan = this.fms.getFlightPlan(planIndex);
        const verticalPath = this.fms.verticalPathCalculator.getVerticalFlightPath(this.fms.getPlanIndexForFmcPage());
        const tocLegIndex = this.tocLegIndex.get();
        const todLegIndex = this.todLegIndex.get();
        const eodLegIndex = this.bodLegIndex.get();
        if (tocLegIndex === -1) {
            this._tocEta.set(null);
        }
        if (todLegIndex === -1) {
            this._todEta.set(null);
        }
        if (eodLegIndex === -1) {
            this._eodEta.set(null);
        }
        let timestampAccumulator = this.simTimeValue.get();
        const unixDayStartMs = this.simTimeValue.get() - (this.simTimeValue.get() % (1000 * 60 * 60 * 24));
        for (let i = 0; i < lateralPlan.length; i++) {
            const leg = lateralPlan.tryGetLeg(i);
            if (leg) {
                const matchingVerticalLeg = verticalPath.legs[i];
                if (matchingVerticalLeg) {
                    let verticalLegDurationMs;
                    if (matchingVerticalLeg.vectors.length > 0) {
                        verticalLegDurationMs = matchingVerticalLeg.simDuration * 1000;
                    }
                    else {
                        const previousLeg = lateralPlan.tryGetLeg(i - 1);
                        const nextLeg = lateralPlan.tryGetLeg(i + 1);
                        const nextLegMatchingVerticalLeg = verticalPath.legs[i + 1];
                        // This is a special case for handling a situation where an IF leg is not predicted due to it following a discontinuity.
                        // We need to calculate this so that the T/D ETA can be roughly figured out (it is displayed on the VNAV CRZ page)
                        // Once BoeingVerticalPathCalculator handles predicting through discontinuities, we can remove this.
                        // FIXME remove this once the above is done
                        if (previousLeg && nextLeg && nextLegMatchingVerticalLeg && nextLegMatchingVerticalLeg.vectors.length > 0) {
                            const legEndPointExists = BoeingFmsUtils.writeLegCalculatedEndPoint(leg, this.geoPointCache[0]);
                            if (leg.leg.type === LegType.IF && legEndPointExists && BoeingFmsUtils.isDiscontinuityLeg(previousLeg.leg.type)) {
                                const legBeforeDiscontinuity = lateralPlan.tryGetLeg(i - 2);
                                const legBeforeDiscontinuityEndPointExists = legBeforeDiscontinuity && BoeingFmsUtils.writeLegCalculatedEndPoint(legBeforeDiscontinuity, this.geoPointCache[1]);
                                if (legBeforeDiscontinuityEndPointExists) {
                                    const distanceInDiscontinuity = this.geoPointCache[0].distance(this.geoPointCache[1]);
                                    const distanceInDiscontinuityNm = UnitType.NMILE.convertFrom(distanceInDiscontinuity, UnitType.GA_RADIAN);
                                    const nextLegStartAltitude = nextLegMatchingVerticalLeg.vectors[0].startAltitude;
                                    const nextLegStartPressure = AeroMath.isaPressure(nextLegStartAltitude);
                                    const nextLegSimulatedStartCas = nextLegMatchingVerticalLeg.vectors[0].startCas;
                                    const nextLegSimulatedStartTas = AeroMath.casToTas(nextLegSimulatedStartCas, nextLegStartPressure, AeroMath.isaTemperature(nextLegStartAltitude));
                                    // FIXME when we have wind/temp plan, we can use the right pressure + find ground speed
                                    const timeInDiscontinuitySeconds = (distanceInDiscontinuityNm / nextLegSimulatedStartTas) * 3600;
                                    verticalLegDurationMs = timeInDiscontinuitySeconds * 1000;
                                }
                            }
                        }
                    }
                    // Accumulate time
                    if (verticalLegDurationMs !== undefined) {
                        if (i === lateralPlan.activeLateralLeg) {
                            const activeLegPredictions = this.fms.activeRoutePredictor.getPredictionsForLeg(i);
                            if (activeLegPredictions) {
                                timestampAccumulator = activeLegPredictions.estimatedTimeOfArrival * 1000;
                            }
                        }
                        else if (i > lateralPlan.activeLateralLeg) {
                            timestampAccumulator += verticalLegDurationMs;
                        }
                    }
                    // Process TOC if on this leg
                    if (i === tocLegIndex && verticalLegDurationMs !== undefined) {
                        const tocLegDistance = this.distanceTodLeg.get();
                        let tocVector;
                        let durationToEndOfTocVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfTocVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < tocLegDistance) {
                                tocVector = vector;
                                break;
                            }
                        }
                        if (tocVector) {
                            this._tocEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfTocVectorMs);
                        }
                        else {
                            this._tocEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                    // Process TOD if on this leg
                    if (i === todLegIndex && verticalLegDurationMs !== undefined) {
                        const todLegDistance = this.distanceTodLeg.get();
                        let todVector;
                        let durationToEndOfTodVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfTodVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < todLegDistance) {
                                todVector = vector;
                                break;
                            }
                        }
                        if (todVector) {
                            this._todEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfTodVectorMs);
                        }
                        else {
                            this._todEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                    // Process EOD if on this leg
                    if (i === eodLegIndex && verticalLegDurationMs !== undefined) {
                        const eodLegDistance = this.distanceTodLeg.get();
                        let eodVector;
                        let durationToEndOfEodVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfEodVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < eodLegDistance) {
                                eodVector = vector;
                                break;
                            }
                        }
                        if (eodVector) {
                            this._eodEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfEodVectorMs);
                        }
                        else {
                            this._eodEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                }
            }
        }
        this.bus.getPublisher().pub('boeing_vnav_data_etas', {
            toc: this._tocEta.get(),
            tod: this._todEta.get(),
            eod: this._eodEta.get()
        }, true);
    }
}
BoeingFmsVNavDataProvider.phasesBeforeCruise = [
    FmsOperatingPhase.PREFLIGHT,
    FmsOperatingPhase.TAKEOFF,
    FmsOperatingPhase.CLIMB,
];

/* eslint-disable jsdoc/require-jsdoc */
/**
 * TODO: This needs to have the aircraft specific performance values split out from the static constants and methods.
 * Boeing Performance Math Utility Class.
 */
class BoeingAeroMath {
    // TODO: Clean up these various delta/pressure ratio methods....
    /**
     * Calculates the current dynamic pressure ratio.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg.
     * @param mach The current aircraft mach number.
     * @returns the current dynamic pressure ratio.
     */
    static calcDynamicPressureRatio(ambientPressure, mach) {
        return 1481.4 * Math.pow(mach, 2) * BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure);
    }
    /**
     * Calculate atmospheric pressure ratio from pressure altitude
     * @todo belongs somewhere else
     * @param zp Pressure altitude in feet
     * @param tropopause Tropopause altitude in feet
     * @returns Atmospheric pressure ratio (delta)
     */
    static deltaFromPressureAlt(zp, tropopause = 36089.24) {
        return zp < tropopause ? ((288.15 - 0.0019812 * zp) / 288.15) ** 5.25588 : 0.22336 * Math.E ** ((36089.24 - zp) / 20805.7);
    }
    /**
     * Calculate the Delta Pressure Ratio for a given altitude above sea level.
     * @param altitude The altitude, in Ft.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAltitude(altitude) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
        return isa[1] * 100 / BoeingAeroMath.slIsaPres;
    }
    /**
     * Calculate the Delta Pressure Ratio for a given ambient pressure.
     * @param ambientPressure The ambient pressure, in inHg.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAmbientPressure(ambientPressure) {
        return ambientPressure / 29.92;
    }
    /**
     * Calculate the Delta Total Pressure Ratio for a given Delta Pressure Ratio and Mach.
     * @param deltaPressureRatio The Delta Pressure Ratio.
     * @param mach The Mach.
     * @returns The Delta Total Pressure Ratio.
     */
    static calcDeltaTotalPressureRatio(deltaPressureRatio, mach) {
        return deltaPressureRatio * Math.pow(1 + 0.2 * (Math.pow(mach, 2)), 3.5);
    }
    /**
     * Calculates a thrust correction factor. Multiplying the correction factor by uncorrected thrust yields corrected
     * thrust.
     * @param mach The mach number.
     * @param ambientPressure The ambient pressure in inHg.
     * @returns The thrust correction factor for the specified parameters.
     */
    static calculateThrustCorrectionFactor(mach, ambientPressure) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        return 1 / (deltaPressureRatio * totalInletPressureMachRise);
    }
    /**
     * Gets the ISA Standard Temp and Press from Altitude.
     * @param altitude The altitude in feet.
     * @param isaPresDeviation Optional Pressure Deviation, in inHg.
     * @param isaTempDeviation Optional Temperature Deviation, in C.
     * @returns an array of [temp K, pressure HPA]
     */
    static calcIsaFromAltitude(altitude, isaPresDeviation, isaTempDeviation) {
        if (isaPresDeviation !== undefined) {
            altitude = BoeingAeroMath.calcPressureAltitude(altitude, 29.92 + isaPresDeviation);
        }
        let temp = 0.0;
        let pressure = 0.0;
        if (altitude <= 36089) {
            // 36089 is the altitude of the top of the troposphere
            temp = BoeingAeroMath.slIsaTemp + (-BoeingAeroMath.lapseFt * altitude);
            pressure = BoeingAeroMath.slIsaPres * Math.pow((BoeingAeroMath.slIsaTemp / temp), (0.034163203 / -0.0065));
        }
        else if (altitude <= 65616) {
            // 65616 is the altitude of the tropopause
            // 22335.6 is the pressure at the base of the tropopause in PA
            // const tropoPres = 22335.6;
            // tropoTemp = 216.65;
            temp = 216.65;
            pressure = 0.223356 * 101325 * Math.exp(-0.000157688 * (altitude - 36089));
        }
        else {
            temp = NaN;
            pressure = NaN;
        }
        return [temp + (isaTempDeviation !== null && isaTempDeviation !== void 0 ? isaTempDeviation : 0), pressure / 100];
    }
    /**
     * Calculate the speed of sound from temperature.
     * @param ambientTemperature The ambient temperature, in C.
     * @returns The speed of sound in ft/s.
     */
    static calcSpeedOfSoundFromTemp(ambientTemperature) {
        return Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE));
    }
    /**
     * Calculate the pressure altitude from Indicated Altitude and Sea Level Pressure.
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Pressure Altitude.
     */
    static calcPressureAltitude(indicatedAltitude, baroSettingInHg) {
        return indicatedAltitude + (1000 * (29.92 - baroSettingInHg));
    }
    /**
     * Calculate the static pre
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Static Pressure in inHg.
     */
    static calcStaticPressure(indicatedAltitude, baroSettingInHg) {
        return UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(BoeingAeroMath.calcPressureAltitude(indicatedAltitude, baroSettingInHg))[1], UnitType.IN_HG);
    }
    /**
     * Calculate the Impact Pressure from CAS.
     * @param cas Calibrated Airspeed in knots.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromCas(cas) {
        return BoeingAeroMath.airDensity * Math.pow(UnitType.KNOT.convertTo(cas, UnitType.MPS), 2) / 2;
    }
    /**
     * Calculate the Impact Pressure.
     * @param mach Mach Number.
     * @param ambientPressure The Ambient Pressure, in inHg.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromMach(mach, ambientPressure) {
        return 100 * (UnitType.IN_HG.convertTo(ambientPressure, UnitType.HPA) * (Math.pow(1 + Math.pow(0.2 * mach, 2), 2 / 7) - 1));
    }
    /**
     * Calculate the Mach number from airspeed, altitude and pressure.
     * @param cas Calibrated Airspeed in knots.
     * @param indicatedAltitude Indicated Altitude in Feet.
     * @param baroSettingInHg The local altimeter setting in inHg.
     * @returns The current Mach Number.
     */
    static calcMachFromCasAltitudePressure(cas, indicatedAltitude, baroSettingInHg) {
        const impactPressure = BoeingAeroMath.calcImpactPressureFromCas(cas);
        const staticPressure = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        return Math.sqrt(5 * (Math.pow((impactPressure / staticPressure) + 1, 2 / 7) - 1));
    }
    /**
     * Calculate static air temperature (SAT, also OAT), from total air temperature (TAT) and Mach.
     * @param tat Total Air Temp in degrees C.
     * @param mach Mach number.
     * @returns The Static Air Temperature in degrees C.
     */
    static calcSatFromTatAndMach(tat, mach) {
        // Gamma minus 1 / 2 = 0.2
        return UnitType.KELVIN.convertTo(UnitType.CELSIUS.convertTo(tat, UnitType.KELVIN) / (1 + (Math.pow(mach, 2) * 0.2)), UnitType.CELSIUS);
    }
    /**
     * Calculate the True Airspeed from Altitude, Temperature and Calibrated Airspeed.
     * @param altitude Altitude in Feet.
     * @param tat Total Air Temp in degrees C.
     * @param cas Calibrated Airspeed in KT.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns True Airspeed in KT.
     */
    static calcTasFromCas(altitude, tat, cas, baroSettingInHg) {
        const pressureAltitude = BoeingAeroMath.calcPressureAltitude(altitude, baroSettingInHg);
        const isa = BoeingAeroMath.calcIsaFromAltitude(pressureAltitude);
        const isaPres = isa[1];
        const mach = BoeingAeroMath.calcMachFromCasAltitudePressure(cas, altitude, baroSettingInHg);
        const temp = UnitType.CELSIUS.convertTo(BoeingAeroMath.calcSatFromTatAndMach(tat, mach), UnitType.KELVIN);
        const alpha = Math.sqrt(BoeingAeroMath.gammaGasVolume * temp);
        const tas = Math.sqrt(5) * alpha * Math.sqrt(Math.pow(((BoeingAeroMath.slIsaPres / isaPres) *
            (Math.pow((cas * cas / BoeingAeroMath.sqrtGammaGasSlNmSqd5) + 1, BoeingAeroMath.gammaOverGammaMinus1) - 1) + 1), BoeingAeroMath.gammaMinus1OverGamma) - 1);
        return UnitType.FPS.convertTo(tas, UnitType.KNOT);
    }
    /**
     * Calculate EAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientPressure Ambient Pressure, in inHg.
     * @returns The Equivalent Airspeed (EAS).
     */
    static calcEasFromMachAndAmbientPressure(mach, ambientPressure) {
        return UnitType.FPS.convertTo(BoeingAeroMath.sound * mach *
            Math.sqrt(BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure)), UnitType.KNOT);
    }
    /**
     * Calculate CAS from EAS.
     * @param eas Equivalent Airspeed in knots
     * @param pressureAlt The current pressure altitude, in Feet.
     * @returns Calibrated airspeed in knots
     */
    static easToCas(eas, pressureAlt) {
        const delta = BoeingAeroMath.deltaFromPressureAlt(pressureAlt);
        return 1479.1 * Math.sqrt((1 + delta * ((1 + 1 / delta * (eas / 1479.1) ** 2) ** 3.5 - 1)) ** (1 / 3.5) - 1);
    }
    /**
     * Calculate CAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientTemp Ambient Temperature, in C.
     * @returns The True Airspeed (TAS).
     */
    static calcTasFromMachAndTemp(mach, ambientTemp) {
        return mach * BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemp);
    }
    /**
     * Calculate density altitude from indicated altitude, barometer setting and static air temperature.
     * @param indicatedAltitude indicated altitude in feet (ft)
     * @param baroSettingInHg barometer setting in inches of mercury (inHg)
     * @param sat static air temperature in degrees celsius (°C)
     * @returns density altitude in feet (ft)
     */
    static calcDensityAltitude(indicatedAltitude, baroSettingInHg, sat) {
        const stationPressurePa = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        const stationPressureinHg = UnitType.HPA.convertTo(stationPressurePa / 100, UnitType.IN_HG);
        const tempR = 459.67 + UnitType.CELSIUS.convertTo(sat, UnitType.FAHRENHEIT);
        // NWS Calculation for ASOS/AWOS
        return 145422.16 * (1 - Math.pow(17.326 * stationPressureinHg / tempR, 0.235));
    }
    /**
     * Calculate observed wind from true airspeed, ground speed, magnetic heading and magnetic track.
     * @param tas The true airspeed in KT.
     * @param gs The ground speed in KT.
     * @param heading The current magnetic heading in degrees.
     * @param track The current magnetic ground track in degrees.
     * @returns Array of [wind direction degrees mag, wind speed kt].
     */
    static calcWind(tas, gs, heading, track) {
        const headingRad = UnitType.DEGREE.convertTo(heading, UnitType.RADIAN);
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windComponentNorth = gs * Math.cos(trackRad) - tas * Math.cos(headingRad);
        const windComponentEast = gs * Math.sin(trackRad) - tas * Math.sin(headingRad);
        const windDirection = NavMath.normalizeHeading(90 - Math.round(UnitType.RADIAN.convertTo(Math.atan2(-windComponentNorth, -windComponentEast), UnitType.DEGREE)));
        const windSpeed = Math.sqrt(Math.pow(windComponentNorth, 2) + Math.pow(windComponentEast, 2));
        return [windDirection, windSpeed];
    }
    /**
     * Calculate headwind and crosswind components from the current ground track, wind speed and wind direction.
     * @param track Current magnetic ground track.
     * @param windSpeed Current wind speed in kt.
     * @param windDirection Current wind direction in degrees magnetic.
     * @returns Array of [headwind component in kt (+ is headwind, - is tailwind),
     * crosswind component in kt (+ is Left crosswind, - is Right crosswind)].
     */
    static calcRelativeWindComponents(track, windSpeed, windDirection) {
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windDirectionRad = UnitType.DEGREE.convertTo(windDirection, UnitType.RADIAN);
        return [
            Math.round(windSpeed * (Math.cos(trackRad - windDirectionRad))),
            Math.round(windSpeed * (Math.sin(trackRad - windDirectionRad)))
        ];
    }
}
/** ISA temp at Sea Level in Kelvin  */
BoeingAeroMath.slIsaTemp = 288.15;
/** ISA pressure at Sea Level in Pascals  */
BoeingAeroMath.slIsaPres = 101325;
/** Specific heat ratio for air  */
BoeingAeroMath.gamma = 1.4;
/** Constant: gamma over gamma minus 1 */
BoeingAeroMath.gammaOverGammaMinus1 = BoeingAeroMath.gamma / (BoeingAeroMath.gamma - 1);
/** Constant: gamma minus 1 over gamma */
BoeingAeroMath.gammaMinus1OverGamma = (BoeingAeroMath.gamma - 1) / BoeingAeroMath.gamma;
/** Specific gas constant in Kelvin (from the world)  */
BoeingAeroMath.gasKelvin = 287.05;
/** Specific gas constant in Rankine (from sim code) */
BoeingAeroMath.gasRankine = 1716;
/** Specific heat ratio for air times gas constant.  */
BoeingAeroMath.gammaGas = BoeingAeroMath.gamma * BoeingAeroMath.gasKelvin;
/** Specific heat ratio for air times gas constant divided per cubic ft.  */
BoeingAeroMath.gammaGasVolume = BoeingAeroMath.gammaGas / Math.pow(UnitType.FOOT.convertTo(1, UnitType.METER), 2);
/** Constant: gammaGas * slIsaTemp */
BoeingAeroMath.gammaGasSl = BoeingAeroMath.gammaGas * BoeingAeroMath.slIsaTemp;
/** Constant: sqrt gammaGasSl * nm */
BoeingAeroMath.sqrtGammaGasSlNm = Math.sqrt(BoeingAeroMath.gammaGasSl) * UnitType.METER.convertTo(3600.0, UnitType.NMILE);
/** Constant: 5 * sqrtGammaGasSlNm squared  */
BoeingAeroMath.sqrtGammaGasSlNmSqd5 = 5.0 * BoeingAeroMath.sqrtGammaGasSlNm * BoeingAeroMath.sqrtGammaGasSlNm;
/** Atmospheric Lapse Rate Constant (Kelvin per foot)  */
BoeingAeroMath.lapseFt = 0.0019812;
/** Fluid density of Air in kg/m^3.  */
BoeingAeroMath.airDensity = 1.225;
/** Gravity at SL ft/s^2.  */
BoeingAeroMath.gravity = 32.17405;
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;
/** Speed of Sound at SL ft/s.  */
BoeingAeroMath.sound = Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE);

/* eslint-disable max-len */
/**
 * An interface for accessing aircraft specific performance data.
 */
class BoeingPerformanceDataProvider {
    constructor() {
        /** Aircraft Specific values from flight_model.cfg and engines.cfg files.  */
        this.aircraftFlightModel = this.getAircraftFlightModel();
        this.aspectRatio = Math.pow(this.aircraftFlightModel.wing_span, 2) / this.aircraftFlightModel.wing_area;
    }
    /**
     * Calculate the Optimum (best range) Altitude for a specific Mach.
     * @param mach The Mach number.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude, in FT.
     */
    calcOptimumAltitudeFromCruiseMach(mach, weight) {
        const rangeTable = [];
        let altitude = 25000;
        while (altitude <= 41000) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            altitude += 1000;
        }
        const maxRange = Math.max(...rangeTable);
        const optAltitude = 25000 + 1000 * rangeTable.findIndex(v => v === maxRange);
        return optAltitude;
    }
    /**
     * Calculate the Optimum (best range) Mach for a specific Altitude.
     * @param altitude The Altitude, in FT.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Mach.
     */
    calcOptimumCruiseMachFromAltitude(altitude, weight) {
        const rangeTable = [];
        let mach = .7;
        while (mach <= 0.9) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            mach += 0.01;
        }
        const maxRange = Math.max(...rangeTable);
        const optMach = .7 + (0.01 * rangeTable.findIndex(v => v === maxRange));
        return optMach;
    }
    /**
     * Calculate the Optimum (best range) Mach and Altitude for a specific aircraft weight.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude and Mach as [Alt in FT, Mach].
     */
    calcOptimumCruiseMachAndAltitude(weight) {
        const rangeTable = [];
        let mach = 70;
        let altitude = 25000;
        while (Math.round(altitude) <= 41000) {
            while (Math.round(mach) <= 90) {
                const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
                const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
                const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
                const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach / 100, ambientTemperature);
                const cl = this.calculateCL(weight, ambientPressure, mach / 100);
                const netThrust = this.calculateThrustRequired(weight, cl, 0);
                const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach / 100, altitude, ambientTemperature, ambientPressure);
                const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
                const rangePerThousandPounds = (1000 / fuelFlow) * tas;
                rangeTable.push(rangePerThousandPounds);
                mach += 1;
            }
            altitude += 1000;
            mach = 70;
        }
        //21 values per altitude
        const maxRange = Math.max(...rangeTable);
        const index = rangeTable.findIndex(v => v === maxRange);
        const altIndex = Math.floor(index / 21);
        const machIndex = index - (altIndex * 21);
        const optMach = .7 + (0.01 * machIndex);
        const optAlt = 25000 + (altIndex * 1000);
        return [optAlt, optMach];
    }
    /**
     * Calculates the current Lift Coefficient.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg
     * @param mach The current aircraft mach number.
     * @returns the current lift coefficient.
     */
    calculateCL(aircraftWeight, ambientPressure, mach) {
        return aircraftWeight / (BoeingAeroMath.calcDynamicPressureRatio(ambientPressure, mach) * this.aircraftFlightModel.wing_area);
    }
    /**
     * Gets the number of possible aircraft configurations, clean and flaps.
     * @returns The number of aircraft configurations.
     */
    getNumberOfConfigurations() {
        return this.aircraftFlightModel.cl_cd.length;
    }
    /**
     * Calculates the current drag coefficient.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The Drag Coefficient
     */
    calculateCD(cl, flapsIndex) {
        const correctedCl = cl - this.aircraftFlightModel.cl_cd[flapsIndex][0];
        const parasiticDrag = this.aircraftFlightModel.cl_cd[flapsIndex][1];
        const inducedDrag = (Math.pow(correctedCl, 2) * this.aircraftFlightModel.induced_drag_scalar) /
            (Math.PI * this.aircraftFlightModel.oswald_efficiency_factor * this.aspectRatio);
        return parasiticDrag + inducedDrag;
    }
    /**
     * Calculates the efficiency factor.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the efficiency factor.
     */
    calculateEfficiency(cl, flapsIndex) {
        return cl / this.calculateCD(cl, flapsIndex);
    }
    /**
     * Calculates the best L/D speed by finding a mach value at the altitude that produces the highest L/D ratio.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param altitude Altitude to find the best econ speed for.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best Econ Speed in Mach.
     */
    calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex) {
        const ambientPressure = UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(altitude)[1], UnitType.IN_HG);
        let machTarget = 0.5;
        let clTarget = 0;
        let ldTarget = 0;
        let iterations = 0;
        while (iterations < 300) {
            clTarget = this.calculateCL(aircraftWeight, ambientPressure, machTarget);
            const newldTarget = this.calculateEfficiency(clTarget, flapsIndex);
            if (newldTarget > ldTarget) {
                ldTarget = newldTarget;
                machTarget += .01;
            }
            else {
                return machTarget -= .01;
            }
            iterations++;
        }
        return machTarget;
    }
    /**
     * Gets the best econ speed based on CAFE/Carson Speed multiplier against best L/D speed.
     * @param aircraftWeight The aircraft weight.
     * @param altitude The altitide to find the best speed at.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best econ speed.
     */
    calculateBestEconSpeed(aircraftWeight, altitude, flapsIndex) {
        return 1.32 * this.calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex);
    }
    /**
     * Calculates the total required net thrust to maintain the current speed and altitude.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The total required net thrust.
     */
    calculateThrustRequired(aircraftWeight, cl, flapsIndex) {
        return aircraftWeight / this.calculateEfficiency(cl, flapsIndex);
    }
    /**
     * Calculates an FPA for a total net thrust at a constant speed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The predicted FPA in Degrees.
     */
    calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex) {
        return Avionics.Utils.RAD2DEG * Math.asin((totalNetThrust / aircraftWeight) - (1 / this.calculateEfficiency(cl, flapsIndex)));
    }
    /**
     * Calculates a vertical speed for a total net thrust for a constant true airspeed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the predicted VS in FPM
     */
    calculateConstantSpeedVerticalSpeedFromThrust(totalNetThrust, tas, aircraftWeight, cl, flapsIndex) {
        return VNavUtils.getVerticalSpeedFromFpa(this.calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex), tas);
    }
    /**
     * Calculates a total net thrust at a constant speed for a given FPA
     * @param fpa Flight Path Angle in degrees (+ve = up)
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForFpa(fpa, aircraftWeight, cl, flapsIndex) {
        return aircraftWeight * (Math.sin(fpa * Avionics.Utils.DEG2RAD) + 1 / this.calculateEfficiency(cl, flapsIndex));
    }
    /**
     * Calculates a total net thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/sec
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex) {
        return this.calculateConstantSpeedThrustForFpa(VNavUtils.getFpaFromVerticalSpeed(vs, tas), aircraftWeight, cl, flapsIndex);
    }
    /**
     * Calculates a gross thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/sec
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param enginesAvailable The number of engines currently running to provide the thrust
     * @param altitude Altitude in feet
     * @param isaDeviation ISA temperature deviation in °C
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns Total Net Thrust in LBS.
     */
    calculateCorrectedN1ForVerticalSpeed(vs, tas, aircraftWeight, enginesAvailable, altitude, isaDeviation, flapsIndex) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude, undefined, isaDeviation);
        const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
        const mach = AeroMath.tasToMach(UnitType.KNOT.convertTo(tas, UnitType.MPS), AeroMath.soundSpeedAir(ambientTemperature));
        const cl = this.calculateCL(aircraftWeight, ambientPressure, mach);
        const netThrust = this.calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex);
        const netThrustPerEngine = netThrust / Math.max(1, enginesAvailable);
        const grossThrustPerEngine = this.findGrossThrustFromNetThrust(netThrustPerEngine, mach, altitude, ambientTemperature, ambientPressure) * BoeingAeroMath.calculateThrustCorrectionFactor(mach, ambientPressure);
        return this.calculateCorrectedN1FromThrust(grossThrustPerEngine, mach);
    }
    /**
     * Calculates fuel flow from a corrected thrust and corrected ram drag.
     * @param thrust Corrected Net thrust (if ram drag is given) or corrected gross thrust, in LBS.
     * @param ramDrag An optional corrected ram drag, in LBS.
     * @returns The calculated fuel flow, in LBS/HR.
     */
    calculateFuelFlowFromThrust(thrust, ramDrag) {
        if (ramDrag !== undefined) {
            return (thrust + ramDrag) * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
        }
        return thrust * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param n1 The corrected N1 percent.
     * @param mach The mach number.
     * @returns The corrected gross thrust, in pounds, at the specified corrected N1 and mach.
     */
    calculateThrustFromCorrectedN1(n1, mach) {
        return this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(n1, mach) * this.aircraftFlightModel.static_thrust;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param grossThrust The corrected gross thrust, in pounds
     * @param mach The mach number.
     * @returns The corrected N1 percent.
     */
    calculateCorrectedN1FromThrust(grossThrust, mach) {
        return this.aircraftFlightModel.thrust_and_mach_on_n1_table.get(grossThrust / this.aircraftFlightModel.static_thrust, mach);
    }
    /**
     * Calculates idle corrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @returns The idle corrected N1 (%) at the specified mach number.
     */
    calculateIdleCorrectedN1(ambientTemperature, mach) {
        // TODO Should this use ambient or TAT? We call it with TAT right now
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        return (mach * this.aircraftFlightModel.mach_influence_on_n1) + (this.aircraftFlightModel.low_idle_n1 / Math.sqrt(thetaTotalTempRatio));
    }
    /**
     * Calculates uncorrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @param correctedN1 The corrected n1.
     * @returns The uncorrected N1 (%) at the specified mach number.
     */
    uncorrectN1(ambientTemperature, mach, correctedN1) {
        const totalInletTempMachRise = 1.0 + 0.2 * mach * mach;
        const StandardSeaLevelTemperature = BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        const ambientRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const theta_temperature_ratio = ambientRankine / StandardSeaLevelTemperature;
        const thetaTotalTempRatio = theta_temperature_ratio * totalInletTempMachRise;
        return correctedN1 * Math.sqrt(thetaTotalTempRatio);
    }
    /**
     * Calculates idle corrected gross thrust, in LBS, for one engine.
     * @param ambientTemperature The Ambient Temperature at the aircraft location in C.
     * @param mach The current aircraft mach number.
     * @returns The idle corrected gross thrust, in LBS, for one engine.
     */
    calculateIdleThrust(ambientTemperature, mach) {
        return this.calculateThrustFromCorrectedN1(this.calculateIdleCorrectedN1(ambientTemperature, mach), mach);
    }
    /**
     * Calculates the uncorrected ram drag provided by an engine, in pounds.
     * @param mach The airplane's mach number.
     * @param n1 The engine's corrected N1, as a percent.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius.
     * @param ambientPressure The ambient pressure, in inches of mercury.
     * @param inletTemp The engine inlet temperature, in Rankine.
     * @returns The uncorrected ram drag provided by an engine, in pounds, with the specified parameters.
     */
    calculateRamDrag(mach, n1, ambientTemperature, ambientPressure, inletTemp) {
        const airflowTableResult = this.aircraftFlightModel.corrected_airflow_table.get(n1, mach);
        const correctedAirflow = airflowTableResult * this.aircraftFlightModel.inlet_area;
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        const deltaTotalPressureRatio = deltaPressureRatio * totalInletPressureMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE; //Divide by sim normal SL temp constant to get thetaTTR
        const airflow = correctedAirflow * deltaTotalPressureRatio / Math.sqrt(thetaTotalTempRatio);
        const speedOfSound = BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemperature);
        return speedOfSound * mach * airflow / BoeingAeroMath.gravity; // Ram Drag in pounds
    }
    /**
     * Finds the uncorrected gross thrust, in pounds, provided by an engine when it is providing a given uncorrected net
     * thrust.
     * @param netThrust The uncorrected net thrust, in pounds, for which to find the gross thrust.
     * @param mach The airplane's mach number.
     * @param altitude The airplane's pressure altitude, in feet.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius. Defaults to ISA temperature for
     * the specified pressure altitude.
     * @param ambientPressure The ambient pressure, in inches of mercury. Defaults to ISA pressure for the specified
     * pressure altitude.
     * @param idleN1 The engine's idle corrected N1, as a percent. If not defined, it will be calculated from the specified mach
     * number and temperature.
     * @returns The uncorrected gross thrust, in pounds, provided by the engine with the specified parameters when it is
     * providing the specified uncorrected net thrust.
     */
    findGrossThrustFromNetThrust(netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1) {
        if (!ambientTemperature || !ambientPressure) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            if (!ambientTemperature) {
                ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            }
            if (!ambientPressure) {
                ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            }
        }
        idleN1 !== null && idleN1 !== void 0 ? idleN1 : (idleN1 = this.calculateIdleCorrectedN1(ambientTemperature, mach));
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const thrustCorrectionFactor = BoeingAeroMath.calculateThrustCorrectionFactor(mach, ambientPressure);
        const correctedNetThrust = netThrust * thrustCorrectionFactor;
        let lowCorrectedN1 = idleN1;
        let highCorrectedN1 = 110;
        let numIterations = 0;
        let estimatedCorrectedGrossThrust = 0;
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const lowCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(lowCorrectedN1, mach) * this.aircraftFlightModel.static_thrust;
        let lowCorrectedNetThrust = lowCorrectedGrossThrust - this.calculateRamDrag(mach, lowCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        if (correctedNetThrust <= lowCorrectedNetThrust) {
            return lowCorrectedGrossThrust / thrustCorrectionFactor;
        }
        const highCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(highCorrectedN1, mach) * this.aircraftFlightModel.static_thrust;
        let highCorrectedNetThrust = highCorrectedGrossThrust - this.calculateRamDrag(mach, highCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        const epsilon = this.aircraftFlightModel.static_thrust * 0.001;
        while (numIterations < 100) {
            const estimatedCorrectedN1 = MathUtils.lerp(correctedNetThrust, lowCorrectedNetThrust, highCorrectedNetThrust, lowCorrectedN1, highCorrectedN1);
            estimatedCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(estimatedCorrectedN1, mach)
                * this.aircraftFlightModel.static_thrust;
            /** corrected net thrust estimate */
            const estimatedNetThrust = estimatedCorrectedGrossThrust
                - (this.calculateRamDrag(mach, estimatedCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor);
            if (Math.abs(estimatedNetThrust - correctedNetThrust) < epsilon) {
                return estimatedCorrectedGrossThrust / thrustCorrectionFactor;
            }
            const errorSign = Math.sign(estimatedNetThrust - correctedNetThrust);
            if (errorSign < 0) {
                lowCorrectedN1 = estimatedCorrectedN1;
                lowCorrectedNetThrust = estimatedNetThrust;
            }
            else {
                highCorrectedN1 = estimatedCorrectedN1;
                highCorrectedNetThrust = estimatedNetThrust;
            }
            numIterations++;
        }
        return estimatedCorrectedGrossThrust / thrustCorrectionFactor;
    }
}
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;

/**
 * An default implementation of {@link BoeingPathPerformanceProvider} which derives performance data from a
 * {@link BoeingPerformanceDataProvider}.
 */
class DefaultBoeingPathPerformanceProvider {
    /**
     * Creates an instance of DefaultBoeingPathPerformanceProvider.
     * @param performanceData The aircraft's performance data provider.
     */
    constructor(performanceData) {
        this.performanceData = performanceData;
    }
    /** @inheritdoc */
    getWingArea() {
        return this.performanceData.aircraftFlightModel.wing_area * 0.09290304;
    }
    /** @inheritdoc */
    getThrustCorrectionFactor(pressure, mach) {
        return BoeingAeroMath.calculateThrustCorrectionFactor(mach, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineIdleCorrectedN1(temperature, mach) {
        return this.performanceData.calculateIdleCorrectedN1(temperature, mach);
    }
    /** @inheritdoc */
    getEngineCorrectedGrossThrust(n1, mach) {
        return this.performanceData.calculateThrustFromCorrectedN1(n1, mach);
    }
    /** @inheritdoc */
    getEngineRamDrag(n1, mach, pressure, temperature) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(temperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        return this.performanceData.calculateRamDrag(mach, n1, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG), inletTemp);
    }
    /** @inheritdoc */
    getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) {
        return this.getEngineCorrectedGrossThrust(n1, mach) / this.getThrustCorrectionFactor(pressure, mach) - this.getEngineRamDrag(n1, mach, pressure, temperature);
    }
    /** @inheritdoc */
    estimateGrossThrustFromNetThrust(netThrust, mach, pressure, temperature) {
        return this.performanceData.findGrossThrustFromNetThrust(netThrust, mach, 0, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineFuelFlow(grossThrust) {
        return this.performanceData.calculateFuelFlowFromThrust(grossThrust);
    }
    /** @inheritdoc */
    getRequiredThrust(weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return weight * (sin + this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos));
    }
    /** @inheritdoc */
    getLevelFlightRequiredThrust(weight, cl, flapsIndex) {
        return this.performanceData.calculateThrustRequired(weight, cl, flapsIndex);
    }
    /** @inheritdoc */
    getVerticalSpeed(netThrust, weight, cl, tas, flapsIndex) {
        return UnitType.FPM.convertTo(this.performanceData.calculateConstantSpeedVerticalSpeedFromThrust(netThrust, UnitType.MPS.convertTo(tas, UnitType.KNOT), weight, cl, flapsIndex), UnitType.MPS);
    }
    /** @inheritdoc */
    getAcceleration(netThrust, weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return UnitType.G_ACCEL.convertTo(netThrust / weight - sin - this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos), UnitType.MPS_PER_SEC);
    }
    /** @inheritdoc */
    estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineNetThrust, engineCount, wingArea, flapsIndex, weight, pressure, temperature, out, density, soundSpeed, minAccel = 0.1) {
        let totalTime = 0;
        let totalDistance = 0;
        if (density === undefined) {
            density = AeroMath.densityAir(pressure, temperature);
        }
        // For performance reasons, only calculate engine fuel flow at the starting speed.
        const initialMach = AeroMath.tasToMach(initialTas, soundSpeed !== null && soundSpeed !== void 0 ? soundSpeed : AeroMath.soundSpeedAir(temperature));
        const grossThrustPerEngineRequired = this.estimateGrossThrustFromNetThrust(engineNetThrust, initialMach, pressure, temperature);
        const engineFuelFlow = this.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
        let currentTas = initialTas;
        while (Math.abs(finalTas - currentTas) > 0.1) {
            const weightNewtons = weight * 4.44822;
            let acceleration = this.getAcceleration(engineNetThrust * engineCount, weight, AeroMath.liftCoefficient(weightNewtons, wingArea, density, currentTas), currentTas, vs, flapsIndex);
            if (finalTas - currentTas > 0) {
                acceleration = Math.max(minAccel, acceleration);
            }
            else {
                acceleration = Math.min(-minAccel, acceleration);
            }
            const tasStep = MathUtils.clamp(finalTas - currentTas, -3, 3);
            const timeStep = tasStep / acceleration;
            totalTime += timeStep;
            totalDistance += currentTas * timeStep + acceleration * timeStep * timeStep / 2;
            currentTas += acceleration * timeStep;
            weight = Math.max(0, weight - engineFuelFlow * timeStep);
        }
        return Vec2Math.set(totalTime, totalDistance, out);
    }
}

/**
 * Formats a text using input box styling
 *
 * @param text the text to surround with an input box
 *
 * @returns the styled text for FMC display
 */
function inputBox(text) {
    const regex = /([^[\]\n]+)(\[[^[\]\n]+])*/g;
    let finalString = '';
    let pos = 0;
    let endPos = 0;
    let match = regex.exec(text);
    if (match) {
        while (match !== null) {
            endPos += match[0].length;
            // Special case if we only have one match for the whole string
            if (pos === 0 && endPos === text.length) {
                if (match[2]) {
                    if (match[1].length > 2) {
                        const startStr = match[1][0];
                        const startStyle = match[2].replace(']', ' box-s]');
                        const midStr = match[1].substring(1, match[1].length - 1);
                        const midStyle = match[2].replace(']', ' box-m]');
                        const endStr = match[1][match[1].length - 1];
                        const endStyle = match[2].replace(']', ' box-e]');
                        finalString = `${startStr}${startStyle}${midStr}${midStyle}${endStr}${endStyle}`;
                    }
                    else if (match[1].length > 1) {
                        const startStr = match[1][0];
                        const startStyle = match[2].replace(']', ' box-s]');
                        const endStr = match[1][match[1].length - 1];
                        const endStyle = match[2].replace(']', ' box-e]');
                        finalString = `${startStr}${startStyle}${endStr}${endStyle}`;
                    }
                    else {
                        const str = match[1][0];
                        const style = match[2].replace(']', ' box-s box-e]');
                        finalString = `${str}${style}`;
                    }
                    return finalString;
                }
                else {
                    if (match[1].length > 2) {
                        const startStr = match[1][0];
                        const midStr = match[1].substring(1, match[1].length - 1);
                        const endStr = match[1][match[1].length - 1];
                        finalString = `${startStr}[box-s]${midStr}[box-m]${endStr}[box-e]`;
                    }
                    else if (match[1].length > 1) {
                        const startStr = match[1][0];
                        const endStr = match[1][match[1].length - 1];
                        finalString = `${startStr}[box-s]${endStr}[box-e]`;
                    }
                    else {
                        finalString = `${match[1]}[box-s box-e]`;
                    }
                    return finalString;
                }
            }
            if (pos === 0) {
                // Style fragment is at the start of the string
                if (match[2]) {
                    finalString += match[1][0] + match[2].replace(']', ' box-s]') + match[1].substring(1) + match[2].replace(']', ' box-m]');
                }
                else {
                    finalString += match[1][0] + '[box-s]' + match[1].substring(1);
                }
            }
            else if (endPos === text.length) {
                // Style fragment is at the end of the string
                if (match[2]) {
                    if (match[1].length > 1) {
                        finalString += match[1].substring(0, match[1].length - 1) + match[2].replace(']', ' box-m]') + match[1][match[1].length - 1] + match[2].replace(']', ' box-e]');
                    }
                    else {
                        finalString += match[1][match[1].length - 1] + match[2].replace(']', ' box-e]');
                    }
                }
                else {
                    if (match[1].length > 1) {
                        finalString += match[1].substring(0, match[1].length - 1) + '[box-m]' + match[1][match[1].length - 1] + '[box-e]';
                    }
                    else {
                        finalString += match[1] + '[box-e]';
                    }
                }
            }
            else {
                // Style fragment is in the middle of the string
                if (match[2]) {
                    finalString += match[1] + match[2].replace(']', ' box-m]');
                }
                else {
                    finalString += match[1] + '[box-m]';
                }
            }
            pos += match[0].length;
            match = regex.exec(text);
        }
    }
    return finalString;
}
/** Contains B787 FMC format functions and format function factories. */
class B787FmcFormatters {
    /**
     * A formatter for calibrated airspeeds.
     * @param type Whether the field is an input or a display.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` if the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @returns A CAS airspeed formatter.
     */
    static AirspeedCas(type, targetCas) {
        return (cas) => {
            const spdStr = cas.toString().padStart(3, ' ');
            const spdStrWithStyling = targetCas && targetCas.get() === cas ? `${spdStr}[magenta]` : spdStr;
            return type === 'input' ? inputBox(spdStrWithStyling) : spdStrWithStyling;
        };
    }
    /**
     * A formatter for Mach airspeeds.
     * @param type Whether the field is an input or a display.
     * @param targetMach Optional: The Mach which the FMS is actively targeting (or `null` when the FMS is targeting CAS).
     * The speed will appear magenta when it is equal to this value.
     * @returns A Mach airspeed formatter.
     */
    static AirspeedMach(type, targetMach) {
        return (mach) => {
            const target = targetMach === null || targetMach === void 0 ? void 0 : targetMach.get();
            const isFmsCommand = typeof target === 'number' && Math.round(target * 1000) === Math.round(mach * 1000);
            const spdStr = `.${Math.round(mach * 1000)}${isFmsCommand ? '[magenta]' : ''}`;
            return type === 'input' ? inputBox(spdStr) : spdStr;
        };
    }
    /**
     * A formatter factory for airspeed CAS/Mach pairs.
     * @param modality Whether the field is an input or a display.
     * @param displayType Whether the field displays a single value or a pair of values.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` when the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @param targetMach Optional: The Mach which the FMS is actively targeting (or `null` when the FMS is targeting CAS).
     * The speed will appear magenta when it is equal to this value.
     * @throws If type 'single' is passed and both values are null or both values are numbers.
     * @returns A CAS/Mach airspeed pair formatter.
     */
    static AirspeedCasAndOrMach(modality, displayType, targetCas, targetMach) {
        return ([cas, mach]) => {
            const casStr = cas === null ? '---' : B787FmcFormatters.AirspeedCas('display', targetCas)(cas);
            const machStr = mach === null ? '----' : B787FmcFormatters.AirspeedMach('display', targetMach)(mach);
            let valueStr;
            switch (displayType) {
                case 'cas_mach':
                    valueStr = `${casStr}/[d-text]${machStr}`;
                    break;
                case 'mach_cas':
                    valueStr = `${machStr}/[d-text]${casStr}`;
                    break;
                case 'single':
                    if ((cas === null && mach === null) || (cas !== null && mach !== null)) {
                        throw new Error('AirspeedCasAndOrMach formatter cannot be used in "single" mode unless one value is null and the other is a number');
                    }
                    valueStr = cas ? casStr : machStr;
                    break;
            }
            return modality === 'input' ? inputBox(valueStr) : valueStr;
        };
    }
    /**
     * A calibrated airspeed/altitude pair formatter factory.
     * @param type Whether the field is an input or a display.
     * @param transitionAlt The transition altitude, in feet.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` when the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @returns A formatted CAS/Alt pair formatter.
     */
    static AirspeedCasAltitudePair(type, transitionAlt, targetCas) {
        return ([cas, alt]) => {
            const casStr = cas === null ? '---' : B787FmcFormatters.AirspeedCas('display', targetCas)(cas);
            const altStr = alt === null ? '-----' : B787FmcFormatters.Altitude(type, transitionAlt)(alt);
            const str = `${casStr}/${altStr}`;
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A CAS or Mach airspeed formatter, depending on the speed unit type.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` when the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @param targetMach Optional: The Mach which the FMS is actively targeting (or `null` when the FMS is targeting CAS).
     * The speed will appear magenta when it is equal to this value.
     * @returns A formatted CAS or Mach, depending on the speed unit type.
     */
    static AirspeedCasOrMach(targetCas, targetMach) {
        return ([cas, mach, unit]) => unit === 'cas' ?
            cas === null ? '' : B787FmcFormatters.AirspeedCas('input', targetCas)(cas) :
            mach === null ? '' : B787FmcFormatters.AirspeedMach('input', targetMach)(mach);
    }
    /**
     * An altitude formatter factory.
     * @param type Whether the field is an input or a display.
     * @param transitionAltSub The transition altitude, in feet.
     * @param targetAltSub Optional: The altitude which the FMS is actively targeting.
     * The altitude will appear magenta when it is equal to this value.
     * @returns An altitude formatter.
     */
    static Altitude(type, transitionAltSub, targetAltSub) {
        return (value) => {
            const altStr = (value < transitionAltSub.get()) ?
                `${Math.round(value).toString().padStart(5, ' ')}` :
                `FL${Math.round(value / 100).toString().padStart(3, '0').substring(0, 3)}`;
            const altStrWithStyling = (targetAltSub === null || targetAltSub === void 0 ? void 0 : targetAltSub.get()) === value ? `${altStr}[magenta]` : altStr;
            return type === 'input' ? inputBox(altStrWithStyling) : altStrWithStyling;
        };
    }
    /**
     * A formatter factory for altitudes in feet.
     * @param type Whether the field is an input or a display.
     * @returns A altitude in feet formatter.
     */
    static AltitudeFeet(type) {
        return (alt) => {
            const str = alt.toString().padStart(5, ' ');
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A climb/descent waypoint constraint header formatter factory.
     * @param leg The constraint's associated {@link LegDefinition}, if it exists.
     * @returns A climb/descent waypoint constraint header formatter.
     */
    static ConstraintHeader(leg) {
        var _a;
        if (leg) {
            const prefix = BoeingFmsUtils.isHoldAtLeg(leg.leg.type) ? 'HOLD ' : '';
            let suffix;
            switch (leg.leg.type) {
                case LegType.FM:
                case LegType.VM:
                    suffix = 'VECTORS';
                    break;
                case LegType.CI:
                case LegType.VI:
                case LegType.PI:
                    suffix = '(INTC)';
                    break;
                default:
                    suffix = (_a = leg.name) !== null && _a !== void 0 ? _a : '';
                    break;
            }
            return `${prefix}AT ${suffix}`;
        }
        else {
            return '';
        }
    }
    /**
     * A climb/descent waypoint constraint field formatter.
     * @param verticalDisplayData An object containing vertical display data.
     * @returns A formatted climb/descent constraint.
     */
    static ConstraintField(verticalDisplayData) {
        if (verticalDisplayData) {
            const speed = verticalDisplayData.speed;
            let speedConstraintString = '';
            if (typeof speed === 'number' && !verticalDisplayData.speedIsPredicted) {
                speedConstraintString = verticalDisplayData.speedIsMach ?
                    speed.toFixed(3).substring(1) :
                    speed.toFixed(0);
                if (verticalDisplayData.speedIsCommanded) {
                    speedConstraintString += '[magenta]';
                }
                speedConstraintString += '/[d-text]';
            }
            let altitudeConstraintString = '';
            if (verticalDisplayData.altitudes.length > 0) {
                for (let i = 0; i < verticalDisplayData.altitudes.length; i++) {
                    const altitude = verticalDisplayData.altitudes[i];
                    const isFlightLevel = verticalDisplayData.altitudesAreFlightLevels[i];
                    const suffix = verticalDisplayData.altitudeSuffixes[i];
                    let str = '';
                    if (isFlightLevel) {
                        str += `FL${(altitude / 100).toFixed(0).padStart(3, '0')}`;
                    }
                    else {
                        str += altitude.toFixed(0).padStart(5, ' ');
                    }
                    str += suffix;
                    altitudeConstraintString += str;
                }
                const altStyleStr = [];
                if (verticalDisplayData.altitudeIsCommanded) {
                    altStyleStr.push('magenta');
                }
                altStyleStr.push(verticalDisplayData.altitudesArePredicted ? 's-text' : 'd-text');
                altitudeConstraintString += `[${altStyleStr.join(' ')}]`;
            }
            else {
                altitudeConstraintString = '------';
            }
            return `${speedConstraintString}${altitudeConstraintString}`;
        }
        else {
            return '';
        }
    }
    /**
     * A flight level formatter factory.
     * @param type Whether the field is an input or a display.
     * @returns A flight level formatter.
     */
    static FlightLevel(type) {
        return (value) => {
            const str = `FL${Math.round(value / 100).toString().padStart(3, '0').substring(0, 3)}`;
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A formatter for the Assumed Temp field.
     * @param type the formatter type
     * @returns A formatted string.
     */
    static AssumedTempInput(type) {
        return ([temp, limit]) => {
            const formatted = temp ? temp.toFixed(0).padStart(3) : '---';
            return `${type === 'display' ? formatted : inputBox(formatted)}°C ${limit}`;
        };
    }
    /**
     * A formatter for Assumed Temp/Outside Air Temp pairs.
     * @param data The data.
     * @param data."0" The assumed temperature.
     * @param data."1" The outside air temperature.
     * @returns A formatted assumed temp/oat pair.
     */
    static AssumedOatTempPair([assumedTemp, outsideTemp]) {
        const assumedTempFormatter = B787FmcFormatters.Unit('°C', { spaceBetween: false, padString: ' ', padStart: 3, type: 'inputWithUnit' }, '---');
        const outsideTempFormatter = B787FmcFormatters.Unit('°C', { spaceBetween: false, fontSize: 'small' });
        return `${assumedTempFormatter(assumedTemp)}/${outsideTempFormatter(outsideTemp)}`;
    }
    /**
     * A formatter for center of gravity and trim.
     * @param type the formatter type
     * @returns The center of gravity in an input box and the trim setting, if it exists.
     */
    static CenterOfGravityTrim(type) {
        const cgFormatter = B787FmcFormatters.Unit('%', { type, spaceBetween: false, padStart: 2, padString: ' ' }, '□□');
        const trimFormatter = NumberFormatter.create({ precision: 0.25 });
        return ([cg, trim]) => {
            const trimOutput = trim === null ? '' : trimFormatter(trim);
            return `${cgFormatter(cg)}  ${trimOutput}`;
        };
    }
    /**
     * A formatter for the Flap/Speed field.
     * @param input The input
     * @param input."0" The flap setting.
     * @param input."1" The airspeed.
     * @returns A formatted string.
     */
    static FlapSpeed([flap, speed]) {
        return `${inputBox(`${flap === null ? '--' : flap.toString().padStart(2, ' ')}°/${speed.toString().padStart(3, ' ')}[d-text]`)}KT[s-text]`;
    }
    /**
     * A formatter for the Flight Path Angle/Vertical Bearing/Vertical Speed field.
     * @param spacing The reference spacing.
     * @returns A formatting function.
     */
    static FpaVbVs(spacing) {
        return ([distToWaypointRad, waypointAltFt, currentAltFt, groundSpeedKts, verticalSpeedFpm]) => {
            if (distToWaypointRad === null || waypointAltFt === null || currentAltFt < waypointAltFt) {
                return '';
            }
            const fpa = VNavUtils.getFpa(UnitType.KNOT.convertTo(groundSpeedKts, UnitType.FPM), verticalSpeedFpm);
            const vb = VNavUtils.getFpa(UnitType.FOOT.convertFrom(distToWaypointRad, UnitType.GA_RADIAN), currentAltFt - waypointAltFt);
            const vs = VNavUtils.getRequiredVs(UnitType.NMILE.convertFrom(distToWaypointRad, UnitType.GA_RADIAN), waypointAltFt, currentAltFt, groundSpeedKts);
            const fpaClamped = MathUtils.clamp(-1 * fpa, 0, 9.9);
            const vbClamped = MathUtils.clamp(vb, 0, 9.9);
            const vsClamped = MathUtils.clamp(-1 * vs, 0, 9999);
            const fpaStr = isNaN(fpa) || fpa > -0.02 ? '' : fpaClamped.toFixed(1);
            const vbStr = vbClamped.toFixed(1).padStart(spacing + 2, ' ');
            const vsStr = vsClamped.toFixed(0).padStart(spacing + 3, ' ');
            return `${fpaStr}${vbStr}${vsStr}`;
        };
    }
    /**
     * A formatter for the line six FMC PREFLIGHT COMPLETE header.
     * @param preflightComplete Whether preflight has been completed.
     * @param isOnGround Whether the aircraft is on the ground.
     * @param isAfterTakeoff Whether the flight phase is after takeoff.
     * @returns A PRE-FLT message, white-on-green FMC PREFLIGHT COMPLETE message, or a dashed line.
     */
    static PreflightCompleteHeader(preflightComplete, isOnGround, isAfterTakeoff) {
        const line6HeaderOnGroundBeforeTakeoff = preflightComplete ?
            ['------------------', '------------------', 'F[bg-dark-green bg-start]MC PREFLIGHT COMPLET[bg-dark-green]E[bg-dark-green bg-end]'] :
            ['--------------------------------------', ' PRE-FLT'];
        const line6HeaderInAir = ['--------------------------------------'];
        return !isOnGround || isAfterTakeoff ? line6HeaderInAir : line6HeaderOnGroundBeforeTakeoff;
    }
    /**
     * A formatter for takeoff runway/position shift.
     * @param type The formatter type.
     * @param textSize The text size.
     * @returns A formatted runway/position shift pair.
     */
    static RunwayPositionShift(type, textSize) {
        const posFormatter = B787FmcFormatters.Unit('FT', { type, spaceBetween: false, forceSign: true, fontSize: textSize });
        return ([originRwy, takeoffRwy, takeoffRwyPos]) => {
            const rwy = takeoffRwy !== null && takeoffRwy !== void 0 ? takeoffRwy : originRwy;
            const rwyStr = rwy ? rwy.designation.padEnd(3, ' ') : '---';
            const posStr = takeoffRwyPos !== null ? posFormatter(takeoffRwyPos) : '----';
            return type !== 'display' ? inputBox(`${rwyStr}/${posStr}`) : `${rwyStr}/${posStr}`;
        };
    }
    /**
     * A formatter for runway slope and condition.
     * @param input The input
     * @param input."0" The runway slope (negative is downhill, positive is uphill).
     * @param input."1" The runway condition.
     * @returns A formatted runway slope/condition pair.
     */
    static RunwaySlopeAndCondition([slope, cond]) {
        const slopeStr = `${slope < 0 ? 'D' : 'U'}${NumberFormatter.create({ precision: 0.1 })(Math.abs(slope))}`;
        return inputBox(`${slopeStr}/${cond.padEnd(8, ' ')}`);
    }
    /**
     * A formatter factory for the Takeoff Gross Weight field.
     * @param unit The unit subscribable.
     * @param spacing The amount of spacing to use.
     * @param type The formatter type.
     * @param fontSize The text size.
     * @returns A formatter.
     */
    static TakeoffGrossWeightInput(unit, spacing, type, fontSize) {
        const gwDisplayFormatter = B787FmcFormatters.Weight('display', unit, fontSize);
        const inputFormatter = B787FmcFormatters.Weight(type, unit, fontSize);
        const textStyle = `${fontSize === 'large' ? 'd' : 's'}-text`;
        return ([grwt, togw]) => {
            let togwDisplay;
            if (togw) {
                togwDisplay = inputFormatter(togw);
            }
            else {
                const nullString = type === 'input' ? inputBox(`---.-[${textStyle}]`) : `---.-[${textStyle}]`;
                togwDisplay = grwt ? nullString : inputFormatter(togw);
            }
            return `${gwDisplayFormatter(grwt)}${' '.repeat(spacing)}[${textStyle}]${togwDisplay}`;
        };
    }
    /**
     * A thrust reduction point formatter.
     * @param type The formatter type.
     * @param altitudeFontSize The altitude font size.
     * @returns The climb thrust mode and thrust reduction point as either a flap setting or altitude.
     */
    static ThrustReduction(type, altitudeFontSize) {
        const altitudeFormatter = B787FmcFormatters.Unit('FT', { padStart: 4, padString: ' ', spaceBetween: false, type, fontSize: altitudeFontSize });
        return ([climbThrust, thrustReduction]) => {
            const reductionStr = thrustReduction > 100 ?
                // Thrust reduction point is an altitude
                altitudeFormatter(thrustReduction) :
                // Thrust reduction point is a single-digit flap setting
                `FLAPS [s-text]${type !== 'display' ? inputBox(thrustReduction.toString()) : thrustReduction.toString()}`;
            return `${climbThrust.padEnd(6, ' ')}[s-text]${reductionStr}`;
        };
    }
    /**
     * Formats a value with a unit.
     * @param unit The unit to display.
     * @param suppliedOptions The options object.
     * @param nullValueString The string to display when the value is null.
     * @returns A unit formatter function.
     */
    static Unit(unit, suppliedOptions, nullValueString = '') {
        const defaults = {
            precision: 0,
            padStart: 0,
            padString: '-',
            spaceBetween: true,
            forceSign: false,
            type: 'display',
            fontSize: 'large',
            unitSize: 'small',
            prefix: '',
            absoluteValue: false,
        };
        const options = Object.assign(defaults, suppliedOptions);
        return (value) => {
            const signString = options.forceSign && (value === null || value >= 0) ? '+[d-text]' : '';
            let valueString = value === null
                ? nullValueString.padStart(options.padStart, options.padString)
                : (options.absoluteValue ? Math.abs(value) : value).toFixed(options.precision).padStart(options.padStart, options.padString);
            if (valueString) {
                valueString = `${valueString}${options.fontSize === 'large' ? '[d-text]' : '[s-text]'}`;
            }
            const inputString = options.type === 'input' ? inputBox(valueString) : valueString;
            const spaceString = options.spaceBetween ? ' ' : '';
            const unitString = unit ? `${SubscribableUtils.isSubscribable(unit) ? unit.get() : unit}${options.unitSize === 'large' ? '[d-text]' : '[s-text]'}` : '';
            const inputSpaceUnitString = options.type === 'inputWithUnit'
                ? inputBox(`${inputString}${spaceString}${unitString}`)
                : `${inputString}${spaceString}${unitString}`;
            return `${options.prefix}${signString}${inputSpaceUnitString}`;
        };
    }
    /**
     * UTC time formatter factory.
     * The formatter outputs the format HHMMZ from a unix timestamp in ms.
     * @param type 'input' for an inputBox or 'display' for a plain string
     * @param suffix Suffix after the 4-digit time value, default 'Z'
     * @returns A UTC time formatter.
     */
    static UtcTime(type, suffix) {
        return (value) => {
            B787FmcFormatters.dateCache.setTime(value);
            const formatted = `${B787FmcFormatters.dateCache.getUTCHours().toFixed(0).padStart(2, '0')}${B787FmcFormatters.dateCache.getUTCMinutes().toFixed(0).padStart(2, '0')}${suffix !== null && suffix !== void 0 ? suffix : 'Z'}`;
            return type === 'input' ? inputBox(formatted) : formatted;
        };
    }
    /**
     * A formatter for weights.
     * @param type Whether the field is an input or a display.
     * @param unitSub A subscribable to unit to show the value in.
     * @param fontSize The font size. Defaults to `large`.
     * @returns The formatted weight in kilo-units.
     */
    static Weight(type, unitSub, fontSize) {
        const textStyle = fontSize === 'small' ? 's-text' : 'd-text';
        return (weight) => {
            var _a;
            const weightValue = weight === null || weight === void 0 ? void 0 : weight.asUnit((_a = unitSub === null || unitSub === void 0 ? void 0 : unitSub.get()) !== null && _a !== void 0 ? _a : weight.unit);
            const str = weightValue === undefined ? `□□□.□[${textStyle}]` : `${(weightValue / 1000).toFixed(1).padStart(5, ' ')}[${textStyle}]`;
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A wind vector formatter.
     * @param windEntry A {@link WindEntry} input.
     * @param showSpeedUnit whether to show KT at the end
     * @returns A formatted wind vector.
     */
    static WindVector(windEntry, showSpeedUnit = true) {
        const nonZeroDirection = windEntry.direction === 0 ? 360 : windEntry.direction;
        const dirStr = nonZeroDirection.toString().padStart(3, '0');
        const speedStr = windEntry.speed.toString().padStart(3, ' ');
        const degreesStr = windEntry.trueDegrees ? 'T' : '°';
        const formattedStr = `${dirStr}${degreesStr}/${speedStr}`;
        const speedUnitText = showSpeedUnit ? 'KT[s-text]' : '';
        return `${inputBox(`${formattedStr}[d-text]`)}${speedUnitText}`;
    }
    /** A wind component formatter factory for runway winds.
     * @param runwaySub The runway to which the winds are to be displayed relative to.
     * @returns A formatter for displaying wind components relative to the given runway's heading.
     */
    static WindComponentsRunway(runwaySub) {
        return (wind) => {
            const runway = runwaySub.get();
            if (runway === null) {
                return B787FmcFormatters.Unit('KT', { spaceBetween: false, type: 'input' }, '---')(null);
            }
            const magVar = Facilities.getMagVar(runway.latitude, runway.longitude);
            const [headwind, crosswind] = BoeingAeroMath.calcRelativeWindComponents(runway.course - magVar, wind.speed, wind.direction);
            const headwindStr = B787FmcFormatters.Unit('KT', { spaceBetween: false, padStart: 2, padString: ' ', absoluteValue: true, type: 'input' })(headwind);
            const crosswindStr = B787FmcFormatters.Unit('KT', { spaceBetween: false, padStart: 2, padString: ' ', absoluteValue: true })(crosswind);
            return `${headwindStr}${(headwind >= 0 ? 'H' : 'T')} ${crosswindStr}${(crosswind >= 0 ? 'L' : 'R')}`;
        };
    }
    /**
     * A zulu time formatter.
     * @param suffix The suffix to include after the time digits.
     * @returns A four digit time with suffix.
     * */
    static ZuluTime(suffix) {
        return ([time, gpsIsAvailable]) => {
            const hrsStr = Math.floor(time / 60 / 60).toFixed(0).padStart(2, '0');
            const minStr = Math.floor(time / 60 % 60).toFixed(0).padStart(2, '0');
            return gpsIsAvailable ? `${hrsStr}${minStr}${suffix}` : '';
        };
    }
    /**
     * A bearing formatter factory
     *
     * @param type the formatter type
     *
     * @returns A bearing formatter
     */
    static Bearing(type) {
        return (bearing) => {
            let fontSize;
            if ('pilotEdited' in bearing) {
                fontSize = bearing.pilotEdited ? 'large' : 'small';
            }
            else {
                fontSize = 'large';
            }
            const renderValue = bearing.value === 0 ? 360 : bearing.value;
            return B787FmcFormatters.Unit(bearing.isTrueRef ? 'T' : '°', { type, padStart: 3, padString: '0', fontSize, unitSize: 'large', spaceBetween: false })(renderValue);
        };
    }
}
B787FmcFormatters.dateCache = new Date();

/** Keep this in sync with WTB748_Common.css & WTB78x_Common.css */
class BoeingColors {
}
BoeingColors.black = 'black';
BoeingColors.blackTranslucent = 'rgba(0, 0, 0, 0.2)';
BoeingColors.white = 'white';
BoeingColors.gray = 'hsl(0, 0%, 70%)';
BoeingColors.darkGray = 'hsl(0, 0%, 50%)';
BoeingColors.blue = 'hsl(230, 100%, 51%)';
BoeingColors.red = 'red';
BoeingColors.amber = 'hsl(45, 100%, 50%)';
BoeingColors.green = '#49e700';
BoeingColors.magenta = 'magenta';
BoeingColors.cyan = 'hsl(195, 100%, 50%)';

const MIN_PREDICTIONS_IAS = 160;
const NULL_WIND_ENTRY = { speed: 0, direction: 0, trueDegrees: false };
/**
 * An implementation of {@link FlightPlanPredictionsProvider} that uses {@link BoeingPathCalculator}
 */
class BoeingFlightPlanPredictionsProvider {
    /**
     * Ctor
     * @param bus the bus
     * @param fmsPosIndex the index of the fms position to use
     * @param planIndex the index of the plan to predict data for
     * @param updateRate the update rate, in Hertz, at which to update plan predictions
     * @param flightPlanner the flight planner
     * @param windPlanner the wind planner
     * @param verticalPathCalculator the path calculator
     * @param performancePlanRepository the perf plan repo
     * @param perfProvider the perf provider
     * @param facLoader the fac loader
     */
    constructor(bus, fmsPosIndex, planIndex, updateRate, flightPlanner, windPlanner, verticalPathCalculator, performancePlanRepository, perfProvider, facLoader) {
        this.bus = bus;
        this.fmsPosIndex = fmsPosIndex;
        this.planIndex = planIndex;
        this.updateRate = updateRate;
        this.flightPlanner = flightPlanner;
        this.windPlanner = windPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.perfProvider = perfProvider;
        this.facLoader = facLoader;
        this.onPredictionsUpdated = new SubEvent();
        this.updateDebouncer = new DebounceTimer();
        this.realTimeValue = ConsumerValue.create(null, -1);
        this.simTimeValue = ConsumerValue.create(null, -1);
        this.activeLegDistanceAlongValue = ConsumerValue.create(null, -1);
        this.activeLegDtgValue = ConsumerValue.create(null, -1);
        this.pposValue = ConsumerValue.create(null, new LatLongAlt(NaN, NaN));
        this.casValue = ConsumerValue.create(null, 0);
        this.indicatedAltValue = ConsumerValue.create(null, 0);
        this.oatValue = ConsumerValue.create(null, 0);
        this.isaValue = ConsumerValue.create(null, 0);
        this.ambientWindMagnitudeValue = ConsumerValue.create(null, 0);
        this.ambientWindDirectionValue = ConsumerValue.create(null, 0);
        this.fobValue = ConsumerValue.create(null, -1);
        this.fuelWeightValue = ConsumerValue.create(null, -1);
        this.fuelFlowValue = ConsumerValue.create(null, -1);
        this.planPredictions = new Map();
        this.trackedFacilityEntries = new Map();
        this.trackedFacilityEntryPredictions = new Map();
        this.trackFacilityLastUpdates = new Map();
        this.resolvedFacilities = new Map();
        this.destinationPredictions = {
            ident: '',
            position: new GeoPoint(0, 0),
            valid: true,
            distance: NaN,
            estimatedTimeOfArrival: NaN,
            fob: NaN,
            altitude: NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.cachedSyncPacket = { planPredictions: {}, destinationPredictions: {}, trackedFacilityPredictions: {} };
        this.cachedSyncPositions = [];
        this.cachedSyncFacilityPositions = {};
        this.syncSub = this.bus.getSubscriber();
        this.syncPub = this.bus.getPublisher();
        this.initialized = false;
        this.useLocalCalculations = true;
    }
    /**
     * Fixes a Predictions object that was deserialized from JSON.
     * @param predictions The deserialized predictions object.
     * @returns The fixed predictions object.
     */
    static fixDeserializedPredictions(predictions) {
        var _a, _b, _c, _d, _e, _f;
        // We return a new object here to ensure that we don't forget to handle new fields.
        return {
            ident: predictions.ident,
            position: new GeoPoint((_a = predictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = predictions.position.lon) !== null && _b !== void 0 ? _b : NaN),
            valid: predictions.valid,
            distance: (_c = predictions.distance) !== null && _c !== void 0 ? _c : NaN,
            estimatedTimeOfArrival: (_d = predictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN,
            fob: (_e = predictions.fob) !== null && _e !== void 0 ? _e : NaN,
            altitude: (_f = predictions.altitude) !== null && _f !== void 0 ? _f : NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
    }
    /**
     * Initializes the predictor
     *
     * @param useLocalCalculations whether to use local calculations or receive calculations from another calculator
     */
    init(useLocalCalculations) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.useLocalCalculations = useLocalCalculations;
        const sub = this.bus.getSubscriber();
        if (useLocalCalculations) {
            this.setupLocalSyncEvents();
        }
        else {
            this.setupRemoteSyncEvents();
        }
        if (useLocalCalculations) {
            sub.on('realTime').whenChangedBy(this.updateRate).handle(() => {
                this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
            });
            this.realTimeValue.setConsumer(sub.on('realTime'));
            this.simTimeValue.setConsumer(sub.on('simTime'));
            this.activeLegDistanceAlongValue.setConsumer(sub.on('lnav_leg_distance_along'));
            this.activeLegDtgValue.setConsumer(sub.on('lnav_leg_distance_remaining'));
            this.pposValue.setConsumer(sub.on(`fms_pos_gps-position_${this.fmsPosIndex}`));
            this.casValue.setConsumer(sub.on('ias'));
            this.indicatedAltValue.setConsumer(sub.on('indicated_alt'));
            this.oatValue.setConsumer(sub.on('ambient_temp_c'));
            this.isaValue.setConsumer(sub.on('isa_temp_c'));
            this.ambientWindMagnitudeValue.setConsumer(sub.on('ambient_wind_velocity'));
            this.ambientWindDirectionValue.setConsumer(sub.on('ambient_wind_direction'));
            this.fobValue.setConsumer(sub.on('fuel_total_weight'));
            this.fuelWeightValue.setConsumer(sub.on('fuel_weight_per_gallon'));
            this.fuelFlowValue.setConsumer(sub.on('fuel_flow_total'));
            sub.on('fplLegChange').handle(({ legIndex, type }) => {
                const legPredictions = this.planPredictions.get(legIndex);
                switch (type) {
                    case LegEventType.Removed:
                        legPredictions && (legPredictions.valid = false);
                }
            });
        }
    }
    /**
     * Sets up sync events for receiving remote calculations
     */
    setupRemoteSyncEvents() {
        this.syncSub.on('boeing_predictions_sync').handle((predictions) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
            for (const [index, legPredictions] of Object.entries(predictions.planPredictions)) {
                const existing = this.planPredictions.get(parseInt(index));
                if (existing) {
                    existing.ident = legPredictions.ident;
                    existing.position.set((_a = legPredictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = legPredictions.position.lon) !== null && _b !== void 0 ? _b : NaN);
                    existing.valid = legPredictions.valid;
                    existing.distance = (_c = legPredictions.distance) !== null && _c !== void 0 ? _c : NaN;
                    existing.estimatedTimeOfArrival = (_d = legPredictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN;
                    existing.fob = (_e = legPredictions.fob) !== null && _e !== void 0 ? _e : NaN;
                    existing.altitude = (_f = legPredictions.altitude) !== null && _f !== void 0 ? _f : NaN;
                    existing.speed = (_g = legPredictions.speed) !== null && _g !== void 0 ? _g : NaN;
                    existing.isSpeedMach = (_h = legPredictions.isSpeedMach) !== null && _h !== void 0 ? _h : false;
                    existing.duration = (_j = legPredictions.duration) !== null && _j !== void 0 ? _j : NaN;
                }
                else {
                    this.planPredictions.set(parseInt(index), BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(legPredictions));
                }
            }
            this.destinationPredictions.ident = predictions.destinationPredictions.ident;
            this.destinationPredictions.position.set((_k = predictions.destinationPredictions.position.lat) !== null && _k !== void 0 ? _k : NaN, (_l = predictions.destinationPredictions.position.lon) !== null && _l !== void 0 ? _l : NaN);
            this.destinationPredictions.valid = predictions.destinationPredictions.valid;
            this.destinationPredictions.distance = (_m = predictions.destinationPredictions.distance) !== null && _m !== void 0 ? _m : NaN;
            this.destinationPredictions.estimatedTimeOfArrival = (_o = predictions.destinationPredictions.estimatedTimeOfArrival) !== null && _o !== void 0 ? _o : NaN;
            this.destinationPredictions.fob = (_p = predictions.destinationPredictions.fob) !== null && _p !== void 0 ? _p : NaN;
            for (const [id, facilityPredictions] of Object.entries(predictions.trackedFacilityPredictions)) {
                const existing = this.trackedFacilityEntryPredictions.get(id);
                if (existing && facilityPredictions) {
                    existing.ident = facilityPredictions.ident;
                    existing.position.set((_q = facilityPredictions.position.lat) !== null && _q !== void 0 ? _q : NaN, (_r = facilityPredictions.position.lon) !== null && _r !== void 0 ? _r : NaN);
                    existing.valid = facilityPredictions.valid;
                    existing.distance = (_s = facilityPredictions.distance) !== null && _s !== void 0 ? _s : NaN;
                    existing.estimatedTimeOfArrival = (_t = facilityPredictions.estimatedTimeOfArrival) !== null && _t !== void 0 ? _t : NaN;
                    existing.fob = (_u = facilityPredictions.fob) !== null && _u !== void 0 ? _u : NaN;
                    existing.altitude = (_v = facilityPredictions.altitude) !== null && _v !== void 0 ? _v : NaN;
                    existing.speed = (_w = facilityPredictions.speed) !== null && _w !== void 0 ? _w : NaN;
                    existing.isSpeedMach = (_x = facilityPredictions.isSpeedMach) !== null && _x !== void 0 ? _x : false;
                    existing.duration = (_y = facilityPredictions.duration) !== null && _y !== void 0 ? _y : NaN;
                }
                else if (facilityPredictions) {
                    this.trackedFacilityEntryPredictions.set(id, BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(facilityPredictions));
                }
                else {
                    this.trackedFacilityEntryPredictions.set(id, undefined);
                }
            }
            this.onPredictionsUpdated.notify(this);
        });
    }
    /**
     * Sets up sync events for starting/stopping facility tracking from other predictors
     */
    setupLocalSyncEvents() {
        this.syncSub.on('boeing_predictions_start_tracking_facility').handle(({ id, entry }) => {
            this.startTrackingFacility(id, entry);
        });
        this.syncSub.on('boeing_predictions_stop_tracking_facility').handle((id) => {
            this.stopTrackingFacility(id);
        });
    }
    /**
     * Updates predictions for the flight plan, then notifies subscribers.
     */
    updatePredictions() {
        this.updatePredictionsInternal();
        this.onPredictionsUpdated.notify(this);
        this.syncPredictions();
    }
    /**
     * Updates predictions for the flight plan
     */
    updatePredictionsInternal() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return;
        }
        const cruiseAlt = this.performancePlanRepository.getActivePlan().cruiseAltitude.get();
        const zeroFuelWeight = this.performancePlanRepository.getActivePlan().manualZfw.get();
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        const verticalPath = this.verticalPathCalculator.getVerticalFlightPath(this.planIndex);
        const unixTimestamp = this.simTimeValue.get() / 1000;
        const canComputeAdvancedPredictions = cruiseAlt !== null && zeroFuelWeight !== null;
        const pposValue = this.pposValue.get();
        this.geoPointCache[2].set(pposValue.lat, pposValue.long);
        const _lastPosition = this.geoPointCache[2];
        const altitude = this.indicatedAltValue.get();
        const cas = this.casValue.get();
        const deltaIsa = this.oatValue.get() - this.isaValue.get();
        let _lastGroundSpeedMps = AeroMath.casToTasIsa(cas, altitude, deltaIsa);
        let accumulatedDistance = 0;
        let accumulatedTime = 0;
        for (let i = 0; i < plan.length; i++) {
            let legPredictions = this.planPredictions.get(i);
            const lateralLeg = plan.getLeg(i);
            const previousLateralLeg = plan.tryGetLeg(i - 1);
            const matchingVerticalLeg = verticalPath.legs[i];
            if (i < plan.activeLateralLeg || !matchingVerticalLeg) {
                if (legPredictions) {
                    legPredictions.valid = false;
                }
                this.invalidateTrackedFacilitiesForPosition(i);
                continue;
            }
            const legIsFollowingDiscontinuity = previousLateralLeg
                && ((BoeingFmsUtils.isDiscontinuityLeg(previousLateralLeg.leg.type) && !BitFlags.isAll(previousLateralLeg.flags, LegDefinitionFlags.DirectTo))
                    || BoeingFmsUtils.isVectorsLeg(previousLateralLeg === null || previousLateralLeg === void 0 ? void 0 : previousLateralLeg.leg.type));
            if (legPredictions === undefined) {
                legPredictions = {
                    ident: (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '',
                    position: new GeoPoint(0, 0),
                    valid: true,
                    distance: NaN,
                    estimatedTimeOfArrival: NaN,
                    fob: NaN,
                    altitude: NaN,
                    speed: NaN,
                    isSpeedMach: false,
                    duration: NaN,
                };
                this.planPredictions.set(i, legPredictions);
            }
            legPredictions.ident = (_b = lateralLeg.name) !== null && _b !== void 0 ? _b : '';
            let legDistance = NaN;
            let predictFromPpos = false;
            if (i === plan.activeLateralLeg) {
                // Active leg
                if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type) && matchingVerticalLeg.vectors.length > 0) {
                    // Active vectors leg
                    this.offsetPposAlongVectorsLeg(lateralLeg, 0.1, this.geoPointCache[1]);
                    this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1], legPredictions);
                    accumulatedDistance = legPredictions.distance;
                    // We skip the rest, and do not care about tracked facilities because who would put one on a VECTORS?
                    continue;
                }
                else {
                    accumulatedDistance += UnitType.METER.convertFrom(this.activeLegDtgValue.get(), UnitType.NMILE);
                    if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                        // Active non-vectors leg with a valid VNAV profile
                        accumulatedTime += (_c = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _c !== void 0 ? _c : matchingVerticalLeg.simDuration;
                    }
                    else {
                        // Active non-vectors leg without a valid VNAV profile
                        predictFromPpos = true;
                    }
                }
            }
            else if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type)) {
                // Upcoming vectors legs
                const previousPredictions = this.planPredictions.get(i - 1);
                if (previousPredictions) {
                    legPredictions.valid = previousPredictions.valid;
                    legPredictions.position.set(previousPredictions.position);
                    legPredictions.distance = previousPredictions.distance;
                    legPredictions.estimatedTimeOfArrival = previousPredictions.estimatedTimeOfArrival;
                    legPredictions.fob = previousPredictions.fob;
                    legPredictions.altitude = previousPredictions.altitude;
                    legPredictions.speed = previousPredictions.speed;
                    legPredictions.isSpeedMach = previousPredictions.isSpeedMach;
                    legPredictions.duration = previousPredictions.duration;
                }
                else {
                    legPredictions.valid = false;
                }
                accumulatedDistance += (_d = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _d !== void 0 ? _d : matchingVerticalLeg.simDistance;
                accumulatedTime += (_e = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _e !== void 0 ? _e : matchingVerticalLeg.simDuration;
                continue;
            }
            else if (legIsFollowingDiscontinuity) {
                if (((_f = lateralLeg.calculated) === null || _f === void 0 ? void 0 : _f.endLat) && lateralLeg.calculated.endLon) {
                    // Upcoming leg after discontinuity with valid termination point
                    const distance = GeoPoint.distance(_lastPosition.lat, _lastPosition.lon, lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                    const distanceMeters = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    accumulatedDistance += distanceMeters;
                    accumulatedTime += distanceMeters / _lastGroundSpeedMps;
                }
                else {
                    // Upcoming leg after discontinuity without a valid termination point
                    legPredictions.valid = false;
                    continue;
                }
            }
            else if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                // Upcoming non-vectors leg with a valid VNAV profile
                accumulatedDistance += (_g = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _g !== void 0 ? _g : matchingVerticalLeg.simDistance;
                accumulatedTime += (_h = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _h !== void 0 ? _h : matchingVerticalLeg.simDuration;
            }
            else if (lateralLeg.calculated) {
                // Upcoming non-vectors leg without a valid VNAV profile
                accumulatedDistance += lateralLeg.calculated.distanceWithTransitions;
                accumulatedTime += lateralLeg.calculated.distanceWithTransitions / _lastGroundSpeedMps;
            }
            legDistance = accumulatedDistance;
            if (canComputeAdvancedPredictions && predictFromPpos && ((_j = lateralLeg.calculated) === null || _j === void 0 ? void 0 : _j.endLat) && lateralLeg.calculated.endLon) {
                this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1].set((_k = lateralLeg.calculated) === null || _k === void 0 ? void 0 : _k.endLat, (_l = lateralLeg.calculated) === null || _l === void 0 ? void 0 : _l.endLon), legPredictions);
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (canComputeAdvancedPredictions && matchingVerticalLeg && matchingVerticalLeg.vectors.length !== 0) {
                const lastVector = this.getVerticalVectorForPredictions(matchingVerticalLeg);
                legPredictions.valid = true;
                legPredictions.position.set((_o = (_m = lateralLeg.calculated) === null || _m === void 0 ? void 0 : _m.endLat) !== null && _o !== void 0 ? _o : NaN, (_q = (_p = lateralLeg.calculated) === null || _p === void 0 ? void 0 : _p.endLon) !== null && _q !== void 0 ? _q : NaN);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = unixTimestamp + accumulatedTime;
                legPredictions.fob = lastVector.endWeight - zeroFuelWeight;
                legPredictions.altitude = lastVector.endAltitude;
                const predictedCas = lastVector.endCas;
                const predictedMach = lastVector.endMach;
                const targetCas = lastVector.targetCas;
                const targetMach = lastVector.targetMach;
                // TODO get pressure from vector
                const pressure = AeroMath.isaPressure(lastVector.endAltitude);
                const machCasEquivalent = AeroMath.machToCas(targetMach, pressure);
                const targetMachCasEquivalentKnots = UnitType.KNOT.convertFrom(machCasEquivalent, UnitType.MPS);
                if (targetMachCasEquivalentKnots < targetCas) {
                    legPredictions.speed = predictedMach;
                    legPredictions.isSpeedMach = true;
                }
                else {
                    legPredictions.speed = predictedCas;
                    legPredictions.isSpeedMach = false;
                }
                legPredictions.duration = matchingVerticalLeg.vectors.reduce((acc, vec) => acc + vec.duration, 0);
                const gs = this.getPredictedGroundSpeedAtEndOfLeg(matchingVerticalLeg);
                if (gs !== undefined && gs !== 0) {
                    _lastGroundSpeedMps = gs;
                }
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (lateralLeg.calculated && lateralLeg.calculated.endLat !== undefined && lateralLeg.calculated.endLon !== undefined) {
                legPredictions.valid = true;
                legPredictions.position.set(lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = NaN;
                legPredictions.fob = NaN;
                legPredictions.altitude = NaN;
                legPredictions.speed = NaN;
                legPredictions.isSpeedMach = false;
                legPredictions.duration = NaN;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            else {
                legPredictions.valid = false;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            if (legPredictions.valid) {
                Number.isFinite(legPredictions.position.lat) && _lastPosition.set(legPredictions.position);
            }
        }
        // Update tracked facilities with no leg index
        if (canComputeAdvancedPredictions) {
            for (const [id, entry] of this.getTrackedFacilityEntriesForPosition('direct')) {
                this.updateTrackedFacilityPredictionsFromPpos(id, entry);
            }
        }
        else {
            this.invalidateAllTrackedFacilities();
        }
        this.updateDestinationPredictions(canComputeAdvancedPredictions);
    }
    /**
     * Sync locally calculated predictions data to remote instruments
     */
    syncPredictions() {
        for (const [index, legPredictions] of this.planPredictions.entries()) {
            if (!this.cachedSyncPacket.planPredictions[index]) {
                this.cachedSyncPacket.planPredictions[index] = {};
            }
            Object.assign(this.cachedSyncPacket.planPredictions[index], legPredictions);
            if (!this.cachedSyncPositions[index]) {
                this.cachedSyncPositions[index] = { lat: 0, lon: 0 };
            }
            this.cachedSyncPositions[index].lat = legPredictions.position.lat;
            this.cachedSyncPositions[index].lon = legPredictions.position.lon;
            this.cachedSyncPacket.planPredictions[index].position = this.cachedSyncPositions[index];
        }
        Object.assign(this.cachedSyncPacket.destinationPredictions, this.destinationPredictions);
        if (!this.cachedSyncPositions[Number.MAX_SAFE_INTEGER]) {
            this.cachedSyncPositions[Number.MAX_SAFE_INTEGER] = { lat: 0, lon: 0 };
        }
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lat = this.destinationPredictions.position.lat;
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lon = this.destinationPredictions.position.lon;
        this.cachedSyncPacket.destinationPredictions.position = this.cachedSyncPositions[Number.MAX_SAFE_INTEGER];
        for (const [id] of this.trackedFacilityEntries) {
            const predictions = this.trackedFacilityEntryPredictions.get(id);
            if (predictions) {
                if (!this.cachedSyncPacket.trackedFacilityPredictions[id]) {
                    this.cachedSyncPacket.trackedFacilityPredictions[id] = {};
                }
                Object.assign(this.cachedSyncPacket.trackedFacilityPredictions[id], predictions);
                if (!this.cachedSyncFacilityPositions[id]) {
                    this.cachedSyncFacilityPositions[id] = { lat: 0, lon: 0 };
                }
                this.cachedSyncFacilityPositions[id].lat = predictions.position.lat;
                this.cachedSyncFacilityPositions[id].lon = predictions.position.lon;
                this.cachedSyncPacket.trackedFacilityPredictions[id].position = this.cachedSyncFacilityPositions[id];
            }
            else {
                this.cachedSyncPacket.trackedFacilityPredictions[id] = null;
            }
        }
        this.syncPub.pub('boeing_predictions_sync', this.cachedSyncPacket, true);
    }
    /**
     * Updates a tracked facility entry's predictions based on the predictions of a given leg index
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     * @param legIndex the leg index
     */
    updateTrackedFacilityPredictionsAfterLeg(id, entry, legIndex) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        const legPredictions = this.planPredictions.get(legIndex);
        if (!legPredictions || !legPredictions.valid) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        this.trackFacilityLastUpdates.set(entry, this.realTimeValue.get());
        const distance = legPredictions.position.distance(facilityPredictions.position);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(legPredictions.position, facilityPredictions.position, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions, legPredictions.estimatedTimeOfArrival, legPredictions.fob);
    }
    /**
     * Updates a tracked facility entry's predictions based on PPOS
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     */
    updateTrackedFacilityPredictionsFromPpos(id, entry) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        const ppos = this.pposValue.get();
        const distance = GeoPoint.distance(facility.lat, facility.lon, ppos.lat, ppos.long);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions);
    }
    /**
     * Linearly predicts over a distance with fixed parameters
     *
     * @param startLla the position to predict at
     * @param endLla the position to predict at
     * @param distance the distance, in metres, over which to predict
     * @param speed the speed, in knots CAS or mach number, to predict at
     * @param speedIsMach whether {@link speed} is a mach number
     * @param altitude the altitude, in metres, to predict at
     * @param oatTemperature the outside air temperature, in Celsius, to predict at
     * @param oatAltitude the altitude of measure of {@link oatTemperature}
     * @param wind the wind vector to predict with
     * @param out the predictions object to hold the results
     * @param startingTime the starting time, or the current time if not provided
     * @param startingFob the starting fob, or the current fob if not provided
     */
    predictLinearly(startLla, endLla, distance, speed, speedIsMach, altitude, oatTemperature, oatAltitude, wind, out, startingTime, startingFob) {
        var _a;
        const unixTimestamp = startingTime !== null && startingTime !== void 0 ? startingTime : (this.simTimeValue.get() / 1000);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.METER);
        const distanceNm = UnitType.NMILE.convertFrom(distance, UnitType.METER);
        let predictionFuelFlow;
        const predictionOatIsaDev = oatTemperature - AeroMath.isaTemperature(oatAltitude);
        let predictionTrueAirspeed;
        if (speedIsMach) {
            predictionTrueAirspeed = AeroMath.machToTasIsa(speed, altitude, predictionOatIsaDev);
        }
        else {
            const predictionCasMps = UnitType.MPS.convertFrom(speed, UnitType.KNOT);
            predictionTrueAirspeed = AeroMath.casToTasIsa(predictionCasMps, altitude, predictionOatIsaDev);
        }
        const predictionTrueAirSpeedKnots = UnitType.KNOT.convertFrom(predictionTrueAirspeed, UnitType.MPS);
        const currentWeight = ((_a = this.performancePlanRepository.getActivePlan().manualZfw.get()) !== null && _a !== void 0 ? _a : 0) + this.fobValue.get();
        predictionFuelFlow = this.getInstantaneousFuelFlowIsa(altitude, predictionTrueAirspeed, predictionOatIsaDev, currentWeight, 0);
        // Cache great circle between positions
        this.geoCircleCache[0].setAsGreatCircle(startLla, endLla);
        let windKnots = FlightPathUtils.projectVelocityToCircle(wind.speed, startLla, wind.trueDegrees ? wind.direction : MagVar.magneticToTrue(wind.direction, startLla), this.geoCircleCache[0]);
        if (!Number.isFinite(windKnots)) {
            windKnots = 0;
        }
        const predictionGroundSpeed = predictionTrueAirSpeedKnots + windKnots;
        const durationSeconds = (distanceNm / predictionGroundSpeed) * 3600;
        if (predictionFuelFlow === undefined) {
            const fuelFlowPph = this.fuelFlowValue.get() * this.fuelWeightValue.get();
            predictionFuelFlow = fuelFlowPph / 3600;
        }
        const currentFob = startingFob !== null && startingFob !== void 0 ? startingFob : this.fobValue.get();
        out.valid = true;
        out.position.set(endLla);
        out.distance = distanceMetres;
        out.estimatedTimeOfArrival = unixTimestamp + durationSeconds;
        out.fob = currentFob - (durationSeconds * predictionFuelFlow);
        out.altitude = altitude;
        out.speed = speed;
        out.isSpeedMach = speedIsMach;
        out.duration = durationSeconds;
    }
    /**
     * Predicts performance linearly, with current conditions
     *
     * @param startLla the start point of the predictions
     * @param endLla the end point of the predictions
     * @param out the predictions object to hold the results
     */
    predictLinearlyWithCurrentConditions(startLla, endLla, out) {
        const distance = GeoPoint.distance(startLla, endLla);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        const speed = Math.max(MIN_PREDICTIONS_IAS, this.casValue.get());
        const altitude = this.indicatedAltValue.get();
        const altitudeMetres = UnitType.METER.convertFrom(altitude, UnitType.FOOT);
        const oat = this.oatValue.get();
        const wind = {
            speed: this.ambientWindMagnitudeValue.get(),
            direction: this.ambientWindDirectionValue.get(),
            trueDegrees: true,
        };
        this.predictLinearly(startLla, endLla, distanceMetres, speed, false, altitudeMetres, oat, altitudeMetres, wind, out);
    }
    /**
     * Offsets the present position along a vectors leg
     *
     * @param vectorsLeg the vectors leg
     * @param distanceToAdd the distance, in nautical miles, to offset by
     * @param out where the resulting position will be stored
     */
    offsetPposAlongVectorsLeg(vectorsLeg, distanceToAdd, out) {
        var _a;
        const distanceAlong = this.activeLegDistanceAlongValue.get();
        const distanceAlongGa = UnitType.GA_RADIAN.convertFrom(Math.max(0, distanceAlong) + distanceToAdd, UnitType.NMILE);
        if (((_a = vectorsLeg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) === undefined || vectorsLeg.calculated.startLon === undefined || vectorsLeg.calculated.initialDtk === undefined) {
            return;
        }
        this.geoPointCache[1].set(vectorsLeg.calculated.startLat, vectorsLeg.calculated.startLon);
        this.geoCircleCache[1].setAsGreatCircle(this.geoPointCache[1], vectorsLeg.calculated.initialDtk + vectorsLeg.calculated.courseMagVar);
        this.geoCircleCache[1].offsetDistanceAlong(this.geoPointCache[1], distanceAlongGa, out);
    }
    /**
     * Gets the predicited ground speed at the end of a vertical leg.
     * @param verticalLeg The vertical leg to get the predicted ground speed for.
     * @returns The predicted grouns speed, or undefined if one could not be determined.
     */
    getPredictedGroundSpeedAtEndOfLeg(verticalLeg) {
        if (verticalLeg.vectors.length === 0) {
            return undefined;
        }
        const lastVector = this.getVerticalVectorForPredictions(verticalLeg);
        return lastVector.gs;
    }
    /**
     * Returns the total distance of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDistance(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
        }
        return distance;
    }
    /**
     * Returns the total duration of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDuration(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.duration;
        }
        return distance;
    }
    /**
     * Returns the vertical path vector of a vertical leg that should be used for predictions, or the last vector if none are eligible
     *
     * **Note:** this function assumes the leg contains at least one vector
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a {@link VerticalFlightPathVector}
     */
    getVerticalVectorForPredictions(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return verticalLeg.vectors[verticalLeg.vectors.length - 1];
        }
        return verticalLeg.vectors[lastVectorIndex];
    }
    /**
     * Returns the index of the last vertical path vector that is contained within the lateral path of a leg
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a number, or -1 if no eligible vectors found
     */
    getLastVerticalVectorIndexAlongLegPath(verticalLeg) {
        for (let i = verticalLeg.vectors.length - 1; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            if (vector.startDistanceToLegEnd >= 0) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Calculates the instantaneous fuel flow for given parameters at ISA conditions
     *
     * @param altitude the altitude, in metres
     * @param tas the true airspeed, in metres per second
     * @param isaDev the ISA temperature deviation, in degrees Celsius
     * @param weight the weight, in pounds
     * @param flapsIndex The flaps index to use, or zero for a clean configuration.
     *
     * @returns the fuel flow, in pounds per second
     */
    getInstantaneousFuelFlowIsa(altitude, tas, isaDev, weight, flapsIndex) {
        const weightForce = UnitType.NEWTON.convertFrom(weight, UnitType.POUND_FORCE);
        const density = AeroMath.isaDensity(altitude, isaDev);
        const cl = AeroMath.liftCoefficient(weightForce, this.perfProvider.getWingArea(), density, tas);
        const thrust = this.perfProvider.getLevelFlightRequiredThrust(weight, cl, flapsIndex);
        const mach = AeroMath.tasToMachIsa(tas, altitude, AeroMath.soundSpeedIsa(altitude, isaDev));
        const grossThrust = this.perfProvider.estimateGrossThrustFromNetThrust(thrust, mach, AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + isaDev);
        return this.perfProvider.getEngineFuelFlow(grossThrust) / 3600;
    }
    /**
     * Returns the predictions object for a tracked facility entry, creating a new empty and invalid object if none is present
     *
     * @param id the unique id for the tracked facility entry
     * @param entry the tracked facility entry
     *
     * @returns a {@link Predictions} object
     */
    getTrackedFacilityPredictions(id, entry) {
        var _a;
        const predictions = this.trackedFacilityEntryPredictions.get(id);
        if (!predictions) {
            const emptyPredictions = {
                ident: (_a = ICAO.getIdent(entry.facIcao)) !== null && _a !== void 0 ? _a : '',
                position: new GeoPoint(NaN, NaN),
                valid: false,
                distance: NaN,
                estimatedTimeOfArrival: NaN,
                fob: NaN,
                altitude: NaN,
                groundSpeed: NaN,
                speed: NaN,
                isSpeedMach: false,
                duration: NaN,
            };
            this.trackedFacilityEntryPredictions.set(id, emptyPredictions);
            return emptyPredictions;
        }
        return predictions;
    }
    /**
     * Updates the destination prediction
     *
     * @param computeAdvancedPredictions whether to computer advanced predictions, or just distance
     */
    updateDestinationPredictions(computeAdvancedPredictions) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let mapIndex = -1;
        if (plan.length > 0) {
            for (let i = plan.length - 1; i > 0; i--) {
                const planLeg = plan.tryGetLeg(i);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    mapIndex = i;
                }
            }
        }
        // Use the MAP index if it is available
        if (mapIndex !== -1) {
            const mapLegPredictions = this.planPredictions.get(mapIndex);
            if (mapLegPredictions && mapLegPredictions.valid) {
                this.destinationPredictions.valid = true;
                Object.assign(this.destinationPredictions, mapLegPredictions);
                return;
            }
        }
        // Otherwise, predict using the prediction at the last non-missed-approach plan leg + great circle direct
        // distance to the destination airport reference point
        if (plan.length > 0 && plan.destinationAirport) {
            let lastNonMissedApproachLegIndex = -1;
            for (let i = plan.length - 1; i > 0; i--) {
                const leg = plan.getLeg(i);
                if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
                    lastNonMissedApproachLegIndex = i;
                    break;
                }
            }
            if (lastNonMissedApproachLegIndex !== -1) {
                const backwardsIterator = this.iteratePredictionsReverse(lastNonMissedApproachLegIndex);
                let lastLegPredictions;
                let prevLastLegPredictions;
                for (const predictions of backwardsIterator) {
                    if (!prevLastLegPredictions && lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        prevLastLegPredictions = predictions;
                        break;
                    }
                    if (!lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        lastLegPredictions = predictions;
                    }
                }
                if (prevLastLegPredictions && lastLegPredictions) {
                    this.destinationPredictions.valid = true;
                    Object.assign(this.destinationPredictions, lastLegPredictions);
                    const airportFacility = this.resolvedFacilities.get(plan.destinationAirport);
                    if (!airportFacility) {
                        this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                        this.destinationPredictions.valid = false;
                        return;
                    }
                    const distance = lastLegPredictions.position.distance(airportFacility);
                    const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    if (Math.abs(prevLastLegPredictions.distance - lastLegPredictions.distance) > Number.EPSILON) {
                        BoeingFlightPlanPredictionsProvider.extrapolatePrediction(prevLastLegPredictions, lastLegPredictions, distanceMetres, this.destinationPredictions);
                    }
                    else {
                        this.predictLinearly(lastLegPredictions.position, this.geoPointCache[0].set(airportFacility.lat, airportFacility.lon), distanceMetres, UnitType.MPS.convertFrom(MIN_PREDICTIONS_IAS, UnitType.KNOT), false, lastLegPredictions.altitude, 15, 0, NULL_WIND_ENTRY, this.destinationPredictions);
                    }
                    return;
                }
            }
        }
        // In the worst case scenario, predict the great circle direct distance from PPOS to the destination airport reference point
        if (plan.destinationAirport) {
            const facility = this.resolvedFacilities.get(plan.destinationAirport);
            if (!facility) {
                this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                this.destinationPredictions.valid = false;
                return;
            }
            const ppos = this.pposValue.get();
            this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, this.destinationPredictions);
            if (!computeAdvancedPredictions) {
                this.destinationPredictions.estimatedTimeOfArrival = NaN;
                this.destinationPredictions.fob = NaN;
                this.destinationPredictions.altitude = NaN;
                this.destinationPredictions.speed = NaN;
                this.destinationPredictions.isSpeedMach = false;
                this.destinationPredictions.duration = NaN;
            }
            return;
        }
        // Otherwise mark the destination predictions as invalid
        this.destinationPredictions.valid = false;
    }
    /**
     * Invalidates all tracked facility predictions
     */
    invalidateAllTrackedFacilities() {
        for (const [, predictions] of this.trackedFacilityEntryPredictions.entries()) {
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Invalidates all tracked facility predictions attached to a given position
     *
     * @param position the position
     */
    invalidateTrackedFacilitiesForPosition(position) {
        const entries = this.getTrackedFacilityEntriesForPosition(position);
        for (const [entry] of entries) {
            const predictions = this.trackedFacilityEntryPredictions.get(entry);
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Returns all facility tracking entries for a given position
     *
     * @param position the position
     *
     * @returns an array of {@link FacilityPredictionsTrackingEntry} objects
     */
    getTrackedFacilityEntriesForPosition(position) {
        const indices = [];
        for (const mapEntry of this.trackedFacilityEntries.entries()) {
            const [, entry] = mapEntry;
            if (entry.startAfterFlightPlanLeg === position) {
                indices.push(mapEntry);
            }
        }
        return indices;
    }
    /** @inheritDoc */
    *iteratePredictions(startGlobalLegIndex = 0) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = startGlobalLegIndex; i < plan.length; i++) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    *iteratePredictionsReverse(startGlobalLegIndex = this.flightPlanner.getFlightPlan(this.planIndex).length - 1) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = Math.min(plan.length - 1, startGlobalLegIndex); i > 0; i--) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    getPredictionsForLeg(globalLegIndex) {
        return this.planPredictions.get(globalLegIndex);
    }
    /** @inheritDoc */
    getDestinationPredictions() {
        return this.destinationPredictions;
    }
    /** @inheritDoc */
    getPredictionsForTrackedFacility(id) {
        var _a;
        return (_a = this.trackedFacilityEntryPredictions.get(id)) !== null && _a !== void 0 ? _a : undefined;
    }
    /** @inheritDoc */
    startTrackingFacility(id, entry) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_start_tracking_facility', { id, entry }, true);
            return;
        }
        this.trackedFacilityEntries.set(id, entry);
        this.facLoader.getFacility(ICAO.getFacilityType(entry.facIcao), entry.facIcao).then((facility) => {
            this.resolvedFacilities.set(entry.facIcao, facility);
            this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
        });
    }
    /** @inheritDoc */
    stopTrackingFacility(id) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_stop_tracking_facility', id, true);
            return true;
        }
        return this.trackedFacilityEntries.delete(id) && this.trackedFacilityEntryPredictions.delete(id);
    }
    /** @inheritDoc */
    getPredictionsForTime(time) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('estimatedTimeOfArrival', time, 1);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const ratio = (time - predictionsBefore.estimatedTimeOfArrival) / (predictionsAfter.estimatedTimeOfArrival - predictionsBefore.estimatedTimeOfArrival);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, ratio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForAltitude(altitude) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let startAltitude;
        let crossingDirection = 1;
        for (let i = 0; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (startAltitude === undefined && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                startAltitude = predictions.altitude;
                crossingDirection = startAltitude > altitude ? -1 : 1;
            }
            if (!predictions) {
                continue;
            }
            if (crossingDirection > 0 && predictions.altitude > altitude) {
                predictionsBefore = this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
            if (crossingDirection < 0 && predictions.altitude < altitude) {
                predictionsBefore = this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return undefined;
        }
        const altitudeRatio = Math.abs(altitude - predictionsBefore.altitude) / Math.abs(predictionsAfter.altitude - predictionsBefore.altitude);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, altitudeRatio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForDistance(distance) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('distance', distance, 1);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const distanceRatio = (distance - predictionsBefore.distance) / (predictionsAfter.distance - predictionsBefore.distance);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, distanceRatio, out);
        return out;
    }
    /**
     * Gets the bounding (previous and next) leg predictions that surround a given value of a property
     *
     * @param discriminant the property to evaluate
     * @param value the value (the value the previous prediction must be below, and the next prediction above)
     * @param progression the progression direction: if -1, inverts the example conditions of the {@link value} param
     *
     * @returns a tuple of {@link Predictions} objects, or null if none found
     */
    getBoundingLegPredictions(discriminant, value, progression) {
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = 0; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (!predictions) {
                continue;
            }
            if (progression > 0 ? predictions[discriminant] < value : predictions[discriminant] > value) {
                predictionsBefore = predictions;
                continue;
            }
            if (progression > 0 ? predictions[discriminant] > value : predictions[discriminant] < value) {
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return null;
        }
        return [predictionsBefore, predictionsAfter];
    }
    /**
     * Loads a facility and schedules a predictions update
     *
     * @param facilityIcao the facility ICAO
     */
    loadFacilityAndScheduleUpdate(facilityIcao) {
        this.facLoader.getFacility(ICAO.getFacilityType(facilityIcao), facilityIcao).then((loadedFac) => {
            this.resolvedFacilities.set(facilityIcao, loadedFac);
            this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
        });
    }
    /**
     * Linearly interpolates two prediction objects
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param ratio the ratio to interpolate at
     * @param out the output value object
     */
    static linearlyInterpolatePredictions(predictionsA, predictionsB, ratio, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsA.distance + (ratio * (predictionsB.distance - predictionsA.distance));
            out.estimatedTimeOfArrival = predictionsA.estimatedTimeOfArrival + (ratio * (predictionsB.estimatedTimeOfArrival - predictionsA.estimatedTimeOfArrival));
            out.fob = predictionsA.fob + (ratio * (predictionsB.fob - predictionsA.fob));
            out.altitude = predictionsA.altitude + (ratio * (predictionsB.altitude - predictionsA.altitude));
            out.speed = predictionsA.speed + (ratio * (predictionsB.speed - predictionsA.speed));
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
    /**
     * Linearly extrapolates two prediction objects into another prediction given an additional distance flown
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param additionalDistance the additional distance to extrapolate to
     * @param out the output value object
     */
    static extrapolatePrediction(predictionsA, predictionsB, additionalDistance, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsB.distance + additionalDistance;
            out.estimatedTimeOfArrival = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival);
            out.fob = MathUtils.lerp(out.estimatedTimeOfArrival, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival, predictionsA.fob, predictionsB.fob);
            out.altitude = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.altitude, predictionsB.altitude);
            out.speed = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.speed, predictionsB.speed);
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
}

/**
 * Correlates flight plan indices with performance plan objects
 */
class PerformancePlanRepository {
    /**
     * Ctor
     * @param flightPlanner a flight planner instance
     * @param bus the event bus
     */
    constructor(flightPlanner, bus) {
        this.flightPlanner = flightPlanner;
        this.bus = bus;
        this.repoId = Math.floor(Math.random() * 10000000);
        this._plans = [];
        this.plans = this._plans;
        this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[BoeingFms.ACT_RTE_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        const sub = this.bus.getSubscriber();
        sub.on('fplOriginDestChanged').handle((data) => {
            if (data.type === OriginDestChangeType.OriginAdded || data.type === OriginDestChangeType.OriginRemoved) {
                this.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, data.planIndex);
            }
        });
        sub.on('performancePlanChanged').handle((data) => {
            if (data.repoId !== this.repoId) {
                PerformancePlanUtils.deserializeInto(data.serializedPlan, this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX]);
                if (this.has(data.planIndex)) {
                    this.copy(PerformancePlanRepository.SYNC_PLAN_INDEX, data.planIndex, true);
                }
            }
        });
    }
    /**
     * Whether the repository has a performance plan already stored for a given index
     *
     * @param index the index
     *
     * @returns boolean
     */
    has(index) {
        return this._plans[index] !== undefined;
    }
    /**
     * Returns a performance plan for a given flight plan index, or creates it
     *
     * @param index flight plan index
     *
     * @throws if an invalid flight plan index is specified
     *
     * @returns the performance plan
     */
    forFlightPlanIndex(index) {
        const existing = this._plans[index];
        if (!existing) {
            return this.create(index);
        }
        return existing;
    }
    /**
     * Gets the active plan. This is the plan that always exists even if there is no valid flight plan yet.
     * @returns the active plan
     */
    getActivePlan() {
        return this._plans[0];
    }
    /**
     * Returns the performance plan containing default values
     *
     * @returns the plan
     */
    defaultValuesPlan() {
        return this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX];
    }
    /**
     * Returns whether this plan repository has nay valid plans
     *
     * @returns boolean
     */
    hasAnyPlan() {
        return this._plans.some((it, index) => !!it && this.flightPlanner.hasFlightPlan(index));
    }
    /**
     * Creates a performance plan at the given index if it doesn't exist, or returns the existing one
     *
     * @param atIndex the index
     *
     * @returns the created plan
     */
    create(atIndex) {
        if (!this.has(atIndex)) {
            const newPerformancePlan = PerformancePlanUtils.createPlanFromDefinitions();
            this._plans[atIndex] = newPerformancePlan;
            return newPerformancePlan;
        }
        else {
            return this._plans[atIndex];
        }
    }
    /**
     * Copies a performance plan onto another
     *
     * @param from from index
     * @param to to index
     * @param skipChecks whether to skip flight planner checks
     */
    copy(from, to, skipChecks = false) {
        const fromPlan = this._plans[from];
        const toPlan = skipChecks ? this._plans[to] : this.forFlightPlanIndex(to);
        // Copy data
        for (const key in toPlan) {
            const fromValue = fromPlan[key];
            const toValue = toPlan[key];
            if (fromValue instanceof Subject && toValue instanceof Subject) {
                toValue.set(fromValue.get());
            }
        }
    }
    /**
     * Triggers a synchronisation of the active plan performance plan over the EventBus.
     * @param planIndex the plan index
     */
    triggerSync(planIndex) {
        const packet = {
            repoId: this.repoId,
            planIndex,
            serializedPlan: PerformancePlanUtils.serialize(this._plans[planIndex]),
        };
        this.bus.getPublisher().pub('performancePlanChanged', packet, true, true);
    }
}
PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX = Number.MAX_SAFE_INTEGER;
PerformancePlanRepository.SYNC_PLAN_INDEX = PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX - 1;

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
/**
 * A Boeing FMS
 */
class BoeingFms {
    /**
     * Initialize an instance of the FMS.
     * @param bus is the event bus
     * @param flightPlanner is the flight planner
     * @param verticalPathCalculator is the VNAV Path Calculator.
     * @param performancePlanRepository the performance plan repository
     * @param windPlanner Handles wind and temperature entries and propagation for climb, cruise, and descent
     * @param perfProvider the BoeingPathPerformanceProvider
     * @param engineDataProvider the BoeingEngineDataProvider
     * @param isPrimaryFms Whether this is the primary FMS
     * @param activeRoutePredictor The active route predictions provider
     * @param fixInfo The fix info manager
     * @param messageTransmitter A boeing message transmitter
     */
    constructor(bus, flightPlanner, verticalPathCalculator, performancePlanRepository, windPlanner, perfProvider, engineDataProvider, isPrimaryFms, activeRoutePredictor, fixInfo, messageTransmitter) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.windPlanner = windPlanner;
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.isPrimaryFms = isPrimaryFms;
        this.activeRoutePredictor = activeRoutePredictor;
        this.fixInfo = fixInfo;
        this.messageTransmitter = messageTransmitter;
        /** Set to true by FMC pages when the plan on this FMS instance is in modification and awaiting a cancel or exec. */
        this.planInMod = Subject.create(false);
        /**
         * Map of routes numbers to whether or not they are activated
         */
        this.routesActivated = {
            1: Subject.create(false),
            2: Subject.create(false),
        };
        this.route1Activated = this.routesActivated['1'];
        /** Set to true when an event is received from the bus indicating that another instrument is in MOD on the plan. */
        this.remotePlanInMod = false;
        this.ppos = new GeoPoint(0, 0);
        this.alternates = new BoeingAlternates(this.bus, this, this.isPrimaryFms);
        this.vnavData = new BoeingFmsVNavDataProvider(this.bus, this, !this.isPrimaryFms);
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        /** Information on our origin, arrival and destination facilities to save lookups.
         * When in MOD, this will reflect the current origin and destination in the MOD plan. */
        this.facilityInfo = {
            originFacility: undefined,
            destinationFacility: undefined
        };
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false,
            approachIsCircling: false,
            approachName: '',
            approachRunway: '',
            missedApproachFacility: null,
            referenceFacility: null,
            finalApproachCourse: -1,
        };
        /** Approach details for the active flight plan. Note `approachIsActive` is **not** synced here! Use {@link approachDetails} for that. */
        this.activeApproachDetails = Object.assign({}, this.approachDetails);
        this._pendingTakeoffDataUplink = Subject.create(null);
        /**
         * The currently pending takeoff data uplink, or null if there is none
         */
        this.pendingTakeoffDataUplink = this._pendingTakeoffDataUplink;
        /** Current true aircraft track */
        this.aircraftTrack = undefined;
        /** Current aircraft indicated altitude */
        this.aircraftAltitude = undefined;
        this.approachFrequency = Subject.create(undefined);
        this._lastApproachFrequencyEventValue = undefined;
        this.cdiSource = { type: NavSourceType.Gps, index: 1 };
        this.missedApproachActive = false;
        this.tunedIlsFrequency = null;
        this.tunedIlsCourse = null;
        this.approachFrequencyMismatch = Subject.create(false);
        this.approachCourseMismatch = Subject.create(false);
        /** Set to true when a leg is activated,
         * meaning that sequencing should be resumed once EXEC is pressed.
         * Should be reset whenever leaving MOD. */
        this.legWasActivatedInModPlan = false;
        /** Set to true when a new DTO is created,
         * meaning its origin should be regularly updated while in MOD and when hitting EXEC.
         * Should be reset whenever leaving MOD. */
        this.dtoWasCreatedInModPlan = false;
        /** Set to true when a new vertical DTO is created,
         * meaning its origin should be regularly updated while in MOD and when hitting EXEC.
         * Should be reset whenever leaving MOD. */
        this.verticalDtoWasCreatedInModPlan = false;
        /**
         * Set to true when the vertical DTO in the mod flight plan was automatic
         */
        this.verticalDtoWasCreatedInModPlanWasAutomatic = false;
        this.operatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT);
        this.onGround = ConsumerValue.create(null, false);
        this._performancePlanProxy = PerformancePlanUtils.createProxyFromDefinitions({
            defaultValuesPlan: this.performancePlanRepository.defaultValuesPlan(),
            /** @inheritDoc */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            onBeforeEdit: (property, newValue) => {
                if (!property.editInPlace) {
                    this.getPlanToModify();
                }
            },
            /** @inheritDoc */
            onAfterEdit: (property, newValue) => {
                if (property.editInPlace) {
                    // We edit all plans, since we do not want to involve an EXEC to confirm a value.
                    // This makes sure that if a value is modified while a MOD plan exists, we modify it, making a copy
                    // from ACT -> MOD not reset the value.
                    for (let i = 0; i < this.performancePlanRepository.plans.length; i++) {
                        const plan = this.performancePlanRepository.plans[i];
                        if (!plan) {
                            continue;
                        }
                        plan[property.key].set(newValue);
                        this.performancePlanRepository.triggerSync(i);
                    }
                }
            },
        });
        this.onOriginDestinationChanged = (e) => {
            if (e.planIndex === this.getPlanIndexForFmcPage()) {
                this.setFacilityInfo();
            }
        };
        /**
         * Called when 'fplProcDetailsChanged' event is fired from changes in procedure details of a flight plan.
         * @param e The event fired when flight plan procedure details change.
         */
        this.onProcedureDetailsChanged = (e) => {
            this.syncProcedureDetailsChangesToPerformancePlan(e);
        };
        this.onPlanCopied = (ev) => {
            this.setFacilityInfo();
            this.ensureActiveHMSuspended();
            this.applyCopyToPerformancePlans(ev);
            if (ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.tryUnsuspend();
                this.syncFlightPlanToPerformancePlan();
                this.syncHudTakeoff();
            }
            if (ev.planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX && ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.routesActivated[1].set(true);
            }
        };
        this.onPlanCreated = (ev) => {
            this.applyCreationToPerformancePlans(ev);
        };
        this.onPlanCalculated = (e) => {
            if (e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && this.planInMod.get()) {
                const plan = this.getPlanToModify();
                if (this.verticalDtoWasCreatedInModPlan) {
                    this.updateVerticalDtoOrigin(plan);
                }
                if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX)) {
                    this.updateDtoOrigin(plan);
                }
                this.tryUpdatePposHoldPosition(plan);
            }
        };
        this.onPlanLoaded = (ev) => {
            this.checkApproachState().then();
            this.switchPerformanceProxyToRenderPlan(true);
            this.syncFlightPlanToPerformancePlan();
            const plan = this.flightPlanner.getFlightPlan(ev.planIndex);
            const route = plan.getUserData(BoeingFms.USER_DATA_KEY_ROUTE);
            if (ev.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                if (typeof route === 'number') {
                    this.routesActivated[route].set(true);
                }
                this.syncHudTakeoff();
            }
        };
        this.onFmsOperatingPhaseChanged = (newPhase) => {
            if (newPhase === FmsOperatingPhase.COMPLETE) {
                // Reset performance plan
                this.performancePlanRepository.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, BoeingFms.ACT_RTE_PLAN_INDEX);
                this.performancePlanRepository.triggerSync(BoeingFms.ACT_RTE_PLAN_INDEX);
                // Reset flight plan
                this.emptyFlightPlan();
                this.routesActivated[1].set(false);
            }
        };
        this.onEfbRequestFlightInitializationData = async () => {
            const plan = this.getPrimaryFlightPlan();
            if (plan.originAirport) {
                const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
                const runways = airportFacility.runways;
                const takeoffRunway = plan.procedureDetails.originRunway;
                const airportOrigin = plan.originAirport;
                const airportDestination = plan.destinationAirport;
                const oat = this.activePerformancePlan.takeoffTemp.get();
                const gw = this.activePerformancePlan.takeoffGw.get();
                if (takeoffRunway === undefined ||
                    oat === null ||
                    gw === null ||
                    airportOrigin === undefined ||
                    airportDestination === undefined ||
                    runways === undefined) {
                    return;
                }
                const data = {
                    airportOrigin,
                    airportDestination,
                    runways,
                    takeoffRunway,
                    rwyCondition: EfbRunwayCondition.DRY,
                    runwayDisplacement: 0,
                    oat,
                    qnh: 0,
                    gw,
                };
                this.bus.getPublisher().pub('fmc_send_flight_initialization_data', data, true);
            }
        };
        this.onEfbSendTakeoffDataUplink = (data) => {
            this._pendingTakeoffDataUplink.set(data);
            this.messageTransmitter.sendMessage(BoeingFmcErrorKeys.TakeoffDataUplink);
        };
        this.insertApproachOpId = 0;
        /**
         * Sets the approach details when an approach_details_set event is received from the bus.
         * @param approachDetails The approachDetails received from the bus.
         */
        this.onApproachDetailsSet = (approachDetails) => {
            if (approachDetails !== this.approachDetails) {
                this.approachDetails = approachDetails;
                this.checkTunedIlsMismatch();
            }
            const canApproachActivate = this.canApproachActivate();
            if (!canApproachActivate && this.approachDetails.approachIsActive) {
                this.setApproachDetails(undefined, undefined, undefined, canApproachActivate);
            }
        };
        this.perfInitPageCompleted = MappedSubject.create(([hasZfw, hasReserves, hasCrzAlt, hasCostIndex]) => hasZfw && hasReserves && hasCrzAlt && hasCostIndex, this.activePerformancePlan.manualZfw.map((val) => val !== null), this.activePerformancePlan.reserveFuel.map((val) => val !== null), this.activePerformancePlan.cruiseAltitude.map((val) => val !== null), this.activePerformancePlan.costIndex.map((val) => val !== null));
        this.perfIsInitialized = MappedSubject.create(([posIsInit, routeIsAct, perfInitDone]) => posIsInit && routeIsAct && perfInitDone, ConsumerSubject.create(this.bus.getSubscriber().on('all_irs_systems_operating'), true), this.routesActivated['1'], this.perfInitPageCompleted);
        this.takeoffRefPageCompleted = MappedSubject.create(([hasTakeoffFlaps, hasCog]) => hasTakeoffFlaps && hasCog, this.activePerformancePlan.takeoffFlaps.map((val) => val !== null), this.activePerformancePlan.takeoffCg.map((val) => val !== null));
        this.preflightComplete = MappedSubject.create(([perfInitDone, takeoffRefDone]) => perfInitDone && takeoffRefDone, this.perfIsInitialized, this.takeoffRefPageCompleted);
        this.cdiScaleLabel = ConsumerSubject.create(this.bus.getSubscriber().on('lnavdata_cdi_scale_label'), 4);
        this.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
        this.bus.getSubscriber().on('track_deg_true').handle((track) => this.aircraftTrack = track);
        this.bus.getSubscriber().on('indicated_alt').handle((track) => this.aircraftAltitude = track);
        this.bus.getSubscriber().on('cdi_select').handle(source => this.cdiSource = source);
        const planEvents = this.bus.getSubscriber();
        planEvents.on('fplActiveLegChange').handle(data => this.onActiveLegChanged(data.type, data.planIndex));
        planEvents.on('fplLoaded').handle(this.onPlanLoaded);
        planEvents.on('fplCalculated').handle(this.onPlanCalculated);
        planEvents.on('fplCopied').handle(this.onPlanCopied);
        planEvents.on('fplCreated').handle(this.onPlanCreated);
        planEvents.on('fplOriginDestChanged').handle(this.onOriginDestinationChanged);
        planEvents.on('fplProcDetailsChanged').handle(this.onProcedureDetailsChanged);
        planEvents.on('fplUserDataSet').handle(this.onPlanUserDataSet.bind(this));
        const efbFmcCommunicationEvents = this.bus.getSubscriber();
        efbFmcCommunicationEvents.on('efb_request_flight_initialization_data').handle(this.onEfbRequestFlightInitializationData);
        efbFmcCommunicationEvents.on('efb_send_takeoff_data').handle(this.onEfbSendTakeoffDataUplink);
        this.operatingPhase.setConsumer(this.bus.getSubscriber().on('fms_operating_phase'));
        this.operatingPhase.sub(this.onFmsOperatingPhaseChanged.bind(this), true);
        this.onGround.setConsumer(this.bus.getSubscriber().on('on_ground'));
        this.planInMod.sub((v) => {
            if (v) {
                SimVar.SetSimVarValue('L:FMC_EXEC_ACTIVE', 'number', 1);
            }
            else {
                SimVar.SetSimVarValue('L:FMC_EXEC_ACTIVE', 'number', 0);
            }
        }, true);
        this.planInMod.sub((v) => {
            if (!v) {
                // Need to update facility info on ERASE
                this.setFacilityInfo();
                // Need to copy the active approach details back in case a mod was cancelled
                this.syncApproachDetailsFromActive();
            }
        });
        this.planInMod.sub(() => {
            this.switchPerformanceProxyToRenderPlan();
        });
        this.bus.getSubscriber().on('fmcExecActive').whenChanged().handle((v) => {
            const state = v === 1;
            this.remotePlanInMod = state;
        });
        this.bus.getSubscriber().on('approach_details_set').handle(this.onApproachDetailsSet);
        this.cdiScaleLabel.sub(v => {
            const canApproachActivate = this.canApproachActivate(v);
            if (canApproachActivate !== this.approachDetails.approachIsActive) {
                this.setApproachDetails(undefined, undefined, undefined, canApproachActivate);
            }
        });
        if (this.isPrimaryFms) {
            this.bus.getSubscriber().on('altimeter_baro_is_std_1').whenChanged().handle((std) => {
                // Reset landing reference to QNH when baro STD is activated in climb phase.
                if (std && this.operatingPhase.get() === FmsOperatingPhase.CLIMB) {
                    this._performancePlanProxy.approachLandingRef.set(1);
                }
            });
        }
        this.bus.getSubscriber().on('nav_active_frequency_3').handle((frequency) => {
            this.tunedIlsFrequency = frequency;
            if (this.hasPrimaryFlightPlan()) {
                this.checkTunedIlsMismatch();
            }
        });
        this.bus.getSubscriber().on('nav_obs_3').handle((obs) => {
            this.tunedIlsCourse = obs;
            if (this.hasPrimaryFlightPlan()) {
                this.checkTunedIlsMismatch();
            }
        });
        this.approachFrequencyMismatch.sub((v) => this.bus.getPublisher().pub('approach_frequency_mismatch', v, true));
        this.approachCourseMismatch.sub((v) => this.bus.getPublisher().pub('approach_course_mismatch', v, true));
        this.activePerformancePlan.glideSlope.sub((v) => this.bus.getPublisher().pub('boeing_glideslope_selected', v === GlideslopeStatus.ON));
        this.activePerformancePlan.approachLandingRef.sub((v) => this.bus.getPublisher().pub('boeing_qfe_approach_selected', v === 0));
    }
    /**
     * Obtain the performance plan for FMC render
     * @returns the plan
     */
    get performancePlanForFmcRender() {
        let index;
        if (this.planInMod.get()) {
            index = BoeingFms.RTE_1_MOD_PLAN_INDEX;
        }
        else {
            index = BoeingFms.ACT_RTE_PLAN_INDEX;
        }
        return this.performancePlanRepository.forFlightPlanIndex(index);
    }
    /**
     * Returns the active performance plan
     *
     * @returns the performance plan for the active flight plan index
     */
    get activePerformancePlan() {
        return this.performancePlanRepository.getActivePlan();
    }
    /**
     * Returns the performance plan proxy
     *
     * @returns the performance plan proxy
     */
    get performancePlanProxy() {
        return this._performancePlanProxy;
    }
    /**
     * Syncs the primary flight plan data to the relevant performance plan values
     */
    syncFlightPlanToPerformancePlan() {
        var _a, _b, _c, _d;
        if (this.hasPrimaryFlightPlan()) {
            const plan = this.getPrimaryFlightPlan();
            this.activePerformancePlan.takeoffAirportIcao.set((_a = plan.originAirport) !== null && _a !== void 0 ? _a : null);
            this.activePerformancePlan.originRunway.set((_b = plan.procedureDetails.originRunway) !== null && _b !== void 0 ? _b : null);
            this.activePerformancePlan.approachAirportIcao.set((_c = plan.destinationAirport) !== null && _c !== void 0 ? _c : null);
            this.activePerformancePlan.approachRunway.set((_d = plan.procedureDetails.destinationRunway) !== null && _d !== void 0 ? _d : null);
        }
    }
    /**
     * Switches the performance proxy to use the FMC render plan
     *
     * @param initial whether this is a call on the initial plan load
     */
    switchPerformanceProxyToRenderPlan(initial = false) {
        this._performancePlanProxy.switchToPlan(this.performancePlanForFmcRender, initial);
    }
    /**
     * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
     */
    async initPrimaryFlightPlan() {
        if (this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX)) {
            // Plan was synced
            await this.setFacilityInfo();
            return;
        }
        this.flightPlanner.createFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        const inactivePlanRte1 = this.flightPlanner.createFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        const modPlanRte1 = this.flightPlanner.createFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        inactivePlanRte1.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        modPlanRte1.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        this.emptyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        this.emptyFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        const simPlaneLoaded = await FlightPlanAsoboSync.loadFromGame(this);
        if (simPlaneLoaded) {
            this.activate(1);
            this.execute();
        }
    }
    /**
     * Checks whether an indexed flight plan exists.
     * @param index A flight plan index.
     * @returns Whether a flight plan at the specified index exists.
     */
    hasFlightPlan(index) {
        return this.flightPlanner.hasFlightPlan(index);
    }
    /**
     * Gets a specified flightplan, or by default the primary flight plan.
     * @param index The index of the flight plan.
     * @returns the requested flight plan
     * @throws Error if no flight plan exists at the specified index.
     */
    getFlightPlan(index = BoeingFms.ACT_RTE_PLAN_INDEX) {
        return this.flightPlanner.getFlightPlan(index);
    }
    /**
     * Checks whether the primary flight plan exists.
     * @returns Whether the primary flight plan exists.
     */
    hasPrimaryFlightPlan() {
        return this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Gets the primary lateral flight plan.
     * @returns The primary flight plan.
     * @throws Error if the primary flight plan does not exist.
     */
    getPrimaryFlightPlan() {
        return this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Gets the primary vertical flight plan.
     * @returns the primary vertical flight plan.
     */
    getPrimaryVerticalFlightPlan() {
        return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Checks whether the Primary Mod Flight Plan Exists - when modifications to the plan are being made.
     * @returns Whether the Primary Mod Flight Plan Exists flight plan exists.
     */
    hasPrimaryModFlightPlan() {
        return this.flightPlanner.hasFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Gets the Primary Mod Flight Plan Exists - when modifications to the plan are being made.
     * @returns The Primary Mod Flight Plan.
     * @throws Error if the Primary Mod Flight Plan flight plan does not exist.
     */
    getPrimaryModFlightPlan() {
        return this.flightPlanner.getFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Gets the primary mod vertical flight plan.
     * @returns the primary mod vertical flight plan.
     */
    getPrimaryModVerticalFlightPlan() {
        return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Returns whether the route is activated
     * @param route the route
     * @returns a boolean
     */
    isRouteActivated(route) {
        return this.routesActivated[route].get();
    }
    /**
     * Returns a subscribable the route is activated
     * @param route the route
     * @returns a subscribable
     */
    routeActivated(route) {
        return this.routesActivated[route];
    }
    /**
     * Handles when the EXEC button is pressed and copies the MOD plan back to the PRIMARY plan
     */
    execute() {
        if (this.planInMod.get()) {
            const modPlan = this.getPlanToModify();
            if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX) === DirectToState.TOEXISTING) {
                this.updateDtoOrigin(modPlan);
            }
            if (this.verticalDtoWasCreatedInModPlan) {
                this.updateVerticalDtoOrigin(modPlan);
            }
            // Make sure this is only reset after the call to updateDTOOrigin
            this.dtoWasCreatedInModPlan = false;
            this.verticalDtoWasCreatedInModPlan = false;
            this.verticalDtoWasCreatedInModPlanWasAutomatic = false;
            this.syncApproachDetailsToActive();
            if (typeof modPlan.getUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN) === 'boolean') {
                // In this case the user changed the origin on an active route, causing a new inactive plan to be created
                modPlan.deleteUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN);
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, true);
                this.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX).calculate(0);
                this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                this.emptyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
                this.routesActivated[1].set(false);
                this.planInMod.set(false);
                this.legWasActivatedInModPlan = false;
            }
            else {
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.ACT_RTE_PLAN_INDEX, true);
                this.getPrimaryFlightPlan().calculate(0);
                this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                this.planInMod.set(false);
                // make sure ACT performance plan has new values
                this.syncFlightPlanToPerformancePlan();
                // sync ACT performance plan
                this.performancePlanRepository.triggerSync(BoeingFms.ACT_RTE_PLAN_INDEX);
                if (this.legWasActivatedInModPlan) {
                    this.legWasActivatedInModPlan = false;
                    this.resumeSequencing();
                }
                if (this.getPrimaryFlightPlan().getUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING)) {
                    this.handleVnavDesPending();
                }
                FlightPlanAsoboSync.SaveToGame(this);
            }
            // TODO listen to f-pln events to calculate this
            // If the selected approach is not LOC-based, and there is an approach selected, the lateral approach guidance should be FMS LOC
            this.bus.getPublisher().pub('boeing_fms_loc_approach_selected', !BoeingFmsUtils.isLocalizerApproach(this.approachDetails.approachType) && this.approachDetails.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN);
        }
    }
    /**
     * Activates the indicated route
     * @param route the route index, 1-based
     */
    activate(route) {
        this.flightPlanner.copyFlightPlan(BoeingFms[`RTE_${route}_INACTIVE_PLAN_INDEX`], BoeingFms[`RTE_${route}_MOD_PLAN_INDEX`], true);
        this.planInMod.set(true);
        this.emptyFlightPlan(BoeingFms[`RTE_${route}_INACTIVE_PLAN_INDEX`]);
    }
    /** Resumes flight plan sequencing. */
    resumeSequencing() {
        this.bus.getPublisher().pub('suspend_sequencing', false, true);
    }
    /**
     * Handles when the ERASE button is pressed.
     */
    cancelMod() {
        if (this.planInMod.get()) {
            if (!this.isRouteActivated(1)) {
                // Copy mod back to inactive when there is no active plan yet
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, true);
            }
            this.legWasActivatedInModPlan = false;
            this.dtoWasCreatedInModPlan = false;
            this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
            this.planInMod.set(false);
        }
    }
    /**
     * Handles when a modification is being made to the plan to ensure the plan is in MOD mode
     * @param routeNumber the route number (currently always RTE 1)
     * @returns The Flight Plan to modify
     */
    getPlanToModify(routeNumber = 1) {
        if (this.planInMod.get()) {
            return this.getFlightPlan(BoeingFms[`RTE_${routeNumber}_MOD_PLAN_INDEX`]);
        }
        const isRouteActivated = this.isRouteActivated(routeNumber);
        if (!isRouteActivated) {
            return this.getFlightPlan(BoeingFms[`RTE_${routeNumber}_INACTIVE_PLAN_INDEX`]);
        }
        // Active route going into MOD
        this.flightPlanner.copyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX, BoeingFms[`RTE_${routeNumber}_MOD_PLAN_INDEX`], true);
        this.getPrimaryModFlightPlan().calculate(0);
        this.planInMod.set(true);
        return this.getPrimaryModFlightPlan();
    }
    /**
     * Gets the plan index FMC pages should use to monitor events.
     * @returns A Flight Plan Index
     */
    getPlanIndexForFmcPage() {
        if (this.planInMod.get()) {
            return BoeingFms.RTE_1_MOD_PLAN_INDEX;
        }
        else if (this.isRouteActivated(1)) {
            return BoeingFms.ACT_RTE_PLAN_INDEX;
        }
        else {
            return BoeingFms.RTE_1_INACTIVE_PLAN_INDEX;
        }
    }
    /**
     * Gets the current lateral flight plan for the FMC pages based on whether the plan is in MOD or ACT.
     * @returns A Lateral Flight Plan
     */
    getPlanForFmcRender() {
        if (this.planInMod.get()) {
            return this.getPrimaryModFlightPlan();
        }
        else if (this.isRouteActivated(1)) {
            return this.getPrimaryFlightPlan();
        }
        else {
            return this.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        }
    }
    /**
     * Gets the current vertical flight plan for the FMC pages based on whether the plan is in MOD or ACT.
     * @returns A Vertical Flight Plan
     */
    getVerticalPlanForFmcRender() {
        if (this.planInMod.get()) {
            return this.getPrimaryModVerticalFlightPlan();
        }
        else if (this.isRouteActivated(1)) {
            return this.getPrimaryVerticalFlightPlan();
        }
        else {
            return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        }
    }
    /**
     * Checks whether the plan can go into MOD/be edited on this instance of WT21Fms.
     * @returns Whether to allow plan edits or not
     */
    canEditPlan() {
        if (this.remotePlanInMod && !this.planInMod.get()) {
            return false;
        }
        return true;
    }
    /**
     * Sync the procedure details changes from a flight plan to its respective performance plan.
     * Only sync departureFacilityIcao and originRunway changes at the moment.
     * @param e The event fired when flight plan procedure details change.
     */
    syncProcedureDetailsChangesToPerformancePlan(e) {
        var _a, _b;
        const targetPerfPlan = this.performancePlanRepository.forFlightPlanIndex(e.planIndex);
        targetPerfPlan.takeoffAirportIcao.set((_a = e.details.departureFacilityIcao) !== null && _a !== void 0 ? _a : null);
        targetPerfPlan.originRunway.set((_b = e.details.originRunway) !== null && _b !== void 0 ? _b : null);
    }
    /**
     * Accepts a pending takeoff uplink
     */
    acceptPendingTakeoffUplink() {
        const data = this.pendingTakeoffDataUplink.get();
        if (data) {
            const vSpeedsSettings = VSpeedUserSettings.getManager(this.bus);
            vSpeedsSettings.getSettings(VSpeedType.V1).value.set(data.v1);
            vSpeedsSettings.getSettings(VSpeedType.Vr).value.set(data.vr);
            vSpeedsSettings.getSettings(VSpeedType.V2).value.set(data.v2);
            this.performancePlanProxy.takeoffFlaps.set(data.flapSetting);
            this.performancePlanProxy.takeoffThrustMode.set(data.thrustRating);
            this.performancePlanProxy.takeoffAssumedTemp.set(data.assumedTemperature);
            this._pendingTakeoffDataUplink.set(null);
        }
    }
    /**
     * Rejects a pending takeoff uplink
     */
    rejectPendingTakeoffUplink() {
        this._pendingTakeoffDataUplink.set(null);
    }
    /**
     * Sets the Facility Info cache in the Fms.
     */
    async setFacilityInfo() {
        var _a, _b;
        const plan = this.getPlanForFmcRender();
        if (((_a = this.facilityInfo.originFacility) === null || _a === void 0 ? void 0 : _a.icao) !== plan.originAirport) {
            if (plan.originAirport) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
                this.facilityInfo.originFacility = facility !== null && facility !== void 0 ? facility : undefined;
            }
            else {
                this.facilityInfo.originFacility = undefined;
            }
        }
        if (((_b = this.facilityInfo.destinationFacility) === null || _b === void 0 ? void 0 : _b.icao) !== plan.destinationAirport) {
            if (plan.destinationAirport) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                this.facilityInfo.destinationFacility = facility !== null && facility !== void 0 ? facility : undefined;
            }
            else {
                this.facilityInfo.destinationFacility = undefined;
            }
        }
    }
    /**
     * Gets the ALTN airport of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingAlternates` instead
     *
     * @param planIndex the flight plan index
     *
     * @returns the ALTN airport FS ICAO, or undefined
     */
    getFlightPlanAlternates(planIndex) {
        const plan = this.getFlightPlan(planIndex);
        return plan.getUserData(BoeingFms.USER_DATA_KEY_ALTN);
    }
    /**
     * Sets the ALTN airports of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingAlternates` instead
     *
     * @param planIndex the plan index to use
     * @param alternates the ALTN airports
     */
    setFlightPlanAlternates(planIndex, alternates) {
        const plan = this.getFlightPlan(planIndex);
        plan.setUserData(BoeingFms.USER_DATA_KEY_ALTN, alternates);
    }
    /**
     * Returns a flight plan's visual approach, as the runway designator of the approach
     *
     * @param planIndex the plan index
     *
     * @returns a string
     */
    getFlightPlanVisualApproach(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH);
    }
    /**
     * Returns a flight plan's visual approach, as the runway designator of the approach
     *
     * @param planIndex the plan index
     * @param runwayDesignator the visual approach's runway designator
     */
    setFlightPlanVisualApproach(planIndex, runwayDesignator) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH, runwayDesignator);
    }
    /**
     * Deletes a flight plan's visual approach
     *
     * @param planIndex the plan index
     */
    deleteFlightPlanVisualApproach(planIndex) {
        this.getFlightPlan(planIndex).deleteUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH);
    }
    /**
     * Returns a flight plan's visual approach VFR vertical path angle
     *
     * @param planIndex the plan index
     *
     * @returns a number, in degrees
     */
    getFlightPlanVisualApproachVfrVpa(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA);
    }
    /**
     * Sets a flight plan's visual approach VFR vertical path angle
     *
     * @param planIndex the plan index
     * @param vpa the visual approach's VFR vertical path angle, in degrees
     */
    setFlightPlanVisualApproachVfrVpa(planIndex, vpa) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA, vpa);
    }
    /**
     * Handle the flightplan user data changed event
     * @param event User data event
     */
    onPlanUserDataSet(event) {
        if (event.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && event.key === BoeingFms.USER_DATA_KEY_HUD_TAKEOFF) {
            this.syncHudTakeoff();
        }
    }
    /**
     * Returns a flight plan's selected HUD takeoff
     *
     * @param planIndex the plan index
     *
     * @returns the HUD takeoff runway, or undefined
     */
    getFlightPlanHudTakeoff(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_HUD_TAKEOFF);
    }
    /**
     * Sets a flight plan's selected HUD takeoff
     *
     * @param planIndex the plan index
     * @param hudTakeoffRunway the HUD takeoff runway, or undefined
     */
    setFlightPlanHudTakeoff(planIndex, hudTakeoffRunway) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_HUD_TAKEOFF, hudTakeoffRunway);
    }
    /**
     * Sync the active HUD takeoff runway to the bus
     */
    syncHudTakeoff() {
        var _a;
        this.bus.getPublisher().pub('boeing_hud_takeoff_runway_set', (_a = this.getFlightPlanHudTakeoff(BoeingFms.ACT_RTE_PLAN_INDEX)) !== null && _a !== void 0 ? _a : null, true);
        this.checkTunedIlsMismatch();
    }
    /**
     * Set VNAV DES DIR/DES NOW pending
     * @param planIndex the plan index
     * @param type Type of descent action or null to clear
     */
    setVnavDesPending(planIndex, type) {
        const plan = this.getFlightPlan(planIndex);
        if (type === null) {
            plan.deleteUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING);
        }
        else {
            plan.setUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING, type);
        }
    }
    /**
     * Handle pending DES DIR/DES NOW in the active f-pln (after copy from mod plan)
     */
    handleVnavDesPending() {
        const plan = this.getPrimaryFlightPlan();
        switch (plan.getUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING)) {
            case BoeingVnavDescentPendingType.DesDir:
                this.bus.getPublisher().pub('boeingvnav_activate_des_dir', undefined);
                break;
            case BoeingVnavDescentPendingType.DesNow:
                this.bus.getPublisher().pub('boeingvnav_activate_des_now', undefined);
                break;
        }
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING);
    }
    /**
     * After a plan copy, ensure that a now active HM causes a suspend
     */
    ensureActiveHMSuspended() {
        const activeLegIndex = this.getPlanForFmcRender().activeLateralLeg;
        const activeLeg = this.getPlanForFmcRender().tryGetLeg(activeLegIndex === 0 ? 1 : activeLegIndex);
        // TODO considerations for hold exit
        if ((activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.leg.type) === LegType.HM) {
            this.bus.getPublisher().pub('suspend_sequencing', true);
        }
    }
    /**
     * After a plan copy, ensure that we unsuspend if necessary
     */
    tryUnsuspend() {
        if (this.isPrimaryFms) {
            const activeLegIndex = this.getPrimaryFlightPlan().activeLateralLeg;
            if (activeLegIndex >= 0) {
                const activeLeg = this.getPrimaryFlightPlan().tryGetLeg(activeLegIndex);
                if (activeLeg && BoeingFmsUtils.canLegBeAutoUnsuspended(activeLeg.leg.type)) {
                    this.resumeSequencing();
                }
            }
        }
    }
    /**
     * Applies flight plan copy events to the performance plan repository
     *
     * @param ev plan copied event
     */
    applyCopyToPerformancePlans(ev) {
        if (ev.targetPlanIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX || ev.targetPlanIndex === BoeingFms.RTE_2_MOD_PLAN_INDEX) {
            this.performancePlanRepository.copy(BoeingFms.ACT_RTE_PLAN_INDEX, ev.targetPlanIndex);
        }
        else if (ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.performancePlanRepository.copy(ev.planIndex, BoeingFms.ACT_RTE_PLAN_INDEX);
        }
    }
    /**
     * Applies flight plan copy events to the performance plan repository
     *
     * @param ev plan copied event
     */
    applyCreationToPerformancePlans(ev) {
        if (ev.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.performancePlanRepository.create(BoeingFms.ACT_RTE_PLAN_INDEX);
            this._performancePlanProxy.switchToPlan(this.activePerformancePlan, true);
        }
        if (!this.performancePlanRepository.hasAnyPlan()) {
            this.performancePlanRepository.forFlightPlanIndex(ev.planIndex);
        }
    }
    /**
     * Handles when a flight plan active leg changes.
     * @param legType The type of flight plan active leg change.
     * @param planIndex The index of the plan whose active leg changed.
     */
    onActiveLegChanged(legType, planIndex) {
        if (legType === ActiveLegType.Lateral && planIndex === 0) {
            const activePlan = this.flightPlanner.getActiveFlightPlan();
            if (activePlan.length < 1 || this.missedApproachActive) {
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
            this.tryUnsuspend();
        }
    }
    /**
     * A method to check the current approach state.
     */
    async checkApproachState() {
        var _a;
        const plan = this.getFlightPlan();
        let approachLoaded = false;
        let approachIsActive = false;
        let approachType;
        let approachRnavType;
        let approachIsCircling = false;
        let approachName = '';
        let approachRunway = '';
        let missedApproachFacility = null;
        let referenceFacility = null;
        let finalApproachCourse = -1;
        if (plan.destinationAirport && (plan.procedureDetails.approachIndex > -1 || this.getFlightPlanVisualApproach(plan.planIndex) !== undefined)) {
            approachLoaded = true;
            if (plan.length > 0 && plan.activeLateralLeg < plan.length && plan.activeLateralLeg > 0) {
                const segment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                approachIsActive = segment.segmentType === FlightPlanSegmentType.Approach;
            }
            if (plan.procedureDetails.approachIndex > -1) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                const approach = facility.approaches[plan.procedureDetails.approachIndex];
                if (approach) {
                    approachType = approach.approachType;
                    approachRnavType = BoeingFmsUtils.getBestRnavType(approach.rnavTypeFlags);
                    approachIsCircling = !approach.runway;
                    approachName = BoeingFmsUtils.getApproachNameAsEfisString(approach);
                    approachRunway = RunwayUtils.getRunwayNameString(approach.runwayNumber, approach.runwayDesignator, true, 'RW');
                    if (BoeingFmsUtils.approachHasNavFrequency(approach)) {
                        referenceFacility = (_a = await ApproachUtils.getReferenceFacility(approach, this.facLoader)) !== null && _a !== void 0 ? _a : null;
                    }
                    finalApproachCourse = await this.getFinalApproachCourse(facility, approach);
                    const mapIndex = VNavUtils.getMissedApproachLegIndex(plan);
                    const mapLeg = mapIndex >= 0 ? plan.tryGetLeg(mapIndex) : null;
                    missedApproachFacility = mapLeg && mapLeg.leg.fixIcao && mapLeg.leg.fixIcao !== ICAO.emptyIcao
                        ? await this.facLoader.getFacility(ICAO.getFacilityType(mapLeg.leg.fixIcao), mapLeg.leg.fixIcao)
                        : null;
                }
            }
            else {
                approachType = AdditionalApproachType.APPROACH_TYPE_VISUAL;
                approachRnavType = RnavTypeFlags.None;
            }
        }
        this.setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling, approachName, approachRunway, missedApproachFacility, referenceFacility, finalApproachCourse);
    }
    /**
     * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
     * this will effectively cancel it.
     * @param planIndex The flight plan index.
     * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
     * @param calculate Whether to calculate the flight plan
     * to the index of the current active primary flight plan leg.
     */
    removeDirectToExisting(planIndex = BoeingFms.RTE_1_MOD_PLAN_INDEX, lateralLegIndex, calculate = true) {
        const plan = this.getFlightPlan(planIndex);
        const directToData = plan.directToData;
        if (directToData && directToData.segmentIndex > -1) {
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            const activateIndex = lateralLegIndex !== null && lateralLegIndex !== void 0 ? lateralLegIndex : plan.activeLateralLeg;
            const adjustedActivateIndex = activateIndex - Utils.Clamp(activateIndex - (plan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex), 0, 3);
            plan.setDirectToData(-1, true);
            plan.setCalculatingLeg(adjustedActivateIndex);
            plan.setLateralLeg(adjustedActivateIndex);
            if (calculate) {
                plan.calculate(0);
            }
        }
    }
    /**
     * Method to cleanup any legs in segments that exist after the Approach/Arrival Segments.
     * @param plan The Mod Flight Plan.
     */
    cleanupLegsAfterApproach(plan) {
        if (plan.procedureDetails.arrivalIndex > -1 || plan.procedureDetails.approachIndex > -1 || this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            while (plan.getSegment(plan.segmentCount - 1).segmentType === FlightPlanSegmentType.Enroute) {
                this.planRemoveSegment(plan.segmentCount - 1);
            }
        }
    }
    /**
     * Checks whether a leg in the primary flight plan can be manually activated.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg can be manually activated.
     */
    canActivateLeg(segmentIndex, segmentLegIndex) {
        const plan = this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo) || leg === plan.getLeg(0)) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.CF:
            case LegType.FC:
            case LegType.FD:
                return true;
            case LegType.CI:
            case LegType.VI:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.VM:
                return false;
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        switch (prevLeg.leg.type) {
            case LegType.VA:
            case LegType.CA:
            case LegType.VM:
            case LegType.Discontinuity:
                return false;
        }
        return true;
    }
    /**
     * Checks whether a leg in the primary flight plan is a valid direct to target.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg is a valid direct to target.
     * @throws Error if a leg could not be found at the specified location.
     */
    canDirectTo(segmentIndex, segmentLegIndex) {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || leg.leg.fixIcao === '' || leg.leg.fixIcao === ICAO.emptyIcao) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
                return true;
        }
        return false;
    }
    /**
     * Gets the current Direct To State.
     * @param planIndex The Plan Index to check.
     * @returns the DirectToState.
     */
    getDirectToState(planIndex = BoeingFms.ACT_RTE_PLAN_INDEX) {
        if (!this.hasFlightPlan(planIndex)) {
            return DirectToState.NONE;
        }
        const plan = this.getFlightPlan(planIndex);
        const directDataExists = plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1;
        if (!directDataExists) {
            return DirectToState.NONE;
        }
        // Guarding against rare cases where the segment with the dto has been removed and the dt odata hasn't been updated yet.
        const isDtoSegmentInPlan = plan.segmentCount >= plan.directToData.segmentIndex;
        if (!isDtoSegmentInPlan) {
            return DirectToState.NONE;
        }
        const dtoLegGlobalIndex = plan.getLegIndexFromLeg(plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex]);
        // We subtract 3 to get the index of the original DTO target leg
        const doesDtoLegMatchActiveLeg = dtoLegGlobalIndex === plan.activeLateralLeg - 3;
        // TODO This seems to be returning false positives when in MOD in certain scenarios,
        // TODO like after passing the TO leg of a DTO, then trying to add a new DTO
        if (doesDtoLegMatchActiveLeg) {
            return DirectToState.TOEXISTING;
        }
        else {
            return DirectToState.NONE;
        }
    }
    /**
     * Gets the ICAO string of the current Direct To target.
     * @returns The ICAO string of the current Direct To target, or undefined if Direct To is not active.
     */
    getDirectToTargetIcao() {
        var _a;
        return (_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao;
    }
    /**
     * Gets the current DTO Target Flight Plan Leg.
     * @returns the FlightPlanLeg.
     */
    getDirectToLeg() {
        switch (this.getDirectToState()) {
            case DirectToState.TOEXISTING: {
                const plan = this.getFlightPlan();
                return plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg;
            }
        }
        return undefined;
    }
    /**
     * Checks if a segment is the first enroute segment that is not an airway.
     * @param segmentIndex is the segment index of the segment to check
     * @returns whether or not the segment is the first enroute segment that is not an airway.
     */
    isFirstEnrouteSegment(segmentIndex) {
        const plan = this.getFlightPlan();
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && !segment.airway) {
                return i === segmentIndex;
            }
        }
        return false;
    }
    /**
     * Adds a user facility.
     * @param userFacility the facility to add.
     */
    addUserFacility(userFacility) {
        this.facRepo.add(userFacility);
    }
    /**
     * Removes a user facility.
     * @param userFacility the facility to remove.
     */
    removeUserFacility(userFacility) {
        this.facRepo.remove(userFacility);
    }
    /**
     * Gets all user facilities.
     *
     * @returns an array of user facilities
     */
    getUserFacilities() {
        const ret = [];
        // FIXME no.
        this.facRepo.forEach((fac) => {
            if (FacilityUtils.isFacilityType(fac, FacilityType.USR)) {
                ret.push(fac);
            }
        });
        return ret;
    }
    /**
     * Adds a visual or runway facility from the FlightPlanLeg.
     * @param leg the leg to build the facility from.
     * @param visualRunwayDesignation is the visual runway this facility belongs to.
     */
    addVisualFacilityFromLeg(leg, visualRunwayDesignation) {
        const fac = {
            icao: leg.fixIcao,
            lat: leg.lat !== undefined ? leg.lat : 0,
            lon: leg.lon !== undefined ? leg.lon : 0,
            approach: `VISUAL ${visualRunwayDesignation}`,
            city: '',
            name: `${visualRunwayDesignation} - ${ICAO.getIdent(leg.fixIcao)}`,
            region: '',
            magvar: 0
        };
        this.facRepo.add(fac);
    }
    /**
     * Method to insert a waypoint to the flightplan.
     * @param facility is the new facility to add a leg to.
     * @param segmentIndex is index of the segment to add the waypoint to
     * @param legIndex is the index to insert the waypoint (if none, append)
     * @returns whether the waypoint was successfully inserted.
     */
    insertWaypoint(facility, segmentIndex, legIndex) {
        var _a;
        const leg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: facility.icao
        });
        let plan = this.getPlanForFmcRender();
        let createdModPlan = false;
        if (segmentIndex === undefined) {
            const lastSegment = plan.segmentCount > 0 ? plan.getSegment(plan.segmentCount - 1) : undefined;
            if (lastSegment) {
                if (lastSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, lastSegment.segmentIndex + 1);
                    if (plan.planIndex !== BoeingFms.RTE_1_MOD_PLAN_INDEX && plan.planIndex !== BoeingFms.RTE_2_MOD_PLAN_INDEX) {
                        createdModPlan = true;
                    }
                    plan = this.getPlanToModify();
                }
                else {
                    segmentIndex = lastSegment.segmentIndex;
                }
            }
            else {
                return false;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, legIndex !== null && legIndex !== void 0 ? legIndex : Infinity);
        const nextLeg = plan.getNextLeg(segmentIndex, legIndex === undefined ? Infinity : legIndex - 1);
        // Make sure we are not inserting a duplicate leg
        if ((prevLeg && this.isDuplicateLeg(prevLeg.leg, leg)) || (nextLeg && this.isDuplicateLeg(leg, nextLeg.leg))) {
            if (createdModPlan) {
                this.cancelMod();
            }
            return false;
        }
        // Make sure we are not inserting a leg into a direct to sequence
        if (prevLeg) {
            const isInDirectTo = BitFlags.isAll(prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.flags, LegDefinitionFlags.DirectTo);
            const isDirectToTarget = BitFlags.isAll(prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.flags, BoeingExtraLegDefinitionFlags.DirectToTarget);
            if (isInDirectTo && !isDirectToTarget) {
                if (createdModPlan) {
                    this.cancelMod();
                }
                return false;
            }
        }
        plan = this.getPlanToModify();
        // Deal with whether this insert is in an airway segment
        if (segment.airway) {
            //check to see if this insert will leave more than 1 airway leg
            if (!legIndex || segment.legs.length - legIndex < 3) {
                // we don't need another airway segment,
                // we just need to add the inserted segment, the remaining airway segments into the next enroute segment
                const nextSegment = plan.getSegment(segmentIndex + 1);
                if (nextSegment.airway || nextSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    //the next segment is an airway, arrival, approach or destination, so we need to add an enroute segment
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                }
                //now we can add the new leg into the next enroute segment
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                for (let k = 0; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 1, legsToMove[k]);
                }
            }
            else {
                //we need to create a new airway segment
                //split the segment into three
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                const newAirwaySegment = plan.getSegment(segmentIndex + 2);
                //add the leg to the new enroute segment (between the old and new airway segments)
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                this.planAddLeg(segmentIndex + 1, legsToMove[0]);
                for (let k = 1; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 2, legsToMove[k]);
                }
                const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[legIndex - 1].name : segment.airway;
                plan.setAirway(segmentIndex, segment.airway);
                newAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + newAirwaySegment.legs[newAirwaySegment.legs.length - 1].name : segment.airway;
                plan.setAirway(segmentIndex + 2, newAirwaySegment.airway);
            }
            return true;
        }
        else {
            // WT21 Addition; manage where legs are added from the legs page
            // TODO this maybe needs to go before the airway section
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Arrival:
                    if (legIndex === 0) {
                        segmentIndex -= 1;
                        legIndex = undefined;
                    }
                    else if (!legIndex) {
                        if (segmentIndex === plan.segmentCount - 1 || plan.getSegment(segmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                        }
                        else {
                            segmentIndex += 1;
                        }
                        legIndex = 0;
                    }
                    break;
                case FlightPlanSegmentType.Approach:
                    if (legIndex === 0) {
                        if (plan.procedureDetails.arrivalIndex > -1 && plan.getSegment(segmentIndex - 1).segmentType !== FlightPlanSegmentType.Enroute) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                            legIndex = undefined;
                        }
                        else {
                            segmentIndex -= 1;
                            legIndex = undefined;
                        }
                    }
                    else if (!legIndex) {
                        if (segmentIndex === plan.segmentCount - 1) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute);
                        }
                    }
                    break;
            }
            const addedLeg = this.planAddLeg(segmentIndex, leg, legIndex);
            const addedLegGlobalIndex = plan.getLegIndexFromLeg(addedLeg);
            const addedLegSegment = plan.getSegmentFromLeg(addedLeg);
            if (addedLegSegment) {
                const addedLegLocalIndex = plan.getSegmentLegIndex(addedLegGlobalIndex);
                const legAfter = plan.getNextLeg(addedLegSegment === null || addedLegSegment === void 0 ? void 0 : addedLegSegment.segmentIndex, addedLegLocalIndex);
                if (legAfter && !BoeingFmsUtils.isDiscontinuityLeg(legAfter.leg.type)) {
                    this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), addedLegLocalIndex + 1);
                }
            }
            return true;
        }
    }
    /**
     * Removes a leg to a waypoint from the primary flight plan.
     * @param segmentIndex The index of the segment containing the leg to remove.
     * @param segmentLegIndex The index of the leg to remove in its segment.
     * @param skipFafMapCheck Whether to force deletion regardless of FAF/MAP flags
     * @param skipHoldDelete Whether to skip deleting holds associated with this leg
     * @returns Whether the waypoint was successfully removed.
     */
    removeWaypoint(segmentIndex, segmentLegIndex, skipFafMapCheck = false, skipHoldDelete = false) {
        let plan = this.getPlanForFmcRender();
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return false;
        }
        const legGlobalIndex = plan.getLegIndexFromLeg(leg);
        if (!skipFafMapCheck && (!leg || BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF | FixTypeFlags.MAP))) {
            return false;
        }
        const legDeleted = this.planRemoveLeg(segmentIndex, segmentLegIndex);
        if (legDeleted) {
            plan = this.getPlanToModify();
            const prevLeg = plan.tryGetLeg(legGlobalIndex - 1);
            let nextLeg = plan.tryGetLeg(legGlobalIndex);
            if (!skipHoldDelete && legDeleted && nextLeg && BoeingFmsUtils.isHoldAtLeg(nextLeg.leg.type)) {
                if (plan.tryGetLeg(segmentIndex, segmentLegIndex)) {
                    this.planRemoveLeg(segmentIndex, segmentLegIndex, true, true, true);
                }
                nextLeg = plan.tryGetLeg(legGlobalIndex);
            }
            const alreadyDisco = (prevLeg && BoeingFmsUtils.isDiscontinuityLeg(prevLeg.leg.type)) || (nextLeg && BoeingFmsUtils.isDiscontinuityLeg(nextLeg.leg.type));
            if (!BoeingFmsUtils.isDiscontinuityLeg(leg.leg.type) && !alreadyDisco) {
                this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), segmentLegIndex);
            }
        }
        return legDeleted;
    }
    /**
     * Sets the speed and altitude constraints for a log.
     * @param globalLegIndex Global leg index of the leg to modify.
     * @param verticalData The vertical data to set on the leg. Will be merged with existing data.
     * @returns Whether the data was set.
     */
    setUserConstraint(globalLegIndex, verticalData) {
        const plan = this.hasPrimaryFlightPlan() && this.getPlanToModify();
        if (!plan) {
            return false;
        }
        const segment = plan.tryGetSegment(plan.getSegmentIndex(globalLegIndex));
        const leg = segment === null || segment === void 0 ? void 0 : segment.legs[globalLegIndex - segment.offset];
        if (segment === null || leg === undefined) {
            return false;
        }
        const isDeparture = segment.segmentType === FlightPlanSegmentType.Departure || segment.segmentType === FlightPlanSegmentType.Origin;
        const isMapr = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
        plan.setLegVerticalData(globalLegIndex, Object.assign({ phase: isDeparture || isMapr ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent }, verticalData), true);
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Gets the airway leg type of a flight plan leg.
     * @param plan The flight plan containing the query leg.
     * @param segmentIndex The index of the flight plan segment containing the query leg.
     * @param segmentLegIndex The index of the query leg in its segment.
     * @returns The airway leg type of the query leg.
     */
    getAirwayLegType(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        const segmentIsAirway = segment.airway !== undefined;
        const nextSegmentIsAirway = segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined;
        const legIsLast = segmentLegIndex == segment.legs.length - 1;
        if ((segmentIsAirway && legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.EXIT_ENTRY;
        }
        if ((legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.ENTRY;
        }
        if (segmentIsAirway) {
            if (legIsLast) {
                return AirwayLegType.EXIT;
            }
            return AirwayLegType.ONROUTE;
        }
        return AirwayLegType.NONE;
    }
    /**
     * Method to get the distance of an airway segment.
     * @param segmentIndex is the index of the segment of the airway.
     * @returns the cumulative distance for the airway segment.
     */
    getAirwayDistance(segmentIndex) {
        var _a, _b, _c, _d;
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const entrySegment = plan.getSegment(segmentIndex - 1);
        const entryCumulativeDistance = (_b = (_a = entrySegment.legs[entrySegment.legs.length - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance;
        const exitCumulativeDistance = (_d = (_c = segment.legs[segment.legs.length - 1]) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.cumulativeDistance;
        return exitCumulativeDistance && entryCumulativeDistance ? exitCumulativeDistance - entryCumulativeDistance : -1;
    }
    /**
     * Method to add a new origin airport and runway to the flight plan.
     * @param airport is the facility of the origin airport.
     * @param runway is the onewayrunway
     */
    setOrigin(airport, runway) {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        if (airport) {
            if (plan.originAirport !== airport.icao) {
                plan.setOriginAirport(airport.icao);
            }
            plan.setOriginRunway(runway);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, segmentIndex, airport, runway);
            const prevLeg = plan.getPrevLeg(segmentIndex, 1);
            const nextLeg = plan.getNextLeg(segmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        else {
            plan.removeOriginAirport();
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        }
        this.facilityInfo.originFacility = airport;
        plan.calculate(0);
    }
    /**
     * Method to add a new destination airport and runway to the flight plan.
     * @param airport is the facility of the destination airport.
     * @param runway is the selected runway at the destination facility.
     */
    setDestination(airport, runway) {
        const plan = this.getPlanToModify();
        plan.setProcedureDetails({
            arrivalIndex: -1,
            arrivalRunway: undefined,
            arrivalTransitionIndex: -1,
            arrivalRunwayTransitionIndex: -1,
            approachIndex: -1,
            approachTransitionIndex: -1,
        });
        if (airport) {
            plan.setDestinationAirport(airport.icao);
            plan.setDestinationRunway(runway);
        }
        else {
            plan.removeDestinationAirport();
        }
        this.facilityInfo.destinationFacility = airport;
        plan.calculate(0);
        this.performancePlanForFmcRender.transitionLevel.set(definitions.transitionLevel.defaultValue);
    }
    /**
     * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
     * @param segmentType is the segment type we want to evaluate.
     * @param insert is whether to insert the segment if missing
     * @returns segmentIndex of the only segment of this type in the flight plan, -1 if insert is false and and the segment does not exist.
     */
    ensureOnlyOneSegmentOfType(segmentType, insert = true) {
        const plan = this.getPlanToModify();
        let segmentIndex;
        const selectedSegments = plan.segmentsOfType(segmentType);
        const segmentIndexArray = [];
        for (const element of selectedSegments) {
            segmentIndexArray.push(element.segmentIndex);
        }
        if (segmentIndexArray.length === 0) {
            if (insert) {
                segmentIndex = this.planInsertSegmentOfType(segmentType);
            }
            else {
                segmentIndex = -1;
            }
        }
        else if (segmentIndexArray.length > 1) {
            for (let i = 0; i < segmentIndexArray.length; i++) {
                this.planRemoveSegment(segmentIndexArray[i]);
            }
            segmentIndex = this.planInsertSegmentOfType(segmentType);
        }
        else {
            segmentIndex = segmentIndexArray[0];
        }
        return segmentIndex;
    }
    /**
     * Method to invert the flightplan.
     * TODO Does the WT21 support this?
     */
    invertFlightplan() {
        var _a;
        const plan = this.getPlanToModify();
        if (plan.directToData.segmentIndex >= 0 && plan.directToData.segmentLegIndex >= 0) {
            this.removeDirectToExisting();
        }
        const newOriginIcao = plan.destinationAirport;
        const newDestinationIcao = plan.originAirport;
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (lastEnrouteSegmentIndex === 1 && plan.getSegment(1).legs.length > 0) {
            //case for when there is only 1 enroute segment and it has at least 1 waypoint, a simple reversal is all that's required.
            const segment = Object.assign({}, plan.getSegment(1));
            this.emptyFlightPlan();
            for (let l = segment.legs.length - 1; l >= 0; l--) {
                plan.addLeg(1, segment.legs[l].leg);
            }
        }
        else if (lastEnrouteSegmentIndex > 1) {
            //case for when there is more than 1 enroute segment we know we have to deal with airways
            const legs = [];
            for (let i = 1; i <= lastEnrouteSegmentIndex; i++) {
                //create a temporary list of legs that looks like what a flight plan import looks like with ICAO and the airway
                //we fly FROM the leg on.
                const oldSegment = plan.getSegment(i);
                const airway = oldSegment.airway ? (_a = oldSegment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0] : undefined;
                for (const leg of oldSegment.legs) {
                    const legListItem = { icao: leg.leg.fixIcao, airway: airway };
                    legs.push(legListItem);
                }
            }
            //after the array of legs is complete, we just reverse it
            legs.reverse();
            this.emptyFlightPlan();
            let currentSegment = 1;
            let lastLegWasAirway = false;
            //last we go through each leg and use the same logic we use for the flight plan import to go through each leg and create airway
            //segments as appropriate for these legs.
            for (let i = 0; i < legs.length; i++) {
                const wpt = legs[i];
                const segment = plan.getSegment(currentSegment);
                if (wpt.airway) {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airway);
                        currentSegment += 1;
                    }
                    for (let j = i + 1; j < legs.length; j++) {
                        i++;
                        const airwayLeg = FlightPlan.createLeg({
                            type: LegType.TF,
                            fixIcao: legs[j].icao
                        });
                        plan.addLeg(currentSegment, airwayLeg);
                        if (legs[j].airway !== wpt.airway) {
                            lastLegWasAirway = legs[j].airway ? true : false;
                            break;
                        }
                    }
                    plan.setAirway(currentSegment, wpt.airway + '.' + ICAO.getIdent(legs[i].icao));
                    currentSegment += 1;
                    plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? legs[i].airway : undefined);
                }
                else {
                    let leg = undefined;
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    if (leg) {
                        plan.addLeg(currentSegment, leg);
                        if (lastLegWasAirway) {
                            plan.setAirway(currentSegment, segment.airway + '.' + ICAO.getIdent(wpt.icao));
                            currentSegment += 1;
                            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                        }
                        lastLegWasAirway = false;
                    }
                }
            }
            if (plan.getSegment(currentSegment).airway) {
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
            }
        }
        else {
            this.emptyFlightPlan();
        }
        if (newOriginIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newOriginIcao).then((facility) => {
                this.setOrigin(facility);
            });
        }
        if (newDestinationIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newDestinationIcao).then((facility) => {
                this.setDestination(facility);
            });
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
        plan.calculate(0);
    }
    /**
     * Checks whether the procedure being modified contains the currently active from and to legs and, if so,
     * returns those two legs. If the active leg is a direct to, this returns the entire direct to sequence (3 legs)
     * @param plan The flight plan.
     * @param segmentIndex The Segment Index.
     * @returns The array of active legs.
     */
    getActiveLegsInCurrentProcedure(plan, segmentIndex) {
        if (plan.getSegmentIndex(plan.activeLateralLeg) === segmentIndex) {
            const currentToLeg = plan.tryGetLeg(plan.activeLateralLeg);
            const currentFromLeg = plan.tryGetLeg(plan.activeLateralLeg - 1);
            if (!currentToLeg || !currentFromLeg) {
                return undefined;
            }
            const newToLeg = Object.assign({}, currentToLeg.leg);
            const newFromLeg = Object.assign({}, currentFromLeg.leg);
            if (BitFlags.isAll(currentToLeg.flags, LegDefinitionFlags.DirectTo)) {
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                return [discoLeg, newFromLeg, newToLeg];
            }
            else {
                return [newFromLeg, newToLeg];
            }
        }
        return undefined;
    }
    /**
     * Method to add or replace a departure procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param departureIndex is the index of the departure
     * @param departureRunwayIndex is the index of the runway transition
     * @param enrouteTransitionIndex is the index of the enroute transition
     * @param oneWayRunway is the one way runway to set as the origin leg.
     */
    insertDeparture(facility, departureIndex, departureRunwayIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getPlanToModify();
        plan.setDeparture(facility.icao, departureIndex, enrouteTransitionIndex, departureRunwayIndex);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        // Grabbing the active legs (if there are any) in the existing departure semgent,
        // so that we can put them somewhere after clearing the segment.
        const activeLegArray = !Simplane.getIsGrounded() && plan.activeLateralLeg > 0 ? this.getActiveLegsInCurrentProcedure(plan, segmentIndex) : undefined;
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        const insertProcedureObject = this.buildDepartureLegs(facility, departureIndex, enrouteTransitionIndex, departureRunwayIndex, oneWayRunway);
        if (plan.originAirport !== facility.icao) {
            plan.setOriginAirport(facility.icao);
        }
        plan.setOriginRunway(oneWayRunway);
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l, undefined, BoeingExtraLegDefinitionFlags.ProcedureLeg));
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const depSegment = plan.getSegment(segmentIndex);
        const lastDepLeg = depSegment.legs[depSegment.legs.length - 1];
        if (nextLeg && lastDepLeg && this.isDuplicateLeg(lastDepLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastDepLeg, nextLeg);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(depSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        this.generateSegmentVerticalData(plan, segmentIndex);
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildDepartureLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const departure = facility.departures[procedureIndex];
        const enRouteTransition = departure.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = departure.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        let originLeg;
        if (oneWayRunway) {
            originLeg = BoeingFmsUtils.buildRunwayLeg(facility, oneWayRunway, true);
        }
        else {
            originLeg = FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.IF,
                fixIcao: facility.icao
            });
        }
        insertProcedureObject.procedureLegs.push(originLeg);
        if (runwayTransition !== undefined && runwayTransition.legs.length > 0) {
            for (const leg of runwayTransition.legs) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            }
        }
        for (let i = 0; i < departure.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(departure.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (enRouteTransition) {
            for (let i = 0; i < enRouteTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(enRouteTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(enRouteTransition.legs[i]);
            }
        }
        return insertProcedureObject;
    }
    /**
     * Method to add or replace an arrival procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param arrivalIndex is the index of the arrival procedure.
     * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
     * @param enrouteTransitionIndex is the index of the enroute transition.
     * @param oneWayRunway is the one way runway to set as the destination leg.
     */
    insertArrival(facility, arrivalIndex, arrivalRunwayTransitionIndex, enrouteTransitionIndex, oneWayRunway) {
        var _a, _b;
        const plan = this.getPlanToModify();
        const activeSegment = BoeingFmsUtils.getActiveSegment(plan);
        if (plan.procedureDetails.approachIndex < 0) {
            if (plan.destinationAirport !== facility.icao) {
                plan.setDestinationAirport(facility.icao);
            }
            plan.setDestinationRunway(oneWayRunway);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        let arrivalActiveLegIcao;
        if (arrivalIndex > -1 && arrivalIndex === plan.procedureDetails.arrivalIndex && activeSegment !== undefined && activeLegArray !== undefined) {
            arrivalActiveLegIcao = (_b = (_a = plan.tryGetLeg(plan.activeLateralLeg)) === null || _a === void 0 ? void 0 : _a.leg) === null || _b === void 0 ? void 0 : _b.fixIcao;
        }
        plan.setArrival(facility.icao, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Arrival);
        }
        const insertProcedureObject = this.buildArrivalLegs(facility, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex, oneWayRunway);
        let directTargetLeg;
        let handleDirectToDestination = false;
        const directToState = this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        if (directToState === DirectToState.TOEXISTING) {
            directTargetLeg = this.getDirectToLeg();
            if ((directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === plan.destinationAirport &&
                (directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1].fixIcao) {
                handleDirectToDestination = true;
            }
        }
        if (!handleDirectToDestination) {
            this.tryMoveDestinationLeg(plan);
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l, undefined, BoeingExtraLegDefinitionFlags.ProcedureLeg));
        const arrSegment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstArrLeg = arrSegment.legs[0];
        let deduplicatedEnrouteLeg = null;
        if (prevLeg && firstArrLeg && this.isDuplicateLeg(prevLeg.leg, firstArrLeg.leg)) {
            deduplicatedEnrouteLeg = this.planRemoveDuplicateLeg(prevLeg, firstArrLeg);
        }
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const lastArrLeg = arrSegment.legs[arrSegment.legs.length - 1];
        if (nextLeg && lastArrLeg && this.isDuplicateLeg(lastArrLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastArrLeg, nextLeg);
        }
        if (handleDirectToDestination) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Arrival, segmentIndex);
            this.activateLeg(segmentIndex, arrSegment.legs.length - 1);
        }
        // If we didn't remove a duplicate, insert a discontinuity at the start of the arrival
        if (!deduplicatedEnrouteLeg && (!prevLeg || !BoeingFmsUtils.isVectorsLeg(prevLeg.leg.type))) {
            this.tryInsertDiscontinuity(plan, segmentIndex);
        }
        const matchingActiveProcedureLegIndex = BoeingFmsUtils.findIcaoInSegment(arrSegment, arrivalActiveLegIcao);
        if (activeLegArray && matchingActiveProcedureLegIndex === undefined) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(arrSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        else if (matchingActiveProcedureLegIndex !== undefined) {
            plan.setLateralLeg(arrSegment.offset + matchingActiveProcedureLegIndex);
        }
        this.generateSegmentVerticalData(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.tryConnectProcedures(plan);
        plan.calculate(0);
    }
    /**
     * Tries to add a discontinuity when needed at the start of a procedure.
     * @param plan The Flight Plan
     * @param segmentIndex The procedure segment index.
     */
    tryInsertDiscontinuity(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.legs.length > 0) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Arrival:
                case FlightPlanSegmentType.Approach:
                    this.insertDiscontinuity(plan, segmentIndex, 0);
            }
        }
    }
    /**
     * Method to connect an arrival and approach when the approach begins at a leg that exists in the arrival.
     * @param plan The Lateral Flight Plan.
     */
    tryConnectProcedures(plan) {
        if (plan.procedureDetails.approachIndex > -1 && plan.procedureDetails.arrivalIndex > -1) {
            // find the first leg in the approach
            let firstApproachLeg;
            let firstApproachSegmentLegIndex;
            let matchedArrivalLegSegmentLegIndex;
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
            const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival, false);
            if (approachSegmentIndex > -1 && arrivalSegmentIndex > -1) {
                const approachSegment = plan.getSegment(approachSegmentIndex);
                const arrivalSegment = plan.getSegment(arrivalSegmentIndex);
                for (let l = 0; l < approachSegment.legs.length; l++) {
                    const approachLeg = approachSegment.legs[l];
                    if (approachLeg.leg.type !== LegType.Discontinuity && approachLeg.leg.type !== LegType.ThruDiscontinuity) {
                        firstApproachLeg = approachLeg;
                        firstApproachSegmentLegIndex = l;
                        break;
                    }
                }
                for (let i = arrivalSegment.legs.length - 1; i > 0; i--) {
                    const arrivalLeg = arrivalSegment.legs[i];
                    if ((arrivalLeg === null || arrivalLeg === void 0 ? void 0 : arrivalLeg.name) && (firstApproachLeg === null || firstApproachLeg === void 0 ? void 0 : firstApproachLeg.name) && arrivalLeg.name === firstApproachLeg.name) {
                        matchedArrivalLegSegmentLegIndex = i;
                        break;
                    }
                }
                if (firstApproachSegmentLegIndex !== undefined && matchedArrivalLegSegmentLegIndex !== undefined) {
                    while (arrivalSegment.legs.length > matchedArrivalLegSegmentLegIndex) {
                        plan.removeLeg(arrivalSegmentIndex, matchedArrivalLegSegmentLegIndex);
                    }
                    for (let j = 0; j < firstApproachSegmentLegIndex; j++) {
                        plan.removeLeg(approachSegmentIndex, j);
                    }
                }
            }
        }
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildArrivalLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    oneWayRunway) {
        const arrival = facility.arrivals[procedureIndex];
        const enRouteTransition = arrival.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = arrival.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (enRouteTransition !== undefined && enRouteTransition.legs.length > 0) {
            for (const leg of enRouteTransition.legs) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            }
        }
        for (let i = 0; i < arrival.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(arrival.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (runwayTransition) {
            for (let i = 0; i < runwayTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(runwayTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        this.tryInsertIFLeg(insertProcedureObject);
        return insertProcedureObject;
    }
    /**
     * Method to move a direct to destination to a specified target segment.
     * @param plan is the primary flight plan.
     * @param targetSegmentType is the target segment type.
     * @param arrivalSegmentIndex is the arrival segment index
     * @returns whether a direct to destination was moved.
     */
    moveDirectToDestinationLeg(plan, targetSegmentType, arrivalSegmentIndex) {
        const directTargetSegmentIndex = targetSegmentType === FlightPlanSegmentType.Arrival ? arrivalSegmentIndex : this.findLastEnrouteSegmentIndex(plan);
        if (directTargetSegmentIndex !== undefined && directTargetSegmentIndex > 0 && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport) {
            const destinationLeg = Object.assign({}, plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex].leg);
            const directTargetLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg).leg);
            const directOriginLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 1).leg);
            const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
            const newDirectLegIndex = plan.getSegment(directTargetSegmentIndex).legs.length;
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.setDirectToData(directTargetSegmentIndex, newDirectLegIndex);
            plan.addLeg(directTargetSegmentIndex, destinationLeg);
            plan.addLeg(directTargetSegmentIndex, discoLeg, undefined, LegDefinitionFlags.DirectTo);
            plan.addLeg(directTargetSegmentIndex, directOriginLeg, undefined, LegDefinitionFlags.DirectTo);
            const newActiveLeg = plan.addLeg(directTargetSegmentIndex, directTargetLeg, undefined, LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
            const newActiveLegIndex = plan.getLegIndexFromLeg(newActiveLeg);
            plan.setCalculatingLeg(newActiveLegIndex);
            plan.setLateralLeg(newActiveLegIndex);
            plan.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX && plan.calculate(newActiveLegIndex);
            return true;
        }
        return false;
    }
    /**
     * Checks if the last leg in the last enroute segment is the destination airport and, if so, moves it into the approach segment.
     * @param plan The lateral flight plan.
     */
    tryMoveDestinationLeg(plan) {
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
        if (lastEnrouteSegment !== undefined && lastEnrouteSegment.legs.length > 0 &&
            lastEnrouteSegment.legs[lastEnrouteSegment.legs.length - 1].leg.fixIcao === plan.destinationAirport) {
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, true);
            const approachSegment = plan.getSegment(approachSegmentIndex);
            if (approachSegment.legs.length < 1) {
                const destinationLeg = Object.assign({}, lastEnrouteSegment.legs[lastEnrouteSegment.legs.length - 1].leg);
                plan.removeLeg(lastEnrouteSegmentIndex);
                plan.addLeg(approachSegmentIndex, destinationLeg);
            }
        }
    }
    /**
     * Method to find the last enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the last enroute segment in.
     * @returns a segment index.
     */
    findLastEnrouteSegmentIndex(plan) {
        let enrouteSegmentFound = 0;
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute) {
                enrouteSegmentFound = i;
            }
        }
        return enrouteSegmentFound;
    }
    /**
     * Method to check whether an approach can load, or only activate.
     * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
     */
    canApproachLoad() {
        const plan = this.getFlightPlan();
        if (plan.length > 0) {
            const activeSegment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
            if (activeSegment.segmentType !== FlightPlanSegmentType.Approach && plan.length > 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to add or replace an approach procedure in the flight plan.
     *
     * @param description the approach procedure description
     *
     * @returns A Promise which is fulfilled with whether the approach was inserted.
     */
    async insertApproach(description) {
        var _a, _b, _c, _d;
        const plan = this.getPlanToModify();
        if (plan.length > 0 && plan.procedureDetails.approachIndex < 0) {
            const lastLeg = plan.tryGetLeg(plan.length - 1);
            if ((lastLeg === null || lastLeg === void 0 ? void 0 : lastLeg.leg.fixIcao) === plan.destinationAirport) {
                plan.removeLeg(plan.getSegmentIndex(plan.length - 1));
            }
        }
        let visualRunway;
        if (description.visualRunwayNumber !== undefined && description.visualRunwayDesignator !== undefined) {
            visualRunway = RunwayUtils.matchOneWayRunway(description.facility, description.visualRunwayNumber, description.visualRunwayDesignator);
            if (!visualRunway) {
                return false;
            }
        }
        let approach;
        if (visualRunway) {
            approach = BoeingFmsUtils.buildVisualApproach(this.facRepo, description.facility, visualRunway, (_a = description.visualRunwayOffset) !== null && _a !== void 0 ? _a : 5, description.vfrVerticalPathAngle);
        }
        else {
            approach = description.facility.approaches[description.approachIndex];
        }
        const opId = ++this.insertApproachOpId;
        const insertProcedureObject = await this.buildApproachLegs(description, approach, visualRunway);
        if (visualRunway) {
            this.setFlightPlanVisualApproach(plan.planIndex, visualRunway.designation);
            this.setFlightPlanVisualApproachVfrVpa(plan.planIndex, description.vfrVerticalPathAngle);
        }
        else if (this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            this.setFlightPlanVisualApproach(plan.planIndex, undefined);
            this.setFlightPlanVisualApproachVfrVpa(plan.planIndex, undefined);
        }
        plan.setApproach(description.facility.icao, description.approachIndex, description.approachTransitionIndex);
        const directToState = this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        let skipDestinationLegCheck = false;
        if (directToState === DirectToState.TOEXISTING) {
            if (((_b = this.getDirectToLeg()) === null || _b === void 0 ? void 0 : _b.fixIcao) === plan.destinationAirport) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                skipDestinationLegCheck = true;
            }
        }
        if (directToState === DirectToState.TOEXISTING && plan.procedureDetails.arrivalIndex < 0 && !skipDestinationLegCheck) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute);
        }
        if (plan.destinationAirport !== description.facility.icao) {
            plan.setDestinationAirport(description.facility.icao);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        let apprSegment = plan.getSegment(segmentIndex);
        if (apprSegment.legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Approach);
            const newSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
            apprSegment = plan.getSegment(newSegmentIndex);
        }
        if (opId !== this.insertApproachOpId) {
            return false;
        }
        if (insertProcedureObject.runway) {
            plan.setDestinationRunway(insertProcedureObject.runway);
        }
        else {
            plan.setDestinationRunway(undefined);
        }
        let haveAddedMap = false;
        insertProcedureObject.procedureLegs.forEach((l) => {
            var _a;
            let isMissedLeg = false;
            if (visualRunway !== undefined) {
                this.addVisualFacilityFromLeg(l, visualRunway.designation);
                if (haveAddedMap) {
                    isMissedLeg = true;
                }
                if (l.fixTypeFlags & FixTypeFlags.MAP) {
                    haveAddedMap = true;
                }
            }
            let flags = (_a = l.flags) !== null && _a !== void 0 ? _a : LegDefinitionFlags.None;
            flags |= BoeingExtraLegDefinitionFlags.ProcedureLeg;
            if (isMissedLeg) {
                flags |= LegDefinitionFlags.MissedApproach;
            }
            this.planAddLeg(segmentIndex, l, undefined, flags);
        });
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstAppLeg = apprSegment.legs[0];
        let deduplicatedArrivalLeg = null;
        if (prevLeg && firstAppLeg && this.isDuplicateLeg(prevLeg.leg, firstAppLeg.leg)) {
            deduplicatedArrivalLeg = this.planRemoveDuplicateLeg(prevLeg, firstAppLeg);
        }
        // Adds missed approach legs
        if (!visualRunway && insertProcedureObject.procedureLegs.length > 0) {
            const missedLegs = (_c = description.facility.approaches[description.approachIndex].missedLegs) !== null && _c !== void 0 ? _c : [];
            if (missedLegs.length > 0) {
                let maphIndex = -1;
                for (let m = missedLegs.length - 1; m >= 0; m--) {
                    switch (missedLegs[m].type) {
                        case LegType.HA:
                        case LegType.HF:
                        case LegType.HM:
                            maphIndex = m - 1;
                            break;
                    }
                }
                let flags = LegDefinitionFlags.MissedApproach;
                flags |= BoeingExtraLegDefinitionFlags.ProcedureLeg;
                for (let n = 0; n < missedLegs.length; n++) {
                    const newLeg = FlightPlan.createLeg(missedLegs[n]);
                    if (maphIndex >= 0 && n === maphIndex) {
                        newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                        this.planAddLeg(segmentIndex, newLeg, undefined, flags);
                    }
                    else {
                        this.planAddLeg(segmentIndex, newLeg, undefined, flags);
                    }
                }
            }
        }
        const rnavTypeFlag = BoeingFmsUtils.getBestRnavType(approach.rnavTypeFlags);
        const approachIsCircling = !visualRunway && !(approach === null || approach === void 0 ? void 0 : approach.runway);
        const approachName = BoeingFmsUtils.getApproachNameAsEfisString(approach);
        const approachRunway = RunwayUtils.getRunwayNameString(approach.runwayNumber, approach.runwayDesignator, true, 'RW');
        const mapIndex = VNavUtils.getMissedApproachLegIndex(plan);
        const mapLeg = mapIndex >= 0 ? plan.tryGetLeg(mapIndex) : null;
        const missedApproachFacility = mapLeg && mapLeg.leg.fixIcao && mapLeg.leg.fixIcao !== ICAO.emptyIcao
            ? await this.facLoader.getFacility(ICAO.getFacilityType(mapLeg.leg.fixIcao), mapLeg.leg.fixIcao)
            : null;
        let referenceFacility = null;
        if (approach && BoeingFmsUtils.approachHasNavFrequency(approach)) {
            referenceFacility = (_d = await ApproachUtils.getReferenceFacility(approach, this.facLoader)) !== null && _d !== void 0 ? _d : null;
        }
        const finalApproachCourse = await this.getFinalApproachCourse(description.facility, approach);
        this.setApproachDetails(true, approach.approachType, rnavTypeFlag, false, approachIsCircling, approachName, approachRunway, missedApproachFacility, referenceFacility, finalApproachCourse);
        // set the G/S flag default state
        this.performancePlanProxy.glideSlope.set(approach.approachType === ApproachType.APPROACH_TYPE_ILS ? GlideslopeStatus.ON : GlideslopeStatus.OFF);
        // If we didn't remove a duplicate, insert a discontinuity at the start of the approach
        if (!deduplicatedArrivalLeg && (!prevLeg || !BoeingFmsUtils.isVectorsLeg(prevLeg.leg.type))) {
            this.tryInsertDiscontinuity(plan, segmentIndex);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(apprSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                // We should really never get into the scenario where this leg is a discontinuity, but let's be safe
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        this.generateSegmentVerticalData(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.tryConnectProcedures(plan);
        plan.calculate();
        return true;
    }
    /**
     * Method to build the approach legs.
     *
     * @param description the approach procedure description
     * @param resolvedApproach the resolved approach procedure
     * @param resolvedVisualRunway the resolved visual runway, if applicable
     *
     * @returns A Promise which is fulfilled with an `InsertProcedureObject` containing the flight plan legs to insert
     * into the flight plan.
     */
    async buildApproachLegs(description, resolvedApproach, resolvedVisualRunway) {
        const isVisual = resolvedApproach.approachType === AdditionalApproachType.APPROACH_TYPE_VISUAL;
        const transition = resolvedApproach.transitions[description.approachTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (transition !== undefined && transition.legs.length > 0) {
            const startIndex = description.transStartIndex !== undefined ? description.transStartIndex : 0;
            for (let t = startIndex; t < transition.legs.length; t++) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(transition.legs[t]));
            }
        }
        const lastTransitionLeg = insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1];
        const finalLegs = resolvedApproach.finalLegs;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = FlightPlan.createLeg(finalLegs[i]);
            if (i === 0 && lastTransitionLeg && this.isDuplicateIFLeg(lastTransitionLeg, leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] = this.mergeDuplicateLegData(lastTransitionLeg, leg);
                continue;
            }
            if (!isVisual && leg.fixIcao[0] === 'R') {
                const approachRunway = RunwayUtils.matchOneWayRunway(description.facility, resolvedApproach.runwayNumber, resolvedApproach.runwayDesignator);
                if (approachRunway) {
                    insertProcedureObject.runway = approachRunway;
                    const runwayLeg = BoeingFmsUtils.buildRunwayLeg(description.facility, approachRunway, false);
                    runwayLeg.verticalAngle = leg.verticalAngle;
                    insertProcedureObject.procedureLegs.push(runwayLeg);
                }
            }
            else if (isVisual && i === finalLegs.length - 1) {
                insertProcedureObject.runway = resolvedVisualRunway;
                insertProcedureObject.procedureLegs.push(leg);
                if (resolvedApproach.missedLegs.length > 0) {
                    insertProcedureObject.procedureLegs.push(resolvedApproach.missedLegs[0]);
                }
            }
            else {
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        if (!isVisual) {
            this.tryInsertIFLeg(insertProcedureObject);
            this.tryReconcileIAFLeg(insertProcedureObject);
            this.manageFafAltitudeRestriction(insertProcedureObject);
            this.tryCleanupHold(insertProcedureObject);
            this.tryInsertMap(insertProcedureObject);
            if (!insertProcedureObject.runway && resolvedApproach.runway) {
                insertProcedureObject.runway = RunwayUtils.matchOneWayRunway(description.facility, resolvedApproach.runwayNumber, resolvedApproach.runwayDesignator);
            }
            return insertProcedureObject;
        }
        return insertProcedureObject;
    }
    /**
     * Manages the altitude constraints in a segment when adding a procedure by creating a VerticalData object for each leg.
     * @param plan The Flight Plan.
     * @param segmentIndex The segment index for the inserted procedure.
     */
    generateSegmentVerticalData(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        for (let l = 0; l < segment.legs.length; l++) {
            this.generateLegVerticalData(plan, segmentIndex, l);
        }
    }
    /**
     * Manages the altitude constraints for a leg when adding a procedure by creating a VerticalData object for the leg.
     * @param plan The Flight Plan.
     * @param segmentIndex The segment index.
     * @param localLegIndex The local leg index.
     * @param forceVerticalFlightPhase The vertical flight phase to force on the vertical data. Otherwise, determined by the leg segment type.
     */
    generateLegVerticalData(plan, segmentIndex, localLegIndex, forceVerticalFlightPhase) {
        const segment = plan.getSegment(segmentIndex);
        const leg = segment.legs[localLegIndex];
        const altitude1 = leg.leg.altitude1;
        const altitude2 = leg.leg.altitude2;
        const altDesc = (BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.MAP) && altitude1 !== 0) ? AltitudeRestrictionType.At : leg.leg.altDesc;
        const speedRestriction = leg.leg.speedRestriction;
        const verticalData = {
            phase: forceVerticalFlightPhase !== null && forceVerticalFlightPhase !== void 0 ? forceVerticalFlightPhase : (segment.segmentType === FlightPlanSegmentType.Departure || BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)
                ? VerticalFlightPhase.Climb
                : VerticalFlightPhase.Descent),
            altDesc: altDesc,
            altitude1: altitude1,
            altitude2: altitude2,
            speed: speedRestriction <= 0 ? 0 : speedRestriction,
            speedDesc: speedRestriction <= 0 ? SpeedRestrictionType.Unused : SpeedRestrictionType.AtOrBelow,
            speedUnit: SpeedUnit.IAS
        };
        plan.setLegVerticalData(segmentIndex, localLegIndex, verticalData);
    }
    /**
     * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    manageFafAltitudeRestriction(proc) {
        proc.procedureLegs.forEach(leg => {
            if (leg.fixTypeFlags === FixTypeFlags.FAF && leg.altitude2 > 0) {
                const alt = leg.altitude1 <= leg.altitude2 ? leg.altitude1 : leg.altitude2;
                leg.altDesc = AltitudeRestrictionType.At;
                leg.altitude1 = alt;
                leg.altitude2 = alt;
            }
            else if (leg.fixTypeFlags === FixTypeFlags.FAF) {
                leg.altDesc = AltitudeRestrictionType.At;
                leg.altitude2 = leg.altitude1;
            }
        });
        return proc;
    }
    /**
     * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertIFLeg(proc) {
        const firstLeg = proc.procedureLegs[0];
        let icao;
        switch (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) {
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
            case LegType.FD:
            case LegType.FC:
                icao = firstLeg.fixIcao;
                break;
            case LegType.FM:
            case LegType.VM:
                icao = firstLeg.originIcao;
                break;
        }
        if (icao && icao !== ICAO.emptyIcao) {
            proc.procedureLegs.unshift(FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: icao,
                fixTypeFlags: firstLeg.fixTypeFlags & (FixTypeFlags.IF | FixTypeFlags.IAF)
            }));
            if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.HF || (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.PI) {
                proc.procedureLegs[0].altDesc = firstLeg.altDesc;
                proc.procedureLegs[0].altitude1 = firstLeg.altitude1;
                proc.procedureLegs[0].altitude2 = firstLeg.altitude2;
            }
            // need to remove IF/IAF flags from the original first leg (now the second leg)
            const replacementLeg = FlightPlan.createLeg(proc.procedureLegs[1]);
            replacementLeg.fixTypeFlags = replacementLeg.fixTypeFlags & ~(FixTypeFlags.IF | FixTypeFlags.IAF);
            proc.procedureLegs[1] = replacementLeg;
        }
        return proc;
    }
    /**
     * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
     * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
     * an IF leg type.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryReconcileIAFLeg(proc) {
        let iafIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                iafIndex = i;
                switch (leg.type) {
                    case LegType.HA:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.PI:
                    case LegType.FD:
                    case LegType.FC:
                        if (iafIndex > 0) {
                            leg.fixTypeFlags &= ~FixTypeFlags.IAF;
                            proc.procedureLegs[iafIndex - 1].fixTypeFlags |= FixTypeFlags.IAF;
                            iafIndex--;
                        }
                }
                break;
            }
        }
        return proc;
    }
    /**
     * Inserts a MAP fix type flag if none exists on the approach.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertMap(proc) {
        let addMap = true;
        let runwayIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.MAP) {
                addMap = false;
                break;
            }
            if (leg.fixIcao.search('R') === 0) {
                runwayIndex = i;
                break;
            }
        }
        if (addMap && runwayIndex > -1) {
            proc.procedureLegs[runwayIndex].fixTypeFlags = FixTypeFlags.MAP;
        }
        return proc;
    }
    /**
     * Method to remove the duplicate leg after the hold leg.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryCleanupHold(proc) {
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.type === LegType.HF) {
                const next = proc.procedureLegs[i + 1];
                if (leg.fixIcao === next.fixIcao && next.type === LegType.IF) {
                    proc.procedureLegs.splice(i + 1, 1);
                }
            }
        }
        return proc;
    }
    /**
     * Method to remove a course reversal in an approach procedure.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryRemoveCourseReversal(proc) {
        let canRemove = false;
        if (proc.procedureLegs.length > 2) {
            const leg = proc.procedureLegs[1];
            switch (leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    canRemove = true;
            }
        }
        if (canRemove) {
            proc.procedureLegs.splice(1, 1);
        }
        return proc;
    }
    /**
     * Method to remove the departure from the flight plan.
     */
    async removeDeparture() {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        plan.setDeparture();
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        // Remove constraints from first enroute leg
        this.clearFirstEnrouteLegVerticalData(plan);
        if (plan.originAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
            const updatedSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, updatedSegmentIndex, airport, plan.procedureDetails.originRunway);
            const prevLeg = plan.getPrevLeg(updatedSegmentIndex, 1);
            const nextLeg = plan.getNextLeg(updatedSegmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the arrival from the flight plan.
     */
    async removeArrival() {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        plan.setArrival();
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.planRemoveSegment(segmentIndex);
        // Remove constraints from last enroute leg
        this.clearLastEnrouteLegVerticalData(plan);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (activeLegArray && activeLegArray.length === 2) {
            this.addActiveLegsToEnroute(plan, activeLegArray);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the approach from the flight plan.
     */
    async removeApproach() {
        const plan = this.getPlanToModify();
        if (this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            this.deleteFlightPlanVisualApproach(plan.planIndex);
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
        // set the G/S enabled for non-FMS approach
        this.performancePlanProxy.glideSlope.set(GlideslopeStatus.ON);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        plan.procedureDetails.arrivalRunwayTransitionIndex = -1;
        plan.setDestinationRunway(undefined, false);
        plan.setApproach();
        this.cleanupLegsAfterApproach(plan);
        this.planRemoveSegment(segmentIndex);
        // Remove constraints from last enroute leg if there wasn't an arrival
        if (plan.procedureDetails.arrivalIndex === -1) {
            this.clearLastEnrouteLegVerticalData(plan);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            this.addActiveLegsToEnroute(plan, activeLegArray, true);
        }
        plan.calculate(0);
    }
    /**
     * Clears the vertical data of the last enroute leg, if applicable
     *
     * @param plan the lateral flight plan
     */
    clearFirstEnrouteLegVerticalData(plan) {
        let firstEnrouteSegment;
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.legs.length > 0) {
                firstEnrouteSegment = segment;
                break;
            }
        }
        if (firstEnrouteSegment) {
            plan.setLegVerticalData(firstEnrouteSegment.offset, { altDesc: AltitudeRestrictionType.Unused, speedDesc: SpeedRestrictionType.Unused });
        }
    }
    /**
     * Clears the vertical data of the last enroute leg, if applicable
     *
     * @param plan the lateral flight plan
     */
    clearLastEnrouteLegVerticalData(plan) {
        let lastEnrouteSegment;
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.legs.length > 0) {
                lastEnrouteSegment = segment;
                break;
            }
        }
        if (lastEnrouteSegment) {
            plan.setLegVerticalData(lastEnrouteSegment.offset + (lastEnrouteSegment.legs.length - 1), { altDesc: AltitudeRestrictionType.Unused, speedDesc: SpeedRestrictionType.Unused });
        }
    }
    /**
     * Adds active leg pair to the last enroute segment when a procedure is deleted and the current activeLateralLeg is in that procedure.
     * @param plan The FlightPlan.
     * @param activeLegArray The Active Leg Pair.
     * @param checkForArrivalSegment Whether to check first for an arrival segment to add the legs to.
     */
    addActiveLegsToEnroute(plan, activeLegArray, checkForArrivalSegment = false) {
        let segmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (checkForArrivalSegment && plan.procedureDetails.arrivalIndex > -1) {
            const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival, false);
            if (arrivalSegmentIndex > -1) {
                segmentIndex = arrivalSegmentIndex;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        if (activeLegArray.length === 2) {
            plan.addLeg(segmentIndex, activeLegArray[0], undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            plan.addLeg(segmentIndex, activeLegArray[1], undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            this.planAddLeg(segmentIndex, FlightPlan.createLeg({
                type: LegType.Discontinuity
            }), undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            plan.setLateralLeg(segment.offset + segment.legs.length - 2);
        }
        else if (activeLegArray.length === 3) {
            plan.addLeg(segmentIndex, activeLegArray[1]);
            this.planAddLeg(segmentIndex, FlightPlan.createLeg({
                type: LegType.Discontinuity
            }), undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            this.createDirectTo(segmentIndex, segment.legs.length - 2);
        }
    }
    /**
     * Method to activate a leg in the flight plan.
     * @param segmentIndex is the index of the segment containing the leg to activate.
     * @param legIndex is the index of the leg in the selected segment activate.
     * @param removeExistingDTO Whether to check for and remove the existing direct to legs.
     */
    activateLeg(segmentIndex, legIndex, removeExistingDTO = true) {
        const modPlan = this.getPlanToModify();
        const indexInFlightplan = modPlan.getSegment(segmentIndex).offset + legIndex;
        if (removeExistingDTO && this.getDirectToState(modPlan.planIndex) === DirectToState.TOEXISTING) {
            this.removeDirectToExisting(modPlan.planIndex, indexInFlightplan);
            // The call above handles setting the active leg
        }
        else {
            modPlan.setCalculatingLeg(indexInFlightplan);
            modPlan.setLateralLeg(indexInFlightplan);
            modPlan.calculate(Math.max(0, indexInFlightplan - 1));
        }
        this.legWasActivatedInModPlan = true;
    }
    /**
     * Method to create a direct to in the plan. This method will also then call activateLeg.
     * A DTO consists of 4 legs:
     * 1. The original leg that was used to create the DTO.
     * a. We preserve this leg so that we will have a vlid FROM leg in case the DTO needs to be removed.
     * 2. A DISCO leg, because a DTO is not connected to any legs that came before it.
     * 3. The FROM leg, initializes to the present position (PPOS).
     * 4. The TO leg.
     * @param segmentIndex is the index of the segment containing the leg to activate as direct to.
     * @param segmentLegIndex is the index of the leg in the specified segment to activate as direct to.
     * @param isNewDTO whether to treat this as a new directo to or not.
     * @param course is the course for this direct to in magnetic degrees, if specified.
     * @param facility is the new facility to add to the plan and then create a direct to for, for the case of a direct to random.
     */
    createDirectTo(segmentIndex, segmentLegIndex, isNewDTO = true, course, facility) {
        var _a, _b;
        let newLeg;
        if (isNewDTO) {
            this.dtoWasCreatedInModPlan = true;
            if (facility !== undefined) {
                newLeg = FlightPlan.createLeg({
                    type: LegType.TF,
                    fixIcao: facility.icao
                });
            }
        }
        const plan = this.getPlanToModify();
        if (segmentIndex === undefined) {
            const lastSegment = plan.segmentCount > 0 ? plan.getSegment(plan.segmentCount - 1) : undefined;
            if (lastSegment) {
                if (lastSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, lastSegment.segmentIndex + 1);
                }
                else {
                    segmentIndex = lastSegment.segmentIndex;
                }
            }
            else {
                return;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        if (segmentLegIndex === undefined) {
            segmentLegIndex = Math.max(0, segment.legs.length - 1);
        }
        let modLegVerticalData;
        if (!isNewDTO && this.dtoWasCreatedInModPlan) {
            const existingModDtoTargetLeg = segment.legs[segmentLegIndex + 3];
            if (existingModDtoTargetLeg !== undefined) {
                modLegVerticalData = existingModDtoTargetLeg.verticalData;
                if (existingModDtoTargetLeg.leg.type === LegType.CF) {
                    if (existingModDtoTargetLeg.leg.trueDegrees) {
                        // FIXME we give up if no magvar available from calculations
                        course = MagVar.trueToMagnetic(existingModDtoTargetLeg.leg.course, (_b = (_a = existingModDtoTargetLeg.calculated) === null || _a === void 0 ? void 0 : _a.courseMagVar) !== null && _b !== void 0 ? _b : 0);
                    }
                    else {
                        course = existingModDtoTargetLeg.leg.course;
                    }
                }
            }
        }
        let legIndexDelta = 0;
        if (plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1) {
            legIndexDelta -= plan.directToData.segmentIndex === segmentIndex && segmentLegIndex > plan.directToData.segmentLegIndex ? 3 : 0;
            if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX) === DirectToState.TOEXISTING) {
                this.removeDirectToExisting(BoeingFms.RTE_1_MOD_PLAN_INDEX, undefined, false);
            }
            else {
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
            }
        }
        if (newLeg !== undefined) {
            this.planAddLeg(segmentIndex, newLeg, segmentLegIndex + legIndexDelta);
        }
        const leg = segment.legs[segmentLegIndex + legIndexDelta];
        plan.setDirectToData(segmentIndex, segmentLegIndex + legIndexDelta);
        if (segment && leg) {
            let originPos = this.ppos;
            if (course) {
                originPos = this.ppos.offset(NavMath.normalizeHeading(course + 180), UnitType.NMILE.convertTo(50, UnitType.GA_RADIAN), new GeoPoint(0, 0));
            }
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            const dtoOriginLeg = this.createDTOOriginLeg(originPos);
            const dtoTargetLeg = this.createDTODirectLeg(leg.leg.fixIcao, leg.leg, course);
            // We do a +1,2,3 here so that the original TO leg is preserved, in case the DTO gets removed
            plan.addLeg(segmentIndex, discoLeg, segmentLegIndex + legIndexDelta + 1, LegDefinitionFlags.DirectTo);
            plan.addLeg(segmentIndex, dtoOriginLeg, segmentLegIndex + legIndexDelta + 2, LegDefinitionFlags.DirectTo);
            plan.addLeg(segmentIndex, dtoTargetLeg, segmentLegIndex + legIndexDelta + 3, (leg.flags & LegDefinitionFlags.MissedApproach) | LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
            const newVerticalData = modLegVerticalData !== null && modLegVerticalData !== void 0 ? modLegVerticalData : leg.verticalData;
            plan.setLegVerticalData(segmentIndex, segmentLegIndex + legIndexDelta + 3, newVerticalData);
            this.activateLeg(segmentIndex, segmentLegIndex + legIndexDelta + 3, false);
        }
    }
    /**
     * Method to create a direct to in the flight plan to an arbitrary airport.
     *
     * This:
     *
     * - empties out the flight plan;
     * - sets the destination as the provided airport facility;
     * - creates a direct-to sequence to that facility.
     *
     * @param airportFacility the airport facility to go direct to
     */
    createDirectToAirport(airportFacility) {
        const plan = this.getPlanToModify();
        const segmentCount = plan.segmentCount;
        for (let i = segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i, true);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, true);
        plan.addSegment(1, FlightPlanSegmentType.Enroute, undefined, true);
        BoeingFmsUtils.reconcileDirectToData(plan);
        this.setDestination(airportFacility);
        this.createDirectTo(undefined, undefined, true, undefined, airportFacility);
    }
    /**
     * Method to create a direct to in the flight plan to an arbitrary airport+runway using a visual approach.
     *
     * This:
     *
     * - empties out the flight plan;
     * - sets the destination as the provided airport facility;
     * - inserts a visual approach to the provided runway;
     * - creates a direct-to sequence to the FAF of that approach.
     *
     * @param airportFacility the airport facility to go direct to
     * @param runway the one way runway to insert a visual approach for
     */
    async createDirectToRunwayVisualApproach(airportFacility, runway) {
        const plan = this.getPlanToModify();
        const segmentCount = plan.segmentCount;
        for (let i = segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i, true);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, true);
        plan.addSegment(1, FlightPlanSegmentType.Enroute, undefined, true);
        BoeingFmsUtils.reconcileDirectToData(plan);
        await this.insertApproach({
            facility: airportFacility,
            approachIndex: -1,
            approachTransitionIndex: -1,
            visualRunwayNumber: runway.direction,
            visualRunwayDesignator: runway.runwayDesignator,
        });
        const approachSegment = Array.from(plan.segmentsOfType(FlightPlanSegmentType.Approach))[0];
        if (approachSegment) {
            let activateIndex = -1;
            for (let i = 0; i < approachSegment.legs.length; i++) {
                activateIndex = i;
                const leg = approachSegment.legs[i];
                const isFaf = BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.FAF);
                if (isFaf) {
                    break;
                }
            }
            if (activateIndex !== -1) {
                this.createDirectTo(approachSegment.segmentIndex, activateIndex, true, undefined);
            }
        }
    }
    /**
     * Creates a Direct-To origin IF leg.
     * @param ppos The current plane position.
     * @returns a Direct-To origin IF leg.
     */
    createDTOOriginLeg(ppos) {
        return FlightPlan.createLeg({
            type: LegType.IF,
            lat: ppos.lat,
            lon: ppos.lon
        });
    }
    /**
     * Creates a Direct-To target leg.
     * @param icao is the icao.
     * @param leg The FlightPlanLeg.
     * @param course The magnetic course for the Direct To.
     * @returns a Direct-To leg.
     */
    createDTODirectLeg(icao, leg, course) {
        let legType;
        if (course === undefined) {
            legType = LegType.DF;
            const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES MAGNETIC', 'degrees');
            course = planeHeading === 0 ? 360 : planeHeading;
        }
        else {
            legType = LegType.CF;
        }
        if (leg) {
            const directLeg = Object.assign({}, leg);
            directLeg.type = legType;
            directLeg.course = course;
            directLeg.trueDegrees = false;
            directLeg.turnDirection = LegTurnDirection.None;
            return directLeg;
        }
        else {
            return FlightPlan.createLeg({
                type: legType,
                fixIcao: icao,
                course,
                trueDegrees: false
            });
        }
        // const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
        // if (leg) {
        //   const directLeg = Object.assign({}, leg);
        //   directLeg.type = LegType.DF;
        //   directLeg.course = planeHeading === 0 ? 360 : planeHeading;
        //   return directLeg;
        // } else {
        //   return FlightPlan.createLeg({
        //     type: LegType.DF,
        //     fixIcao: icao,
        //     course: planeHeading === 0 ? 360 : planeHeading
        //   });
        // }
    }
    /**
     * Updates the DTO Origin Leg Lat/Lon with the PPOS.
     * @param plan The Flight Plan.
     */
    updateDtoOrigin(plan) {
        // We only want to update the DTO origin if the DTO was created in this current MOD plan
        if (!this.dtoWasCreatedInModPlan) {
            return;
        }
        const pposLeg = plan.tryGetLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 2);
        // Making sure that we are in a DTO
        if (!pposLeg) {
            return;
        }
        // We need to recreate the DTO so that the proper events get sent and legs get recreated and what not
        this.createDirectTo(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex, false);
    }
    /**
     * Creates a vertical direct-to to a leg. This creates a manual constraint with an fpa that reaches
     * the desired altitude using a continuous descent from the present position and altitude.
     *
     * **NOTE:** This will not delete any constraints - it is the responsibility of the caller to do so.
     *
     * @param plan the plan to use
     * @param globalIndex the global leg index to apply the constraint to
     * @param finalAltitude the altitude to target, in metres.
     * @param isAutomatic whether this was an automatic VDTO (created with a lateral DTO)
     *
     * @returns whether the vdto was successfully created
     */
    createVerticalDirectTo(plan, globalIndex, finalAltitude, isAutomatic = false) {
        var _a;
        const distanceToConstraint = isAutomatic
            ? (_a = plan.getLeg(globalIndex).calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions
            : BoeingFmsUtils.getDistanceFromPposToLegEnd(plan, globalIndex);
        if (distanceToConstraint === undefined) {
            return false;
        }
        const currentAltitude = this.aircraftAltitude;
        if (currentAltitude === undefined) {
            return false;
        }
        const currentAltitudeMetres = UnitType.METER.convertFrom(currentAltitude, UnitType.FOOT);
        const fpa = VNavUtils.getFpa(distanceToConstraint, 75 + currentAltitudeMetres - finalAltitude);
        const isFpaValid = fpa > 1 && fpa <= 6;
        if (!isFpaValid) {
            return false;
        }
        plan.setLegVerticalData(globalIndex, {
            phase: VerticalFlightPhase.Descent,
            altDesc: AltitudeRestrictionType.At,
            altitude1: finalAltitude,
            altitude2: undefined,
            fpa: isAutomatic ? Math.max(3, fpa) : fpa,
        });
        this.verticalPathCalculator.requestPathCompute(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        this.verticalDtoWasCreatedInModPlan = true;
        this.verticalDtoWasCreatedInModPlanWasAutomatic = isAutomatic;
        return true;
    }
    /**
     * Updates the vertical DTO origin with the current altitude and distance to constraint.
     * @param plan The Flight Plan.
     * @returns whether the vertical DTO is still valid
     */
    updateVerticalDtoOrigin(plan) {
        const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(this.getVerticalPlanForFmcRender(), plan.activeLateralLeg);
        if (constraintIndex === -1) {
            return false;
        }
        const constraint = this.getVerticalPlanForFmcRender().constraints[constraintIndex];
        return this.createVerticalDirectTo(plan, constraint.index, constraint.targetAltitude, this.verticalDtoWasCreatedInModPlanWasAutomatic);
    }
    /**
     * Creates a direct to existing to the next valid leg in the plan after the input global leg index.
     * @param globalLegIndex The global leg index.
     * @returns Whether a direct to existing was created.
     */
    createDirectToExistingNextValidLeg(globalLegIndex) {
        const modPlan = this.getPrimaryModFlightPlan();
        for (let l = globalLegIndex + 1; l < modPlan.length; l++) {
            const leg = modPlan.tryGetLeg(l);
            if ((leg === null || leg === void 0 ? void 0 : leg.leg.type) !== LegType.Discontinuity && (leg === null || leg === void 0 ? void 0 : leg.leg.type) !== LegType.ThruDiscontinuity) {
                const targetSegmentIndex = modPlan.getSegmentIndex(l);
                const targetSegment = modPlan.getSegment(targetSegmentIndex);
                const targetSegmentLegIndex = l - targetSegment.offset;
                this.createDirectTo(targetSegmentIndex, targetSegmentLegIndex, true);
                return true;
            }
        }
        return false;
    }
    /**
     * Creates an alternate diversion in the MOD plan based on provided alternate data
     *
     * @param alternateData the alternate data to use
     *
     * @throws if the alternate diversion mode is unknown or not implemented yet
     */
    createAlternateDiversion(alternateData) {
        const plan = this.getPlanToModify();
        // Always create a direct diversion if no legs in front of us
        if (((plan.length - 1) - plan.activeLateralLeg) < 0) {
            this.createDirectAlternateDiversion(plan, alternateData.facilityIcao).then();
            return;
        }
        switch (alternateData.diversion.mode) {
            case AlternateDiversionMode.Direct:
                this.createDirectAlternateDiversion(plan, alternateData.facilityIcao).then();
                break;
            case AlternateDiversionMode.Overhead:
                this.createOverheadAlternateDiversion(plan, alternateData.facilityIcao, alternateData.diversion.legIndex);
                break;
            default: throw new Error(`Unknown or unimplemented alternate diversion mode: ${alternateData.diversion.mode}`);
        }
    }
    /**
     * Creates a DIRECT alternate diversion
     *
     * @param plan the flight plan to create the diversion in
     * @param alternateFacilityIcao the ICAO of the alternate facility to divert to
     */
    async createDirectAlternateDiversion(plan, alternateFacilityIcao) {
        const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, alternateFacilityIcao);
        this.createDirectToAirport(airportFacility);
    }
    /**
     * Creates an OVERHEAD alternate diversion. This should only be called with an {@link overheadLegIndex} that is
     * in the flight plan, or if `undefined`, with a flight plan that contains an active leg.
     *
     * @param plan the flight plan to create the diversion in
     * @param alternateFacilityIcao the ICAO of the alternate facility to divert to
     * @param overheadLegIndex the leg index of the overhead point, or `undefined` if the active leg shall be used
     */
    async createOverheadAlternateDiversion(plan, alternateFacilityIcao, overheadLegIndex) {
        const segmentCount = plan.segmentCount;
        // Find leg index of the overhead fix
        const overheadFixLegIndex = overheadLegIndex !== null && overheadLegIndex !== void 0 ? overheadLegIndex : plan.activeLateralLeg; // TODO what if there are no legs in the plan after active?
        const activeSegmentIndex = plan.getSegmentIndex(overheadFixLegIndex);
        // Remove all next segments
        for (let i = segmentCount - 1; i > activeSegmentIndex + 1; i--) {
            plan.removeSegment(i, true);
        }
        // Remove everything after that leg
        while ((plan.length - 1) > overheadFixLegIndex) {
            const lastLegGlobalIndex = plan.length - 1;
            const lastLegSegmentIndex = plan.getSegmentIndex(lastLegGlobalIndex);
            const lastLegLocalIndex = plan.getSegmentLegIndex(lastLegGlobalIndex);
            plan.removeLeg(lastLegSegmentIndex, lastLegLocalIndex);
        }
        // Create a DF leg to that airport
        const dfLeg = this.createDTODirectLeg(alternateFacilityIcao);
        // Add that DF leg at the end of the plan
        const lastLegGlobalIndex = plan.length - 1;
        const lastLegSegmentIndex = plan.getSegmentIndex(lastLegGlobalIndex);
        plan.addLeg(lastLegSegmentIndex, dfLeg);
        const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, alternateFacilityIcao);
        this.setDestination(airportFacility);
    }
    /**
     * Updates an existing PPOS hold if it exists and is in the MOD flight plan
     *
     * @param plan the plan
     */
    tryUpdatePposHoldPosition(plan) {
        const modPlan = this.getPrimaryModFlightPlan();
        const activePlan = this.getPrimaryFlightPlan();
        const modActiveLeg = modPlan.tryGetLeg(modPlan.activeLateralLeg);
        const activeActiveLeg = activePlan.tryGetLeg(activePlan.activeLateralLeg);
        // We don't wanna update any PPOS hold in the mod flight plan if that hold is already confirmed (in the active flight plan)
        const pposHoldInActive = activeActiveLeg && activeActiveLeg.leg.type === LegType.HM && activeActiveLeg.leg.fixIcao === ICAO.emptyIcao;
        const notPposHold = modActiveLeg && (modActiveLeg.leg.type !== LegType.HM || modActiveLeg.leg.fixIcao !== ICAO.emptyIcao);
        if (plan.planIndex !== BoeingFms.RTE_1_MOD_PLAN_INDEX || pposHoldInActive || !modActiveLeg || notPposHold) {
            // Not in MOD or no PPOS hold at FROM leg
            return;
        }
        this.insertPposHold();
    }
    /**
     * Empties the primary flight plan.
     * @param planIndex The plan index to empty. Defaults to the active plan index.
     */
    emptyFlightPlan(planIndex = BoeingFms.ACT_RTE_PLAN_INDEX) {
        if (!this.flightPlanner.hasFlightPlan(planIndex)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure);
        plan.addSegment(1, FlightPlanSegmentType.Enroute);
        plan.addSegment(2, FlightPlanSegmentType.Destination);
        plan.removeOriginAirport();
        plan.removeDestinationAirport();
        plan.setDirectToData(-1);
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
        }
        plan.setCalculatingLeg(0);
        plan.setLateralLeg(0);
        plan.setVerticalLeg(0);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_ALTN);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_ROUTE);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN);
        // Just making sure that these plans still have their route key set
        if (planIndex === BoeingFms.RTE_1_INACTIVE_PLAN_INDEX || planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX) {
            plan.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        }
        else if (planIndex === BoeingFms.RTE_2_INACTIVE_PLAN_INDEX || planIndex === BoeingFms.RTE_2_MOD_PLAN_INDEX) {
            plan.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 2);
        }
    }
    /**
     * Adds an airway and airway segment to the flight plan.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     */
    insertAirwaySegment(airway, entry, exit, segmentIndex, legIndex) {
        const plan = this.getPlanToModify();
        const airwaySegmentIndex = this.prepareAirwaySegment(`${airway.name}`, segmentIndex, legIndex);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        const airwayLegs = airwayLegObject.procedureLegs;
        for (let i = 1; i < airwayLegs.length; i++) {
            this.planAddLeg(airwaySegmentIndex, airwayLegs[i]);
        }
        // handle duplicates
        const airwaySegment = plan.getSegment(airwaySegmentIndex);
        const lastLeg = airwaySegment.legs[airwaySegment.legs.length - 1];
        const nextLeg = plan.getNextLeg(airwaySegmentIndex + 1, -1);
        if (lastLeg && nextLeg && this.isDuplicateLeg(lastLeg.leg, nextLeg.leg)) {
            const nextLegIndex = plan.getLegIndexFromLeg(nextLeg);
            const nextLegSegmentIndex = plan.getSegmentIndex(nextLegIndex);
            const nextLegSegment = plan.getSegment(nextLegSegmentIndex);
            if (this.getAirwayLegType(plan, nextLegSegmentIndex, nextLegIndex - nextLegSegment.offset) === AirwayLegType.ENTRY) {
                // the duplicated leg is an airway entry -> remove the segment containing it (the segment is guaranteed to
                // contain just the one leg)
                this.planRemoveSegment(nextLegSegmentIndex);
            }
            else {
                this.planRemoveDuplicateLeg(lastLeg, nextLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
     * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
     * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
     * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
     * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
     * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
     * removed.
     * @param airwayName The name of the airway.
     * @param entrySegmentIndex The index of the segment containing the airway entry leg.
     * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
     * @returns The index of the new airway segment.
     */
    prepareAirwaySegment(airwayName, entrySegmentIndex, entrySegmentLegIndex) {
        const plan = this.getPlanToModify();
        if (entrySegmentIndex < plan.directToData.segmentIndex
            || (entrySegmentIndex === plan.directToData.segmentIndex && entrySegmentLegIndex < plan.directToData.segmentLegIndex)) {
            this.removeDirectToExisting();
        }
        const entrySegment = plan.getSegment(entrySegmentIndex);
        const nextSegment = entrySegmentIndex + 1 < plan.segmentCount ? plan.getSegment(entrySegmentIndex + 1) : undefined;
        let airwaySegmentIndex = entrySegmentIndex + 1;
        let removeLegsSegmentIndex = -1;
        let removeLegsFromIndex = -1;
        if (entrySegment.airway !== undefined) {
            // the entry leg is within an existing airway segment -> remove all legs in the same segment after the entry leg
            removeLegsSegmentIndex = entrySegmentIndex;
            removeLegsFromIndex = entrySegmentLegIndex + 1;
        }
        else if (entrySegmentLegIndex === entrySegment.legs.length - 1 && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.airway) !== undefined) {
            // the entry leg is the entry leg for an existing airway segment -> remove all legs from the existing airway segment
            removeLegsSegmentIndex = entrySegmentIndex + 1;
            removeLegsFromIndex = 0;
        }
        // remove legs as required
        if (removeLegsSegmentIndex >= 0) {
            const removeLegsSegment = plan.getSegment(removeLegsSegmentIndex);
            if (this.getAirwayLegType(plan, removeLegsSegmentIndex, removeLegsSegment.legs.length - 1) === AirwayLegType.EXIT_ENTRY) {
                // preserve the airway entry leg
                const lastLeg = removeLegsSegment.legs[removeLegsSegment.legs.length - 1];
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, removeLegsSegmentIndex + 1);
                this.planAddLeg(removeLegsSegmentIndex + 1, lastLeg.leg, 0);
            }
            if (removeLegsFromIndex > 0) {
                while (removeLegsSegment.legs.length > removeLegsFromIndex) {
                    this.planRemoveLeg(removeLegsSegmentIndex, removeLegsSegment.legs.length - 1, true, true);
                }
            }
            else {
                this.planRemoveSegment(removeLegsSegmentIndex);
            }
        }
        if (entrySegment.legs.length - 1 > entrySegmentLegIndex) {
            // entry leg is not the last leg in its segment -> split the segment after the entry leg
            airwaySegmentIndex = this.splitSegment(plan, entrySegmentIndex, entrySegmentLegIndex);
        }
        else if (plan.getSegment(entrySegmentIndex).segmentType === FlightPlanSegmentType.Enroute
            && ((nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) !== FlightPlanSegmentType.Enroute)) {
            // entry leg is the last leg in its segment and the following segment doesn't exist or is not an enroute segment
            plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute);
        }
        plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
        return airwaySegmentIndex;
    }
    /**
     * Splits a segment into two segments if type is enroute; if departure, remove legs after the legIndex, else do nothing.
     * @param plan is the flight plan to edit.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     * @returns the segment number of the new airway segment if one was created, else the current segment or if no action was taken.
     */
    splitSegment(plan, segmentIndex, legIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.segmentType === FlightPlanSegmentType.Enroute) {
            const nextSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            // Move legs after leg index to new segment
            // It's funky without the i++, but it works correctly because the length of the segment is changing
            for (let i = legIndex + 1; i < segment.legs.length;) {
                const leg = segment.legs[i].leg;
                this.planAddLeg(nextSegmentIndex, leg);
                this.planRemoveLeg(segmentIndex, i);
            }
            return nextSegmentIndex;
        }
        else if (segment.segmentType === FlightPlanSegmentType.Departure) {
            // Remove legs after leg index
            // It's funky without the i++, but it works correctly because the length of the segment is changing
            for (let i = legIndex + 1; i < segment.legs.length;) {
                this.planRemoveLeg(segmentIndex, i);
            }
        }
        return segmentIndex;
    }
    /**
     * Builds a legs for an airway.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the InsertProcedureObject.
     */
    buildAirwayLegs(airway, entry, exit) {
        const insertAirwayObject = { procedureLegs: [] };
        const waypoints = airway.waypoints;
        const entryIndex = waypoints.findIndex((w) => w.icao === entry.icao);
        const exitIndex = waypoints.findIndex((w) => w.icao === exit.icao);
        const ascending = exitIndex > entryIndex;
        if (ascending) {
            for (let i = entryIndex; i <= exitIndex; i++) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        else {
            for (let i = entryIndex; i >= exitIndex; i--) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        return insertAirwayObject;
    }
    /**
     * Method to remove an airway from the flight plan.
     * @param segmentIndex is the segment index of the airway to remove.
     */
    removeAirway(segmentIndex) {
        const plan = this.getPlanToModify();
        let combineSegments = false;
        const segment = plan.getSegment(segmentIndex);
        const exitLeg = segment.legs[segment.legs.length - 1].leg;
        if (segmentIndex > 0) {
            const priorSegmentEnrouteNonAirway = plan.getSegment(segmentIndex - 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex - 1).airway === undefined;
            const nextSegmentEnrouteNonAirway = plan.getSegment(segmentIndex + 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex + 1).airway === undefined;
            if (priorSegmentEnrouteNonAirway && nextSegmentEnrouteNonAirway) {
                combineSegments = true;
            }
            // Add the exit leg as a direct in the prior segment if it is enroute and not an airway.
            if (priorSegmentEnrouteNonAirway) {
                this.planAddLeg(segmentIndex - 1, exitLeg);
            }
            // Remove the airway segment
            this.planRemoveSegment(segmentIndex);
            // If we have two adjacent enroute non-airway segments, merge them.
            if (combineSegments) {
                this.mergeSegments(plan, segmentIndex - 1);
            }
            // If we need to add a non-airway enroute segment
            if (!priorSegmentEnrouteNonAirway) {
                if (!nextSegmentEnrouteNonAirway) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                }
                this.planAddLeg(segmentIndex, exitLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
     * first, and the second segment is removed from the flight plan.
     * @param plan The flight plan to modify.
     * @param segmentIndex The index of the first segment to merge.
     */
    mergeSegments(plan, segmentIndex) {
        const segmentToGrow = plan.getSegment(segmentIndex);
        const segmentToRemove = plan.getSegment(segmentIndex + 1);
        const segmentToGrowOrigLength = segmentToGrow.legs.length;
        segmentToRemove.legs.forEach((l) => {
            plan.addLeg(segmentIndex, l.leg, undefined, l.flags);
        });
        if (plan.directToData.segmentIndex === segmentIndex + 1) {
            plan.setDirectToData(segmentIndex, segmentToGrowOrigLength + plan.directToData.segmentLegIndex);
        }
        this.planRemoveSegment(segmentIndex + 1);
    }
    /**
     * Insert a hold into the flight plan.
     * @param globalLegIndex The global index of the parent leg.
     * @returns Whether the hold was inserted in the flight plan.
     * */
    createHold(globalLegIndex) {
        const plan = this.getPlanToModify();
        const parentLeg = plan.getLeg(globalLegIndex);
        const parentLegIndex = plan.getLegIndexFromLeg(parentLeg);
        const parentLegSegmentIndex = plan.getSegmentIndex(parentLegIndex);
        const parentLegSegment = plan.getSegment(parentLegSegmentIndex);
        let course = 100;
        if (parentLeg.calculated) {
            const trueCourse = FlightPathUtils.getLegFinalCourse(parentLeg.calculated);
            if (trueCourse !== undefined) {
                course = MagVar.trueToMagnetic(trueCourse, parentLeg.calculated.courseMagVar);
            }
        }
        const holdLeg = FlightPlan.createLeg({
            type: LegType.HM,
            fixIcao: parentLeg.leg.fixIcao,
            turnDirection: LegTurnDirection.Right,
            distanceMinutes: true,
            distance: 1,
            course,
        });
        return this.insertHold(parentLegSegmentIndex, parentLegIndex - parentLegSegment.offset, holdLeg);
    }
    /**
     * Inserts a hold-at-waypoint leg to the primary flight plan. The hold leg will be inserted immediately after the
     * specified parent leg. The hold leg must have the same fix as the parent leg.
     * @param segmentIndex The index of the segment that contains the hold's parent leg.
     * @param legIndex The index of the hold's parent leg in its segment.
     * @param holdLeg The hold leg to add.
     * @returns Whether the hold-at-waypoint leg was successfully inserted.
     */
    insertHold(segmentIndex, legIndex, holdLeg) {
        const plan = this.getPlanForFmcRender();
        if (!plan) {
            return false;
        }
        const modPlan = this.getPlanToModify();
        const prevLeg = modPlan.getPrevLeg(segmentIndex, legIndex + 1);
        if ((prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.fixIcao) !== holdLeg.fixIcao) {
            return false;
        }
        const nextLeg = modPlan.getNextLeg(segmentIndex, legIndex);
        // If we are editing a hold, delete the old leg.
        if (nextLeg && BoeingFmsUtils.isHoldAtLeg(nextLeg.leg.type) && nextLeg.leg.fixIcao === holdLeg.fixIcao) {
            const segment = modPlan.getSegmentFromLeg(nextLeg);
            segment && modPlan.removeLeg(segment.segmentIndex, segment.legs.indexOf(nextLeg));
        }
        this.planAddLeg(segmentIndex, holdLeg, legIndex + 1);
        return true;
    }
    /**
     * Inserts a PPOS hold as the active leg
     *
     * @param partial an object to modify the PPOS hold leg with, if applicable
     *
     * @returns whether the leg was inserted
     */
    insertPposHold(partial) {
        const activeLegIndex = this.getPlanForFmcRender().activeLateralLeg;
        const activeLeg = this.getPlanForFmcRender().tryGetLeg(activeLegIndex);
        let activeSegmentIndex = this.getPlanForFmcRender().getSegmentIndex(activeLegIndex);
        const plan = this.getPlanToModify();
        if (activeSegmentIndex === -1) {
            plan.addSegment(0, FlightPlanSegmentType.Enroute);
            activeSegmentIndex = 0;
        }
        const { lon, lat } = this.ppos;
        const magVar = MagVar.get(lat, lon);
        const insertAfterActive = activeLegIndex === 0;
        const activeLegSegment = plan.getSegment(activeSegmentIndex);
        let insertIndex = activeLegIndex - activeLegSegment.offset + (insertAfterActive ? 1 : 0);
        const parentLeg = FlightPlan.createLeg({ type: LegType.IF, fixIcao: 'W      PPOS', lat, lon });
        if (!activeLeg) {
            plan.addLeg(activeSegmentIndex, parentLeg);
            // There was no active leg, meaning an empty plan - we want to add at the end of the newly created segment
            insertIndex = undefined;
        }
        else {
            if (activeLeg.leg.type === LegType.HM && activeLeg.leg.fixIcao === ICAO.emptyIcao) {
                activeLegSegment && this.removeWaypoint(activeLegSegment.segmentIndex, activeLegIndex - activeLegSegment.offset);
            }
            else {
                plan.addLeg(activeSegmentIndex, parentLeg, insertIndex);
                insertIndex++;
            }
        }
        const pposHold = FlightPlan.createLeg(Object.assign({ type: LegType.HM, fixIcao: ICAO.emptyIcao, turnDirection: LegTurnDirection.Right, distanceMinutes: true, distance: 1, course: this.aircraftTrack ? this.aircraftTrack - magVar : 100, // I think the leg path builder adds magvar
            lat,
            lon }, partial !== null && partial !== void 0 ? partial : {}));
        let insertHoldLeg;
        try {
            // If the active leg is 0 (only airport or runway in the flight plan), we want to insert the hold after the active leg
            insertHoldLeg = plan.addLeg(activeSegmentIndex, pposHold, insertIndex);
        }
        catch (e) {
            console.error(e);
            return false;
        }
        plan.setLateralLeg(plan.getLegIndexFromLeg(insertHoldLeg));
        return true;
    }
    /**
     * Returns the index of the last element in the array where predicate is true, and -1
     * otherwise.
     * @param array The source array to search in
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
     * @param defaultReturn is the default value
     * @returns either the index or the default if the predicate criteria is not met
     */
    findLastSegmentIndex(array, predicate, defaultReturn = -1) {
        let l = array.length;
        while (l--) {
            if (predicate(array[l], l, array)) {
                return array[l].segmentIndex;
            }
        }
        return defaultReturn;
    }
    /**
     * Method to insert a discontinuity in a provided plan at a specified position.
     * @param plan The FlightPlan to modify.
     * @param segmentIndex The segment index to insert the disco in.
     * @param segmentLegIndex The leg index to insert the disco at.
     */
    insertDiscontinuity(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segmentLegIndex === undefined) {
            segmentLegIndex = Math.max(0, segment.legs.length - 1);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if ((prevLeg && prevLeg.leg.type === LegType.Discontinuity) || (leg && leg.leg.type === LegType.Discontinuity)) {
            return;
        }
        this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), segmentLegIndex);
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the {@link LegDefinition} that was added to the plan
     */
    planAddLeg(segmentIndex, leg, index, flags = 0, notify = true) {
        const plan = this.getPlanToModify();
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        // TODO Removed the segmentIndex < dtoSegmentIndex from Garmin as it does not apply to WT21 (I think, but want to verify)
        // if (
        //   dtoSegmentIndex >= 0
        //   && (
        //     segmentIndex < dtoSegmentIndex
        //     || (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex)
        //   )
        // ) {
        //   this.removeDirectToExisting(plan.planIndex);
        // }
        if (dtoSegmentIndex >= 0
            && (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex)) {
            this.removeDirectToExisting(plan.planIndex);
        }
        const segment = plan.getSegment(segmentIndex);
        const addIndex = index !== undefined ? index : Math.max(segment.legs.length - 1, 0);
        if (segment.segmentType === FlightPlanSegmentType.Approach
            && addIndex > 0
            && BitFlags.isAll(segment.legs[addIndex - 1].flags, LegDefinitionFlags.MissedApproach)) {
            flags |= LegDefinitionFlags.MissedApproach;
        }
        const legDefinition = plan.addLeg(segmentIndex, leg, index, flags, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (activeSegmentIndex !== -1) {
            const activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (segmentIndex < activeSegmentIndex || (index && segmentIndex == activeSegmentIndex && index < activeLegIndex)) {
                const newActiveLegIndex = plan.activeLateralLeg + 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        else {
            console.error('planAddLeg: activeSegmentIndex was -1');
        }
        return legDefinition;
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove.
     * @param notify Whether or not to send notifications after the operation. True by default.
     * @param skipDupCheck Whether to skip checking for duplicates. False by default.
     * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
     * located before the direct to target. False by default.
     * @returns whether a leg was removed.
     */
    planRemoveLeg(segmentIndex, segmentLegIndex, notify = true, skipDupCheck = false, skipCancelDirectTo = false) {
        let plan = this.getPlanForFmcRender();
        if (segmentIndex < 0 || segmentIndex >= plan.segmentCount) {
            return false;
        }
        const toRemoveLeg = plan.getSegment(segmentIndex).legs[segmentLegIndex];
        if (!toRemoveLeg) {
            return false;
        }
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.getDirectToState() === DirectToState.TOEXISTING;
        plan = this.getPlanToModify();
        let removed = false;
        const airwayLegType = this.getAirwayLegType(plan, segmentIndex, segmentLegIndex);
        if (airwayLegType !== AirwayLegType.NONE) {
            removed = this.removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex);
        }
        else {
            removed = plan.removeLeg(segmentIndex, segmentLegIndex, notify) !== null;
            if (!removed) {
                return false;
            }
            const dtoLegIndex = plan.directToData.segmentLegIndex;
            const dtoSegmentIndex = plan.directToData.segmentIndex;
            if (!skipCancelDirectTo
                && dtoSegmentIndex >= 0
                && (segmentIndex < dtoSegmentIndex
                    || (segmentIndex === dtoSegmentIndex && segmentLegIndex <= dtoLegIndex))) {
                // Need to adjust direct to data to compensate for removed leg.
                if (segmentIndex === dtoSegmentIndex) {
                    plan.directToData.segmentLegIndex--;
                }
                // if (isDirectToExistingActive && segmentIndex === dtoSegmentIndex && segmentLegIndex === dtoLegIndex) {
                // Create a DTO random to replace the canceled DTO existing if we are directly removing the target leg of the DTO existing.
                //   const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg.fixIcao;
                //   this.createDirectToRandom(directIcao);
                // }
                this.removeDirectToExisting(plan.planIndex, plan.activeLateralLeg - 1);
            }
            else if (removeLegGlobalIndex < plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        const prevLeg = removeLegGlobalIndex - 1 >= 0 ? plan.getLeg(removeLegGlobalIndex - 1) : null;
        const nextLeg = removeLegGlobalIndex < plan.length ? plan.getLeg(removeLegGlobalIndex) : null;
        // Detect if we have created consecutive duplicate legs. If we have, we need to delete one of them.
        if (!skipDupCheck && prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (!skipDupCheck) {
            this.checkAndRemoveEmptySegment(plan, segmentIndex);
        }
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Method to handle a remove leg request t.
     * @param plan is the flight plan.
     * @param airwayLegType is the airwayLegType returned from the checkIfAirwayLeg method.
     * @param segmentIndex The segment we are removing from.
     * @param segmentLegIndex is the leg index in the segment we are removing.
     * @returns whether this handler processed the remove request.
     */
    removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex) {
        var _a, _b;
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        let removed = false;
        let needReconcileDto = plan.directToData.segmentIndex >= 0;
        if (segmentIndex < plan.directToData.segmentIndex
            || (segmentIndex === plan.directToData.segmentIndex && segmentLegIndex <= plan.directToData.segmentLegIndex)) {
            this.removeDirectToExisting();
            needReconcileDto = false;
        }
        switch (airwayLegType) {
            case AirwayLegType.ONROUTE: {
                const segment = plan.getSegment(segmentIndex);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex > 0) {
                    // Need to rename the airway segment with the new exit (if we removed the first leg after the entry, the
                    // airway segment will be deleted so no need to bother)
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    plan.setAirway(segmentIndex, segment.airway.replace(/\..*/, `.${segment.legs[segmentLegIndex - 1].name}`));
                }
                // We need to move the leg immediately after the removed leg to the next enroute segment
                // (if the next enroute segment does not exist we will create one)
                if (plan.segmentCount <= segmentIndex + 1 || plan.getSegment(segmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                }
                const legAfterRemoved = segment.legs[segmentLegIndex].leg;
                plan.addLeg(segmentIndex + 1, legAfterRemoved, 0);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex < segment.legs.length) {
                    // There is at least one more leg in the original airway segment after the one we moved to the next enroute
                    // segment -> move these remaining legs into a new airway segment
                    const newEntrySegment = plan.getSegment(segmentIndex + 1);
                    let newAirwaySegmentIndex = segmentIndex + 2;
                    if (newEntrySegment.legs.length > 1) {
                        // need to split the segment containing the entry leg of the new airway segment
                        newAirwaySegmentIndex = this.splitSegment(plan, segmentIndex + 1, 0);
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const airwayName = segment.airway.replace(/\..*/, `.${segment.legs[segment.legs.length - 1].name}`);
                    plan.insertSegment(newAirwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
                    while (segment.legs.length > segmentLegIndex) {
                        const leg = segment.legs[segmentLegIndex].leg;
                        plan.removeLeg(segmentIndex, segmentLegIndex);
                        plan.addLeg(newAirwaySegmentIndex, leg);
                    }
                    // If the newly added airway segment is the last enroute segment, we need to insert an empty enroute segment
                    // after it to ensure that the last enroute segment in the plan is not an airway segment
                    if (newAirwaySegmentIndex >= plan.segmentCount - 1 || plan.getSegment(newAirwaySegmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                        plan.insertSegment(newAirwaySegmentIndex + 1, FlightPlanSegmentType.Enroute);
                    }
                }
                removed = true;
                break;
            }
            case AirwayLegType.ENTRY: {
                if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Enroute) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into the previous enroute segment to serve as the new entry leg.
                    const segment = plan.getSegment(segmentIndex + 1);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 1, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 1);
                    this.planAddLeg(segmentIndex, leg);
                }
                else if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Departure) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into a newly created enroute segment placed before the airway segment to serve as the new entry leg.
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const segment = plan.getSegment(segmentIndex + 2);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 2, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 2);
                    this.planAddLeg(segmentIndex + 1, leg, 0);
                }
                removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                break;
            }
            case AirwayLegType.EXIT: {
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the airway segment, so just delete the segment.
                    this.removeAirway(segmentIndex);
                    return true;
                }
                else {
                    // Remove the leg, then change the name of the airway segment to reflect the new exit waypoint.
                    const segment = plan.getSegment(segmentIndex);
                    const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                    segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[segmentLegIndex - 1].name : segment.airway;
                    plan.setAirway(segmentIndex, segment.airway);
                    removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                }
                break;
            }
            case AirwayLegType.EXIT_ENTRY: {
                // We need to move the first leg in the next airway segment out of that segment and into an enroute segment
                // before the next airway segment.
                const segment = plan.getSegment(segmentIndex + 1);
                const leg = segment.legs[0].leg;
                plan.removeLeg(segmentIndex + 1, 0);
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the first airway segment, so just remove the segment.
                    plan.removeSegment(segmentIndex);
                    let prevSegmentIndex = segmentIndex - 1;
                    const prevSegment = plan.getSegment(prevSegmentIndex);
                    if (prevSegment.segmentType !== FlightPlanSegmentType.Enroute || prevSegment.airway !== undefined) {
                        plan.insertSegment(segmentIndex, FlightPlanSegmentType.Enroute);
                        prevSegmentIndex = segmentIndex;
                    }
                    plan.addLeg(prevSegmentIndex, leg);
                }
                else {
                    // Remove the leg from the first airway segment, then change the name of the airway segment to reflect the
                    // new exit waypoint.
                    plan.removeLeg(segmentIndex, segmentLegIndex);
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                    plan.addLeg(segmentIndex + 1, leg);
                    const firstAirwaySegment = plan.getSegment(segmentIndex);
                    const airway = (_b = firstAirwaySegment.airway) === null || _b === void 0 ? void 0 : _b.split('.');
                    firstAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + firstAirwaySegment.legs[segmentLegIndex - 1].name : firstAirwaySegment.airway;
                    plan.setAirway(segmentIndex, firstAirwaySegment.airway);
                }
                removed = true;
            }
        }
        if (removed) {
            if (needReconcileDto) {
                BoeingFmsUtils.reconcileDirectToData(plan);
            }
            if (removeLegGlobalIndex <= plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        return removed;
    }
    /**
     * Checks if a flight plan segment is empty, and removes the segment if it is eligible to be removed. Only Enroute
     * segments that are followed by another Enroute segment are eligible to be removed if empty.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment to check.
     * @returns Whether the segment was removed.
     */
    checkAndRemoveEmptySegment(plan, segmentIndex) {
        if (this.checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex)) {
            this.planRemoveSegment(segmentIndex);
            const prevSegmentIndex = segmentIndex - 1;
            const nextSegmentIndex = segmentIndex;
            const prevSegment = prevSegmentIndex >= 0 ? plan.getSegment(prevSegmentIndex) : undefined;
            const nextSegment = nextSegmentIndex < plan.segmentCount ? plan.getSegment(nextSegmentIndex) : undefined;
            if ((prevSegment === null || prevSegment === void 0 ? void 0 : prevSegment.segmentType) === FlightPlanSegmentType.Enroute
                && prevSegment.airway === undefined
                && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) === FlightPlanSegmentType.Enroute
                && nextSegment.airway === undefined) {
                // We are left with two consecutive non-airway enroute segments -> merge the two
                this.mergeSegments(plan, prevSegmentIndex);
            }
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Checks if a remove left an empty segment that also needs to be removed.
     * @param plan is the flight plan
     * @param segmentIndex The segment to add the leg to.
     * @returns whether to remove the segment.
     */
    checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        let nextSegment;
        if (segmentIndex < plan.segmentCount - 1) {
            nextSegment = plan.getSegment(segmentIndex + 1);
        }
        if (segment.legs.length < 1) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Enroute:
                    {
                        if (nextSegment && nextSegment.segmentType === FlightPlanSegmentType.Enroute) {
                            return true;
                        }
                        const priorSegment = plan.getSegment(segmentIndex - 1);
                        if (priorSegment.segmentType === FlightPlanSegmentType.Approach || priorSegment.segmentType === FlightPlanSegmentType.Arrival) {
                            return true;
                        }
                    }
                    break;
                //TODO: Add more cases as appropriate
            }
        }
        return false;
    }
    /**
     * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
     * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
     * segment.
     * @param isOrigin Whether to add an origin leg.
     * @param segmentIndex The index of the segment to which to add the leg.
     * @param airport The origin airport.
     * @param runway The origin runway.
     */
    planAddOriginDestinationLeg(isOrigin, segmentIndex, airport, runway) {
        let leg;
        if (runway) {
            leg = BoeingFmsUtils.buildRunwayLeg(airport, runway, isOrigin);
        }
        else {
            leg = FlightPlan.createLeg({
                lat: airport.lat,
                lon: airport.lon,
                type: isOrigin ? LegType.IF : LegType.TF,
                fixIcao: airport.icao,
                altitude1: airport.runways[0].elevation + UnitType.FOOT.convertTo(50, UnitType.METER)
            });
        }
        if (leg) {
            this.planAddLeg(segmentIndex, leg, isOrigin ? 0 : undefined);
            if (!isOrigin) {
                const plan = this.getPlanToModify();
                const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
                for (let i = lastEnrouteSegment.legs.length - 1; i >= 0; i--) {
                    if (lastEnrouteSegment.legs[i].leg.fixIcao === airport.icao) {
                        this.planRemoveLeg(lastEnrouteSegmentIndex, i, true, true);
                    }
                }
            }
        }
    }
    /**
     * Method to add a segment to the flightplan.
     * @param segmentType is the FlightPlanSegmentType.
     * @param index is the optional segment index to insert the segment.
     * @returns the segment index of the inserted segment.
     */
    planInsertSegmentOfType(segmentType, index) {
        const plan = this.getPlanToModify();
        let segmentIndex = -1;
        if (index) {
            segmentIndex = index - 1;
        }
        else {
            const segments = [];
            for (const segment of plan.segments()) {
                segments.push(segment);
            }
            switch (segmentType) {
                case FlightPlanSegmentType.Origin:
                    break;
                case FlightPlanSegmentType.Departure:
                    segmentIndex = 0;
                    break;
                case FlightPlanSegmentType.Arrival:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Approach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival;
                    }, 2);
                    break;
                case FlightPlanSegmentType.MissedApproach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Approach;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Destination:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach;
                    }, 5);
                    break;
                default:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach || v.segmentType === FlightPlanSegmentType.Destination;
                    }, 1);
                    segmentIndex--;
                    break;
            }
        }
        return this.planInsertSegment(segmentIndex + 1, segmentType).segmentIndex;
    }
    /**
     * Method to remove all legs from a segment.
     * @param segmentIndex is the index of the segment to delete all legs from.
     * @param segmentType is the type if segment to delete all legs from, if known.
     */
    planClearSegment(segmentIndex, segmentType) {
        this.planRemoveSegment(segmentIndex);
        this.planInsertSegment(segmentIndex, segmentType);
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    planInsertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const plan = this.getPlanToModify();
        const segment = plan.insertSegment(segmentIndex, segmentType, airway, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        if (plan.directToData.segmentIndex >= 0 && segmentIndex <= plan.directToData.segmentIndex) {
            plan.setDirectToData(plan.directToData.segmentIndex + 1, plan.directToData.segmentLegIndex);
        }
        return segment;
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    planRemoveSegment(segmentIndex, notify = true) {
        const plan = this.getPlanToModify();
        const segment = plan.getSegment(segmentIndex);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (plan.directToData.segmentIndex >= 0) {
            if (segmentIndex < plan.directToData.segmentIndex) {
                plan.setDirectToData(plan.directToData.segmentIndex - 1, plan.directToData.segmentLegIndex);
            }
            else if (segmentIndex === plan.directToData.segmentIndex) {
                plan.setDirectToData(-1);
            }
        }
        // If the segment we are trying to delete is the active one,
        // then we need to do something to preserve the active legs so they aren't deleted.
        // We only need to do this for the Enroute segment, because if other segments are getting deleted,
        // their functions are already handling this.
        if (activeSegmentIndex === segmentIndex && !Simplane.getIsGrounded() && plan.length > 1 && segment.segmentType === FlightPlanSegmentType.Enroute) {
            // I think this block of code is only supposed to run when called from the cleanupLegsAfterApproach() function
            const currentToLeg = plan.getLeg(plan.activeLateralLeg);
            const currentFromLeg = plan.getLeg(plan.activeLateralLeg - 1);
            const newToLeg = Object.assign({}, currentToLeg.leg);
            const newFromLeg = Object.assign({}, currentFromLeg.leg);
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            if (BitFlags.isAll(currentToLeg.flags, LegDefinitionFlags.DirectTo)) {
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                plan.addLeg(lastEnrouteSegmentIndex, discoLeg, undefined, LegDefinitionFlags.DirectTo);
                plan.addLeg(lastEnrouteSegmentIndex, newFromLeg, undefined, LegDefinitionFlags.DirectTo);
                plan.addLeg(lastEnrouteSegmentIndex, newToLeg, undefined, LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
            }
            else {
                plan.addLeg(lastEnrouteSegmentIndex, newFromLeg, undefined);
                plan.addLeg(lastEnrouteSegmentIndex, newToLeg, undefined);
            }
            const newSegment = plan.getSegment(lastEnrouteSegmentIndex);
            const newActiveLegIndex = newSegment.offset + newSegment.legs.length - 1;
            plan.setCalculatingLeg(newActiveLegIndex - 2);
            plan.setLateralLeg(newActiveLegIndex);
        }
        else {
            const newActiveLegIndex = plan.activeLateralLeg - Utils.Clamp(plan.activeLateralLeg - segment.offset, 0, segment.legs.length);
            plan.setCalculatingLeg(newActiveLegIndex);
            plan.setLateralLeg(newActiveLegIndex);
        }
        plan.removeSegment(segmentIndex, notify);
        plan.calculate(plan.activeLateralLeg - 1);
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
     * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
     * which is also an IF, TF, or DF leg.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is a duplicate of the first.
     */
    isDuplicateLeg(leg1, leg2) {
        if (leg1.type === LegType.Discontinuity && leg2.type === LegType.Discontinuity) {
            return true;
        }
        if (leg2.type !== LegType.IF
            && leg2.type !== LegType.DF
            && leg2.type !== LegType.TF
            && leg2.type !== LegType.CF) {
            return false;
        }
        return (leg1.type === LegType.IF
            || leg1.type === LegType.TF
            || leg1.type === LegType.DF
            || leg1.type === LegType.CF)
            && leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
     * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is an duplicate IF leg of the first.
     */
    isDuplicateIFLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF) {
            return false;
        }
        if (leg1.type !== LegType.TF
            && leg1.type !== LegType.DF
            && leg1.type !== LegType.RF
            && leg1.type !== LegType.CF
            && leg1.type !== LegType.AF
            && leg1.type !== LegType.IF) {
            return false;
        }
        return leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
     * and all other data is derived from the target leg.
     * @param target The target leg.
     * @param source The source leg.
     * @returns the merged leg.
     */
    mergeDuplicateLegData(target, source) {
        const merged = FlightPlan.createLeg(target);
        merged.fixTypeFlags |= source.fixTypeFlags;
        merged.altDesc = source.altDesc;
        merged.altitude1 = source.altitude1;
        merged.altitude2 = source.altitude2;
        merged.speedRestriction = source.speedRestriction;
        return merged;
    }
    /**
     * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
     * a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
     * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
     * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
     * @param leg1 The first duplicate leg.
     * @param leg2 The second duplicate leg.
     * @returns the leg that was deleted, or null if neither leg was deleted.
     * @throws Error if direct to legs could not be updated.
     */
    planRemoveDuplicateLeg(leg1, leg2) {
        const plan = this.getPlanToModify();
        const leg1Segment = plan.getSegmentFromLeg(leg1);
        const leg2Segment = plan.getSegmentFromLeg(leg2);
        const leg1GlobalIndex = plan.getLegIndexFromLeg(leg1);
        const leg2GlobalIndex = plan.getLegIndexFromLeg(leg2);
        if (!leg1Segment || !leg2Segment) {
            return null;
        }
        const isLeg1DirectToLeg = BitFlags.isAll(leg1.flags, LegDefinitionFlags.DirectTo);
        const isLeg2DirectToLeg = BitFlags.isAll(leg2.flags, LegDefinitionFlags.DirectTo);
        const dupDirectToLeg = isLeg1DirectToLeg ? leg1
            : isLeg2DirectToLeg ? leg2
                : null;
        if (dupDirectToLeg) {
            if (dupDirectToLeg.leg.type === LegType.IF) {
                // Technically this should never happen.
                return null;
            }
            else {
                // If one of the duplicates is the second leg in a direct to sequence, then the true duplicated leg is the
                // target leg of the DTO. In this case, we call this method with the DTO target leg replacing the DTO leg.
                const dtoTargetLeg = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                return isLeg1DirectToLeg ? this.planRemoveDuplicateLeg(dtoTargetLeg, leg2) : this.planRemoveDuplicateLeg(leg1, dtoTargetLeg);
            }
        }
        const isLeg1InProc = leg1Segment.segmentType !== FlightPlanSegmentType.Enroute;
        const isLeg2InProc = leg2Segment.segmentType !== FlightPlanSegmentType.Enroute;
        let toDeleteSegment;
        let toDeleteIndex;
        let toDeleteLeg;
        // TODO Probably shouldn't modify the LegDefinition like this,
        // TODO because events won't fire and things won't know that it changed.
        // If leg1 is in a procedure, and leg2 not, we want to delete leg1 because when reloading that procedure, it will
        // come back - unlike leg2, which is in the enroute, and would not be reloaded.
        // The opposite is true if leg1 is not, and leg2 is in a procedure.
        if (isLeg1InProc && !isLeg2InProc) {
            // Leg1 in proc + Leg2 not in proc - take data from Leg1
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1GlobalIndex - leg1Segment.offset;
            leg2.leg = this.mergeDuplicateLegData(leg2.leg, leg1.leg);
            toDeleteLeg = leg1;
        }
        else if (isLeg1InProc && isLeg2InProc) {
            // Leg1 in proc + Leg2 in proc - leave Leg2 alone
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1GlobalIndex - leg1Segment.offset;
            toDeleteLeg = leg1;
        }
        else {
            // Leg1 not in proc + Leg2 in proc - take data from Leg2
            toDeleteSegment = leg2Segment;
            toDeleteIndex = leg2GlobalIndex - leg2Segment.offset;
            leg1.leg = this.mergeDuplicateLegData(leg1.leg, leg2.leg);
            toDeleteLeg = leg2;
        }
        // If the kept leg is not in a procedure, we need to manually generate the leg vertical data, as we won't get to it when doing it for
        // the procedure segments later
        if (isLeg1InProc !== isLeg2InProc) {
            const keptLeg = toDeleteLeg === leg1 ? leg2 : leg1;
            const keptLegSegment = toDeleteLeg === leg1 ? leg2Segment : leg1Segment;
            const forceVerticalFlightPhase = (toDeleteSegment.segmentType === FlightPlanSegmentType.Departure || BitFlags.isAll(keptLeg.flags, LegDefinitionFlags.MissedApproach))
                ? VerticalFlightPhase.Climb
                : VerticalFlightPhase.Descent;
            this.generateLegVerticalData(plan, keptLegSegment.segmentIndex, (toDeleteLeg === leg1 ? leg2GlobalIndex : leg1GlobalIndex) - keptLegSegment.offset, forceVerticalFlightPhase);
        }
        if (toDeleteIndex >= 0) {
            const dtoTargetLeg = plan.directToData.segmentIndex < 0 ? null : plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
            const needMoveDtoLegs = toDeleteLeg === dtoTargetLeg;
            if (needMoveDtoLegs) {
                const isDtoExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
                // If the removed leg was the target leg of a DTO existing, we need to shift the DTO legs to target the leg
                // that was not removed.
                const oldDiscoLeg = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg1 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg2 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                if (!oldDtoLeg1 || !oldDtoLeg2 || !oldDiscoLeg) {
                    throw new Error(`Fms: Could not remove direct to legs starting at segment index ${plan.directToData.segmentIndex}, leg index ${plan.directToData.segmentLegIndex} during duplicate leg resolution.`);
                }
                const preservedLeg = toDeleteLeg === leg1 ? leg2 : leg1;
                const preservedLegIndex = plan.getLegIndexFromLeg(preservedLeg);
                const newTargetSegmentIndex = plan.getSegmentIndex(preservedLegIndex);
                const newTargetSegmentLegIndex = preservedLegIndex - plan.getSegment(newTargetSegmentIndex).offset;
                plan.setDirectToData(newTargetSegmentIndex, newTargetSegmentLegIndex);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDiscoLeg.leg), newTargetSegmentLegIndex + 1, LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg1.leg), newTargetSegmentLegIndex + 2, LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg2.leg), newTargetSegmentLegIndex + 3, LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
                if (isDtoExistingActive) {
                    plan.setLateralLeg(preservedLegIndex + 3);
                }
            }
            const success = this.planRemoveLeg(toDeleteSegment.segmentIndex, toDeleteIndex, true, false, needMoveDtoLegs);
            if (success) {
                return toDeleteLeg;
            }
        }
        return null;
    }
    /**
     * Resets the subject to force a cross-instrument notification.
     */
    forceNotifyApproachFrequency() {
        const approachFrequency = this.approachFrequency.get();
        this.approachFrequency.set(undefined);
        this.approachFrequency.set(approachFrequency);
    }
    /**
     * Sets the approach details for the loaded approach and sends an event across the bus.
     * @param approachLoaded Whether an approach is loaded.
     * @param approachType The approach type.
     * @param approachRnavType The approach RNAV type.
     * @param approachIsActive Whether the approach is active.
     * @param approachIsCircling Whether the approach is a circling approach.
     * @param approachName The name of the approach.
     * @param approachRunway The runway associated with the approach
     * @param missedApproachFacility Missed Approach Point facility for the approach
     * @param referenceFacility The reference navaid for the approach
     * @param finalApproachCourse The final approach course (-1 is invalid)
     * @todo This data is currently set with any flightplan approach edits and isn't aware of mod plan, secondary plan etc.
     * If an edit is cancelled it will retain the previously edited data. It **does not** reflect the active flightplan state.
     */
    setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling, approachName, approachRunway, missedApproachFacility, referenceFacility, finalApproachCourse) {
        // reduce the MAP facility down to the basic facility fields for syncing on the bus
        const baseMissedApproachFacility = missedApproachFacility ? BoeingFmsUtils.getBaseFacility(missedApproachFacility) : missedApproachFacility;
        const approachDetails = {
            approachLoaded: approachLoaded !== undefined ? approachLoaded : this.approachDetails.approachLoaded,
            approachType: approachType !== undefined ? approachType : this.approachDetails.approachType,
            approachRnavType: approachRnavType !== undefined ? approachRnavType : this.approachDetails.approachRnavType,
            approachIsActive: approachIsActive !== undefined ? approachIsActive : this.approachDetails.approachIsActive,
            approachIsCircling: approachIsCircling !== undefined ? approachIsCircling : this.approachDetails.approachIsCircling,
            approachName: approachName !== undefined ? approachName : this.approachDetails.approachName,
            approachRunway: approachRunway !== undefined ? approachRunway : this.approachDetails.approachRunway,
            missedApproachFacility: baseMissedApproachFacility !== undefined ? baseMissedApproachFacility : this.approachDetails.missedApproachFacility,
            referenceFacility: referenceFacility !== undefined ? referenceFacility : this.approachDetails.referenceFacility,
            finalApproachCourse: finalApproachCourse !== undefined ? finalApproachCourse : this.approachDetails.finalApproachCourse,
        };
        if (approachDetails.approachIsActive && !approachDetails.approachLoaded) {
            this.checkApproachState();
            return;
        }
        if (approachDetails !== this.approachDetails) {
            this.approachDetails = approachDetails;
            this.bus.getPublisher().pub('approach_details_set', this.approachDetails, true);
            this.bus.getPublisher().pub('approach_available', approachDetails.approachIsActive && approachDetails.approachLoaded, true);
            // this.bus.getPublisher<WT21VNavDataEvents>().pub('approach_supports_gp', this.doesApproachSupportGp(), true);
        }
    }
    /** Set edited approach details for the active flight plan (on exec) */
    syncApproachDetailsToActive() {
        this.activeApproachDetails = Object.assign({}, this.approachDetails);
        this.bus.getPublisher().pub('active_approach_details_set', this.activeApproachDetails, true);
    }
    /** Set approach details from the active flight plan (on cancel/erase of mod plan) */
    syncApproachDetailsFromActive() {
        this.approachDetails = Object.assign({}, this.activeApproachDetails);
        this.bus.getPublisher().pub('approach_details_set', this.approachDetails, true);
    }
    /**
     * Checks whether the approach details indicate that vertical guidance (GP) can be supported.
     * @returns whether or not vertical guidance is supported.
     */
    doesApproachSupportGp() {
        if (this.approachDetails.approachLoaded && this.approachDetails.approachIsActive && !this.approachDetails.approachIsCircling) {
            switch (this.approachDetails.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                case ApproachType.APPROACH_TYPE_RNAV:
                case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                    return true;
            }
        }
        return false;
    }
    /**
     * Checks if an RNAV approach can be activated in the AP.
     * @param cdiScaling The current CDI Scaling Label
     * @returns Whether approach can activate.
     */
    canApproachActivate(cdiScaling = this.cdiScaleLabel.get()) {
        const apprModeAvailable = cdiScaling === CDIScaleLabel.Terminal || cdiScaling === CDIScaleLabel.TerminalArrival || cdiScaling === CDIScaleLabel.Approach;
        return this.approachDetails.approachLoaded && apprModeAvailable;
    }
    /** Check if the tuned ILS frequency and course match the selected approach */
    checkTunedIlsMismatch() {
        var _a, _b, _c, _d;
        // we need to consider HUD takeoff as it also uses the approach reference data block
        const hudRunway = this.onGround.get() && this.operatingPhase.get() <= FmsOperatingPhase.TAKEOFF ? this.getFlightPlanHudTakeoff(BoeingFms.ACT_RTE_PLAN_INDEX) : undefined;
        if (hudRunway && hudRunway.ilsFrequency) {
            this.approachFrequencyMismatch.set(!!(hudRunway.ilsFrequency.freqMHz)
                && !BoeingFmsUtils.vhfFrequenciesEqual(hudRunway.ilsFrequency.freqMHz, (_a = this.tunedIlsFrequency) !== null && _a !== void 0 ? _a : -1));
            this.approachCourseMismatch.set(hudRunway.ilsFrequency.localizerCourse >= 0
                && Math.round(hudRunway.ilsFrequency.localizerCourse) !== Math.round((_b = this.tunedIlsCourse) !== null && _b !== void 0 ? _b : -1));
        }
        else {
            // consider approach
            this.approachFrequencyMismatch.set(!!(this.activeApproachDetails.referenceFacility)
                && !BoeingFmsUtils.vhfFrequenciesEqual(this.activeApproachDetails.referenceFacility.freqMHz, (_c = this.tunedIlsFrequency) !== null && _c !== void 0 ? _c : -1));
            this.approachCourseMismatch.set(this.activeApproachDetails.finalApproachCourse >= 0
                && Math.round(this.activeApproachDetails.finalApproachCourse) !== Math.round((_d = this.tunedIlsCourse) !== null && _d !== void 0 ? _d : -1));
        }
    }
    /**
     * Get the true course for the final approach
     * @param facility Destination airport facility
     * @param approach The approach
     */
    async getFinalApproachTrueCourse(facility, approach) {
        // the final leg is guaranteed to be CF, TF, or RF
        // the default navdata doesn't code a course on TFs (navigraph does)
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        if (finalLeg.type === LegType.CF && finalLeg.trueDegrees) {
            return finalLeg.course;
        }
        let trueCourse = MagVar.magneticToTrue(finalLeg.course, facility.lat, facility.lon);
        if (finalLeg.type === LegType.TF) {
            const finalFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.fixIcao), finalLeg.fixIcao);
            const penultimateLeg = approach.finalLegs[approach.finalLegs.length - 2];
            if (!finalFacility || !penultimateLeg) {
                return -1;
            }
            // guaranteed to be XF
            const penultimateFacility = await this.facLoader.getFacility(ICAO.getFacilityType(penultimateLeg.fixIcao), penultimateLeg.fixIcao);
            if (!penultimateFacility) {
                return -1;
            }
            const penultimatePoint = BoeingFms.geoPointCache[0].set(penultimateFacility);
            trueCourse = penultimatePoint.bearingTo(finalFacility);
        }
        else if (finalLeg.type === LegType.RF) {
            // for exactly one airport in the world... but it is legal
            const finalFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.fixIcao), finalLeg.fixIcao);
            const centreFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.arcCenterFixIcao), finalLeg.arcCenterFixIcao);
            if (!finalFacility || !centreFacility) {
                return -1;
            }
            const finalPoint = BoeingFms.geoPointCache[0].set(finalFacility);
            trueCourse = NavMath.normalizeHeading(finalPoint.bearingTo(centreFacility) + (finalLeg.turnDirection === LegTurnDirection.Left ? 90 : -90));
        }
        return trueCourse;
    }
    /**
     * Get the magnetic course for the final approach
     * @param facility Destination airport facility
     * @param approach The approach
     * @param trueCourse The true course if already calculated, else it will be calculated
     */
    async getFinalApproachCourse(facility, approach, trueCourse) {
        if (trueCourse === undefined) {
            trueCourse = await this.getFinalApproachTrueCourse(facility, approach);
        }
        // the final leg is guaranteed to be CF, TF, or RF
        // the default navdata doesn't code a course on TFs (navigraph does)
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        // use the published airport magvar for terminal legs, except VHF navaids which use station declination
        let magVar = MagVar.get(facility.lat, facility.lon);
        if (finalLeg.originIcao !== ICAO.emptyIcao && ICAO.getFacilityType(finalLeg.originIcao) === FacilityType.VOR && finalLeg.type !== LegType.TF) {
            const originFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.originIcao), finalLeg.originIcao);
            // ILS approach must use the ILS declination
            if (originFacility && originFacility.type === VorType.ILS) {
                magVar = -originFacility.magneticVariation;
            }
        }
        else if (finalLeg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(finalLeg.fixIcao) === FacilityType.VOR && finalLeg.type !== LegType.TF) {
            const fixFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.originIcao), finalLeg.originIcao);
            if (fixFacility) {
                magVar = -fixFacility.magneticVariation;
            }
        }
        return MagVar.trueToMagnetic(trueCourse, magVar);
    }
}
BoeingFms.ACT_RTE_PLAN_INDEX = 0;
BoeingFms.RTE_1_INACTIVE_PLAN_INDEX = 1;
BoeingFms.RTE_1_MOD_PLAN_INDEX = 2;
BoeingFms.RTE_2_INACTIVE_PLAN_INDEX = 3;
BoeingFms.RTE_2_MOD_PLAN_INDEX = 4;
BoeingFms.USER_DATA_KEY_ALTN = 'wtboeing.altn';
BoeingFms.USER_DATA_KEY_FIX_INFO = 'wtboeing.fix-info';
BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN = 'wtboeing.new-inactive-plan';
BoeingFms.USER_DATA_KEY_ROUTE = 'wtboeing.route';
BoeingFms.USER_DATA_KEY_VISUAL_APPROACH = 'wtboeing.visual-approach';
BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA = 'wtboeing.visual-approach-vfr-vpa';
BoeingFms.USER_DATA_KEY_HUD_TAKEOFF = 'wtboeing.hud-takeoff';
BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING = 'wtboeing.vnav-des-pending';
BoeingFms.geoPointCache = [new GeoPoint(0, 0)];

/**
 * Boeing aural alert IDs.
 */
var BoeingAuralAlertIds;
(function (BoeingAuralAlertIds) {
    // TODO Modify as needed, these are copied from the g3000
    BoeingAuralAlertIds["TawsRtc"] = "boeing-taws-rtc";
    BoeingAuralAlertIds["TawsIti"] = "boeing-taws-iti";
    BoeingAuralAlertIds["TawsRoc"] = "boeing-taws-roc";
    BoeingAuralAlertIds["TawsIoi"] = "boeing-taws-ioi";
    BoeingAuralAlertIds["TawsEdr"] = "boeing-taws-edr";
    BoeingAuralAlertIds["TawsEcr"] = "boeing-taws-ecr";
    BoeingAuralAlertIds["AutopilotDisconnect"] = "boeing-autopilot-disconnect";
    BoeingAuralAlertIds["AutopilotDisengage"] = "boeing-autopilot-disengage";
    BoeingAuralAlertIds["LandingGear"] = "boeing-landing-gear";
    BoeingAuralAlertIds["Minimums"] = "boeing-minimums";
    BoeingAuralAlertIds["CabinAltitude"] = "boeing-cabin-altitude";
    BoeingAuralAlertIds["CabinDeltaPressure"] = "boeing-cabin-delta-pressure";
    BoeingAuralAlertIds["MasterWarning"] = "boeing-master-warning";
    BoeingAuralAlertIds["TcasRA"] = "boeing-tcas-ra";
    BoeingAuralAlertIds["AutothrottleDisconnect"] = "boeing-autothrottle-disconnect";
    BoeingAuralAlertIds["AutothrottleDisengage"] = "boeing-autothrottle-disengage";
    BoeingAuralAlertIds["PfdAlert"] = "boeing-pfd-alert";
    BoeingAuralAlertIds["MasterCaution"] = "boeing-master-caution";
    BoeingAuralAlertIds["TouchdownCallout"] = "boeing-touchdown-callout";
    BoeingAuralAlertIds["TcasTA"] = "boeing-tcas-ta";
    BoeingAuralAlertIds["AltitudeAlert"] = "boeing-altitude-alert";
    BoeingAuralAlertIds["VerticalTrack"] = "boeing-vertical-track";
})(BoeingAuralAlertIds || (BoeingAuralAlertIds = {}));
/**
 * A utility class for working with Boeing aural alerts.
 */
class BoeingAuralAlertUtils {
}
/** The name of the primary Boeing aural alert queue. */
BoeingAuralAlertUtils.PRIMARY_QUEUE = 'boeing-aural-primary';
/** A map from Boeing aural alert IDs to their default priorities. */
BoeingAuralAlertUtils.PRIORITIES = {
    // TODO Modify as needed, these are copied from the g3000
    [BoeingAuralAlertIds.TawsRtc]: -10,
    [BoeingAuralAlertIds.TawsIti]: -10,
    [BoeingAuralAlertIds.TawsRoc]: -10,
    [BoeingAuralAlertIds.TawsIoi]: -10,
    [BoeingAuralAlertIds.TawsEdr]: -10,
    [BoeingAuralAlertIds.TawsEcr]: -10,
    [BoeingAuralAlertIds.AutopilotDisconnect]: -20,
    [BoeingAuralAlertIds.AutopilotDisengage]: -20,
    [BoeingAuralAlertIds.LandingGear]: -30,
    [BoeingAuralAlertIds.Minimums]: -40,
    [BoeingAuralAlertIds.CabinAltitude]: -50,
    [BoeingAuralAlertIds.CabinDeltaPressure]: -60,
    [BoeingAuralAlertIds.MasterWarning]: -70,
    [BoeingAuralAlertIds.TcasRA]: -80,
    [BoeingAuralAlertIds.AutothrottleDisconnect]: -90,
    [BoeingAuralAlertIds.AutothrottleDisengage]: -90,
    [BoeingAuralAlertIds.PfdAlert]: -100,
    [BoeingAuralAlertIds.MasterCaution]: -110,
    [BoeingAuralAlertIds.TouchdownCallout]: -120,
    [BoeingAuralAlertIds.TcasTA]: -130,
    [BoeingAuralAlertIds.AltitudeAlert]: -140,
    [BoeingAuralAlertIds.VerticalTrack]: -150
};

var BoeingInhibitStates;
(function (BoeingInhibitStates) {
    BoeingInhibitStates["EngineStopped"] = "engine-shutdown-inhibit";
    BoeingInhibitStates["EngineStarting"] = "engine-start-inhibit";
    BoeingInhibitStates["OnGroundAllShutoff"] = "on-ground-all-shutoff";
    BoeingInhibitStates["TakingOff"] = "takeoff-inhibit";
    BoeingInhibitStates["BeforeCruiseFlightPhases"] = "all-prior-cruise";
    BoeingInhibitStates["DuringAndAfterCruiseFlightPhases"] = "all-past-cruise";
    BoeingInhibitStates["BeforeTakeoff"] = "all-before-takeoff";
    BoeingInhibitStates["AfterTakeoff"] = "all-after-takeoff";
    BoeingInhibitStates["NotInCruise"] = "not-in-cruise";
})(BoeingInhibitStates || (BoeingInhibitStates = {}));

/**
 * Altitude-related CAS message IDs.
 */
var AltitudeCrewAlertIDs;
(function (AltitudeCrewAlertIDs) {
    AltitudeCrewAlertIDs["AltitudeAlert"] = "altitude-alert";
})(AltitudeCrewAlertIDs || (AltitudeCrewAlertIDs = {}));
/**
 * Manages altitude-related CAS and aural alerts.
 */
class AltitudeCrewAlerts {
    /**
     * Creates an instance of AltitudeCrewAlerts.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.auralAlertPublisher = this.bus.getPublisher();
        this.registrationManager = new CasRegistrationManager(this.bus);
        this.auralRegistrationManager = new AuralAlertRegistrationManager(this.bus);
        this.altitudeAlertState = ConsumerSubject.create(null, AltAlertState.DISABLED);
        const engStoppedAndStarting = [BoeingInhibitStates.EngineStopped, BoeingInhibitStates.EngineStarting];
        this.registrationManager.register({ uuid: AltitudeCrewAlertIDs.AltitudeAlert, message: 'ALTITUDE ALERT', inhibitedBy: engStoppedAndStarting, debounceTime: 500 });
        this.auralRegistrationManager.register({
            uuid: BoeingAuralAlertIds.AltitudeAlert,
            queue: BoeingAuralAlertUtils.PRIMARY_QUEUE,
            priority: BoeingAuralAlertUtils.PRIORITIES[BoeingAuralAlertIds.AltitudeAlert],
            // TODO This is the incorrect sound according the the FCOM and pilots, it should be the Beeper sound, but we don't have it yet
            sequence: 'tone_altitude_alert_default',
            continuous: false,
            repeat: false,
            timeout: 3000,
        });
        this.initAlerts();
    }
    /**
     * Initalizes altitude CAS and aural alerts.
     */
    initAlerts() {
        const sub = this.bus.getSubscriber();
        this.altitudeAlertState.setConsumer(sub.on('altitude_alert'));
        CasAlertTransporter.create(this.bus, AltitudeCrewAlertIDs.AltitudeAlert, AnnunciationType.Caution)
            .bind(this.altitudeAlertState, altitudeAlert => altitudeAlert === AltAlertState.DEVIATION_200);
        this.altitudeAlertState.sub(state => {
            if (state === AltAlertState.WITHIN_900) {
                this.auralAlertPublisher.pub('aural_alert_activate', BoeingAuralAlertIds.AltitudeAlert, true, false);
            }
            else {
                this.auralAlertPublisher.pub('aural_alert_deactivate', BoeingAuralAlertIds.AltitudeAlert, true, false);
            }
        }, true);
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A Boeing airspeed indicator.
 */
class AirspeedIndicator extends DisplayComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.maxSpeedRangeRef = FSComponent.createRef();
        this.minManeuverSpeedRangeRef = FSComponent.createRef();
        this.minSpeedRangeRef = FSComponent.createRef();
        this.selectedSpeedBugRef = FSComponent.createRef();
        this.vnavSpeedBandRef = FSComponent.createRef();
        this.flapSpeedBugPositions = Array.from(this.props.flapSpeedBugDataProvider.data.keys());
        this.flapSpeedBugRefs = new Map(Array.from(this.props.flapSpeedBugDataProvider.data.keys(), position => [position, FSComponent.createRef()]));
        this.vrBugRef = FSComponent.createRef();
        this.v2BugRef = FSComponent.createRef();
        this.v1BugRef = FSComponent.createRef();
        this.v1BugClampedRef = FSComponent.createRef();
        this.vrefBugRef = FSComponent.createRef();
        this.vrefBugClampedRef = FSComponent.createRef();
        this.showManeuverSpeedBands = SubscribableUtils.toSubscribable((_a = this.props.showManeuverSpeedBands) !== null && _a !== void 0 ? _a : true, true);
        this.v1Setting = this.props.vSpeedSettings.getSettings(VSpeedType.V1).value;
        this.vrSetting = this.props.vSpeedSettings.getSettings(VSpeedType.Vr).value;
        this.v2Setting = this.props.vSpeedSettings.getSettings(VSpeedType.V2).value;
        this.vrefSetting = this.props.vSpeedSettings.getSettings(VSpeedType.Vref).value;
        this.pixelPerKnot = this.props.windowHeight / AirspeedIndicator.WINDOW_IAS;
        this.v1BugPositionClamp = this.props.v1BugPositionClamp / this.props.windowHeight;
        this.vrefBugPositionClamp = this.props.vrefBugPositionClamp / this.props.windowHeight;
        this.tapeTickCount = AirspeedIndicator.WINDOW_IAS * 2 / AirspeedIndicator.TAPE_TICK_INTERVAL + 1;
        this.tapeCenterTickOffset = Math.floor(this.tapeTickCount / 2);
        this.tapeTickSpeeds = ArrayUtils.create(this.tapeTickCount, index => Subject.create((index - this.tapeCenterTickOffset) * AirspeedIndicator.TAPE_TICK_INTERVAL, SubscribableUtils.NUMERIC_NAN_EQUALITY));
        this.tapeCenterIas = 0;
        this.tapeScrolledIas = 0;
        this.tapeTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', '%', 'px'));
        this.trendVectorScaleTransform = CssTransformSubject.create(CssTransformBuilder.scaleY());
        this.trendVectorTranslateTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.isTrendVectorHidden = Subject.create(false);
        this.truncateVrLabel = MappedSubject.create(([v1, vr, v2]) => vr > 50 && ((v1 > 50 && Math.abs(vr - v1) <= 4) || (v2 > 50 && Math.abs(vr - v2) <= 4)), this.v1Setting, this.vrSetting, this.v2Setting).pause();
        this.v1ReadoutHidden = Subject.create(false);
        this.v1ReadoutText = Subject.create('');
        this.vrefReadoutHidden = Subject.create(false);
        this.vrefReadoutText = Subject.create('');
        this.isRadioAltAbove100 = this.props.dataProvider.radioAltitude.map((alt, previousVal) => alt >= (previousVal ? 90 : 110)).pause();
        this.isSpeedBelowMinManeuver = MappedSubject.create(([ias, minManeuverIas]) => minManeuverIas !== null && ias < minManeuverIas, this.props.dataProvider.ias, this.props.dataProvider.minimumManeuveringIas).pause();
        this.scrollerIas = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.isReadoutAlertActive = Subject.create(false);
        this.isPaused = true;
        this.pauseableSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.resume();
        this.readoutAlertPipe = this.isSpeedBelowMinManeuver.pipe(this.isReadoutAlertActive, true);
        const updateMinimumManeuveringSpeed = this.updateMinimumManeuveringSpeed.bind(this);
        const updateVNavSpeedBand = this.updateVNavSpeedBand.bind(this);
        this.pauseableSubs.push(this.props.dataProvider.ias.sub(this.updateIas.bind(this), true, this.isPaused), this.props.dataProvider.maximumIas.sub(this.updateMaximumSpeed.bind(this), false, this.isPaused), this.props.dataProvider.minimumManeuveringIas.sub(updateMinimumManeuveringSpeed, false, this.isPaused), this.props.dataProvider.minimumIas.sub(this.updateMinimumSpeed.bind(this), false, this.isPaused), this.showManeuverSpeedBands.sub(updateMinimumManeuveringSpeed, false, this.isPaused), this.props.dataProvider.iasTrend.sub(this.onTrendChanged.bind(this), this.isPaused), this.isRadioAltAbove100.sub(this.onRadioAltAbove100Changed.bind(this), true, this.isPaused), this.props.flapRetractionDataProvider.isFirstFlapRetractionStarted.sub(this.updateMinimumManeuveringSpeedVisibility.bind(this), false, this.isPaused), this.props.dataProvider.selectedSpeedIas.sub(this.updateSelectedSpeedBug.bind(this), false, this.isPaused), this.props.vnavSpeedBandDataProvider.minimumIas.sub(updateVNavSpeedBand, false, this.isPaused), this.props.vnavSpeedBandDataProvider.maximumIas.sub(updateVNavSpeedBand, false, this.isPaused), ...Array.from(this.props.flapSpeedBugDataProvider.data, ([position, data]) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return data.maneuverIas.sub(this.updateFlapSpeedBug.bind(this, this.flapSpeedBugRefs.get(position), data), true, this.isPaused);
        }), this.vrSetting.sub(this.updateVSpeedBug.bind(this, this.vrBugRef, this.vrSetting), false, this.isPaused), this.v2Setting.sub(this.updateVSpeedBug.bind(this, this.v2BugRef, this.v2Setting), false, this.isPaused), this.v1Setting.sub(this.onV1Changed.bind(this), false, this.isPaused), this.vrefSetting.sub(this.onVrefChanged.bind(this), false, this.isPaused), this.v1Setting.pipe(this.v1ReadoutText, value => value.toFixed(0), this.isPaused), this.props.performancePlan.approachFlapSpeed.pipe(this.vrefReadoutText, data => {
            var _a;
            if (data === null) {
                return '';
            }
            return `${((_a = data[0]) !== null && _a !== void 0 ? _a : 0).toFixed(0)}/${data[1].toFixed(0)}`;
        }, this.isPaused));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.truncateVrLabel.resume();
        this.isRadioAltAbove100.resume();
        for (const sub of this.pauseableSubs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        var _a;
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.truncateVrLabel.pause();
        this.isRadioAltAbove100.pause();
        this.isSpeedBelowMinManeuver.pause();
        for (const sub of this.pauseableSubs) {
            sub.pause();
        }
        (_a = this.readoutAlertPipe) === null || _a === void 0 ? void 0 : _a.pause();
    }
    /**
     * Gets the position of an indicated airspeed on this indicator's tape window, with `0` at the top of the window and
     * `1` at the bottom.
     * @param ias An indicated airspeed, in knots.
     * @returns The position of the specified indicated airspeed on this indicator's tape window, with `0` at the top of
     * the window and `1` at the bottom.
     */
    getTapeWindowPosition(ias) {
        return 0.5 - (ias - this.tapeScrolledIas) / AirspeedIndicator.WINDOW_IAS;
    }
    /**
     * A callback called when the IAS updates from the event bus.
     * @param ias The current IAS value.
     */
    updateIas(ias) {
        const clampedIas = MathUtils.clamp(ias, 30, 999);
        this.scrollerIas.set(clampedIas);
        let tapeTranslation = (clampedIas - this.tapeCenterIas) / (AirspeedIndicator.WINDOW_IAS * 2) * 100;
        if (Math.abs(tapeTranslation) > 25) {
            // We need to reset the tape's center altitude such that the tape translation is back within +/-25%.
            this.tapeCenterIas = MathUtils.round(clampedIas, 100);
            for (let i = 0; i < this.tapeTickSpeeds.length; i++) {
                this.tapeTickSpeeds[i].set((i - this.tapeCenterTickOffset) * AirspeedIndicator.TAPE_TICK_INTERVAL + this.tapeCenterIas);
            }
            tapeTranslation = (clampedIas - this.tapeCenterIas) / (AirspeedIndicator.WINDOW_IAS * 2) * 100;
        }
        this.tapeTransform.transform.set(0, tapeTranslation, 0, undefined, 0.02);
        this.tapeTransform.resolve();
        this.tapeScrolledIas = clampedIas;
        this.updateAllBugsAndRanges();
    }
    /**
     * Responds to when the airspeed trend changes.
     * @param trend The new airspeed trend, in knots.
     */
    onTrendChanged(trend) {
        const absoluteTrend = Math.abs(trend);
        if (absoluteTrend > 5) {
            this.trendVectorScaleTransform.transform.set(trend < 0 ? -1 : 1);
            this.trendVectorScaleTransform.resolve();
            this.trendVectorTranslateTransform.transform.set(0, -this.pixelPerKnot * Math.min(absoluteTrend, AirspeedIndicator.HALF_WINDOW_IAS * 1.5), 0, undefined, 0.1);
            this.trendVectorTranslateTransform.resolve();
            this.isTrendVectorHidden.set(false);
        }
        else {
            this.isTrendVectorHidden.set(true);
        }
    }
    /**
     * A method called to update all bugs and ranges on the tape.
     */
    updateAllBugsAndRanges() {
        this.updateMaximumSpeed();
        this.updateMinimumManeuveringSpeed();
        this.updateMinimumSpeed();
        this.updateSelectedSpeedBug();
        this.updateVNavSpeedBand();
        for (let i = 0; i < this.flapSpeedBugPositions.length; i++) {
            const position = this.flapSpeedBugPositions[i];
            this.updateFlapSpeedBug(this.flapSpeedBugRefs.get(position), this.props.flapSpeedBugDataProvider.data.get(position));
        }
        this.updateAllVSpeedBugs();
    }
    /**
     * Updates this indicator's displayed maximum speed.
     */
    updateMaximumSpeed() {
        this.maxSpeedRangeRef.instance.updatePosition(this.getTapeWindowPosition(this.props.dataProvider.maximumIas.get()));
    }
    /**
     * Updates this indicator's displayed minimum maneuvering speed.
     */
    updateMinimumManeuveringSpeed() {
        let position;
        if (this.showManeuverSpeedBands.get()) {
            const ias = this.props.dataProvider.minimumManeuveringIas.get();
            position = ias === null ? 2 : this.getTapeWindowPosition(ias);
        }
        else {
            position = 2;
        }
        this.minManeuverSpeedRangeRef.instance.updatePosition(position);
    }
    /**
     * Updates this indicator's displayed minimum speed.
     */
    updateMinimumSpeed() {
        const ias = this.props.dataProvider.minimumIas.get();
        this.minSpeedRangeRef.instance.updatePosition(ias === null ? 2 : this.getTapeWindowPosition(ias));
    }
    /**
     * Updates the visibility of this indicator's maximum speed range.
     */
    updateMaximumSpeedVisibility() {
        this.maxSpeedRangeRef.instance.setIsVisible(this.isRadioAltAbove100.get());
    }
    /**
     * Updates the visibility of this indicator's minimum maneuvering speed range.
     */
    updateMinimumManeuveringSpeedVisibility() {
        this.minManeuverSpeedRangeRef.instance.setIsVisible(this.isRadioAltAbove100.get() && this.props.flapRetractionDataProvider.isFirstFlapRetractionStarted.get());
    }
    /**
     * Updates the visibility of this indicator's minimum speed range.
     */
    updateMinimumSpeedVisibility() {
        this.minSpeedRangeRef.instance.setIsVisible(this.isRadioAltAbove100.get());
    }
    /**
     * Updates the visibility of all of this indicator's speed ranges.
     */
    updateAllSpeedRangeVisibilities() {
        this.updateMaximumSpeedVisibility();
        this.updateMinimumManeuveringSpeedVisibility();
        this.updateMinimumSpeedVisibility();
    }
    /**
     * Updates the visibility and position of this indicator's selected speed bug.
     */
    updateSelectedSpeedBug() {
        const ias = this.props.dataProvider.selectedSpeedIas.get();
        if (ias === null) {
            this.selectedSpeedBugRef.instance.setIsVisible(false);
        }
        else {
            this.selectedSpeedBugRef.instance.setIsVisible(true);
            this.selectedSpeedBugRef.instance.updatePosition(this.getTapeWindowPosition(ias));
        }
    }
    /**
     * Updates the visibility and position of this indicator's VNAV speed band.
     */
    updateVNavSpeedBand() {
        const minIas = this.props.vnavSpeedBandDataProvider.minimumIas.get();
        const maxIas = this.props.vnavSpeedBandDataProvider.maximumIas.get();
        if (minIas === null || maxIas === null) {
            this.vnavSpeedBandRef.instance.setIsVisible(false);
        }
        else {
            this.vnavSpeedBandRef.instance.setIsVisible(true);
            this.vnavSpeedBandRef.instance.updatePosition(this.getTapeWindowPosition(minIas), this.getTapeWindowPosition(maxIas));
        }
    }
    /**
     * Updates the visibility and position of a flap maneuver speed bug.
     * @param ref A reference to the speed bug to update.
     * @param data Data describing the speed bug to update.
     */
    updateFlapSpeedBug(ref, data) {
        const ias = data.maneuverIas.get();
        if (ias === null) {
            ref.instance.setIsVisible(false);
        }
        else {
            ref.instance.setIsVisible(true);
            ref.instance.updatePosition(this.getTapeWindowPosition(ias));
        }
    }
    /**
     * Updates the visibility and positions of all V-speed bugs.
     */
    updateAllVSpeedBugs() {
        this.updateVSpeedBug(this.vrBugRef, this.props.vSpeedSettings.getSettings(VSpeedType.Vr).value);
        this.updateVSpeedBug(this.v2BugRef, this.props.vSpeedSettings.getSettings(VSpeedType.V2).value);
        this.updateVSpeedBug(this.v1BugRef, this.props.vSpeedSettings.getSettings(VSpeedType.V1).value);
        this.updateVSpeedBug(this.v1BugClampedRef, this.props.vSpeedSettings.getSettings(VSpeedType.V1).value);
        this.updateVSpeedBug(this.vrefBugRef, this.props.vSpeedSettings.getSettings(VSpeedType.Vref).value);
        this.updateVSpeedBug(this.vrefBugClampedRef, this.props.vSpeedSettings.getSettings(VSpeedType.Vref).value);
        this.updateVSpeedReadoutVisibility(this.v1ReadoutHidden, this.v1Setting, -Infinity, this.v1BugPositionClamp);
        this.updateVSpeedReadoutVisibility(this.vrefReadoutHidden, this.vrefSetting, -Infinity, Infinity);
    }
    /**
     * Updates the visibility and position of a V-speed bug.
     * @param ref A reference to the speed bug to update.
     * @param setting The user setting that controls the value of the bug's V-speed.
     */
    updateVSpeedBug(ref, setting) {
        const ias = setting.value;
        if (ias <= 50) {
            ref.instance.setIsVisible(false);
        }
        else {
            ref.instance.setIsVisible(true);
            ref.instance.updatePosition(this.getTapeWindowPosition(ias));
        }
    }
    /**
     * Updates the visibility of a V-speed readout.
     * @param isHidden The subject that controls whether the readout is hidden.
     * @param setting The user setting that controls the value of the V-speed.
     * @param minPosition A minimum position limit on this indicator's tape window, with `0` at the top and `1` at the
     * bottom, such that the readout is displayed if the corresponding V-speed bug is positioned within the limit.
     * @param maxPosition A maximum position limit on this indicator's tape window, with `0` at the top and `1` at the
     * bottom, such that the readout is displayed if the corresponding V-speed bug is positioned within the limit.
     */
    updateVSpeedReadoutVisibility(isHidden, setting, minPosition, maxPosition) {
        const ias = setting.value;
        if (ias <= 50) {
            isHidden.set(true);
        }
        else {
            const position = this.getTapeWindowPosition(ias);
            isHidden.set(position < minPosition || position > maxPosition);
        }
    }
    /**
     * Responds to when whether the airplane's radio altitude is above 100 feet changes.
     * @param isAbove100 Whether the airplane's radio altitude is above 100 feet.
     */
    onRadioAltAbove100Changed(isAbove100) {
        this.updateAllSpeedRangeVisibilities();
        if (isAbove100) {
            this.isSpeedBelowMinManeuver.resume();
            this.readoutAlertPipe.resume(true);
        }
        else {
            this.isSpeedBelowMinManeuver.pause();
            this.readoutAlertPipe.pause();
            this.isReadoutAlertActive.set(false);
        }
    }
    /**
     * Responds to when the V1 speed value changes.
     */
    onV1Changed() {
        this.updateVSpeedBug(this.v1BugRef, this.v1Setting);
        this.updateVSpeedBug(this.v1BugClampedRef, this.v1Setting);
        this.updateVSpeedReadoutVisibility(this.v1ReadoutHidden, this.v1Setting, -Infinity, this.v1BugPositionClamp);
    }
    /**
     * Responds to when the Vref speed value changes.
     */
    onVrefChanged() {
        this.updateVSpeedBug(this.vrefBugRef, this.vrefSetting);
        this.updateVSpeedBug(this.vrefBugClampedRef, this.vrefSetting);
        this.updateVSpeedReadoutVisibility(this.vrefReadoutHidden, this.vrefSetting, -Infinity, Infinity);
    }
    /** @inheritdoc */
    render() {
        const zipperUnitHeight = Math.round(this.pixelPerKnot * 2.5) * 2;
        return (FSComponent.buildComponent("div", { class: "airspeed-box" },
            FSComponent.buildComponent("div", { class: "airspeed", style: `position: absolute; top: 0px; height: ${this.props.windowHeight}px;` },
                FSComponent.buildComponent("div", { class: "airspeed-mask", style: "position: absolute; top: 0px; height: 100%; overflow: hidden;" },
                    FSComponent.buildComponent("div", { class: "airspeed-tape", style: {
                            'position': 'absolute',
                            'top': '-50%',
                            'height': `${this.props.windowHeight * 2}px`,
                            'transform': this.tapeTransform
                        } },
                        FSComponent.buildComponent("div", { class: "airspeed-tape-tick-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAirspeedTapeTicks()),
                        FSComponent.buildComponent("div", { class: "airspeed-tape-label-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAirspeedTapeLabels())),
                    FSComponent.buildComponent(SpeedRange, { ref: this.maxSpeedRangeRef, type: "max", tapeWindowHeight: this.props.windowHeight, repeatingHeight: zipperUnitHeight, class: "airspeed-range-container-max" }),
                    FSComponent.buildComponent(SpeedRange, { ref: this.minManeuverSpeedRangeRef, type: "min", tapeWindowHeight: this.props.windowHeight, class: "airspeed-range-container-min-maneuver" }),
                    FSComponent.buildComponent(SpeedRange, { ref: this.minSpeedRangeRef, type: "min", tapeWindowHeight: this.props.windowHeight, repeatingHeight: zipperUnitHeight, class: "airspeed-range-container-min" }),
                    FSComponent.buildComponent("div", { class: {
                            'airspeed-trend-vector': true,
                            'hidden': this.isTrendVectorHidden,
                        }, style: {
                            'position': 'absolute',
                            'bottom': '50%',
                            'height': '50%',
                            'overflow': 'hidden',
                            'transform': this.trendVectorScaleTransform,
                            'transform-origin': '50% 100%'
                        } },
                        FSComponent.buildComponent("div", { style: { 'position': 'absolute', 'left': '0px', 'top': '100%', 'width': '100%', 'height': '150%', 'transform': this.trendVectorTranslateTransform } },
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-stem shadow", style: "position: absolute; bottom: 0px;" },
                                FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "airspeed-trend-vector-stroke" })),
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-pointer shadow", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                                FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "airspeed-trend-vector-stroke" })),
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-stem", style: "position: absolute; bottom: 0px;" },
                                FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "airspeed-trend-vector-stroke" })),
                            FSComponent.buildComponent("svg", { class: "airspeed-trend-vector-svg airspeed-trend-vector-pointer", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                                FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "airspeed-trend-vector-stroke" })))),
                    FSComponent.buildComponent(SpeedBug, { ref: this.selectedSpeedBugRef, tapeWindowHeight: this.props.windowHeight, clamp: true, class: "airspeed-bug-selected" },
                        FSComponent.buildComponent("svg", { viewBox: "0 -14 56 28", preserveAspectRatio: "none", class: "airspeed-bug-selected-symbol", style: "overflow: visible;" },
                            FSComponent.buildComponent("path", { d: "M 0 0 L 22 -14 l 34 0 l 0 28 l -34 0 z", class: "airspeed-bug-selected-stroke shadow" }),
                            FSComponent.buildComponent("path", { d: "M 0 0 L 22 -14 l 34 0 l 0 28 l -34 0 z", class: "airspeed-bug-selected-stroke" }))),
                    FSComponent.buildComponent(VNavSpeedBand, { ref: this.vnavSpeedBandRef, tapeWindowHeight: this.props.windowHeight }),
                    Array.from(this.flapSpeedBugRefs).map(([position, ref]) => {
                        return (FSComponent.buildComponent(TickLabelSpeedBug, { ref: ref, tapeWindowHeight: this.props.windowHeight, tick: true, label: position === 0 ? 'UP' : position.toString().padStart(2, ' '), class: "airspeed-bug-flap" }));
                    }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.vrBugRef, tapeWindowHeight: this.props.windowHeight, tick: true, label: this.truncateVrLabel.map(truncate => truncate ? '  R' : 'VR'), class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.v2BugRef, tapeWindowHeight: this.props.windowHeight, tick: true, label: "V2", class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.v1BugRef, tapeWindowHeight: this.props.windowHeight, tick: true, class: "airspeed-bug-vspeed airspeed-bug-vspeed-large" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.v1BugClampedRef, tapeWindowHeight: this.props.windowHeight, label: "V1", clamp: Vec2Math.create(this.v1BugPositionClamp, Infinity), class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent("div", { class: { 'airspeed-vspeed-readout': true, 'airspeed-v1-readout': true, 'hidden': this.v1ReadoutHidden } }, this.v1ReadoutText),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.vrefBugRef, tapeWindowHeight: this.props.windowHeight, tick: true, class: "airspeed-bug-vspeed airspeed-bug-vspeed-large" }),
                    FSComponent.buildComponent(TickLabelSpeedBug, { ref: this.vrefBugClampedRef, tapeWindowHeight: this.props.windowHeight, label: "REF", clamp: Vec2Math.create(-Infinity, this.vrefBugPositionClamp), class: "airspeed-bug-vspeed" }),
                    FSComponent.buildComponent("div", { class: { 'airspeed-vspeed-readout': true, 'airspeed-vref-readout': true, 'hidden': this.vrefReadoutHidden } }, this.vrefReadoutText)),
                FSComponent.buildComponent("div", { class: "airspeed-readout" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 103 96", preserveAspectRatio: "none", "stroke-linejoin": "round", class: { 'airspeed-readout-box': true, 'warning': this.isReadoutAlertActive }, style: "overflow: visible;" },
                        FSComponent.buildComponent("path", { class: "airspeed-readout-box-border shadow", d: "M 0 0 l 86 0 l 0 33 l 17 15 l -17 15 l 0 33 l -86 0 z" }),
                        FSComponent.buildComponent("path", { class: "airspeed-readout-box-border", d: "M 0 0 l 86 0 l 0 33 l 17 15 l -17 15 l 0 33 l -86 0 z" })),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerIas, base: 10, factor: 100, scrollThreshold: 99, renderDigit: digit => digit === 0 ? ' ' : (Math.abs(digit) % 10).toString(), nanString: '-', class: 'airspeed-digit-scroller airspeed-hundreds-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerIas, base: 10, factor: 10, scrollThreshold: 9, nanString: '-', class: 'airspeed-digit-scroller airspeed-tens-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerIas, base: 10, factor: 1, nanString: '-', class: 'airspeed-digit-scroller airspeed-ones-scroller' })))));
    }
    /**
     * Builds the tick marks on the airspeed tape.
     * @returns The tick marks on the airspeed tape, as an array of VNodes.
     */
    buildAirspeedTapeTicks() {
        const tickIntervalPx = AirspeedIndicator.TAPE_TICK_INTERVAL * this.pixelPerKnot;
        const isHiddenMap = (ias) => ias < 30 || ias > 999;
        const isMajorMap = (ias) => ias % 20 === 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const ias = this.tapeTickSpeeds[index];
            const y = (this.tapeTickCount - index - 1) * tickIntervalPx;
            return (FSComponent.buildComponent("div", { class: {
                    'airspeed-tape-tick': true,
                    'airspeed-tape-tick-major': ias.map(isMajorMap),
                    'hidden': ias.map(isHiddenMap)
                }, style: `position: absolute; top: ${y}px; transform: translateY(-50%);` }));
        });
    }
    /**
     * Builds the labels on the airspeed tape.
     * @returns The labels on the airspeed tape, as an array of VNodes.
     */
    buildAirspeedTapeLabels() {
        const labelIntervalPx = AirspeedIndicator.TAPE_TICK_INTERVAL * this.pixelPerKnot;
        const isHiddenMap = (ias) => ias < 30 || ias > 999 || ias % 20 !== 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const ias = this.tapeTickSpeeds[index];
            const y = (this.tapeTickCount - index - 1) * labelIntervalPx;
            return (FSComponent.buildComponent("div", { class: {
                    'airspeed-tape-label': true,
                    'hidden': ias.map(isHiddenMap)
                }, style: `position: absolute; right: 0%; top: ${y}px; transform: translateY(-50%)` }, ias));
        });
    }
}
/** The airspeed indicator tape window's IAS range, in knots. */
AirspeedIndicator.WINDOW_IAS = 120;
AirspeedIndicator.HALF_WINDOW_IAS = AirspeedIndicator.WINDOW_IAS / 2;
/** The IAS interval between each airspeed indicator tape tick, in knots. */
AirspeedIndicator.TAPE_TICK_INTERVAL = 10;
/**
 * An airspeed indicator speed range.
 */
class SpeedRange extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.repeatingHeight = this.props.repeatingHeight !== undefined && this.props.repeatingHeight > 0
            ? Math.ceil(this.props.tapeWindowHeight / this.props.repeatingHeight) * this.props.repeatingHeight
            : this.props.tapeWindowHeight;
        this.height = this.repeatingHeight * 2;
        this.repeatingHeightRelative = this.repeatingHeight / this.props.tapeWindowHeight;
        this.heightRelative = this.repeatingHeightRelative * 2;
        this.getTranslateMethod = this.props.type === 'min'
            ? 'getTranslateMin'
            : 'getTranslateMax';
        this.transform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', 'px', 'px'));
        this.hidden = Subject.create(false);
    }
    /**
     * Sets this range's visibility.
     * @param visible The range visibility.
     */
    setIsVisible(visible) {
        this.hidden.set(!visible);
    }
    /**
     * Updates this speed range's position.
     * @param iasPosition The position of this speed range's reference airspeed on its parent indicator's tape window,
     * with `0` at the top of the window and `1` at the bottom.
     */
    updatePosition(iasPosition) {
        this.transform.transform.set(0, this[this.getTranslateMethod](iasPosition), 0, undefined, 0.1);
        this.transform.resolve();
    }
    /**
     * Gets the y-translation, in pixels, required to place this minimum speed range at a given position on its parent
     * indicator's tape window.
     * @param iasPosition A position on this speed range's parent indicator's tape window, with `0` at the top of the
     * window and `1` at the bottom.
     * @returns The y-translation, in pixels, required to place this minimum speed range at a given position on its
     * parent indicator's tape window.
     */
    getTranslateMin(iasPosition) {
        if (iasPosition >= 1.1) {
            return 1.1 * this.props.tapeWindowHeight;
        }
        else if (iasPosition > 1 - this.heightRelative) {
            return iasPosition * this.props.tapeWindowHeight;
        }
        else {
            return ((iasPosition - (1 - this.repeatingHeightRelative)) % this.repeatingHeightRelative + 1 - this.repeatingHeightRelative) * this.props.tapeWindowHeight;
        }
    }
    /**
     * Gets the y-translation, in pixels, required to place this maximum speed range at a given position on its parent
     * indicator's tape window.
     * @param iasPosition A position on this speed range's parent indicator's tape window, with `0` at the top of the
     * window and `1` at the bottom.
     * @returns The y-translation, in pixels, required to place this maximum speed range at a given position on its
     * parent indicator's tape window.
     */
    getTranslateMax(iasPosition) {
        if (iasPosition <= -0.1) {
            return -0.1 * this.props.tapeWindowHeight;
        }
        else if (iasPosition < this.heightRelative) {
            return iasPosition * this.props.tapeWindowHeight;
        }
        else {
            return ((iasPosition - this.repeatingHeightRelative) % this.repeatingHeightRelative + this.repeatingHeightRelative) * this.props.tapeWindowHeight;
        }
    }
    /** @inheritdoc */
    render() {
        const cssClasses = {
            'airspeed-range-container': true,
            'hidden': this.hidden
        };
        const classesToAdd = this.props.class
            ? FSComponent.parseCssClassesFromString(this.props.class, classToAdd => classToAdd !== 'airspeed-range-container' && classToAdd !== 'hidden')
            : undefined;
        if (classesToAdd) {
            for (const classToAdd of classesToAdd) {
                cssClasses[classToAdd] = true;
            }
        }
        return (FSComponent.buildComponent("div", { class: cssClasses, style: {
                'position': 'absolute',
                'top': this.props.type === 'max' ? `${-this.height}px` : '0px',
                'height': `${this.height}px`,
                'transform': this.transform
            } },
            FSComponent.buildComponent("div", { class: "airspeed-range shadow" }),
            FSComponent.buildComponent("div", { class: "airspeed-range" })));
    }
}
/**
 * A speed bug for the airspeed indicator.
 */
class SpeedBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.clamp = this.props.clamp
            ? this.props.clamp === true ? Vec2Math.create(0, 1) : this.props.clamp
            : undefined;
        this.transform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', 'px', 'px'));
        this.isVisible = Subject.create(true);
        this.isInBounds = Subject.create(false);
        this.hidden = MappedSubject.create(([visible, inBounds]) => !visible || !inBounds, this.isVisible, this.isInBounds);
    }
    /**
     * Sets this bug's visibility.
     * @param visible The bug visibility.
     */
    setIsVisible(visible) {
        this.isVisible.set(visible);
    }
    /**
     * Updates this bug's position.
     * @param iasPosition The position of this bug's reference airspeed on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     */
    updatePosition(iasPosition) {
        if (this.clamp) {
            iasPosition = MathUtils.clamp(iasPosition, this.clamp[0], this.clamp[1]);
        }
        this.isInBounds.set(iasPosition >= -0.1 && iasPosition <= 1.1);
        this.transform.transform.set(0, MathUtils.clamp(iasPosition, -0.1, 1.1) * this.props.tapeWindowHeight, 0, undefined, 0.1);
        this.transform.resolve();
    }
    /** @inheritdoc */
    render() {
        const cssClasses = {
            'airspeed-bug': true,
            'hidden': this.hidden
        };
        const classesToAdd = this.props.class
            ? FSComponent.parseCssClassesFromString(this.props.class, classToAdd => classToAdd !== 'airspeed-bug' && classToAdd !== 'hidden')
            : undefined;
        if (classesToAdd) {
            for (const classToAdd of classesToAdd) {
                cssClasses[classToAdd] = true;
            }
        }
        return (FSComponent.buildComponent("div", { class: cssClasses, style: {
                'position': 'absolute',
                'top': '0px',
                'transform': this.transform
            } }, this.props.children));
    }
}
/**
 * An airspeed indicator speed bug which renders an optional tick and label.
 */
class TickLabelSpeedBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.label = SubscribableUtils.isSubscribable(this.props.label)
            ? this.props.label.map(SubscribableMapFunctions.identity())
            : this.props.label;
    }
    /**
     * Sets this bug's visibility.
     * @param visible The bug visibility.
     */
    setIsVisible(visible) {
        this.ref.instance.setIsVisible(visible);
    }
    /**
     * Updates this bug's position.
     * @param iasPosition The position of this bug's reference airspeed on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     */
    updatePosition(iasPosition) {
        this.ref.instance.updatePosition(iasPosition);
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(SpeedBug, { ref: this.ref, tapeWindowHeight: this.props.tapeWindowHeight, clamp: this.props.clamp, class: `airspeed-bug-ticklabel ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}` },
            this.props.tick && (FSComponent.buildComponent("div", { class: "airspeed-bug-ticklabel-tick" })),
            this.label && (FSComponent.buildComponent("div", { class: "airspeed-bug-ticklabel-label" }, this.label))));
    }
}
/**
 * A VNAV speed band for the airspeed indicator.
 */
class VNavSpeedBand extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.transform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px', 'px', 'px'), CssTransformBuilder.translateY('%')));
        this.height = Subject.create(0);
        this.isVisible = Subject.create(true);
        this.isInBounds = Subject.create(false);
        this.hidden = MappedSubject.create(([visible, inBounds]) => !visible || !inBounds, this.isVisible, this.isInBounds);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.transform.transform.getChild(1).set(-50);
        this.transform.resolve();
    }
    /**
     * Sets this band's visibility.
     * @param visible The band visibility.
     */
    setIsVisible(visible) {
        this.isVisible.set(visible);
    }
    /**
     * Updates this band's position.
     * @param minPosition The position of this band's lower limit on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     * @param maxPosition The position of this band's upper limit on its parent indicator's tape window, with `0`
     * at the top of the window and `1` at the bottom.
     */
    updatePosition(minPosition, maxPosition) {
        const isInBounds = minPosition > maxPosition && minPosition > -0.1 && maxPosition < 1.1;
        if (isInBounds) {
            this.isInBounds.set(true);
            const mid = (minPosition + maxPosition) / 2 * this.props.tapeWindowHeight;
            const height = (minPosition - maxPosition) * this.props.tapeWindowHeight;
            this.transform.transform.getChild(0).set(0, mid, 0, undefined, 0.1);
            this.transform.resolve();
            this.height.set(Math.round(height));
        }
        else {
            this.isInBounds.set(false);
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'airspeed-vnav-speed-band': true,
                'hidden': this.hidden
            }, style: {
                'position': 'absolute',
                'top': '0px',
                'height': this.height.map(height => `${height}px`),
                'transform': this.transform
            } },
            FSComponent.buildComponent("div", { class: "airspeed-vnav-speed-band-stroke shadow" }),
            FSComponent.buildComponent("div", { class: "airspeed-vnav-speed-band-stroke" })));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link AirspeedIndicatorDataProvider}.
 */
class DefaultAirspeedIndicatorDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param iasTrendBounds The boundaries, as `[min, max]` in knots, to which indicated airspeed is clamped when
     * calculating the indicated airspeed trend. Defaults to `[30, 999]`.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, index, iasTrendBounds = Vec2Math.create(30, 999), useSelector = false) {
        this.bus = bus;
        this.iasTrendBounds = iasTrendBounds;
        this.useSelector = useSelector;
        this._ias = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.ias = this._ias;
        this._mach = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.mach = this._mach;
        this.machToKiasFactorSource = ConsumerValue.create(null, 0).pause();
        this.machToKiasFactorSmoother = new ExpSmoother(1000 / Math.LN2);
        this._machToKiasFactor = Subject.create(0);
        /** @inheritdoc */
        this.machToKiasFactor = this._machToKiasFactor;
        this.selectedSpeedIsMach = ConsumerSubject.create(null, false).pause();
        this.selectedIasSource = ConsumerSubject.create(null, 0).pause();
        this.selectedMachSource = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.selectedIas = MappedSubject.create(([isMach, ias]) => isMach ? null : ias, this.selectedSpeedIsMach, this.selectedIasSource);
        /** @inheritdoc */
        this.selectedMach = MappedSubject.create(([isMach, mach]) => isMach ? mach : null, this.selectedSpeedIsMach, this.selectedMachSource);
        this._selectedSpeedIas = Subject.create(null);
        /** @inheritdoc */
        this.selectedSpeedIas = this._selectedSpeedIas;
        this._maximumIas = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.maximumIas = this._maximumIas;
        this._minimumManeuveringIas = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.minimumManeuveringIas = this._minimumManeuveringIas;
        this._minimumIas = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.minimumIas = this._minimumIas;
        this._radioAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.radioAltitude = this._radioAltitude;
        this._selectedAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.selectedAltitude = this._selectedAltitude;
        this.iasLookahead = new Lookahead(6000, 2000 / Math.LN2, 1000 / Math.LN2);
        this._iasTrend = Subject.create(0);
        /** @inheritdoc */
        this.iasTrend = this._iasTrend;
        this.isAdcAirspeedDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isAdcDataFailed = this.isAdcAirspeedDataValid.map(SubscribableMapFunctions.not());
        this.simRate = ConsumerValue.create(null, 1).pause();
        this.pauseable = [
            this._ias,
            this._mach,
            this.machToKiasFactorSource,
            this.selectedSpeedIsMach,
            this.selectedIasSource,
            this.selectedMachSource,
            this._maximumIas,
            this._minimumManeuveringIas,
            this._minimumIas,
            this._radioAltitude,
            this._selectedAltitude,
            this.isAdcAirspeedDataValid,
            this.simRate
        ];
        this.lastUpdateTime = undefined;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultAirspeedIndicatorDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this._selectedAltitude.setConsumer(sub.on('ap_altitude_selected_3'));
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAirspeedDataValid.setConsumer(sub.on(`adc_selector_speed_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAirspeedDataValid.setConsumer(sub.on(`adc_speed_data_valid_${index}`));
            }
            this._ias.setConsumer(sub.on(`adc_ias_${index}`));
            this._mach.setConsumer(sub.on(`adc_mach_number_${index}`));
            this.machToKiasFactorSource.setConsumer(sub.on(`adc_mach_to_kias_factor_${index}`));
        }, true);
        this.selectedSpeedIsMach.setConsumer(sub.on('fms_speed_autopilot_target_is_mach'));
        this.selectedIasSource.setConsumer(sub.on('fms_speed_autopilot_target_ias'));
        this.selectedMachSource.setConsumer(sub.on('fms_speed_autopilot_target_mach'));
        this._maximumIas.setConsumer(sub.on('speedlimit_max_ias'));
        this._minimumManeuveringIas.setConsumer(sub.on('speedlimit_min_maneuver_ias'));
        this._minimumIas.setConsumer(sub.on('speedlimit_min_ias'));
        this.simRate.setConsumer(sub.on('simRate'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultAirspeedIndicatorDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        this.updateSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultAirspeedIndicatorDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        this.updateSub.pause();
        this.lastUpdateTime = undefined;
        this.machToKiasFactorSmoother.reset();
        this.iasLookahead.reset();
    }
    /**
     * Executes this data provider's periodic updates.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        var _a;
        const dt = (time - ((_a = this.lastUpdateTime) !== null && _a !== void 0 ? _a : time)) * this.simRate.get();
        this.lastUpdateTime = time;
        this._machToKiasFactor.set(this.machToKiasFactorSmoother.next(this.machToKiasFactorSource.get(), dt));
        this._iasTrend.set(this.iasLookahead.nextTrend(MathUtils.clamp(this.ias.get(), this.iasTrendBounds[0], this.iasTrendBounds[1]), dt));
        if (this.selectedSpeedIsMach.get()) {
            this._selectedSpeedIas.set(this.selectedMachSource.get() * this._machToKiasFactor.get());
        }
        else {
            this._selectedSpeedIas.set(this.selectedIasSource.get());
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.updateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/**
 * A Boeing selected airspeed display box.
 */
class AirspeedSelectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.text = MappedSubject.create(([ias, mach]) => {
            if (ias !== null) {
                return ias.toFixed(0);
            }
            if (mach !== null) {
                const rounded = Math.round(mach * 1000);
                if (rounded < 1000) {
                    return `.${rounded}`;
                }
                else {
                    return mach.toFixed(3);
                }
            }
            return '';
        }, this.props.dataProvider.selectedIas, this.props.dataProvider.selectedMach).pause();
        this.isPaused = true;
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.text.resume();
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.text.pause();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "airspeed-select-box" },
            FSComponent.buildComponent("div", { class: "airspeed-select-value" }, this.text)));
    }
}

/**
 * Display modes for {@link GsMachReadout}.
 */
var GsMachReadoutMode;
(function (GsMachReadoutMode) {
    GsMachReadoutMode["None"] = "None";
    GsMachReadoutMode["GroundSpeed"] = "GroundSpeed";
    GsMachReadoutMode["Mach"] = "Mach";
})(GsMachReadoutMode || (GsMachReadoutMode = {}));
/**
 * A Boeing digital groundspeed/mach readout display. Displays mach when airspeed is at or above mach 0.4 and
 * groundspeed otherwise.
 */
class GsMachReadout extends DisplayComponent {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        super(...arguments);
        this.mach = (_b = (_a = this.props.airspeedIndicatorDataProvider) === null || _a === void 0 ? void 0 : _a.mach) !== null && _b !== void 0 ? _b : Subject.create(0);
        this.groundSpeed = (_d = (_c = this.props.groundSpeedDataProvider) === null || _c === void 0 ? void 0 : _c.groundSpeed) !== null && _d !== void 0 ? _d : Subject.create(0);
        this.mode = MappedSubject.create(([mach, isAdcDataFailed, isGsDataFailed, showGs, showMach], previousVal) => {
            if (showMach && !isAdcDataFailed && mach >= (previousVal === GsMachReadoutMode.Mach ? 0.38 : 0.4)) {
                return GsMachReadoutMode.Mach;
            }
            else if (showGs && !isGsDataFailed) {
                return GsMachReadoutMode.GroundSpeed;
            }
            else {
                return GsMachReadoutMode.None;
            }
        }, (_e = this.mach) !== null && _e !== void 0 ? _e : Subject.create(0), (_g = (_f = this.props.airspeedIndicatorDataProvider) === null || _f === void 0 ? void 0 : _f.isAdcDataFailed) !== null && _g !== void 0 ? _g : Subject.create(true), (_j = (_h = this.props.groundSpeedDataProvider) === null || _h === void 0 ? void 0 : _h.isDataFailed) !== null && _j !== void 0 ? _j : Subject.create(true), SubscribableUtils.toSubscribable((_k = this.props.showGs) !== null && _k !== void 0 ? _k : this.props.groundSpeedDataProvider !== undefined, true), SubscribableUtils.toSubscribable((_l = this.props.showMach) !== null && _l !== void 0 ? _l : this.props.airspeedIndicatorDataProvider !== undefined, true));
        this.machRounded = this.mach.map(SubscribableMapFunctions.withPrecision(0.001)).pause();
        this.gsRounded = this.groundSpeed.map(SubscribableMapFunctions.withPrecision(1)).pause();
        this.text = Subject.create('');
        this.alertTimer = new DebounceTimer();
        this.isAlertActive = Subject.create(false);
        this.hidden = this.mode.map(mode => mode === GsMachReadoutMode.None);
        this.isAlive = true;
        this.isPaused = true;
    }
    /** @inheritdoc */
    onAfterRender() {
        if (this.props.mode) {
            this.modePipe = this.mode.pipe(this.props.mode);
        }
        const machPipe = this.machRounded.pipe(this.text, mach => {
            const rounded = Math.round(mach * 1000);
            if (rounded < 1000) {
                return `.${rounded}`;
            }
            else {
                return mach.toFixed(3);
            }
        }, true);
        const gsPipe = this.gsRounded.pipe(this.text, gs => gs.toFixed(0), true);
        const deactivateAlert = this.isAlertActive.set.bind(this.isAlertActive, false);
        this.mode.sub(mode => {
            let activateAlert = true;
            switch (mode) {
                case GsMachReadoutMode.Mach:
                    gsPipe.pause();
                    machPipe.resume(true);
                    break;
                case GsMachReadoutMode.GroundSpeed:
                    machPipe.pause();
                    gsPipe.resume(true);
                    break;
                default:
                    machPipe.pause();
                    gsPipe.pause();
                    activateAlert = false;
            }
            if (activateAlert) {
                this.isAlertActive.set(true);
                this.alertTimer.schedule(deactivateAlert, GsMachReadout.ALERT_DURATION);
            }
            else {
                this.alertTimer.clear();
            }
        }, true);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     * @throws Error if this component has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('GsMachReadout: cannot resume a dead display');
        }
        this.isPaused = false;
        this.gsRounded.resume();
        this.machRounded.resume();
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     * @throws Error if this component has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('GsMachReadout: cannot pause a dead display');
        }
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.gsRounded.pause();
        this.machRounded.pause();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'gs-mach-readout': true,
                'hidden': this.hidden,
                'gs-mach-readout-alert': this.isAlertActive
            } },
            FSComponent.buildComponent("span", { class: { 'gs-mach-readout-prefix': true, 'hidden': this.mode.map(mode => mode !== GsMachReadoutMode.GroundSpeed) } }, "GS"),
            FSComponent.buildComponent("span", { class: 'gs-mach-readout-value' }, this.text)));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.isAlive = false;
        this.alertTimer.clear();
        this.hidden.destroy();
        this.mode.destroy();
        this.machRounded.destroy();
        this.gsRounded.destroy();
        (_a = this.modePipe) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}
GsMachReadout.ALERT_DURATION = 10000; // milliseconds

/**
 * A Boeing "NO VSPD" failure flag.
 */
class NoVSpdFlag extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.isOnGround = ConsumerSubject.create(null, false).pause();
        this.fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        this.vSpeedSettings = VSpeedUserSettings.getManager(this.props.bus);
        this.hidden = MappedSubject.create(([isAirspeedDataFailed, isOnGround, phase, v1, vr, v2, vref]) => {
            return isAirspeedDataFailed || !isOnGround || phase > FmsOperatingPhase.TAKEOFF || v1 > 50 || vr > 50 || v2 > 50 || vref > 50;
        }, this.props.isAirspeedDataFailed, this.isOnGround, this.fmsOperatingPhase, this.vSpeedSettings.getSettings(VSpeedType.V1).value, this.vSpeedSettings.getSettings(VSpeedType.Vr).value, this.vSpeedSettings.getSettings(VSpeedType.V2).value, this.vSpeedSettings.getSettings(VSpeedType.Vref).value).pause();
        this.isPaused = true;
        this.pauseable = [
            this.isOnGround,
            this.fmsOperatingPhase,
            this.hidden
        ];
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'no-vspd-flag': true, 'hidden': this.hidden } },
            "NO",
            FSComponent.buildComponent("br", null),
            "V",
            FSComponent.buildComponent("br", null),
            "S",
            FSComponent.buildComponent("br", null),
            "P",
            FSComponent.buildComponent("br", null),
            "D"));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link VNavSpeedBandDataProvider}.
 */
class DefaultVNavSpeedBandDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.minimumIasSource = ConsumerSubject.create(null, null).pause();
        this.maximumIasSource = ConsumerSubject.create(null, null).pause();
        this._minimumIas = Subject.create(null);
        /** @inheritdoc */
        this.minimumIas = this._minimumIas;
        this._maximumIas = Subject.create(null);
        /** @inheritdoc */
        this.maximumIas = this._maximumIas;
        this.isVNavActive = ConsumerSubject.create(null, false).pause();
        this.vnavMode = ConsumerSubject.create(null, BoeingVNavModes.NONE).pause();
        this.flapsPosition = ConsumerSubject.create(null, 0).pause();
        this.isAvail = MappedSubject.create(([isVNavActive, vnavMode, flapsPosition], previousVal) => {
            if (previousVal) {
                return isVNavActive && flapsPosition === 0;
            }
            else {
                return vnavMode === BoeingVNavModes.PATH_DESCENT || vnavMode === BoeingVNavModes.PATH_IDLE;
            }
        }, this.isVNavActive, this.vnavMode, this.flapsPosition);
        this.pauseable = [
            this.minimumIasSource,
            this.maximumIasSource,
            this.isVNavActive,
            this.vnavMode,
            this.flapsPosition
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultVNavSpeedBandDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.minimumIasSource.setConsumer(sub.on('vnav_boeing_band_speed_min'));
        this.maximumIasSource.setConsumer(sub.on('vnav_boeing_band_speed_max'));
        this.isVNavActive.setConsumer(sub.on('vnav_active'));
        this.vnavMode.setConsumer(sub.on('vnav_boeing_vnav_mode'));
        this.flapsPosition.setConsumer(sub.on('flap_computer_interpolated_position'));
        this.minimumIasPipe = this.minimumIasSource.pipe(this._minimumIas, true);
        this.maximumIasPipe = this.maximumIasSource.pipe(this._maximumIas, true);
        this.isAvailSub = this.isAvail.sub(isAvail => {
            if (isAvail) {
                this.minimumIasPipe.resume(true);
                this.maximumIasPipe.resume(true);
            }
            else {
                this.minimumIasPipe.pause();
                this.maximumIasPipe.pause();
                this._minimumIas.set(null);
                this._maximumIas.set(null);
            }
        }, false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultVNavSpeedBandDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        this.isAvailSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultVNavSpeedBandDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        this.isAvailSub.pause();
        this.minimumIasPipe.pause();
        this.maximumIasPipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * A Boeing altimeter.
 */
class Altimeter extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.metricAltitudeBoxElement = FSComponent.createRef();
        this.metricAltitudeValue = Subject.create(0);
        this.pixelPerFoot = this.props.windowHeight / Altimeter.WINDOW_ALTITUDE;
        this.tapeTickCount = Altimeter.WINDOW_ALTITUDE * 2 / Altimeter.TAPE_TICK_INTERVAL + 1;
        this.tapeCenterTickOffset = Math.floor(this.tapeTickCount / 2);
        this.tapeTickAltitudes = ArrayUtils.create(this.tapeTickCount, index => Subject.create((index - this.tapeCenterTickOffset) * Altimeter.TAPE_TICK_INTERVAL, SubscribableUtils.NUMERIC_NAN_EQUALITY));
        this.tapeCenterAltitude = 0;
        this.tapeScrolledAltitude = 0;
        this.tapeTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', '%', 'px'));
        this.groundRibbonTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px', 'px', 'px'));
        this.isGroundRibbonHidden = Subject.create(false);
        this.preselectBugTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px', 'px', 'px'), CssTransformBuilder.translateY('%')));
        this.baroMinsBugTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px', 'px', 'px'), CssTransformBuilder.translateY('%')));
        this.isBaroMinsBugHidden = Subject.create(false);
        this.isBaroMinsAlertActive = Subject.create(false);
        this.isBaroMinsBugFlashing = Subject.create(false);
        this.baroMinsBugFlashTimer = new DebounceTimer();
        this.trendVectorScaleTransform = CssTransformSubject.create(CssTransformBuilder.scaleY());
        this.trendVectorTranslateTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.isTrendVectorHidden = Subject.create(false);
        this.scrollerAltitude = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.scrollerAltitude10000 = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.isReadoutAlertActive = Subject.create(false);
        this.isReadoutBold = Subject.create(false);
        this.landingElevation = MappedSubject.create(([landingElevation, isQfe]) => landingElevation === null ? null : isQfe ? 0 : landingElevation, this.props.dataProvider.landingElevation, this.props.isQfe).pause();
        this.radioGroundElevation = MappedSubject.create(([indicatedAltitude, radioAltitude]) => indicatedAltitude - radioAltitude, this.props.dataProvider.indicatedAltitude, this.props.dataProvider.radioAltitude).pause();
        this.groundRibbonAltitude = Subject.create(0);
        this.isPaused = true;
        this.pauseableSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.preselectBugTransform.transform.getChild(1).set(-50);
        this.baroMinsBugTransform.transform.getChild(1).set(-50);
        this.landingElevationPipe = this.landingElevation.pipe(this.groundRibbonAltitude, elev => elev === null ? 0 : elev, true);
        this.radioGroundElevationPipe = this.radioGroundElevation.pipe(this.groundRibbonAltitude, true);
        this.pauseableSubs.push(this.props.dataProvider.indicatedAltitude.sub(this.updateAltitude.bind(this), true, this.isPaused), this.props.dataProvider.selectedAltitude.sub(this.updateSelectedAltitudeBug.bind(this), true, this.isPaused), this.props.minimumsDataProvider.baroMinimums.sub(this.updateBaroMinimumsBug.bind(this), true, this.isPaused), this.props.dataProvider.landingElevation.sub(elev => {
            var _a, _b, _c, _d;
            if (elev === null) {
                (_a = this.landingElevationPipe) === null || _a === void 0 ? void 0 : _a.pause();
                this.radioGroundElevation.resume();
                (_b = this.radioGroundElevationPipe) === null || _b === void 0 ? void 0 : _b.resume(true);
            }
            else {
                this.radioGroundElevation.pause();
                (_c = this.radioGroundElevationPipe) === null || _c === void 0 ? void 0 : _c.pause();
                (_d = this.landingElevationPipe) === null || _d === void 0 ? void 0 : _d.resume(true);
            }
        }, true, this.isPaused), this.props.dataProvider.altitudeAlertState.sub(this.onAltitudeAlertStateChanged.bind(this), true, this.isPaused), this.props.minimumsDataProvider.isBaroMinimumsAlertActive.pipe(this.isBaroMinsAlertActive, this.isPaused), this.props.showMetric.sub(showMetric => {
            this.metricAltitudeBoxElement.instance.classList.toggle('hidden', !showMetric);
        }, true, this.isPaused)
        // TODO: Hook up "no landing altitude" state to toggle "no-ldg-alt" CSS class on .altimeter element
        );
        if (this.props.supportTrendVector) {
            this.pauseableSubs.push(this.props.dataProvider.altitudeTrend.sub(this.onTrendChanged.bind(this), this.isPaused));
        }
        this.groundRibbonAltitude.sub(this.updateGroundRibbon.bind(this), true);
        const deactivateMinsBugFlash = this.isBaroMinsBugFlashing.set.bind(this.isBaroMinsBugFlashing, false);
        this.props.minimumsDataProvider.isBaroMinimumsAlertActive.sub(isActive => {
            if (isActive) {
                this.isBaroMinsBugFlashing.set(true);
                this.baroMinsBugFlashTimer.schedule(deactivateMinsBugFlash, Altimeter.MINIMUMS_FLASH_DURATION);
            }
            else {
                this.baroMinsBugFlashTimer.clear();
                deactivateMinsBugFlash();
            }
        }, true);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.landingElevation.resume();
        for (const sub of this.pauseableSubs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        var _a, _b;
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const sub of this.pauseableSubs) {
            sub.pause();
        }
        this.landingElevation.pause();
        this.radioGroundElevation.pause();
        (_a = this.landingElevationPipe) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.radioGroundElevationPipe) === null || _b === void 0 ? void 0 : _b.pause();
    }
    /**
     * A method called to update the location of the Selected Altitude Bug on the altitude tape.
     */
    updateSelectedAltitudeBug() {
        const deltaBug = this.tapeScrolledAltitude - this.props.dataProvider.selectedAltitude.get();
        this.preselectBugTransform.transform
            .getChild(0)
            .set(0, MathUtils.clamp(deltaBug, -Altimeter.HALF_WINDOW_ALTITUDE, Altimeter.HALF_WINDOW_ALTITUDE) * this.pixelPerFoot, 0, undefined, 0.1);
        this.preselectBugTransform.resolve();
    }
    /**
     * A method called to update the location of the Baro Minimums Bug on the altitude tape.
     */
    updateBaroMinimumsBug() {
        const minimums = this.props.minimumsDataProvider.baroMinimums.get();
        let isVisible = false;
        if (minimums !== null) {
            const deltaBug = this.tapeScrolledAltitude - minimums;
            // Allow the bug to scroll off the tape window, but then hide it once it reaches far enough out of bounds so that
            // we don't keep updating the bug when it can't be seen.
            const maxDelta = Altimeter.HALF_WINDOW_ALTITUDE + 100;
            if (Math.abs(deltaBug) < maxDelta && this.tapeScrolledAltitude >= -2000 && this.tapeScrolledAltitude <= 99900) {
                this.baroMinsBugTransform.transform
                    .getChild(0)
                    .set(0, deltaBug * this.pixelPerFoot, 0, undefined, 0.1);
                this.baroMinsBugTransform.resolve();
                isVisible = true;
            }
        }
        this.isBaroMinsBugHidden.set(!isVisible);
    }
    /**
     * A method called to update the location of the Ground Ribbon on the altitude tape.
     */
    updateGroundRibbon() {
        const groundAltitude = this.groundRibbonAltitude.get();
        let isVisible = false;
        if (this.tapeScrolledAltitude >= -2000 && this.tapeScrolledAltitude <= 99900) {
            // Ground ribbon elements span from ground altitude to ground altitude + 1000 feet. Therefore, with a tape window
            // of 800 feet (400 feet on either side of the indicated altitude), the ground ribbon is visible with indicated
            // altitude within 400 feet below to 1400 feet above ground altitude. We will add 100 feet of buffer to both ends
            // of this range (the ground ribbon stripes do extend below the actual ground altitude but by less than 100 feet)
            // and render/update the ribbon only when indicated altitude is within the buffered range.
            const deltaAltitude = this.tapeScrolledAltitude - groundAltitude;
            if (deltaAltitude >= -500 && deltaAltitude <= 1500) {
                this.groundRibbonTransform.transform.set(0, this.pixelPerFoot * deltaAltitude, 0, undefined, 0.1);
                this.groundRibbonTransform.resolve();
                isVisible = true;
            }
        }
        this.isGroundRibbonHidden.set(!isVisible);
    }
    /**
     * Responds to when the altitude trend changes.
     * @param trend The new altitude trend, in feet.
     */
    onTrendChanged(trend) {
        const absoluteTrend = Math.abs(trend);
        if (absoluteTrend > 30) {
            this.trendVectorScaleTransform.transform.set(trend < 0 ? -1 : 1);
            this.trendVectorScaleTransform.resolve();
            this.trendVectorTranslateTransform.transform.set(0, -this.pixelPerFoot * Math.min(absoluteTrend, Altimeter.HALF_WINDOW_ALTITUDE * 1.5), 0, undefined, 0.1);
            this.trendVectorTranslateTransform.resolve();
            this.isTrendVectorHidden.set(false);
        }
        else {
            this.isTrendVectorHidden.set(true);
        }
    }
    /**
     * Updates the altitude indicator when the altitude changes.
     * @param indicatedAlt The new altitude value.
     */
    updateAltitude(indicatedAlt) {
        this.metricAltitudeValue.set(Math.round(UnitType.FOOT.convertTo(indicatedAlt, UnitType.METER)));
        if (indicatedAlt < -2000 || indicatedAlt > 99900) {
            this.scrollerAltitude.set(NaN);
            this.scrollerAltitude10000.set(NaN);
        }
        else {
            this.scrollerAltitude.set(indicatedAlt);
            if (indicatedAlt >= 0) {
                this.scrollerAltitude10000.set(indicatedAlt);
            }
            else {
                // If indicated altitude is negative, we need the 10000 digit scroller to transition from the zero symbol
                // to the negative sign from 0 to -20 feet.
                this.scrollerAltitude10000.set(Math.max(-9980 + indicatedAlt, -10000));
            }
        }
        if (indicatedAlt < -2000 || indicatedAlt > 99900) {
            this.tapeTransform.transform.set(0, 0, 0);
        }
        else {
            let tapeTranslation = (indicatedAlt - this.tapeCenterAltitude) / (Altimeter.WINDOW_ALTITUDE * 2) * 100;
            if (Math.abs(tapeTranslation) > 25) {
                // We need to reset the tape's center altitude such that the tape translation is back within +/-25%.
                this.tapeCenterAltitude = MathUtils.round(indicatedAlt, 100);
                for (let i = 0; i < this.tapeTickAltitudes.length; i++) {
                    this.tapeTickAltitudes[i].set((i - this.tapeCenterTickOffset) * Altimeter.TAPE_TICK_INTERVAL + this.tapeCenterAltitude);
                }
                tapeTranslation = (indicatedAlt - this.tapeCenterAltitude) / (Altimeter.WINDOW_ALTITUDE * 2) * 100;
            }
            this.tapeTransform.transform.set(0, tapeTranslation, 0, undefined, 0.02);
        }
        this.tapeTransform.resolve();
        this.tapeScrolledAltitude = indicatedAlt;
        this.updateSelectedAltitudeBug();
        this.updateBaroMinimumsBug();
        this.updateGroundRibbon();
    }
    /**
     * Responds to when the altitude alert state changes.
     * @param state The new altitude alert state.
     */
    onAltitudeAlertStateChanged(state) {
        // set styles
        this.isReadoutAlertActive.set(state === AltAlertState.DEVIATION_200);
        this.isReadoutBold.set(state === AltAlertState.DEVIATION_200 || state === AltAlertState.WITHIN_900);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "altimeter-box" },
            FSComponent.buildComponent("div", { class: "altimeter", style: `position: absolute; top: 0px; height: ${this.props.windowHeight}px;` },
                FSComponent.buildComponent("div", { class: "altitude-mask", style: "position: absolute; top: 0px; height: 100%; overflow: hidden;" },
                    FSComponent.buildComponent("div", { class: "altimeter-tape", style: {
                            'position': 'absolute',
                            'top': '-50%',
                            'height': `${this.props.windowHeight * 2}px`,
                            'transform': this.tapeTransform
                        } },
                        FSComponent.buildComponent("div", { class: "altimeter-tape-tick-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAltitudeTapeTicks()),
                        FSComponent.buildComponent("div", { class: "altimeter-tape-label-container", style: "position: absolute; top: 0px; height: 100%;" }, this.buildAltitudeTapeLabels())),
                    this.renderGroundRibbon(),
                    FSComponent.buildComponent("svg", { viewBox: "0 0 53 88", preserveAspectRatio: "none", class: "altimeter-preselect-bug", style: { 'position': 'absolute', 'top': '50%', 'overflow': 'visible', 'transform': this.preselectBugTransform } },
                        FSComponent.buildComponent("path", { d: "m 53 0 l -53 0 l 0 29 l 13 15 l -13 15 l 0 29 l 53 0 Z", class: "altimeter-preselect-bug-stroke shadow" }),
                        FSComponent.buildComponent("path", { d: "m 53 0 l -53 0 l 0 29 l 13 15 l -13 15 l 0 29 l 53 0 Z", class: "altimeter-preselect-bug-stroke" })),
                    FSComponent.buildComponent("svg", { viewBox: "0 -25 144 50", preserveAspectRatio: "none", class: { 'altimeter-baro-mins-bug': true, 'hidden': this.isBaroMinsBugHidden, 'warning': this.isBaroMinsAlertActive, 'flash': this.isBaroMinsBugFlashing }, style: { 'position': 'absolute', 'top': '50%', 'overflow': 'visible', 'transform': this.baroMinsBugTransform } },
                        FSComponent.buildComponent("path", { d: "M 144 0 L 19 0 L 0 25 L 0 -25 L 19 0", stroke: "currentColor", class: "altimeter-baro-mins-bug-stroke" })),
                    this.props.supportTrendVector === true && this.renderTrendVector()),
                FSComponent.buildComponent("div", { class: "metric-altitude-box hidden", ref: this.metricAltitudeBoxElement },
                    FSComponent.buildComponent("div", { class: "metric-altitude-value-container" },
                        FSComponent.buildComponent("span", { class: "value" }, this.metricAltitudeValue),
                        FSComponent.buildComponent("span", { class: "unit" }, "M"))),
                FSComponent.buildComponent("div", { class: "altimeter-readout" },
                    FSComponent.buildComponent("svg", { viewBox: "0 0 146 88", preserveAspectRatio: "none", "stroke-linejoin": "round", class: { 'altimeter-readout-box': true, 'warning': this.isReadoutAlertActive, 'bold': this.isReadoutBold }, style: "overflow: visible;" },
                        FSComponent.buildComponent("path", { class: "altimeter-readout-box-border shadow", d: "M 17 0 l 129 0 l 0 88 l -129 0 l 0 -29 l -17 -15 l 17 -15 z" }),
                        FSComponent.buildComponent("path", { class: "altimeter-readout-box-border", d: "M 17 0 l 129 0 l 0 88 l -129 0 l 0 -29 l -17 -15 l 17 -15 z" })),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude10000, base: 10, factor: 10000, scrollThreshold: 9980, renderDigit: (digit) => digit === 0 ? '$' : digit < 0 ? '-' : (digit % 10).toString(), nanString: ' ', class: 'alt-digit-scroller alt-ten-thousands-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude, base: 10, factor: 1000, scrollThreshold: 980, renderDigit: (digit) => (Math.abs(digit) % 10).toString(), nanString: ' ', class: 'alt-digit-scroller alt-thousands-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude, base: 10, factor: 100, scrollThreshold: 80, renderDigit: (digit) => (Math.abs(digit) % 10).toString(), nanString: ' ', class: 'alt-digit-scroller alt-hundreds-scroller' }),
                    FSComponent.buildComponent(DigitScroller, { value: this.scrollerAltitude, base: 5, factor: 20, renderDigit: (digit) => ((Math.abs(digit) % 5) * 20).toString().padStart(2, '0'), nanString: '--', class: 'alt-digit-scroller alt-tens-scroller' }))),
            FSComponent.buildComponent("div", { class: "altimeter-ldg-alt-flag" }, "LDG ALT")));
    }
    /**
     * Builds the tick marks on the altitude tape.
     * @returns The tick marks on the altitude tape, as an array of VNodes.
     */
    buildAltitudeTapeTicks() {
        const tickIntervalPx = Altimeter.TAPE_TICK_INTERVAL * this.pixelPerFoot;
        const is500Map = (altitude) => altitude % 500 === 0;
        const is1000Map = (altitude) => altitude % 1000 === 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const altitude = this.tapeTickAltitudes[index];
            const y = (this.tapeTickCount - index - 1) * tickIntervalPx;
            const is500 = altitude.map(is500Map);
            const is1000 = altitude.map(is1000Map);
            return (FSComponent.buildComponent("div", { class: { 'altimeter-tape-tick': true, 'altimeter-tape-tick-500': is500, 'altimeter-tape-tick-1000': is1000 }, style: `position: absolute; top: ${y}px; transform: translateY(-50%);` }));
        });
    }
    /**
     * Builds the labels on the altitude tape.
     * @returns The labels on the altitude tape, as an array of VNodes.
     */
    buildAltitudeTapeLabels() {
        const labelIntervalPx = Altimeter.TAPE_TICK_INTERVAL * this.pixelPerFoot;
        const bigTextMap = (altitude) => {
            if (isNaN(altitude)) {
                return '';
            }
            if (altitude < 0 && altitude > -1000) {
                return '-';
            }
            else if (altitude >= 0 && altitude < 1000) {
                return '';
            }
            else {
                return Math.trunc(altitude / 1000).toString();
            }
        };
        const smallTextMap = (altitude) => {
            if (isNaN(altitude)) {
                return '';
            }
            const mod = Math.abs(altitude) % 1000;
            return mod === 0 ? '000' : mod.toString();
        };
        const is1000Map = (altitude) => altitude % 1000 === 0;
        const isHiddenMap = (altitude) => altitude % 200 !== 0;
        return ArrayUtils.create(this.tapeTickCount, index => {
            const altitude = this.tapeTickAltitudes[index];
            const y = (this.tapeTickCount - index - 1) * labelIntervalPx;
            return (FSComponent.buildComponent("div", { class: {
                    'altimeter-tape-label': true,
                    'altimeter-tape-label-1000': altitude.map(is1000Map),
                    'hidden': altitude.map(isHiddenMap)
                }, style: `position: absolute; right: 0%; top: ${y}px; transform: translateY(-50%)` },
                FSComponent.buildComponent("div", { class: "altimeter-tape-label-bar altimeter-tape-label-bar-top", style: "position: absolute;" }),
                FSComponent.buildComponent("div", { class: "altimeter-tape-label-bar altimeter-tape-label-bar-bottom", style: "position: absolute;" }),
                FSComponent.buildComponent("div", { class: 'altimeter-tape-label-numbers' },
                    FSComponent.buildComponent("span", { class: "altimeter-tape-label-big" }, altitude.map(bigTextMap)),
                    FSComponent.buildComponent("span", { class: "altimeter-tape-label-small" }, altitude.map(smallTextMap)))));
        });
    }
    /**
     * Renders this altimeter's ground ribbon.
     * @returns This altimeter's ground ribbon, as a VNode.
     */
    renderGroundRibbon() {
        const top = Math.round(this.pixelPerFoot * -1000);
        const middle = Math.round(this.pixelPerFoot * -500);
        return (FSComponent.buildComponent("div", { class: { 'altimeter-ground-ribbon': true, 'hidden': this.isGroundRibbonHidden }, style: { 'position': 'absolute', 'top': '50%', 'transform': this.groundRibbonTransform } },
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-upper shadow", style: `position: absolute; top: calc(${top}px + var(--altimeter-ground-ribbon-stem-shadow-upper-y-offset, 0px)); height: calc(${middle - top}px + var(--altimeter-ground-ribbon-stem-shadow-upper-height-offset, 0px))` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-lower shadow", style: `position: absolute; top: calc(${middle}px + var(--altimeter-ground-ribbon-stem-shadow-lower-y-offset, 0px)); height: calc(${-middle}px + var(--altimeter-ground-ribbon-stem-shadow-lower-height-offset, 0px))` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-ground-line shadow", style: "position: absolute; top: var(--altimeter-ground-ribbon-ground-line-shadow-y-offset, 0px);" }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-upper", style: `position: absolute; top: ${top}px; height: ${middle - top}px` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-stem altimeter-ground-ribbon-stem-lower", style: `position: absolute; top: ${middle}px; height: ${-middle}px` }),
            FSComponent.buildComponent("div", { class: "altimeter-ground-ribbon-ground-line", style: "position: absolute; top: 0px;" }),
            FSComponent.buildComponent("svg", { viewBox: "0 0 125 50", preserveAspectRatio: "none", class: "altimeter-ground-ribbon-stripes", style: "position: absolute; top: 0px;" },
                FSComponent.buildComponent("path", { d: "M 0 48 L 2 50 M 0 35 L 15 50 M 0 20 L 30 50 M 45 50 L 0 5 M 25 0 L 75 50 M 60 50 L 10 0 M 90 50 L 40 0 M 55 0 L 105 50 M 120 50 L 70 0 M 85 0 L 125 40 M 100 0 L 125 25 M 115 0 L 125 10 M 180 32", class: "altimeter-ground-ribbon-stripes-stroke" }))));
    }
    /**
     * Renders this altimeter's altitude trend vector.
     * @returns This altimeter's altitude trend vector, as a VNode.
     */
    renderTrendVector() {
        return (FSComponent.buildComponent("div", { class: {
                'altimeter-trend-vector': true,
                'hidden': this.isTrendVectorHidden,
            }, style: {
                'position': 'absolute',
                'bottom': '50%',
                'height': '50%',
                'overflow': 'hidden',
                'transform': this.trendVectorScaleTransform,
                'transform-origin': '50% 100%'
            } },
            FSComponent.buildComponent("div", { style: { 'position': 'absolute', 'left': '0px', 'top': '100%', 'width': '100%', 'height': '150%', 'transform': this.trendVectorTranslateTransform } },
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-stem shadow", style: "position: absolute; bottom: 0px;" },
                    FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "altimeter-trend-vector-stroke" })),
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-pointer shadow", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "altimeter-trend-vector-stroke" })),
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-stem", style: "position: absolute; bottom: 0px;" },
                    FSComponent.buildComponent("line", { x1: '50%', y1: "0%", x2: "50%", y2: "100%", class: "altimeter-trend-vector-stroke" })),
                FSComponent.buildComponent("svg", { class: "altimeter-trend-vector-svg altimeter-trend-vector-pointer", viewBox: "0 0 18 18", style: "position: absolute; top: 0px; overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 18 l 9 -18 l 9 18 z", class: "altimeter-trend-vector-stroke" })))));
    }
}
/** The altimeter tape window's altitude range, in feet. */
Altimeter.WINDOW_ALTITUDE = 800;
Altimeter.HALF_WINDOW_ALTITUDE = Altimeter.WINDOW_ALTITUDE / 2;
/** The altitude interval between each altimeter tape tick. */
Altimeter.TAPE_TICK_INTERVAL = 100;
Altimeter.MINIMUMS_FLASH_DURATION = 3000; // milliseconds

/**
 * An altimeter barometric settings display.
 */
class AltimeterBaroDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.settingText = MappedSubject.create(([isStd, setting, showMetric]) => isStd ? 'STD' : showMetric ? UnitType.IN_HG.convertTo(setting, UnitType.HPA).toFixed(0) : setting.toFixed(2), this.props.dataProvider.isStd, this.props.dataProvider.baroInHg, this.props.showMetric).pause();
        this.settingUnitText = MappedSubject.create(([isStd, showMetric]) => isStd ? '' : showMetric ? 'HPA' : 'IN', this.props.dataProvider.isStd, this.props.showMetric).pause();
        this.settingReference = MappedSubject.create(([isStd, isQfe]) => isStd ? null : isQfe ? 'QFE' : 'QNH', this.props.dataProvider.isStd, this.props.dataProvider.isQfe).pause();
        this.settingReferenceTimer = new DebounceTimer();
        this.settingReferenceText = Subject.create('');
        this.preselectText = MappedSubject.create(([isPreselectManual, preselect, showMetric]) => isPreselectManual ? showMetric ? UnitType.IN_HG.convertTo(preselect, UnitType.HPA).toFixed(0) : preselect.toFixed(2) : '', this.props.dataProvider.isPreselectManual, this.props.dataProvider.preselectInHg, this.props.showMetric).pause();
        this.preselectUnitText = MappedSubject.create(([isPreselectManual, showMetric]) => isPreselectManual ? showMetric ? 'HPA' : 'IN' : '', this.props.dataProvider.isPreselectManual, this.props.showMetric).pause();
        this.preselectReferenceText = MappedSubject.create(([isPreselectManual, isQfe]) => isPreselectManual && isQfe ? 'QFE' : '', this.props.dataProvider.isPreselectManual, this.props.dataProvider.isQfe).pause();
        this.isStd = this.props.dataProvider.isStd.map(SubscribableMapFunctions.identity()).pause();
        this.isBaroAlertActive = this.props.dataProvider.isBaroAlertActive.map(SubscribableMapFunctions.identity()).pause();
        this.isQfeAlertActive = Subject.create(false);
        this.isPaused = true;
        this.pauseable = [
            this.settingText,
            this.settingUnitText,
            this.preselectText,
            this.preselectUnitText,
            this.preselectReferenceText,
            this.isStd,
            this.isBaroAlertActive
        ];
    }
    /** @inheritdoc */
    onAfterRender() {
        const deactivateQfeAlert = this.isQfeAlertActive.set.bind(this.isQfeAlertActive, false);
        const clearReferenceText = this.settingReferenceText.set.bind(this.settingReferenceText, '');
        this.settingReference.resume();
        this.settingReference.sub(reference => {
            switch (reference) {
                case 'QNH':
                    deactivateQfeAlert();
                    this.settingReferenceText.set('QNH');
                    this.settingReferenceTimer.schedule(clearReferenceText, AltimeterBaroDisplay.QNH_DURATION);
                    break;
                case 'QFE':
                    this.settingReferenceText.set('QFE');
                    this.isQfeAlertActive.set(true);
                    this.settingReferenceTimer.schedule(deactivateQfeAlert, AltimeterBaroDisplay.QFE_ALERT_DURATION);
                    break;
                default:
                    clearReferenceText();
                    deactivateQfeAlert();
                    this.settingReferenceTimer.clear();
            }
        }, true);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'alt-baro': true,
                'alt-baro-std': this.isStd,
                'alt-baro-alert': this.isBaroAlertActive,
                'alt-baro-qfe-alert': this.isQfeAlertActive
            } },
            FSComponent.buildComponent("div", { class: "alt-baro-row alt-baro-top" },
                FSComponent.buildComponent("div", { class: "alt-baro-source" }, "L"),
                FSComponent.buildComponent("div", { class: "alt-baro-setting" },
                    FSComponent.buildComponent("div", { class: "alt-baro-setting-inner" },
                        FSComponent.buildComponent("div", { class: "alt-baro-value-wrapper" },
                            FSComponent.buildComponent("div", { class: "alt-baro-value" }, this.settingText)),
                        FSComponent.buildComponent("div", { class: "alt-baro-unit" }, this.settingUnitText))),
                FSComponent.buildComponent("div", { class: "alt-baro-reference" }, this.settingReferenceText)),
            FSComponent.buildComponent("div", { class: "alt-baro-row alt-baro-bottom" },
                FSComponent.buildComponent("div", { class: "alt-baro-uplink" }),
                FSComponent.buildComponent("div", { class: "alt-baro-setting" },
                    FSComponent.buildComponent("div", { class: "alt-baro-setting-inner" },
                        FSComponent.buildComponent("div", { class: "alt-baro-value-wrapper" },
                            FSComponent.buildComponent("div", { class: "alt-baro-value" }, this.preselectText)),
                        FSComponent.buildComponent("div", { class: "alt-baro-unit" }, this.preselectUnitText))),
                FSComponent.buildComponent("div", { class: "alt-baro-reference" }, this.preselectReferenceText))));
    }
}
AltimeterBaroDisplay.QNH_DURATION = 10000; // milliseconds
AltimeterBaroDisplay.QFE_ALERT_DURATION = 10000; // milliseconds

/**
 * A default implementation of {@link AltimeterDataProvider} which sources data from one ADC at a time or from the ADC
 * chosen by an ADC selector.
 */
class DefaultAltimeterDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param perfPlan The performance plan that is the source of this provider's landing elevation data.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param landingElevationOffset The offset, in feet, to apply to this provider's landing elevation value.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, perfPlan, index, landingElevationOffset, useSelector = false) {
        this.bus = bus;
        this.perfPlan = perfPlan;
        this.landingElevationOffset = landingElevationOffset;
        this.useSelector = useSelector;
        this._indicatedAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.indicatedAltitude = this._indicatedAltitude;
        this._radioAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.radioAltitude = this._radioAltitude;
        this._selectedAltitude = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.selectedAltitude = this._selectedAltitude;
        this.verticalSpeed = ConsumerSubject.create(null, 0).pause();
        // Vertical speed is already smoothed by the sim, so no need to further smooth it when calculating the trend.
        /** @inheritdoc */
        this.altitudeTrend = this.verticalSpeed.map(vs => vs / 10);
        this._landingElevation = Subject.create(null);
        /** @inheritdoc */
        this.landingElevation = this._landingElevation;
        this._altitudeAlertState = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.altitudeAlertState = this._altitudeAlertState;
        this.isAdcAltitudeDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isAdcDataFailed = this.isAdcAltitudeDataValid.map(SubscribableMapFunctions.not());
        this.ppos = ConsumerValue.create(null, undefined);
        this.pauseable = [
            this._indicatedAltitude,
            this._radioAltitude,
            this._selectedAltitude,
            this.verticalSpeed,
            this._altitudeAlertState,
            this.isAdcAltitudeDataValid,
            this.ppos
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultAltimeterDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this._selectedAltitude.setConsumer(sub.on('ap_altitude_selected_3'));
        this._altitudeAlertState.setConsumer(sub.on('altitude_alert'));
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_altitude_data_valid_${index}`));
            }
            this._indicatedAltitude.setConsumer(sub.on(`adc_indicated_alt_${index}`));
            this.verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
        }, true);
        // TODO: What happens to landing elevation when GPS position is not available?
        this.ppos.setConsumer(sub.on('gps-position'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAltimeterDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAltimeterDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.pause();
    }
    /**
     * Executes this data provider's periodic updates.
     */
    update() {
        const ppos = this.ppos.get();
        if (!ppos) {
            this._landingElevation.set(null);
            return;
        }
        const takeoffRunway = this.perfPlan.originRunway.get();
        const approachRunway = this.perfPlan.approachRunway.get();
        if (!takeoffRunway) {
            this._landingElevation.set(null);
            return;
        }
        if (approachRunway) {
            const distanceToTakeoffRunway = GeoPoint.distance(ppos.lat, ppos.long, takeoffRunway.latitude, takeoffRunway.longitude);
            const distanceToApproachRunway = GeoPoint.distance(ppos.lat, ppos.long, approachRunway.latitude, approachRunway.longitude);
            if (distanceToApproachRunway < distanceToTakeoffRunway || distanceToTakeoffRunway > 0.116147 /* 400 NM */) {
                this._landingElevation.set(UnitType.METER.convertTo(approachRunway.elevation, UnitType.FOOT) + this.landingElevationOffset);
            }
            else {
                this._landingElevation.set(UnitType.METER.convertTo(takeoffRunway.elevation, UnitType.FOOT) + this.landingElevationOffset);
            }
        }
        else {
            this._landingElevation.set(UnitType.METER.convertTo(takeoffRunway.elevation, UnitType.FOOT) + this.landingElevationOffset);
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.updateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/**
 * A Boeing altitude preselector display box.
 */
class AltPreselectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.altAlerterRef = FSComponent.createRef();
        this.metricAltRef = FSComponent.createRef();
        this.selectedAltitudeHundredsSubject = ComputedSubject.create(null, (feetAlt) => {
            return feetAlt ? `${feetAlt % 1000}`.padEnd(3, '0') : '-----';
        });
        this.selectedAltitudeThousandsSubject = ComputedSubject.create(null, (feetAlt) => {
            return feetAlt ? `${Math.floor(feetAlt / 1000)}` : '';
        });
        this.metricAltSubject = ComputedSubject.create(null, (feetAlt) => {
            return feetAlt ? `${MathUtils.round(UnitType.FOOT.convertTo(feetAlt, UnitType.METER), 10)}` : '-----';
        });
        this.isPaused = true;
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subs.push(this.props.selectedAltitude.sub(this.updateSelectedAltitude.bind(this), true, this.isPaused), this.props.showMetric.sub(v => {
            this.metricAltRef.instance.classList.toggle('hidden', !v);
        }, true, this.isPaused), this.props.altitudeAlertState.sub(this.onAlerterStateChanged.bind(this), true, this.isPaused));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const sub of this.subs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const sub of this.subs) {
            sub.pause();
        }
    }
    /**
     * A method called when a selected altitude value changes from the event bus.
     * @param alt The selected altitude value.
     */
    updateSelectedAltitude(alt) {
        this.selectedAltitudeThousandsSubject.set(alt);
        this.selectedAltitudeHundredsSubject.set(alt);
        this.metricAltSubject.set(alt);
    }
    /**
     * A method called when the alt alerter state is changed.
     * @param state is the altitude alerter state
     */
    onAlerterStateChanged(state) {
        this.altAlerterRef.instance.classList.toggle('approaching-alert-border', state === AltAlertState.WITHIN_900);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "alt-preselect-container" },
            FSComponent.buildComponent("div", { class: "alt-preselect-box metric hidden", ref: this.metricAltRef },
                FSComponent.buildComponent("div", null,
                    FSComponent.buildComponent("span", { class: "alt-preselect-hundreds metric" },
                        this.metricAltSubject,
                        FSComponent.buildComponent("span", { class: "alt-preselect-unit" }, "M")))),
            FSComponent.buildComponent("div", { class: "black-box alt-preselect-box" },
                FSComponent.buildComponent("div", { class: "alt-preselect-value", ref: this.altAlerterRef },
                    FSComponent.buildComponent("span", { class: "alt-preselect-thousands" }, this.selectedAltitudeThousandsSubject),
                    FSComponent.buildComponent("span", { class: "alt-preselect-hundreds" }, this.selectedAltitudeHundredsSubject)))));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link BaroDataProvider} which sources data from one ADC at a time or from the ADC
 * chosen by an ADC selector.
 */
class DefaultBaroDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param perfPlan The active performance plan.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, perfPlan, index, useSelector = false) {
        this.bus = bus;
        this.perfPlan = perfPlan;
        this.useSelector = useSelector;
        this._baroInHg = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.baroInHg = this._baroInHg;
        this._isStd = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isStd = this._isStd;
        this._preselectInHg = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.preselectInHg = this._preselectInHg;
        this._isPreselectManual = Subject.create(false);
        /** @inheritdoc */
        this.isPreselectManual = this._isPreselectManual;
        /** @inheritdoc */
        this.isQfe = this.perfPlan.approachLandingRef.map(ref => ref === 0).pause();
        this._isBaroAlertActive = Subject.create(false);
        /** @inheritdoc */
        this.isBaroAlertActive = this._isBaroAlertActive;
        this.indicatedAltitude = ConsumerValue.create(null, 0);
        this.manualPreselectArmedValue = undefined;
        this.isClimbingBaroAlertArmed = false;
        this.isDescendingBaroAlertArmed = false;
        this.isAdcAltitudeDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isDataFailed = this.isAdcAltitudeDataValid.map(SubscribableMapFunctions.not());
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.pauseable = [
            this._baroInHg,
            this._isStd,
            this._preselectInHg,
            this.isQfe,
            this.indicatedAltitude,
            this.isAdcAltitudeDataValid
        ];
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultBaroDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_altitude_data_valid_${index}`));
            }
            this._baroInHg.setConsumer(sub.on(`adc_altimeter_baro_setting_inhg_${index}`));
            this._isStd.setConsumer(sub.on(`adc_altimeter_baro_is_std_${index}`));
            this._preselectInHg.setConsumer(sub.on(`adc_altimeter_baro_preselect_inhg_${index}`));
            this.indicatedAltitude.setConsumer(sub.on(`adc_indicated_alt_${index}`));
        }, true);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultBaroDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
        this.updateSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultBaroDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        this.updateSub.pause();
        this.isClimbingBaroAlertArmed = false;
        this.isDescendingBaroAlertArmed = false;
    }
    /**
     * Updates this data provider.
     */
    update() {
        this.updateManualPreselect();
        this.updateBaroAlert();
    }
    /**
     * Updates whether preselected baro setting has been manually changed.
     */
    updateManualPreselect() {
        if (this._isStd.get()) {
            if (this.manualPreselectArmedValue === undefined) {
                this.manualPreselectArmedValue = this._preselectInHg.get();
            }
            else {
                if (this._preselectInHg.get() !== this.manualPreselectArmedValue) {
                    this.manualPreselectArmedValue = undefined;
                    this._isPreselectManual.set(true);
                }
            }
        }
        else {
            this.manualPreselectArmedValue = undefined;
            this._isPreselectManual.set(false);
        }
    }
    /**
     * Updates the state of the baro alert.
     */
    updateBaroAlert() {
        if (this.isDataFailed.get()) {
            this._isBaroAlertActive.set(false);
            this.isClimbingBaroAlertArmed = false;
            this.isDescendingBaroAlertArmed = false;
            return;
        }
        let isAlertActive = false;
        const isStd = this._isStd.get();
        const indicatedAltitude = this.indicatedAltitude.get();
        const transitionAltitude = this.perfPlan.transitionAltitude.get();
        const transitionLevel = this.perfPlan.transitionLevel.get();
        if (this.isClimbingBaroAlertArmed) {
            if (!isStd && indicatedAltitude > transitionAltitude) {
                isAlertActive = true;
            }
            else if (isStd) {
                this.isClimbingBaroAlertArmed = false;
            }
        }
        else {
            this.isClimbingBaroAlertArmed = !isStd && indicatedAltitude <= transitionAltitude;
        }
        if (this.isDescendingBaroAlertArmed) {
            if (isStd && indicatedAltitude < transitionLevel) {
                isAlertActive = true;
            }
            else if (!isStd) {
                this.isDescendingBaroAlertArmed = false;
            }
        }
        else {
            this.isDescendingBaroAlertArmed = isStd && indicatedAltitude >= transitionLevel;
        }
        this._isBaroAlertActive.set(isAlertActive);
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.updateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * An approach reference display.
 */
class ApproachReference extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.hidden = MappedSubject.create(([approachName, hudTakeoff]) => approachName === null && !hudTakeoff, this.props.dataProvider.approachName, this.props.dataProvider.hudTakeoffIsActive).pause();
        this.line1Hidden = this.props.dataProvider.approachIsVisual.map(isVisual => isVisual === true).pause();
        this.identText = MappedSubject.create(([isLoc, locIdent, locFreq, name]) => { var _a; return isLoc ? ((_a = locIdent !== null && locIdent !== void 0 ? locIdent : locFreq === null || locFreq === void 0 ? void 0 : locFreq.toFixed(2)) !== null && _a !== void 0 ? _a : '') : (name !== null && name !== void 0 ? name : ''); }, this.props.dataProvider.approachIsLoc, this.props.dataProvider.locIdent, this.props.dataProvider.locFrequency, this.props.dataProvider.approachName).pause();
        this.courseText = this.props.dataProvider.approachCourse.map(course => {
            if (course === null) {
                return '';
            }
            const rounded = Math.round(course);
            return rounded === 0 ? 360 : rounded.toString().padStart(3, '0');
        }).pause();
        this.frequencyDisagree = this.props.dataProvider.tunedLocFrequencyDisagree.map(disagree => disagree === true).pause();
        this.courseDisagree = this.props.dataProvider.selectedLocCourseDisagree.map(disagree => disagree === true).pause();
        this.locDmeRounded = this.props.dataProvider.locDme.map(dme => dme === null ? null : MathUtils.round(dme, 0.1)).pause();
        this.mapDistanceRounded = this.props.dataProvider.approachMapDistance.map(dme => dme === null ? null : MathUtils.round(dme, 0.1)).pause();
        this.distanceText = MappedSubject.create(([isLoc, locDme, mapIdent, mapDistance]) => {
            let prefix;
            let distance;
            if (isLoc) {
                prefix = 'DME';
                distance = locDme;
            }
            else {
                prefix = mapIdent !== null && mapIdent !== void 0 ? mapIdent : '';
                distance = mapDistance;
            }
            if (distance === null) {
                return `${prefix} ---`;
            }
            else {
                return `${prefix} ${distance >= 100 ? distance.toFixed(0) : distance.toFixed(1)}`;
            }
        }, this.props.dataProvider.approachIsLoc, this.locDmeRounded, this.props.dataProvider.approachMapIdent, this.mapDistanceRounded).pause();
        this.pauseable = [
            this.hidden,
            this.line1Hidden,
            this.identText,
            this.courseText,
            this.frequencyDisagree,
            this.courseDisagree,
            this.distanceText
        ];
        this.isPaused = true;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.approachIsLocSub = this.props.dataProvider.approachIsLoc.sub(this.onApproachIsLocChanged.bind(this), true, this.isPaused);
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        var _a;
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
        (_a = this.approachIsLocSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        var _a;
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        (_a = this.approachIsLocSub) === null || _a === void 0 ? void 0 : _a.pause();
        this.locDmeRounded.pause();
        this.mapDistanceRounded.pause();
    }
    /**
     * Responds to when whether the selected approach is a localizer-based approach changes.
     * @param isLoc Whether the selected approach is a localizer-based approach, or `null` if approach data is
     * unavailable.
     */
    onApproachIsLocChanged(isLoc) {
        if (isLoc === null) {
            this.locDmeRounded.pause();
            this.mapDistanceRounded.pause();
        }
        else if (isLoc) {
            this.mapDistanceRounded.pause();
            this.locDmeRounded.resume();
        }
        else {
            this.locDmeRounded.pause();
            this.mapDistanceRounded.resume();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'approach-reference': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent("div", { class: {
                    'approach-reference-line': true,
                    'approach-reference-line-1': true,
                    'hidden': this.line1Hidden
                } },
                FSComponent.buildComponent("span", { class: { 'approach-reference-ident': true, 'approach-reference-disagree': this.frequencyDisagree } }, this.identText),
                "/",
                FSComponent.buildComponent("span", { class: { 'approach-reference-course': true, 'approach-reference-disagree': this.courseDisagree } },
                    this.courseText,
                    "\u00B0")),
            FSComponent.buildComponent("div", { class: "approach-reference-line approach-reference-line-2" }, this.distanceText)));
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A default implementation of {@link ApproachReferenceDataProvider}.
 */
class DefaultApproachReferenceDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ilsNavIndicator The ILS nav indicator.
     */
    constructor(bus, ilsNavIndicator) {
        this.bus = bus;
        this.ilsNavIndicator = ilsNavIndicator;
        this.hudTakeoffRunway = ConsumerSubject.create(null, null).pause();
        this.onGround = ConsumerSubject.create(null, true);
        this.flightDirector1 = ConsumerSubject.create(null, false);
        this.flightDirector2 = ConsumerSubject.create(null, false);
        this.isFlightDirectorOn = MappedSubject.create(SubscribableMapFunctions.or(), this.flightDirector1, this.flightDirector2);
        this.approachDetails = ConsumerSubject.create(null, undefined).pause();
        this.fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        this.approachTuningMode = ConsumerSubject.create(null, ApproachTuningMode.Park).pause();
        this.distanceToDest = ConsumerSubject.create(null, 0).pause();
        this.todLegIndex = ConsumerSubject.create(null, -1).pause();
        this.distanceToTod = ConsumerSubject.create(null, 0).pause();
        this.isCloseToDest = this.distanceToDest.map(distance => distance < 150); // < 150 NM
        this.isCloseToTod = MappedSubject.create(([legIndex, distance]) => legIndex >= 0 && distance < 92600, // < 50 NM
        this.todLegIndex, this.distanceToTod);
        this.isTakeoffDataAvailable = MappedSubject.create(([hudTakeoffRunway, onGround, fmsOperatingPhase]) => hudTakeoffRunway !== null && onGround && fmsOperatingPhase <= FmsOperatingPhase.TAKEOFF, this.hudTakeoffRunway, this.onGround, this.fmsOperatingPhase);
        /** Approach reference data shows within 150 of dest, within 50 of ToD, during descent, or when manually tuned for a precision app */
        this.isApproachDataAvailable = MappedSubject.create(([approachDetails, approachTuningMode, closeToDest, closeToToD, fmsOperatingPhase]) => {
            if (approachDetails === undefined) {
                return false;
            }
            if (approachDetails.approachName === '') {
                return false;
            }
            const apprIsLoc = BoeingFmsUtils.isLocalizerApproach(approachDetails.approachType);
            if (((!apprIsLoc || (apprIsLoc && approachTuningMode === ApproachTuningMode.Autotuned)) && (closeToDest || closeToToD))
                || fmsOperatingPhase === FmsOperatingPhase.DESCENT || fmsOperatingPhase === FmsOperatingPhase.APPROACH) {
                return true;
            }
            return apprIsLoc && approachTuningMode === ApproachTuningMode.ManuallyTuned;
        }, this.approachDetails, this.approachTuningMode, this.isCloseToDest, this.isCloseToTod, this.fmsOperatingPhase);
        this.isVisApproach = this.approachDetails.map(details => details && details.approachType === AdditionalApproachType.APPROACH_TYPE_VISUAL);
        this.isLocApproach = this.approachDetails.map(details => details && BoeingFmsUtils.isLocalizerApproach(details.approachType));
        /** @inheritdoc */
        this.approachName = MappedSubject.create(([approachDetails, isAvail]) => !isAvail || !approachDetails || approachDetails.approachName === '' ? null : approachDetails.approachName, this.approachDetails, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.approachCourse = MappedSubject.create(([takeoffRunway, isTakeoffAvail, approachDetails, isApproachAvail]) => {
            if (isTakeoffAvail && takeoffRunway && takeoffRunway.ilsFrequency) {
                return takeoffRunway.ilsFrequency.localizerCourse;
            }
            else if (isApproachAvail && approachDetails && approachDetails.finalApproachCourse >= 0) {
                return approachDetails.finalApproachCourse;
            }
            return null;
        }, this.hudTakeoffRunway, this.isTakeoffDataAvailable, this.approachDetails, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.approachMapIdent = MappedSubject.create(([approachDetails, isAvail]) => !isAvail || !approachDetails || approachDetails.missedApproachFacility === null
            ? null
            : ICAO.getIdent(approachDetails.missedApproachFacility.icao), this.approachDetails, this.isApproachDataAvailable);
        this.distanceToMap = ConsumerSubject.create(null, Number.MAX_SAFE_INTEGER);
        /** @inheritdoc */
        this.approachMapDistance = MappedSubject.create(([distanceToRunway, isAvail]) => !isAvail || distanceToRunway >= Number.MAX_SAFE_INTEGER ? null : distanceToRunway, this.distanceToMap, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.approachIsVisual = MappedSubject.create(([isVis, isAvail]) => !isAvail ? null : isVis, this.isVisApproach, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.hudTakeoffIsActive = MappedSubject.create(([onGround, hudTakeoffRunway, flightDirector, fmsPhase]) => onGround && hudTakeoffRunway !== null && flightDirector && fmsPhase <= FmsOperatingPhase.TAKEOFF, this.onGround, this.hudTakeoffRunway, this.isFlightDirectorOn, this.fmsOperatingPhase);
        /** @inheritdoc */
        this.approachIsLoc = MappedSubject.create(([isLoc, isApprAvail, isHudTo]) => isHudTo ? true : !isApprAvail ? null : isLoc, this.isLocApproach, this.isApproachDataAvailable, this.hudTakeoffIsActive);
        /** @inheritdoc */
        this.locIdent = MappedSubject.create(([takeoffRunway, isTakeoffAvail, approachDetails, isApproachAvail]) => {
            if (isTakeoffAvail && takeoffRunway && takeoffRunway.ilsFrequency) {
                return ICAO.getIdent(takeoffRunway.ilsFrequency.icao);
            }
            else if (isApproachAvail && approachDetails && approachDetails.referenceFacility && approachDetails.referenceFacility.type === VorType.ILS) {
                return ICAO.getIdent(approachDetails.referenceFacility.icao);
            }
            return null;
        }, this.hudTakeoffRunway, this.isTakeoffDataAvailable, this.approachDetails, this.isApproachDataAvailable);
        /** @inheritdoc */
        this.locFrequency = MappedSubject.create(([takeoffRunway, isTakeoffAvail, approachDetails, isApproachAvail]) => {
            if (isTakeoffAvail && takeoffRunway && takeoffRunway.ilsFrequency) {
                return takeoffRunway.ilsFrequency.freqMHz;
            }
            else if (isApproachAvail && approachDetails && approachDetails.referenceFacility && approachDetails.referenceFacility.type === VorType.ILS) {
                return approachDetails.referenceFacility.freqMHz;
            }
            return null;
        }, this.hudTakeoffRunway, this.isTakeoffDataAvailable, this.approachDetails, this.isApproachDataAvailable);
        this.isLocDmeValid = MappedSubject.create(([isTakeoffAvail, isApproachAvail, isLocApproach, hasDme, signal]) => (isTakeoffAvail || (isApproachAvail && isLocApproach)) && hasDme && signal !== null && signal > 0, this.isTakeoffDataAvailable, this.isApproachDataAvailable, this.isLocApproach, this.ilsNavIndicator.hasDme, this.ilsNavIndicator.signalStrength).pause();
        this._locDme = Subject.create(null);
        /** @inheritdoc */
        this.locDme = this._locDme;
        this.tunedLocFrequencyDisagreeSource = ConsumerSubject.create(null, false);
        /** @inheritdoc */
        this.tunedLocFrequencyDisagree = MappedSubject.create(([isAvail, isLocApproach, disagree]) => !isAvail || !isLocApproach ? null : disagree, this.isApproachDataAvailable, this.isLocApproach, this.tunedLocFrequencyDisagreeSource);
        this.selectedLocCourseDisagreeSource = ConsumerSubject.create(null, false);
        /** @inheritdoc */
        this.selectedLocCourseDisagree = MappedSubject.create(([isAvail, isLocApproach, disagree]) => !isAvail || !isLocApproach ? null : disagree, this.isApproachDataAvailable, this.isLocApproach, this.selectedLocCourseDisagreeSource);
        this.pauseable = [
            this.hudTakeoffRunway,
            this.onGround,
            this.flightDirector1,
            this.flightDirector2,
            this.approachDetails,
            this.fmsOperatingPhase,
            this.approachTuningMode,
            this.distanceToDest,
            this.todLegIndex,
            this.distanceToTod,
            this.distanceToMap,
            this.isLocDmeValid,
            this.tunedLocFrequencyDisagreeSource,
            this.selectedLocCourseDisagreeSource
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultApproachReferenceDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.hudTakeoffRunway.setConsumer(sub.on('boeing_hud_takeoff_runway_set'));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.flightDirector1.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.flightDirector2.setConsumer(sub.on('ap_boeing_flight_director_is_active_2'));
        this.approachDetails.setConsumer(sub.on('active_approach_details_set'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this.approachTuningMode.setConsumer(sub.on('approach_tuning_mode'));
        this.distanceToDest.setConsumer(sub.on('lnavdata_destination_distance_direct'));
        this.todLegIndex.setConsumer(sub.on('boeingvnav_performance_tod_global_leg_index'));
        this.distanceToTod.setConsumer(sub.on('boeingvnav_performance_tod_distance'));
        this.distanceToMap.setConsumer(sub.on('lnavdata_distance_to_map_direct'));
        this.tunedLocFrequencyDisagreeSource.setConsumer(sub.on('approach_frequency_mismatch'));
        this.selectedLocCourseDisagreeSource.setConsumer(sub.on('approach_course_mismatch'));
        this.locDmePipe = this.ilsNavIndicator.distance.pipe(this._locDme, true);
        this.isLocDmeValidSub = this.isLocDmeValid.sub(isValid => {
            if (isValid) {
                this.locDmePipe.resume(true);
            }
            else {
                this.locDmePipe.pause();
                this._locDme.set(null);
            }
        }, false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultApproachReferenceDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
        this.isLocDmeValidSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultApproachReferenceDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        this.isLocDmeValidSub.pause();
        this.locDmePipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * A Boeing deviation indicator.
 */
class DeviationIndicator extends DisplayComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.npDeviationScaled = MappedSubject.create(([deviation, rnp]) => deviation === null ? null : deviation / rnp, this.props.npDeviation, this.props.rnp).pause();
        this.isNpDeviationNotFullScale = this.npDeviationScaled.map(deviation => deviation !== null && Math.abs(deviation) < 1.1);
        /** Maneuvering space available to stay within 95% RNP requirement (considering estimated ANP) */
        this.maneuverSpace = MappedSubject.create(([rnp, anp]) => anp < 0 ? 0 : MathUtils.clamp(rnp - anp, 0, rnp), this.props.rnp, this.props.anp).pause();
        this.maneuverSpaceScaled = MappedSubject.create(([rnp, anp]) => {
            if (anp < 0 || rnp <= 0) {
                return 0;
            }
            return MathUtils.clamp(rnp - anp, 0, rnp) / rnp;
        }, this.props.rnp, this.props.anp).pause();
        this.isNpAlertActive = MappedSubject.create(SubscribableMapFunctions.and(), this.props.isNpDeviationAlertActive, this.props.npDeviationVisible);
        this.npDeviationHidden = this.props.npDeviationVisible.map(SubscribableMapFunctions.not()).pause();
        this.npScaleHidden = MappedSubject.create(SubscribableMapFunctions.nor(), this.props.npScaleVisible, this.props.ianScaleVisible).pause();
        this.npDeviationPointerHidden = MappedSubject.create(SubscribableMapFunctions.or(), this.npDeviationHidden, this.npScaleHidden);
        this.isNpDeviationScaleFlashActive = Subject.create(false);
        this.npDeviationScaleFlashTimer = new DebounceTimer();
        this.isNpDeviationPointerFlashActive = Subject.create(false);
        this.npDeviationPointerFlashTimer = new DebounceTimer();
        this.ianDeviationScaled = MappedSubject.create(([deviation, rnp]) => deviation === null ? null : deviation / rnp, this.props.ianDeviation, this.props.rnp).pause();
        /** IAN FAC/GP indicator is white when non-precision deviation is shown */
        this.isIanDeviationPointerSubdued = this.props.npDeviationVisible.map(SubscribableMapFunctions.identity()).pause();
        this.isIanDeviationNotFullScale = MappedSubject.create(([deviation, subdued]) => deviation !== null && Math.abs(deviation) < 1.1 && !subdued, this.ianDeviationScaled, this.isIanDeviationPointerSubdued);
        this.isIanAlertActive = MappedSubject.create(SubscribableMapFunctions.and(), this.props.isIanDeviationAlertActive, this.props.ianDeviationVisible);
        this.ianDeviationHidden = this.props.ianDeviationVisible.map(SubscribableMapFunctions.not()).pause();
        this.ianScaleHidden = this.props.ianScaleVisible.map(SubscribableMapFunctions.not()).pause();
        this.ianDeviationPointerHidden = MappedSubject.create(SubscribableMapFunctions.or(), this.ianDeviationHidden, this.ianScaleHidden);
        this.isIanDeviationPointerFlashActive = Subject.create(false);
        this.ianDeviationPointerFlashTimer = new DebounceTimer();
        // NP scale is shared by NP and IAN pointers
        this.isNpScaleAlertActive = MappedSubject.create(([isUnableRnpAlertActive, npScaleVisible, isNpDeviationAlertActive, isIanDeviationAlertActive]) => npScaleVisible && (isUnableRnpAlertActive || isNpDeviationAlertActive || isIanDeviationAlertActive), this.props.isUnableRnpAlertActive, this.props.npScaleVisible, this.isNpAlertActive, this.isIanAlertActive);
        this.anpBarsHidden = MappedSubject.create(SubscribableMapFunctions.nor(), this.props.npDeviationVisible, this.props.ianDeviationVisible);
        this.isLsDeviationValid = this.props.lsDeviation.map(deviation => deviation !== null).pause();
        this.lsDeviationScaled = MappedSubject.create(([deviation, reducedScale]) => deviation === null ? null : reducedScale ? deviation * 1.5 : deviation * 0.5, this.props.lsDeviation, (_a = this.props.expandedLsScale) !== null && _a !== void 0 ? _a : Subject.create(false)).pause();
        this.isLsDeviationAlertActive = this.props.isLsDeviationAlertActive.map(SubscribableMapFunctions.identity());
        this.isLsDeviationFlashActive = Subject.create(false);
        this.lsDeviationFlashTimer = new DebounceTimer();
        /** Landing System scale is shown when LS signal is valid and NPS not shown */
        this.lsScaleHidden = MappedSubject.create(([lsRequested, npsShown]) => !lsRequested || npsShown, this.props.lsScaleVisible, this.props.npScaleVisible).pause();
        /** Landing System indicator is filled when with 2.5 dots (0.3875 ddm for loc, 0.4375 ddm for gs), and active source */
        this.isLsDeviationPointerFilled = MappedSubject.create(([lsDeviation, npScaleVisible, alert]) => lsDeviation !== null && Math.abs(lsDeviation) < 2.5 && !npScaleVisible && !alert, this.props.lsDeviation, this.props.npScaleVisible, this.props.isLsDeviationAlertActive).pause();
        /** Landing System indicator is white when non-precision scale is shown */
        this.isLsDeviationPointerSubdued = this.props.npScaleVisible.map(SubscribableMapFunctions.identity()).pause();
        this.anpBarLeftTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.anpBarRightTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.npDeviationPointerTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.ianDeviationPointerTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.lsDeviationPointerTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('%', 'px', 'px'));
        this.isAlive = true;
        this.isAwake = false;
        this.isRendered = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isRendered = true;
        this.maneuverSpaceScaled.sub(this.updateAnpBars.bind(this), true);
        this.npDeviationScaled.sub(this.updateNpDeviationPointer.bind(this), true);
        // shared by NP and IAN
        const deactivateNpDeviationScaleFlash = this.isNpDeviationScaleFlashActive.set.bind(this.isNpDeviationScaleFlashActive, false);
        this.isNpScaleAlertActive.sub(alert => {
            if (alert) {
                this.isNpDeviationScaleFlashActive.set(true);
                this.npDeviationScaleFlashTimer.schedule(deactivateNpDeviationScaleFlash, DeviationIndicator.NP_SCALE_FLASH_DURATION);
            }
            else {
                this.npDeviationScaleFlashTimer.clear();
                deactivateNpDeviationScaleFlash();
            }
        }, true);
        const deactivateNpDeviationPointerFlash = this.isNpDeviationPointerFlashActive.set.bind(this.isNpDeviationPointerFlashActive, false);
        this.isNpAlertActive.sub(alert => {
            if (alert) {
                this.isNpDeviationPointerFlashActive.set(true);
                this.npDeviationPointerFlashTimer.schedule(deactivateNpDeviationPointerFlash, DeviationIndicator.NP_POINTER_FLASH_DURATION);
            }
            else {
                this.npDeviationPointerFlashTimer.clear();
                deactivateNpDeviationPointerFlash();
            }
        }, true);
        this.ianDeviationScaled.sub(this.updateIanDeviationPointer.bind(this), true);
        const deactivateIanDeviationPointerFlash = this.isIanDeviationPointerFlashActive.set.bind(this.isIanDeviationPointerFlashActive, false);
        this.isIanAlertActive.sub(alert => {
            if (alert) {
                this.isIanDeviationPointerFlashActive.set(true);
                this.ianDeviationPointerFlashTimer.schedule(deactivateIanDeviationPointerFlash, DeviationIndicator.IAN_POINTER_FLASH_DURATION);
            }
            else {
                this.ianDeviationPointerFlashTimer.clear();
                deactivateIanDeviationPointerFlash();
            }
        }, true);
        this.lsDeviationScaled.sub(this.updateLsDeviationPointer.bind(this), true);
        const deactivateLsDeviationFlash = this.isLsDeviationFlashActive.set.bind(this.isLsDeviationFlashActive, false);
        this.isLsDeviationAlertActive.sub(alert => {
            if (alert) {
                this.isLsDeviationFlashActive.set(true);
                this.lsDeviationFlashTimer.schedule(deactivateLsDeviationFlash, DeviationIndicator.LS_POINTER_FLASH_DURATION);
            }
            else {
                this.lsDeviationFlashTimer.clear();
                deactivateLsDeviationFlash();
            }
        }, true);
        if (this.props.isLsPointerFlashing) {
            this.isLsPointerFlashingPipe = this.isLsDeviationFlashActive.pipe(this.props.isLsPointerFlashing);
        }
        if (this.isAwake) {
            this.wakeSubscriptions();
        }
    }
    /**
     * Resumes all of this indicator's subscriptions that need to be resumed and paused when the indicator is awake and
     * asleep, respectively.
     */
    wakeSubscriptions() {
        this.npDeviationScaled.resume();
        this.maneuverSpace.resume();
        this.maneuverSpaceScaled.resume();
        this.npDeviationHidden.resume();
        this.npScaleHidden.resume();
        this.ianDeviationScaled.resume();
        this.ianDeviationHidden.resume();
        this.ianScaleHidden.resume();
        this.isIanDeviationPointerSubdued.resume();
        this.isLsDeviationValid.resume();
        this.lsDeviationScaled.resume();
        this.lsScaleHidden.resume();
        this.isLsDeviationPointerFilled.resume();
        this.isLsDeviationPointerSubdued.resume();
    }
    /**
     * Wakes this indicator. While awake, this indicator will update its rendered elements.
     * @throws Error if this indicator has been destroyed.
     */
    wake() {
        if (!this.isAlive) {
            throw new Error('DeviationIndicator: cannot wake a dead indicator');
        }
        if (this.isAwake) {
            return;
        }
        this.isAwake = true;
        if (!this.isRendered) {
            return;
        }
        this.wakeSubscriptions();
    }
    /**
     * Puts this indicator to sleep. While asleep, this indicator will not update its rendered elements.
     * @throws Error if this indicator has been destroyed.
     */
    sleep() {
        if (!this.isAlive) {
            throw new Error('DeviationIndicator: cannot sleep a dead indicator');
        }
        if (!this.isAwake) {
            return;
        }
        this.isAwake = false;
        if (!this.isRendered) {
            return;
        }
        this.npDeviationScaled.pause();
        this.maneuverSpace.pause();
        this.maneuverSpaceScaled.pause();
        this.npDeviationHidden.pause();
        this.npScaleHidden.pause();
        this.ianDeviationScaled.pause();
        this.ianDeviationHidden.pause();
        this.ianScaleHidden.pause();
        this.isIanDeviationPointerSubdued.pause();
        this.isLsDeviationValid.pause();
        this.lsDeviationScaled.pause();
        this.lsScaleHidden.pause();
        this.isLsDeviationPointerFilled.pause();
        this.isLsDeviationPointerSubdued.pause();
    }
    /**
     * Updates the position of this indicator's NP deviation pointer.
     */
    updateNpDeviationPointer() {
        var _a;
        const deviation = -((_a = this.npDeviationScaled.get()) !== null && _a !== void 0 ? _a : 0);
        this.npDeviationPointerTransform.transform.set(MathUtils.clamp(deviation, -1.1, 1.1) * 40, 0, 0, 0.1);
        this.npDeviationPointerTransform.resolve();
    }
    /**
     * Updates the position of this indicator's IAN deviation pointer.
     */
    updateIanDeviationPointer() {
        var _a;
        const deviation = -((_a = this.ianDeviationScaled.get()) !== null && _a !== void 0 ? _a : 0);
        this.ianDeviationPointerTransform.transform.set(MathUtils.clamp(deviation, -1.1, 1.1) * 40, 0, 0, 0.1);
        this.ianDeviationPointerTransform.resolve();
    }
    /**
     * Updates the position of this indicator's landing system deviation pointer.
     */
    updateLsDeviationPointer() {
        var _a;
        const deviation = (_a = this.lsDeviationScaled.get()) !== null && _a !== void 0 ? _a : 0;
        this.lsDeviationPointerTransform.transform.set(MathUtils.clamp(deviation, -1.25, 1.25) * 40, 0, 0, 0.1);
        this.lsDeviationPointerTransform.resolve();
    }
    /**
     * Updates this indicator's ANP bars.
     * @param maneuverSpaceScaled The current NP maneuver space (RNP minus ANP) divided by RNP.
     */
    updateAnpBars(maneuverSpaceScaled) {
        const offset = maneuverSpaceScaled * 80 / 0.88;
        this.anpBarLeftTransform.transform.set(-offset, 0, 0, 0.1);
        this.anpBarLeftTransform.resolve();
        this.anpBarRightTransform.transform.set(offset, 0, 0, 0.1);
        this.anpBarRightTransform.resolve();
    }
    /** @inheritdoc */
    render() {
        var _a, _b, _c, _d;
        return (FSComponent.buildComponent("div", { class: "deviation-box" },
            FSComponent.buildComponent("div", { class: {
                    'deviation-background-fmc': true,
                    'translucent-box': true,
                    'hidden': this.npScaleHidden
                } }),
            FSComponent.buildComponent("div", { class: {
                    'deviation-background-ls': true,
                    'translucent-box': true,
                    'hidden': this.lsScaleHidden
                } }),
            FSComponent.buildComponent("div", { class: {
                    'deviation-scale-container': true,
                    'deviation-scale-container-np': true,
                    'hidden': this.npScaleHidden,
                    'alert': this.isNpAlertActive,
                    'flash': this.isNpDeviationScaleFlashActive
                } },
                FSComponent.buildComponent("svg", { class: "deviation-scale deviation-scale-np", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" },
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "68%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "68%" })),
                FSComponent.buildComponent("div", { class: { 'hidden': this.anpBarsHidden }, style: "position: absolute; left: 6%; top: 0px; width: 88%; height: 100%; overflow: hidden;" },
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar-end", style: "position: absolute; left: 0px;" }),
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar", style: {
                            'position': 'absolute',
                            'right': '50%',
                            'width': '50%',
                            'transform': this.anpBarLeftTransform
                        } }),
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar-end", style: "position: absolute; right: 0px;" }),
                    FSComponent.buildComponent("div", { class: "deviation-anp-bar", style: {
                            'position': 'absolute',
                            'left': '50%',
                            'width': '50%',
                            'transform': this.anpBarRightTransform
                        } })),
                FSComponent.buildComponent("svg", { class: "deviation-scale deviation-scale-np", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" },
                    FSComponent.buildComponent("line", { x1: "10%", y1: "16%", x2: "10%", y2: "58%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "10%", y1: "16%", x2: "10%", y2: "58%" }),
                    FSComponent.buildComponent("line", { x1: "90%", y1: "16%", x2: "90%", y2: "58%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "90%", y1: "16%", x2: "90%", y2: "58%" }),
                    FSComponent.buildComponent("g", { class: "fac-gp-ticks", visibility: this.props.ianScaleVisible.map(vis => vis ? 'inherit' : 'hidden') },
                        FSComponent.buildComponent("line", { x1: "30%", y1: "16%", x2: "30%", y2: "58%", class: "shadow" }),
                        FSComponent.buildComponent("line", { x1: "30%", y1: "16%", x2: "30%", y2: "58%" }),
                        FSComponent.buildComponent("line", { x1: "70%", y1: "16%", x2: "70%", y2: "58%", class: "shadow" }),
                        FSComponent.buildComponent("line", { x1: "70%", y1: "16%", x2: "70%", y2: "58%" })))),
            FSComponent.buildComponent("div", { class: {
                    'translatable': true,
                    'hidden': this.npDeviationPointerHidden,
                    'alert': this.isNpAlertActive,
                    'flash': this.isNpDeviationPointerFlashActive
                }, style: {
                    'transform': this.npDeviationPointerTransform
                } },
                FSComponent.buildComponent("svg", { viewBox: "-12 0 24 32", class: {
                        'deviation-pointer': true,
                        'deviation-pointer-np': true
                    }, style: "overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", stroke: "var(--deviation-pointer-np-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isNpDeviationNotFullScale.map(filled => filled ? 'var(--deviation-pointer-np-color)' : 'none') }))),
            FSComponent.buildComponent("div", { class: {
                    'translatable': true,
                    'hidden': this.ianDeviationPointerHidden,
                    'alert': this.isIanAlertActive,
                    'flash': this.isIanDeviationPointerFlashActive
                }, style: {
                    'transform': this.ianDeviationPointerTransform
                } },
                FSComponent.buildComponent("svg", { viewBox: "-12 0 24 32", class: {
                        'deviation-pointer': true,
                        'deviation-pointer-ian': true,
                        'deviation-pointer-ian-subdued': this.isIanDeviationPointerSubdued
                    }, style: "overflow: visible;" },
                    FSComponent.buildComponent("g", { visibility: this.isIanDeviationPointerSubdued.map((v) => v ? 'inherit' : 'hidden') },
                        FSComponent.buildComponent("path", { d: "M 0 0 l 9 24 l -18 0 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 0 0 l 9 24 l -18 0 z", stroke: "var(--deviation-pointer-ian-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isIanDeviationNotFullScale.map(filled => filled ? 'var(--deviation-pointer-ian-color)' : 'none') })),
                    FSComponent.buildComponent("g", { visibility: this.isIanDeviationPointerSubdued.map((v) => v ? 'hidden' : 'inherit') },
                        FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                        FSComponent.buildComponent("path", { d: "M 0 0 l 12 32 l -24 0 z", stroke: "var(--deviation-pointer-ian-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isIanDeviationNotFullScale.map(filled => filled ? 'var(--deviation-pointer-ian-color)' : 'none') })))),
            FSComponent.buildComponent("div", { class: {
                    'translatable': true,
                    'hidden': this.isLsDeviationValid.map(SubscribableMapFunctions.not()),
                    'alert': this.isLsDeviationAlertActive,
                    'flash': this.isLsDeviationFlashActive
                }, style: {
                    'transform': this.lsDeviationPointerTransform
                } },
                FSComponent.buildComponent("svg", { viewBox: "-17 -9 34 18", class: {
                        'deviation-pointer': true,
                        'deviation-pointer-ls': true,
                        'deviation-pointer-ls-subdued': this.isLsDeviationPointerSubdued
                    }, style: "overflow: visible;" },
                    FSComponent.buildComponent("path", { d: "M 0 -9 l 17 9 l -17 9 l -17 -9 z", class: "shadow", stroke: "black", "stroke-width": "var(--deviation-pointer-shadow-stroke-width)", fill: "none" }),
                    FSComponent.buildComponent("path", { d: "M 0 -9 l 17 9 l -17 9 l -17 -9 z", stroke: "var(--deviation-pointer-ls-color)", "stroke-width": "var(--deviation-pointer-stroke-width)", fill: this.isLsDeviationPointerFilled.map(filled => filled ? 'var(--deviation-pointer-ls-color)' : 'none') }))),
            FSComponent.buildComponent("div", { class: {
                    'deviation-scale-container': true,
                    'deviation-scale-container-ls': true,
                    'hidden': this.lsScaleHidden,
                    'alert': this.isLsDeviationAlertActive
                } },
                FSComponent.buildComponent("svg", { class: "deviation-scale deviation-scale-ls", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" },
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "95%", class: "shadow" }),
                    FSComponent.buildComponent("line", { x1: "50%", y1: "5%", x2: "50%", y2: "95%" }),
                    FSComponent.buildComponent("g", { visibility: (_b = (_a = this.props.expandedLsScale) === null || _a === void 0 ? void 0 : _a.map(reduced => reduced ? 'hidden' : 'inherit')) !== null && _b !== void 0 ? _b : 'inherit' },
                        [-2, -1, 1, 2].map(position => FSComponent.buildComponent("circle", { cx: `${(position * 20) + 50}%`, cy: "50%", r: "var(--deviation-scale-ls-dot-radius)", class: "deviation-scale-ls-dot shadow" })),
                        [-2, -1, 1, 2].map(position => FSComponent.buildComponent("circle", { cx: `${(position * 20) + 50}%`, cy: "50%", r: "var(--deviation-scale-ls-dot-radius)", class: "deviation-scale-ls-dot" }))),
                    FSComponent.buildComponent("g", { visibility: (_d = (_c = this.props.expandedLsScale) === null || _c === void 0 ? void 0 : _c.map(reduced => reduced ? 'inherit' : 'hidden')) !== null && _d !== void 0 ? _d : 'hidden' },
                        [-1.5, 1.5].map(position => FSComponent.buildComponent("rect", { x: `${(position * 20) + 50}%`, y: "50%", width: "var(--deviation-scale-ls-reduced-dot-width)", height: "var(--deviation-scale-ls-reduced-dot-height)", class: "deviation-scale-ls-reduced-dot shadow", style: "transform: translate(calc(-1 * var(--deviation-scale-ls-reduced-dot-width) / 2), calc(-1 * var(--deviation-scale-ls-reduced-dot-height) / 2))" })),
                        [-1.5, 1.5].map(position => FSComponent.buildComponent("rect", { x: `${(position * 20) + 50}%`, y: "50%", width: "var(--deviation-scale-ls-reduced-dot-width)", height: "var(--deviation-scale-ls-reduced-dot-height)", class: "deviation-scale-ls-reduced-dot", style: "transform: translate(calc(-1 * var(--deviation-scale-ls-reduced-dot-width) / 2), calc(-1 * var(--deviation-scale-ls-reduced-dot-height) / 2))" })))))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.isAlive = false;
        this.npDeviationScaleFlashTimer.clear();
        this.npDeviationPointerFlashTimer.clear();
        this.lsDeviationFlashTimer.clear();
        this.npDeviationScaled.destroy();
        this.maneuverSpace.destroy();
        this.maneuverSpaceScaled.destroy();
        this.npDeviationHidden.destroy();
        this.npScaleHidden.destroy();
        this.isNpAlertActive.destroy();
        this.isLsDeviationValid.destroy();
        this.lsDeviationScaled.destroy();
        this.isLsDeviationAlertActive.destroy();
        this.lsScaleHidden.destroy();
        this.isLsDeviationPointerFilled.destroy();
        this.isLsDeviationPointerSubdued.destroy();
        (_a = this.isLsPointerFlashingPipe) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}
DeviationIndicator.NP_SCALE_FLASH_DURATION = 3000; // milliseconds
DeviationIndicator.NP_POINTER_FLASH_DURATION = 10000; // milliseconds
DeviationIndicator.IAN_POINTER_FLASH_DURATION = 10000; // milliseconds
DeviationIndicator.LS_POINTER_FLASH_DURATION = 10000; // milliseconds

/**
 * A default implementation of {@link LateralDeviationDataProvider}.
 */
class DefaultLateralDeviationDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ilsNavIndicator The ILS nav indicator.
     * @param fmsPosIndex The index of the FMS position system that is the source of this provider's data.
     */
    constructor(bus, ilsNavIndicator, fmsPosIndex) {
        this.bus = bus;
        this.ilsNavIndicator = ilsNavIndicator;
        this.lateralNavSource = ConsumerSubject.create(null, NavigationSource.NONE).pause();
        this.fmaData = ConsumerSubject.create(null, undefined).pause();
        this._rnp = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.rnp = this._rnp;
        this._anp = Subject.create(-1);
        /** @inheritdoc */
        this.anp = this._anp;
        /** @inheritdoc */
        this.isLateralNavSourceNp = this.lateralNavSource.map(source => source === NavigationSource.NPS);
        this._isApLateralTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.lateralActive === APLateralModes.TO || fmaData.lateralActive === APLateralModes.GA);
        });
        /** @inheritdoc */
        this.isApLateralTogaActive = this._isApLateralTogaActive;
        this._isApVerticalTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.verticalActive === APVerticalModes.TO || fmaData.verticalActive === APVerticalModes.GA);
        });
        /** @inheritdoc */
        this.isApVerticalTogaActive = this._isApVerticalTogaActive;
        this._npDeviation = Subject.create(null);
        /** @inheritdoc */
        this.npDeviation = this._npDeviation;
        this._isUnableRnp = Subject.create(false);
        /** @inheritdoc */
        this.isUnableRnp = this._isUnableRnp;
        this._isNpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isNpDeviationExcessive = this._isNpDeviationExcessive;
        this._locDeviation = Subject.create(null);
        /** @inheritdoc */
        this.locDeviation = this._locDeviation;
        this._isApLocActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.LOC);
        /** @inheritdoc */
        this.isApLocActive = this._isApLocActive;
        this._isApTakeoffLocActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.TO_LOC);
        /** @inheritdoc */
        this.isApTakeoffLocActive = this._isApTakeoffLocActive;
        this._isLocDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isLocDeviationExcessive = this._isLocDeviationExcessive;
        /** @inheritdoc */
        this.isLateralNavSourceFac = this.lateralNavSource.map(source => source === NavigationSource.IAN);
        this._facDeviation = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.facDeviation = this._facDeviation;
        this._isApFacActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.FMS_LOC);
        /** @inheritdoc */
        this.isApFacActive = this._isApFacActive;
        this._isFacDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isFacDeviationExcessive = this._isFacDeviationExcessive;
        this.anpSource = ConsumerSubject.create(null, 0).pause();
        this.anpPipe = this.anpSource.pipe(this._anp, true);
        this.lnavXtkAvailable = ConsumerSubject.create(null, false).pause();
        this.lnavXtk = ConsumerSubject.create(null, 0).pause();
        this.xtkPipe = this.lnavXtk.pipe(this._npDeviation, true);
        this.facAvailable = ConsumerSubject.create(null, false).pause();
        this.locDeviationPipe = this.ilsNavIndicator.lateralDeviation.pipe(this._locDeviation, dev => dev === null ? 0 : dev * 2.5, true);
        this.apMaster = ConsumerSubject.create(null, false).pause();
        this.fdActive = ConsumerSubject.create(null, false).pause();
        this.radioAltitude = ConsumerSubject.create(null, 0).pause();
        this.fmsPosSystemState = ConsumerSubject.create(null, undefined).pause();
        this.isFmsPosDataValid = this.fmsPosSystemState.map(state => {
            return state !== undefined && (state.current === undefined || state.current === AvionicsSystemState.On);
        });
        this.hasNpDeviation = MappedSubject.create(([isDataValid, lateralNavSource, xtkAvailable]) => isDataValid && xtkAvailable && lateralNavSource === NavigationSource.NPS, this.isFmsPosDataValid, this.lateralNavSource, this.lnavXtkAvailable);
        this.isUnableRnpSource = MappedSubject.create(([rnp, anp]) => anp >= 0 && anp >= rnp, this._rnp, this._anp);
        this.isUnableRnpTimer = new DebounceTimer();
        this.isNpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._npDeviation, this.isLateralNavSourceNp);
        this.isNpDeviationExcessiveTimer = new DebounceTimer();
        this.isFacDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._facDeviation, this.isLateralNavSourceFac);
        this.isFacDeviationExcessiveTimer = new DebounceTimer();
        this.hasLocDeviation = MappedSubject.create(([signal, isLoc, facAvailable]) => !!isLoc && signal !== null && signal > 0 && !facAvailable, this.ilsNavIndicator.signalStrength, this.ilsNavIndicator.hasLocalizer, this.facAvailable).pause();
        this.excessiveLocDeviationMode = MappedSubject.create(([apMaster, fdActive, isApTakeoffLocActive, radioAltitude]) => {
            if (isApTakeoffLocActive) {
                return 'takeoff';
            }
            else if ((apMaster || fdActive) && radioAltitude < 500) {
                return 'loc';
            }
            else {
                return 'none';
            }
        }, this.apMaster, this.fdActive, this._isApTakeoffLocActive, this.radioAltitude);
        this.fdTakeoffDeviation = ConsumerSubject.create(null, null).pause();
        this.excessiveLocDeviationPipe = this._locDeviation.pipe(this._isLocDeviationExcessive, deviation => deviation !== null && Math.abs(deviation) > 1, true);
        this.excessiveTakeoffDeviationPipe = this.fdTakeoffDeviation.pipe(this._isLocDeviationExcessive, deviation => deviation !== null && Math.abs(deviation) > 23, true);
        this.pauseableSubjects = [
            this._rnp,
            this.anpSource,
            this.lnavXtkAvailable,
            this.lnavXtk,
            this.facAvailable,
            this._facDeviation,
            this.lateralNavSource,
            this.fmaData,
            this.apMaster,
            this.fdActive,
            this.radioAltitude,
            this.fmsPosSystemState,
            this.hasLocDeviation,
            this.fdTakeoffDeviation
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.fmsPosIndex = SubscribableUtils.toSubscribable(fmsPosIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultLateralDeviationDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._rnp.setConsumer(sub.on('lnavdata_rnp'));
        this.lnavXtk.setConsumer(sub.on('lnav_xtk'));
        this.lnavXtkAvailable.setConsumer(sub.on('lnav_is_tracking'));
        this.lateralNavSource.setConsumer(sub.on('lateral_nav_source'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        this.apMaster.setConsumer(sub.on('ap_master_status'));
        this.fdActive.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this.fmsPosIndexSub = this.fmsPosIndex.sub(index => {
            this.fmsPosSystemState.setConsumer(sub.on(`fms_pos_state_${index}`));
            this.anpSource.setConsumer(sub.on(`fms_pos_anp_${index}`));
        }, true);
        this.fmsPosDataValidSub = this.isFmsPosDataValid.sub(this.onFmsPosDataValidChanged.bind(this), false, true);
        this.hasNpDeviationSub = this.hasNpDeviation.sub(this.onHasNpDeviationChanged.bind(this), false, true);
        this.facAvailable.setConsumer(sub.on('boeing_ian_fac_available'));
        this._facDeviation.setConsumer(sub.on('boeing_ian_fac_deviation'));
        this.fdTakeoffDeviation.setConsumer(sub.on('fd_takeoff_deviation'));
        const activateUnableRnp = this._isUnableRnp.set.bind(this._isUnableRnp, true);
        this.isUnableRnpSub = this.isUnableRnpSource.sub(isUnableRnp => {
            if (isUnableRnp) {
                this.isUnableRnpTimer.schedule(activateUnableRnp, DefaultLateralDeviationDataProvider.UNABLE_RNP_DELAY);
            }
            else {
                this.isUnableRnpTimer.clear();
                this._isUnableRnp.set(false);
            }
        }, false, true);
        const activateExcessiveNpDeviation = this._isNpDeviationExcessive.set.bind(this._isNpDeviationExcessive, true);
        this.isNpDeviationExcessiveSub = this.isNpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isNpDeviationExcessiveTimer.schedule(activateExcessiveNpDeviation, DefaultLateralDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY);
            }
            else {
                this.isNpDeviationExcessiveTimer.clear();
                this._isNpDeviationExcessive.set(false);
            }
        }, false, true);
        const activateExcessiveFacDeviation = this._isFacDeviationExcessive.set.bind(this._isFacDeviationExcessive, true);
        this.isFacDeviationExcessiveSub = this.isFacDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isFacDeviationExcessiveTimer.schedule(activateExcessiveFacDeviation, DefaultLateralDeviationDataProvider.EXCESSIVE_FAC_DEVIATION_DELAY);
            }
            else {
                this.isFacDeviationExcessiveTimer.clear();
                this._isFacDeviationExcessive.set(false);
            }
        }, false, true);
        this.hasLocDeviationSub = this.hasLocDeviation.sub(this.onHasLocDeviationChanged.bind(this), false, true);
        this.excessiveLocDeviationModeSub = this.excessiveLocDeviationMode.sub(this.onExcessiveLocDeviationModeChanged.bind(this), false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Responds to when FMS position data validity changes.
     * @param isDataValid Whether FMS position data is valid.
     */
    onFmsPosDataValidChanged(isDataValid) {
        if (isDataValid) {
            this.anpPipe.resume(true);
        }
        else {
            this.anpPipe.pause();
            this._anp.set(-1);
        }
    }
    /**
     * Responds to when NP deviation availability changes.
     * @param hasNpDeviation Whether NP deviation is available.
     */
    onHasNpDeviationChanged(hasNpDeviation) {
        if (hasNpDeviation) {
            this.xtkPipe.resume(true);
        }
        else {
            this.xtkPipe.pause();
            this._npDeviation.set(null);
        }
    }
    /**
     * Responds to when localizer deviation availability changes.
     * @param hasLocDeviation Whether localizer deviation is available.
     */
    onHasLocDeviationChanged(hasLocDeviation) {
        if (hasLocDeviation) {
            this.locDeviationPipe.resume(true);
        }
        else {
            this.locDeviationPipe.pause();
            this._locDeviation.set(null);
        }
    }
    /**
     * Responds to when the excessive localizer deviation evaluation mode changes.
     * @param mode The new excessive evaluation deviation mode.
     */
    onExcessiveLocDeviationModeChanged(mode) {
        this.excessiveTakeoffDeviationPipe.pause();
        this.excessiveLocDeviationPipe.pause();
        switch (mode) {
            case 'takeoff':
                this.excessiveTakeoffDeviationPipe.resume(true);
                break;
            case 'loc':
                this.excessiveLocDeviationPipe.resume(true);
                break;
            default:
                this._isLocDeviationExcessive.set(false);
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultLateralDeviationDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseableSubjects) {
            subject.resume();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.isNpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.isFacDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.resume(true);
        (_f = this.hasLocDeviationSub) === null || _f === void 0 ? void 0 : _f.resume(true);
        (_g = this.excessiveLocDeviationModeSub) === null || _g === void 0 ? void 0 : _g.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultLateralDeviationDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        for (const subject of this.pauseableSubjects) {
            subject.pause();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.isNpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.isFacDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.pause();
        (_f = this.hasLocDeviationSub) === null || _f === void 0 ? void 0 : _f.pause();
        (_g = this.excessiveLocDeviationModeSub) === null || _g === void 0 ? void 0 : _g.pause();
        this.locDeviationPipe.pause();
        this.excessiveLocDeviationPipe.pause();
        this.excessiveTakeoffDeviationPipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        (_a = this.fmsPosIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const subject of this.pauseableSubjects) {
            subject.destroy();
        }
    }
}
DefaultLateralDeviationDataProvider.UNABLE_RNP_DELAY = 5000; // milliseconds
DefaultLateralDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY = 5000; // milliseconds
DefaultLateralDeviationDataProvider.EXCESSIVE_FAC_DEVIATION_DELAY = 5000; // milliseconds

/**
 * A Boeing navigation source display.
 */
class NavigationSourceDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.isFacDeviationValid = this.props.lateralDeviationDataProvider.facDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isLocDeviationValid = this.props.lateralDeviationDataProvider.locDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isGpDeviationValid = this.props.verticalDeviationDataProvider.gpDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isGsDeviationValid = this.props.verticalDeviationDataProvider.gsDeviation.map(NavigationSourceDisplay.isDeviationValid).pause();
        this.isApTogaActive = MappedSubject.create(SubscribableMapFunctions.or(), this.props.lateralDeviationDataProvider.isApLateralTogaActive, this.props.isVerticalTogaNp ? this.props.lateralDeviationDataProvider.isApVerticalTogaActive : Subject.create(false)).pause();
        this.text = MappedSubject.create(([isLateralNp, isFacDeviationValid, isLocDeviationValid, isVerticalNp, isGpDeviationValid, isGsDeviationValid, isApTogaActive]) => {
            // Sim doesn't have GLS, so we are not going to consider those cases.
            if (isVerticalNp || isGpDeviationValid || isApTogaActive) {
                // Vertical source is FMC.
                if (isLateralNp || isFacDeviationValid || isApTogaActive) {
                    // Lateral source is FMC.
                    return 'FMC';
                }
                else if (isLocDeviationValid) {
                    // Lateral source is ILS.
                    return 'ILS/FMC';
                }
                else {
                    return 'FMC';
                }
            }
            else if (isGsDeviationValid) {
                // If we have a valid glideslope deviation, then both the lateral and vertical source must be ILS.
                return 'ILS';
            }
            else {
                // Vertical source is none.
                if (isLateralNp || isFacDeviationValid || isApTogaActive) {
                    // Lateral source is FMC.
                    return 'FMC';
                }
                else if (isLocDeviationValid) {
                    // Lateral source is ILS.
                    return 'ILS';
                }
            }
            return '';
        }, this.props.lateralDeviationDataProvider.isLateralNavSourceNp, this.isFacDeviationValid, this.isLocDeviationValid, this.props.verticalDeviationDataProvider.isVerticalNavSourceNp, this.isGpDeviationValid, this.isGsDeviationValid, this.isApTogaActive).pause();
        this.isTextSmall = this.text.map(text => text.length > 3);
        this.isTextHidden = this.text.map(text => text.length === 0);
        this.isPaused = true;
        this.pauseable = [
            this.isFacDeviationValid,
            this.isLocDeviationValid,
            this.isGpDeviationValid,
            this.isGsDeviationValid,
            this.isApTogaActive,
            this.text
        ];
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'navigation-source': true,
                'navigation-source-small': this.isTextSmall,
                'hidden': this.isTextHidden
            } }, this.text));
    }
}
NavigationSourceDisplay.isDeviationValid = (deviation) => deviation !== null;

/**
 * A default implementation of {@link VerticalDeviationDataProvider}.
 */
class DefaultVerticalDeviationDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param ilsNavIndicator The ILS nav indicator.
     * @param fmsPosIndex The index of the FMS position system that is the source of this provider's data.
     */
    constructor(bus, ilsNavIndicator, fmsPosIndex) {
        this.bus = bus;
        this.ilsNavIndicator = ilsNavIndicator;
        this.verticalNavSource = ConsumerSubject.create(null, NavigationSource.NONE).pause();
        this.fmaData = ConsumerSubject.create(null, undefined).pause();
        this._fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT).pause();
        /** @inheritdoc */
        this.fmsOperatingPhase = this._fmsOperatingPhase;
        this._rnp = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.rnp = this._rnp;
        this._anp = Subject.create(-1);
        /** @inheritdoc */
        this.anp = this._anp;
        /** @inheritdoc */
        this.isVerticalNavSourceNp = this.verticalNavSource.map(source => source === NavigationSource.NPS);
        this._verticalPathAvailable = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isVerticalPathAvailable = this._verticalPathAvailable;
        this._isApLateralTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.lateralActive === APLateralModes.TO || fmaData.lateralActive === APLateralModes.GA);
        });
        /** @inheritdoc */
        this.isApLateralTogaActive = this._isApLateralTogaActive;
        this._isApVerticalTogaActive = this.fmaData.map(fmaData => {
            return fmaData !== undefined && (fmaData.verticalActive === APVerticalModes.TO || fmaData.verticalActive === APVerticalModes.GA);
        });
        /** @inheritdoc */
        this.isApVerticalTogaActive = this._isApVerticalTogaActive;
        this._npDeviation = Subject.create(null);
        /** @inheritdoc */
        this.npDeviation = this._npDeviation;
        this._isUnableRnp = Subject.create(false);
        /** @inheritdoc */
        this.isUnableRnp = this._isUnableRnp;
        this._isNpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isNpDeviationExcessive = this._isNpDeviationExcessive;
        this._gsDeviation = Subject.create(null);
        /** @inheritdoc */
        this.gsDeviation = this._gsDeviation;
        this._isApGsActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.GS);
        /** @inheritdoc */
        this.isApGsActive = this._isApGsActive;
        this.isApTakeoffLocActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.lateralActive === APLateralModes.TO_LOC);
        this._isGsDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isGsDeviationExcessive = this._isGsDeviationExcessive;
        /** @inheritdoc */
        this.isVerticalNavSourceGp = this.verticalNavSource.map(source => source === NavigationSource.IAN);
        this._gpDeviation = ConsumerSubject.create(null, null);
        /** @inheritdoc */
        this.gpDeviation = this._gpDeviation;
        this._isApGpActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.GP);
        /** @inheritdoc */
        this.isApGpActive = this._isApGpActive;
        this._isGpDeviationExcessive = Subject.create(false);
        /** @inheritdoc */
        this.isGpDeviationExcessive = this._isGpDeviationExcessive;
        this.anpSource = ConsumerSubject.create(null, 0).pause();
        this.anpPipe = this.anpSource.pipe(this._anp, true);
        this._isApFlareActive = this.fmaData.map(fmaData => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.FLARE);
        /** @inheritdoc */
        this.isApFlareActive = this._isApFlareActive;
        this.vDev = ConsumerSubject.create(null, 0).pause();
        this.vDevPipe = this.vDev.pipe(this._npDeviation, error => -error, true);
        this.gpAvailable = ConsumerSubject.create(null, false).pause();
        this.gsDeviationPipe = this.ilsNavIndicator.verticalDeviation.pipe(this._gsDeviation, dev => dev === null ? 0 : -dev * 2.5, true);
        this.apMaster = ConsumerSubject.create(null, false).pause();
        this.fdActive = ConsumerSubject.create(null, false).pause();
        this.radioAltitude = ConsumerSubject.create(null, 0).pause();
        this.fmsPosSystemState = ConsumerSubject.create(null, undefined).pause();
        this.isFmsPosDataValid = this.fmsPosSystemState.map(state => {
            return state !== undefined && (state.current === undefined || state.current === AvionicsSystemState.On);
        });
        this.hasNpDeviation = MappedSubject.create(([verticalPathAvailable, verticalNavSource]) => verticalPathAvailable && verticalNavSource === NavigationSource.NPS, this._verticalPathAvailable, this.verticalNavSource);
        this.isUnableRnpSource = MappedSubject.create(([rnp, anp]) => anp >= 0 && anp >= rnp, this._rnp, this._anp);
        this.isUnableRnpTimer = new DebounceTimer();
        this.isNpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._npDeviation, this.isVerticalNavSourceNp);
        this.isNpDeviationExcessiveTimer = new DebounceTimer();
        this.isGpDeviationExcessiveSource = MappedSubject.create(([rnp, anp, deviation, isSource]) => isSource && deviation !== null && Math.abs(deviation) > rnp - Math.max(anp, 0), this._rnp, this._anp, this._gpDeviation, this.isVerticalNavSourceGp);
        this.isGpDeviationExcessiveTimer = new DebounceTimer();
        this.hasGsDeviation = MappedSubject.create(([signal, isGs, gpAvailable, toLocActive]) => !!isGs && signal !== null && signal > 0 && !gpAvailable && !toLocActive, this.ilsNavIndicator.signalStrength, this.ilsNavIndicator.hasGlideSlope, this.gpAvailable, this.isApTakeoffLocActive);
        this.evalExcessiveGsDeviation = MappedSubject.create(([apMaster, fdActive, radioAltitude]) => (apMaster || fdActive) && radioAltitude < 500, this.apMaster, this.fdActive, this.radioAltitude);
        this.excessiveGsDeviationPipe = this._gsDeviation.pipe(this._isGsDeviationExcessive, deviation => deviation !== null && Math.abs(deviation) > 1, true);
        this.pauseableSubjects = [
            this._fmsOperatingPhase,
            this._rnp,
            this.anpSource,
            this._verticalPathAvailable,
            this.vDev,
            this.verticalNavSource,
            this.fmaData,
            this.gpAvailable,
            this._gpDeviation,
            this.apMaster,
            this.fdActive,
            this.radioAltitude,
            this.fmsPosSystemState,
            this.hasGsDeviation
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.fmsPosIndex = SubscribableUtils.toSubscribable(fmsPosIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this._fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this._rnp.setConsumer(sub.on('boeingvnav_rnp'));
        this.vDev.setConsumer(sub.on('vnav_vertical_deviation'));
        this.verticalNavSource.setConsumer(sub.on('vertical_nav_source'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        this.apMaster.setConsumer(sub.on('ap_master_status'));
        this.fdActive.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.radioAltitude.setConsumer(sub.on('ra_radio_alt_1'));
        this.fmsPosIndexSub = this.fmsPosIndex.sub(index => {
            this.fmsPosSystemState.setConsumer(sub.on(`fms_pos_state_${index}`));
            this.anpSource.setConsumer(sub.on(`fms_pos_vertical_anp_${index}`));
        }, true);
        this.fmsPosDataValidSub = this.isFmsPosDataValid.sub(this.onFmsPosDataValidChanged.bind(this), false, true);
        this.hasNpDeviationSub = this.hasNpDeviation.sub(this.onHasNpDeviationChanged.bind(this), false, true);
        this._verticalPathAvailable.setConsumer(sub.on('vnav_path_available'));
        this.gpAvailable.setConsumer(sub.on('boeing_ian_gp_available'));
        this._gpDeviation.setConsumer(sub.on('boeing_ian_gp_deviation'));
        const activateUnableRnp = this._isUnableRnp.set.bind(this._isUnableRnp, true);
        this.isUnableRnpSub = this.isUnableRnpSource.sub(isUnableRnp => {
            if (isUnableRnp) {
                this.isUnableRnpTimer.schedule(activateUnableRnp, DefaultVerticalDeviationDataProvider.UNABLE_RNP_DELAY);
            }
            else {
                this.isUnableRnpTimer.clear();
                this._isUnableRnp.set(false);
            }
        }, false, true);
        const activateExcessiveNpDeviation = this._isNpDeviationExcessive.set.bind(this._isNpDeviationExcessive, true);
        this.isNpDeviationExcessiveSub = this.isNpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isNpDeviationExcessiveTimer.schedule(activateExcessiveNpDeviation, DefaultVerticalDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY);
            }
            else {
                this.isNpDeviationExcessiveTimer.clear();
                this._isNpDeviationExcessive.set(false);
            }
        }, false, true);
        const activateExcessiveGpDeviation = this._isGpDeviationExcessive.set.bind(this._isGpDeviationExcessive, true);
        this.isGpDeviationExcessiveSub = this.isGpDeviationExcessiveSource.sub(deviationExcessive => {
            if (deviationExcessive) {
                this.isGpDeviationExcessiveTimer.schedule(activateExcessiveGpDeviation, DefaultVerticalDeviationDataProvider.EXCESSIVE_GP_DEVIATION_DELAY);
            }
            else {
                this.isGpDeviationExcessiveTimer.clear();
                this._isGpDeviationExcessive.set(false);
            }
        }, false, true);
        this.hasGsDeviationSub = this.hasGsDeviation.sub(this.onHasGsDeviationChanged.bind(this), false, true);
        this.evalExcessiveGsDeviationSub = this.evalExcessiveGsDeviation.sub(this.onEvalExcessiveGsDeviationChanged.bind(this), false, true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Responds to when FMS position data validity changes.
     * @param isDataValid Whether FMS position data is valid.
     */
    onFmsPosDataValidChanged(isDataValid) {
        if (isDataValid) {
            this.anpPipe.resume(true);
        }
        else {
            this.anpPipe.pause();
            this._anp.set(-1);
        }
    }
    /**
     * Responds to when NP deviation availability changes.
     * @param hasNpDeviation Whether NP deviation is available.
     */
    onHasNpDeviationChanged(hasNpDeviation) {
        if (hasNpDeviation) {
            this.vDevPipe.resume(true);
        }
        else {
            this.vDevPipe.pause();
            this._npDeviation.set(null);
        }
    }
    /**
     * Responds to when glideslope deviation availability changes.
     * @param hasGsDeviation Whether glideslope deviation is available.
     */
    onHasGsDeviationChanged(hasGsDeviation) {
        if (hasGsDeviation) {
            this.gsDeviationPipe.resume(true);
        }
        else {
            this.gsDeviationPipe.pause();
            this._gsDeviation.set(null);
        }
    }
    /**
     * Responds to when whether to evaluate excessive glideslope deviation changes.
     * @param evaluate Whether to evaluate excessive glideslope deviation.
     */
    onEvalExcessiveGsDeviationChanged(evaluate) {
        if (evaluate) {
            this.excessiveGsDeviationPipe.resume(true);
        }
        else {
            this.excessiveGsDeviationPipe.pause();
            this._isGsDeviationExcessive.set(false);
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseableSubjects) {
            subject.resume();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.resume(true);
        (_d = this.isGpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.resume(true);
        (_e = this.isNpDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.resume(true);
        (_f = this.hasGsDeviationSub) === null || _f === void 0 ? void 0 : _f.resume(true);
        (_g = this.evalExcessiveGsDeviationSub) === null || _g === void 0 ? void 0 : _g.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('DefaultVerticalDeviationDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        for (const subject of this.pauseableSubjects) {
            subject.pause();
        }
        (_a = this.fmsPosDataValidSub) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.hasNpDeviationSub) === null || _b === void 0 ? void 0 : _b.pause();
        (_c = this.isUnableRnpSub) === null || _c === void 0 ? void 0 : _c.pause();
        (_d = this.isGpDeviationExcessiveSub) === null || _d === void 0 ? void 0 : _d.pause();
        (_e = this.isNpDeviationExcessiveSub) === null || _e === void 0 ? void 0 : _e.pause();
        (_f = this.hasGsDeviationSub) === null || _f === void 0 ? void 0 : _f.pause();
        (_g = this.evalExcessiveGsDeviationSub) === null || _g === void 0 ? void 0 : _g.pause();
        this.gsDeviationPipe.pause();
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        this.isUnableRnpTimer.clear();
        this.isNpDeviationExcessiveTimer.clear();
        (_a = this.fmsPosIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const subject of this.pauseableSubjects) {
            subject.destroy();
        }
    }
}
DefaultVerticalDeviationDataProvider.UNABLE_RNP_DELAY = 5000; // milliseconds
DefaultVerticalDeviationDataProvider.EXCESSIVE_NP_DEVIATION_DELAY = 5000; // milliseconds
DefaultVerticalDeviationDataProvider.EXCESSIVE_GP_DEVIATION_DELAY = 5000; // milliseconds

/**
 * An FMA mode display slot.
 */
class FmaModeSlot extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.rootCssClass = SetSubject.create(['fma-mode']);
        this.activeModeText = Subject.create('');
        this.alertTimer = new DebounceTimer();
        this.isActiveFailed = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isFailedSub = this.props.isFailed.sub(isFailed => {
            if (isFailed) {
                this.onFailed();
            }
            else if (this.isActiveFailed) {
                this.onRecovered();
            }
        }, true);
        this.activeModeSub = this.props.active.sub(active => {
            this.onActiveModeChanged(active);
        }, true);
    }
    /**
     * Responds to changes in this slot's active mode.
     * @param active The active mode.
     */
    onActiveModeChanged(active) {
        this.activeModeText.set(active);
        if (active.length > 0) {
            this.addBox();
        }
        else {
            this.removeBox();
        }
    }
    /**
     * Responds to when this slot's mode enters a failed state.
     */
    onFailed() {
        this.isActiveFailed = true;
        this.rootCssClass.add('fma-mode-failed');
    }
    /**
     * Responds to when this slot's mode exits a failed state.
     */
    onRecovered() {
        this.isActiveFailed = false;
        this.rootCssClass.delete('fma-mode-failed');
        if (this.activeModeText.get().length > 0) {
            this.addBox();
        }
    }
    /**
     * Adds the FMA alert box style.
     */
    addBox() {
        // schedule clears pending timers
        this.alertTimer.schedule(() => {
            this.rootCssClass.delete('fma-mode-alert');
        }, FmaModeSlot.ALERT_DURATION);
        this.rootCssClass.add('fma-mode-alert');
    }
    /**
     * Removes the FMA alert box style.
     */
    removeBox() {
        this.rootCssClass.delete('fma-mode-alert');
        this.alertTimer.clear();
    }
    /** @inheritdoc */
    render() {
        if (this.props.class !== undefined) {
            const reservedClasses = ['fma-mode', 'fma-mode-alert', 'fma-mode-failed'];
            if (typeof this.props.class === 'string') {
                FSComponent.parseCssClassesFromString(this.props.class)
                    .filter(cssClass => !reservedClasses.includes(cssClass))
                    .forEach(cssClass => { this.rootCssClass.add(cssClass); });
            }
            else {
                this.cssClassSub = FSComponent.bindCssClassSet(this.rootCssClass, this.props.class, reservedClasses);
            }
        }
        return (FSComponent.buildComponent("div", { class: this.rootCssClass }, this.activeModeText));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.cssClassSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.activeModeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.isFailedSub) === null || _c === void 0 ? void 0 : _c.destroy();
        super.destroy();
    }
}
FmaModeSlot.ALERT_DURATION = 10000; // milliseconds

/**
 * Computes a smoothed flight path to be used for a flight path vector.
 */
class FlightPathVectorComputer {
    /**
     * Creates a new instance of FlightPathVectorComputer.
     * @param trackSmoothingTau The smoothing time constant for ground track, in milliseconds.
     * @param gsSmoothingTau The smoothing time constant for ground speed, in milliseconds.
     * @param vsSmoothingTau The smoothing time constant for vertical speed, in milliseconds.
     * @param accelSmoothingTau The smoothing time constant for acceleration, in milliseconds.
     */
    constructor(trackSmoothingTau, gsSmoothingTau, vsSmoothingTau, accelSmoothingTau) {
        this._track = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._gs = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._vs = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._pitch = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._speed = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this._acceleration = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        /**
         * The computed flight path true ground track, in degrees. Has a value of `NaN` if this computer has not been updated
         * since it was created or reset.
         */
        this.fpTrack = this._track;
        /**
         * The computed flight path ground speed, in knots. Has a value of `NaN` if this computer has not been updated since
         * it was created or reset.
         */
        this.fpGs = this._gs;
        /**
         * The computed flight path vertical speed, in feet per minute. Has a value of `NaN` if this computer has not been
         * updated since it was created or reset.
         */
        this.fpVs = this._vs;
        /**
         * The computed flight path pitch angle, in degrees. Positive values represent ascending flight paths. Has a value of
         * `NaN` if this computer has not been updated since it was created or reset.
         */
        this.fpPitch = this._pitch;
        /**
         * The computed flight path speed, in knots. Has a value of `NaN` if this computer has not been updated since it was
         * created or reset.
         */
        this.fpSpeed = this._speed;
        /**
         * The computed flight path acceleration, in knots per second. Has a value of `NaN` if this computer has not been
         * updated since it was created or reset.
         */
        this.fpAcceleration = this._acceleration;
        this.trackSmoother = new ExpSmoother(trackSmoothingTau);
        this.gsSmoother = new ExpSmoother(gsSmoothingTau);
        this.vsSmoother = new ExpSmoother(vsSmoothingTau);
        this.accelSmoother = new ExpSmoother(accelSmoothingTau);
    }
    /**
     * Updates this computer's flight path values.
     * @param heading The airplane's current true heading, in degrees.
     * @param groundTrack The airplane's current true ground track, in degrees.
     * @param groundSpeed The airplane's current ground speed, in knots.
     * @param verticalSpeed The airplane's current vertical speed, in feet per minute.
     * @param acceleration The airplane's current along-track acceleration, in knots per second.
     * @param dt The time elapsed since the last update, in milliseconds.
     */
    update(heading, groundTrack, groundSpeed, verticalSpeed, acceleration, dt) {
        let gs = this.gsSmoother.next(groundSpeed, dt);
        let vs = this.vsSmoother.next(verticalSpeed, dt);
        const accel = this.accelSmoother.next(acceleration, dt);
        // Sim can report wildly oscillating numbers for ground track at low speeds, so use heading when < 5 knots GS.
        this._track.set(this.smoothGroundTrack(groundSpeed < 5 ? heading : groundTrack, dt));
        // With smoothing, GS/VS will never reach zero from a positive initial value, so we will manually set them to zero
        // once they are below a certain threshold (in this case 1 mm/sec).
        if (gs < 1.94e-3) {
            gs = 0;
        }
        if (Math.abs(vs) < 0.197) {
            vs = 0;
        }
        this._gs.set(gs);
        this._vs.set(vs);
        const vsKnot = UnitType.FPM.convertTo(vs, UnitType.KNOT);
        const speed = Math.hypot(gs, vsKnot);
        // We don't want the pitch value to oscillate when absolute speed is low, so we will manually set it to zero when
        // speed is less than 5 knots.
        this._pitch.set(speed < 5 ? 0 : Math.atan2(vsKnot, gs) * Avionics.Utils.RAD2DEG);
        this._speed.set(speed);
        this._acceleration.set(accel);
    }
    /**
     * Smooths a ground track value.
     * @param track A ground track value.
     * @param dt The elapsed time, in milliseconds, since the last smoothed value was calculated.
     * @returns A smoothed ground track value.
     */
    smoothGroundTrack(track, dt) {
        const last = this.trackSmoother.last();
        if (last !== null && !isNaN(last)) {
            // need to handle wraparounds
            let delta = track - last;
            if (delta > 180) {
                delta = delta - 360;
            }
            else if (delta < -180) {
                delta = delta + 360;
            }
            track = last + delta;
        }
        const next = last !== null && isNaN(last) ? this.trackSmoother.reset(track) : this.trackSmoother.next(track, dt);
        const normalized = (next + 360) % 360; // enforce range 0-359
        return this.trackSmoother.reset(normalized);
    }
    /**
     * Resets this computer's flight path values to `NaN`.
     */
    reset() {
        this.trackSmoother.reset();
        this.gsSmoother.reset();
        this.vsSmoother.reset();
        this.accelSmoother.reset();
        this._track.set(NaN);
        this._gs.set(NaN);
        this._vs.set(NaN);
        this._pitch.set(NaN);
        this._speed.set(NaN);
        this._acceleration.set(NaN);
    }
}

/**
 * A default implementation of {@link VerticalSpeedDataProvider} which sources data from one ADC at a time or from the
 * ADC chosen by an ADC selector.
 */
class DefaultVerticalSpeedDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of the ADC that is the source of this provider's data if {@linkcode useSelector} is
     * `false`, or the index of the ADC selector to use to choose the source ADC if `useSelector` is `true`.
     * @param useSelector Whether to source data from the ADC chosen by an ADC selector. Defaults to `false`.
     */
    constructor(bus, index, useSelector = false) {
        this.bus = bus;
        this.useSelector = useSelector;
        this._verticalSpeed = ConsumerSubject.create(null, 0).pause();
        /** @inheritdoc */
        this.verticalSpeed = this._verticalSpeed;
        this.selectedVerticalSpeedSource = ConsumerSubject.create(null, 0).pause();
        this.fmaData = ConsumerSubject.create(null, undefined).pause();
        /** @inheritdoc */
        this.selectedVerticalSpeed = MappedSubject.create(([selectedVs, fmaData]) => fmaData !== undefined && fmaData.verticalActive === APVerticalModes.VS ? selectedVs : null, this.selectedVerticalSpeedSource, this.fmaData);
        this.isAdcAltitudeDataValid = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isDataFailed = this.isAdcAltitudeDataValid.map(SubscribableMapFunctions.not());
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.pauseable = [
            this._verticalSpeed,
            this.selectedVerticalSpeedSource,
            this.fmaData,
            this.isAdcAltitudeDataValid
        ];
        if (useSelector) {
            this.adcSelectorIndex = SubscribableUtils.toSubscribable(index, true);
            this.adcIndex = ConsumerSubject.create(null, -1);
        }
        else {
            this.adcIndex = SubscribableUtils.toSubscribable(index, true);
        }
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalSpeedDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        if (this.adcSelectorIndex) {
            this.adcSelectorIndexSub = this.adcSelectorIndex.sub(index => {
                this.adcIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
            }, true);
        }
        this.adcIndexSub = this.adcIndex.sub(index => {
            if (!this.useSelector) {
                this.isAdcAltitudeDataValid.setConsumer(sub.on(`adc_altitude_data_valid_${index}`));
            }
            this._verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
        }, true);
        this.selectedVerticalSpeedSource.setConsumer(sub.on('ap_vs_selected'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalSpeedDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultVerticalSpeedDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        (_a = this.adcSelectorIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        if (this.useSelector) {
            this.adcIndex.destroy();
        }
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/**
 * The Boeing vertical speed indicator.
 */
class VerticalSpeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.topReadoutHidden = Subject.create(false);
        this.bottomReadoutHidden = Subject.create(false);
        this.selectedBugHidden = Subject.create(false);
        this.selectedBugTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.translateY('%')));
        this.pointerY1 = Subject.create(0);
        this.pointerY2 = Subject.create(0);
        this.topReadoutValue = Subject.create(0);
        this.bottomReadoutValue = Subject.create(0);
        this.isPaused = true;
        this.pauseableSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.selectedBugTransform.transform.getChild(1).set(-50);
        this.pauseableSubs.push(this.props.dataProvider.verticalSpeed.sub(this.onVerticalSpeedChanged.bind(this), true, this.isPaused), this.props.dataProvider.selectedVerticalSpeed.pipe(this.selectedBugHidden, selected => selected === null, this.isPaused), this.props.dataProvider.selectedVerticalSpeed.sub(this.onSelectedVerticalSpeedChanged.bind(this), true, this.isPaused));
    }
    /**
     * Resumes this component. When the component is resumed, it will update its rendering.
     */
    resume() {
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const sub of this.pauseableSubs) {
            sub.resume(true);
        }
    }
    /**
     * Pauses this component. When the component is paused, it will not update its rendering.
     */
    pause() {
        if (this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const sub of this.pauseableSubs) {
            sub.pause();
        }
    }
    /**
     * Responds to when vertical speed changes.
     * @param verticalSpeed The new vertical speed, in feet per minute.
     */
    onVerticalSpeedChanged(verticalSpeed) {
        if (verticalSpeed >= 400) {
            this.topReadoutHidden.set(false);
            this.topReadoutValue.set(MathUtils.floor(Math.abs(verticalSpeed), 50));
        }
        else {
            this.topReadoutHidden.set(true);
        }
        if (verticalSpeed <= -400) {
            this.bottomReadoutHidden.set(false);
            this.bottomReadoutValue.set(MathUtils.floor(Math.abs(verticalSpeed), 50));
        }
        else {
            this.bottomReadoutHidden.set(true);
        }
        const pointerPosition = this.getVerticalSpeedPosition(verticalSpeed) * this.props.scaleHeight;
        this.pointerY1.set(MathUtils.round(pointerPosition, 0.1));
        this.pointerY2.set(MathUtils.round(MathUtils.lerp(this.props.scaleWidth, 0, this.props.scaleWidth + this.props.pointerOriginOffset, 0, pointerPosition), 0.1));
    }
    /**
     * Responds to changes in the selected vertical speed.
     * @param selected The new selected vertical speed, in feet per minute.
     */
    onSelectedVerticalSpeedChanged(selected) {
        const bugPosition = this.getVerticalSpeedPosition(selected !== null && selected !== void 0 ? selected : 0) * this.props.scaleHeight;
        this.selectedBugTransform.transform.getChild(0).set(0, bugPosition, 0, undefined, 0.1);
        this.selectedBugTransform.resolve();
    }
    /**
     * Gets the vertical position on this indicator's scale corresponding to a given vertical speed, scaled to the range
     * `[-0.5, 0.5]`.
     * @param verticalSpeed A vertical speed, in feet per minute.
     * @returns The vertical position on this indicator's scale corresponding to the specified vertical speed, scaled to
     * the range `[-0.5, 0.5]`.
     */
    getVerticalSpeedPosition(verticalSpeed) {
        if (verticalSpeed === 0) {
            return 0;
        }
        const sign = verticalSpeed < 0 ? -1 : 1;
        verticalSpeed *= sign;
        if (verticalSpeed < 1000) {
            return -sign * MathUtils.lerp(verticalSpeed, 0, 1000, 0, 0.225);
        }
        else if (verticalSpeed < 2000) {
            return -sign * MathUtils.lerp(verticalSpeed, 1000, 2000, 0.225, 0.385);
        }
        else if (verticalSpeed < 6000) {
            return -sign * MathUtils.lerp(verticalSpeed, 2000, 6000, 0.385, 0.5);
        }
        else {
            return -sign * 0.5;
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "vertical-speed" },
            FSComponent.buildComponent("div", { class: "vertical-speed-coordinate-box", style: `position: absolute; top: 50%; width: ${this.props.scaleWidth}px; height: 0px;` },
                this.renderScale(),
                FSComponent.buildComponent("svg", { viewBox: `0 ${-this.props.scaleHeight / 2} ${this.props.scaleWidth} ${this.props.scaleHeight}`, class: "vertical-speed-pointer-container", style: `position: absolute; left: 0px; top: ${-this.props.scaleHeight / 2}px; width: ${this.props.scaleWidth}px; height: ${this.props.scaleHeight}px; overflow: visible;` },
                    FSComponent.buildComponent("line", { x1: 0, y1: this.pointerY1, x2: this.props.scaleWidth, y2: this.pointerY2, class: "vertical-speed-pointer shadow" }),
                    FSComponent.buildComponent("line", { x1: 0, y1: this.pointerY1, x2: this.props.scaleWidth, y2: this.pointerY2, class: "vertical-speed-pointer" })),
                FSComponent.buildComponent("svg", { viewBox: "-5 -5 10 10", preserveAspectRatio: "none", class: { 'vertical-speed-bug': true, 'hidden': this.selectedBugHidden }, style: {
                        'position': 'absolute',
                        'top': '0px',
                        'transform': this.selectedBugTransform,
                        'overflow': 'visible'
                    } },
                    FSComponent.buildComponent("line", { x1: -5, y1: -5, x2: 5, y2: -5, class: "vertical-speed-bug-bar shadow" }),
                    FSComponent.buildComponent("line", { x1: -5, y1: 5, x2: 5, y2: 5, class: "vertical-speed-bug-bar shadow" }),
                    FSComponent.buildComponent("line", { x1: -5, y1: -5, x2: 5, y2: -5, class: "vertical-speed-bug-bar" }),
                    FSComponent.buildComponent("line", { x1: -5, y1: 5, x2: 5, y2: 5, class: "vertical-speed-bug-bar" }))),
            FSComponent.buildComponent("div", { class: { 'vertical-speed-readout': true, 'vertical-speed-readout-top': true, 'hidden': this.topReadoutHidden } }, this.topReadoutValue),
            FSComponent.buildComponent("div", { class: { 'vertical-speed-readout': true, 'vertical-speed-readout-bottom': true, 'hidden': this.bottomReadoutHidden } }, this.bottomReadoutValue)));
    }
    /**
     * Renders this indicator's scale.
     * @returns This indicator's scale, as a VNode.
     */
    renderScale() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("svg", { class: "vertical-speed-scale-tick-container", style: "position: absolute; left: 0px; top: 0px; width: 100%; height: 1px; overflow: visible;" },
                [-6000, -4000, -2000, -1500, -1000, -500, 0, 500, 1000, 1500, 2000, 4000, 6000].map((fpm, index) => {
                    const y = this.getVerticalSpeedPosition(fpm) * this.props.scaleHeight;
                    const length = fpm === 0 ? this.props.scaleZeroTickLength : this.props.scaleTickLength;
                    return (FSComponent.buildComponent("line", { x1: this.props.scaleTickOffset, y1: y, x2: this.props.scaleTickOffset + length, y2: y, class: {
                            'vertical-speed-scale-tick': true,
                            'shadow': true,
                            'vertical-speed-scale-tick-zero': fpm === 0,
                            'vertical-speed-scale-tick-major': index % 2 === 0,
                            'vertical-speed-scale-tick-minor': fpm !== 0 && index % 2 === 1
                        } }));
                }),
                [-6000, -4000, -2000, -1500, -1000, -500, 0, 500, 1000, 1500, 2000, 4000, 6000].map((fpm, index) => {
                    const y = this.getVerticalSpeedPosition(fpm) * this.props.scaleHeight;
                    const length = fpm === 0 ? this.props.scaleZeroTickLength : this.props.scaleTickLength;
                    return (FSComponent.buildComponent("line", { x1: this.props.scaleTickOffset, y1: y, x2: this.props.scaleTickOffset + length, y2: y, class: {
                            'vertical-speed-scale-tick': true,
                            'vertical-speed-scale-tick-zero': fpm === 0,
                            'vertical-speed-scale-tick-major': index % 2 === 0,
                            'vertical-speed-scale-tick-minor': fpm !== 0 && index % 2 === 1
                        } }));
                })),
            /* Labels */
            [-6000, -2000, -1000, 1000, 2000, 6000].map(fpm => {
                return (FSComponent.buildComponent("div", { class: "vertical-speed-scale-label", style: `position: absolute; top: ${this.getVerticalSpeedPosition(fpm) * this.props.scaleHeight}px;` }, (Math.abs(fpm) / 1000).toFixed(0)));
            })));
    }
}

/**
 * A default implementation of {@link AoaDataProvider}.
 */
class DefaultAoaDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param aoaIndex The index of the AoA computer that is the source of this provider's data.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     */
    constructor(bus, aoaIndex, adcIndex) {
        this.bus = bus;
        this._aoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.aoa = this._aoa;
        this._normAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.normAoa = this._normAoa;
        this._stallAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.stallAoa = this._stallAoa;
        this._zeroLiftAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.zeroLiftAoa = this._zeroLiftAoa;
        this.ias = ConsumerValue.create(null, 0);
        this._isOnGround = ConsumerSubject.create(null, false);
        /** @inheritdoc */
        this.isOnGround = this._isOnGround;
        this.aoaCoefSmoother = new ExpSmoother(DefaultAoaDataProvider.AOA_COEF_SMOOTHING_TAU);
        this._normAoaIasCoef = Subject.create(null);
        /** @inheritdoc */
        this.normAoaIasCoef = this._normAoaIasCoef;
        this._normAoaIasCoef1g = Subject.create(null);
        /** @inheritdoc */
        this.normAoaIasCoef1g = this._normAoaIasCoef1g;
        this._isDataFailed = Subject.create(false);
        /** @inheritdoc */
        this.isDataFailed = this._isDataFailed;
        this.loadFactorSource = ConsumerValue.create(null, 1);
        this.loadFactorSmoother = new ExpSmoother(DefaultAoaDataProvider.LOAD_FACTOR_SMOOTHING_TAU);
        this.loadFactor = 1;
        this.aoaSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.adcSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.isAdcDataFailed = false;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = false;
        this.aoaIndex = SubscribableUtils.toSubscribable(aoaIndex, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.isPaused = paused;
        const sub = this.bus.getSubscriber();
        this._isOnGround.setConsumer(sub.on('on_ground'));
        this.aoaIndexSub = this.aoaIndex.sub(index => {
            this._aoa.setConsumer(sub.on(`aoa_aoa_${index}`));
            this._normAoa.setConsumer(sub.on(`aoa_norm_aoa_${index}`));
            this._stallAoa.setConsumer(sub.on(`aoa_stall_aoa_${index}`));
            this._zeroLiftAoa.setConsumer(sub.on(`aoa_zero_lift_aoa_${index}`));
            this.loadFactorSource.setConsumer(sub.on(`aoa_load_factor_${index}`));
            this.aoaSystemState.setConsumer(sub.on(`aoa_state_${index}`));
        }, true);
        this.adcIndexSub = this.adcIndex.sub(index => {
            this.ias.setConsumer(sub.on(`adc_ias_${index}`));
            this.adcSystemState.setConsumer(sub.on(`adc_state_${index}`));
        }, true);
        this.aoaSystemState.sub(state => {
            if (state.current === undefined || state.current === AvionicsSystemState.On) {
                this._isDataFailed.set(false);
            }
            else {
                this._isDataFailed.set(true);
            }
        }, true);
        this.adcSystemState.sub(state => {
            this.isAdcDataFailed = !(state.current === undefined || state.current === AvionicsSystemState.On);
        }, true);
        this.clockSub = sub.on('realTime').handle(this.update.bind(this));
        if (paused) {
            this.pause();
        }
    }
    /** @inheritdoc */
    aoaToNormAoa(aoa) {
        const zeroLiftAoa = this._zeroLiftAoa.get();
        return (aoa - zeroLiftAoa) / (this._stallAoa.get() - zeroLiftAoa);
    }
    /** @inheritdoc */
    normAoaToAoa(normAoa) {
        const zeroLiftAoa = this._zeroLiftAoa.get();
        return normAoa * (this._stallAoa.get() - zeroLiftAoa) + zeroLiftAoa;
    }
    /** @inheritdoc */
    estimateIasFromAoa(aoa, loadFactor) {
        return this.estimateIasFromNormAoa(this.aoaToNormAoa(aoa), loadFactor);
    }
    /** @inheritdoc */
    estimateIasFromNormAoa(normAoa, loadFactor) {
        var _a;
        const ratio = loadFactor === undefined ? 1 : loadFactor / this.loadFactor;
        return Math.sqrt(((_a = this._normAoaIasCoef.get()) !== null && _a !== void 0 ? _a : NaN) * ratio / normAoa);
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot resume a dead provider');
        }
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this._aoa.resume();
        this._normAoa.resume();
        this._stallAoa.resume();
        this._zeroLiftAoa.resume();
        this.loadFactorSource.resume();
        this.ias.resume();
        this._isOnGround.resume();
        this.aoaSystemState.resume();
        this.adcSystemState.resume();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot pause a dead provider');
        }
        if (this.isPaused) {
            return;
        }
        this._aoa.pause();
        this._normAoa.pause();
        this._stallAoa.pause();
        this._zeroLiftAoa.pause();
        this.loadFactorSource.pause();
        this.ias.pause();
        this._isOnGround.pause();
        this.aoaSystemState.pause();
        this.adcSystemState.pause();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.pause();
        this.lastUpdateTime = undefined;
        this.aoaCoefSmoother.reset();
        this.loadFactorSmoother.reset();
        this.isPaused = true;
    }
    /**
     * Updates this data provider.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (this._isDataFailed.get() || this.isAdcDataFailed || this._isOnGround.get()) {
            this._normAoaIasCoef.set(null);
            this.loadFactor = 1;
            this.aoaCoefSmoother.reset();
            this.loadFactorSmoother.reset();
            this.lastUpdateTime = undefined;
            return;
        }
        const dt = this.lastUpdateTime === undefined ? 0 : Math.max(0, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
        const normAoa = this._normAoa.get();
        const ias = this.ias.get();
        const iasSquared = ias * ias;
        const coef = normAoa * iasSquared;
        this._normAoaIasCoef.set(this.aoaCoefSmoother.next(coef, dt));
        this.loadFactor = this.loadFactorSmoother.next(this.loadFactorSource.get(), dt);
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        this._aoa.destroy();
        this._normAoa.destroy();
        this._stallAoa.destroy();
        this._zeroLiftAoa.destroy();
        this.loadFactorSource.destroy();
        this.ias.destroy();
        this._isOnGround.destroy();
        this.aoaSystemState.destroy();
        this.adcSystemState.destroy();
        (_a = this.aoaIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.clockSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}
DefaultAoaDataProvider.AOA_COEF_SMOOTHING_TAU = 2000 / Math.LN2;
DefaultAoaDataProvider.LOAD_FACTOR_SMOOTHING_TAU = 2000 / Math.LN2;

/**
 * An active map flightplan waypoint icon that can be set to flash.
 */
class ActiveWaypointIcon extends MapWaypointImageIcon {
    constructor() {
        super(...arguments);
        this.isDisplayed = true;
    }
    /**
     * Sets whether or not the icon is displayed.
     * @param isDisplayed Whether or not the icon is displayed.
     */
    setDisplayed(isDisplayed) {
        this.isDisplayed = isDisplayed;
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, left, top) {
        if (this.isDisplayed) {
            super.drawIconAt(context, mapProjection, left, top);
        }
    }
}

/**
 * A collection of common keys used by the BoeingMap API.
 */
class BoeingMapKeys {
}
BoeingMapKeys.Tod = 'tod';
BoeingMapKeys.CtrWpt = 'ctrwpt';
BoeingMapKeys.CompassArcLowerLayer = 'compass-arc-lower-layer';
BoeingMapKeys.CompassArcUpperLayer = 'compass-arc-upper-layer';
BoeingMapKeys.CompassCenterLowerLayer = 'compass-center-lower-layer';
BoeingMapKeys.CompassCenterUpperLayer = 'compass-center-upper-layer';
BoeingMapKeys.MapFormatController = 'map-format-controller';
BoeingMapKeys.PlanFormatController = 'plan-format-controller';
BoeingMapKeys.RangeController = 'RangeController';
BoeingMapKeys.WaypointDisplayController = 'WaypointDisplayController';
BoeingMapKeys.PlanLowerLayer = 'plan-lower-layer';
BoeingMapKeys.PlanUpperLayer = 'plan-upper-layer';
BoeingMapKeys.OwnShipTriLayer = 'ownship-tri';
BoeingMapKeys.OwnShipOutlineLayer = 'ownship-outline';
BoeingMapKeys.OwnShipXtkErrorLayer = 'ownship-xtk-error';
BoeingMapKeys.PlanAirportsLayer = 'plan-airports';
BoeingMapKeys.PositionTrendVector = 'trackVector';
BoeingMapKeys.NdDataProvider = 'NdDataProvider';
BoeingMapKeys.MapStyles = 'MapStyles';
BoeingMapKeys.VNavData = 'VNavData';
BoeingMapKeys.TcasAdvisoryStatusLayer = 'tcas-advisory-status-layer';
BoeingMapKeys.TerrainWeatherState = 'terrain-weather-state';

/**
 * Updates the properties in a {@link MapAutopilotPropsModule}.
 */
class BoeingMapAutopilotPropsController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.subs.push(sub.on('ap_altitude_selected_3').atFrequency(4).handle(alt => this.module.selectedAltitude.set(alt, UnitType.FOOT)));
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.subs.forEach(sub => sub.destroy());
    }
}

/** Bitflags that describe which map waypoint types should be displayed. */
var MapWaypointsDisplay;
(function (MapWaypointsDisplay) {
    MapWaypointsDisplay[MapWaypointsDisplay["None"] = 0] = "None";
    MapWaypointsDisplay[MapWaypointsDisplay["NearestAirports"] = 1] = "NearestAirports";
    MapWaypointsDisplay[MapWaypointsDisplay["HiNavaids"] = 2] = "HiNavaids";
    MapWaypointsDisplay[MapWaypointsDisplay["LoNavaids"] = 4] = "LoNavaids";
    MapWaypointsDisplay[MapWaypointsDisplay["Intersections"] = 8] = "Intersections";
    MapWaypointsDisplay[MapWaypointsDisplay["TerminalWaypoints"] = 16] = "TerminalWaypoints";
    MapWaypointsDisplay[MapWaypointsDisplay["ETA"] = 32] = "ETA";
    MapWaypointsDisplay[MapWaypointsDisplay["Speed"] = 64] = "Speed";
    MapWaypointsDisplay[MapWaypointsDisplay["Altitude"] = 128] = "Altitude";
    MapWaypointsDisplay[MapWaypointsDisplay["Airports"] = 256] = "Airports";
    MapWaypointsDisplay[MapWaypointsDisplay["NDBs"] = 512] = "NDBs";
    MapWaypointsDisplay[MapWaypointsDisplay["MissedApproach"] = 1024] = "MissedApproach";
})(MapWaypointsDisplay || (MapWaypointsDisplay = {}));
/**
 * Priorities for map labels on Boeings maps.
 * Higher numbers are rendered oin top of lower numbers if drawn on same canvas.
 */
var BoeingMapLabelPriority;
(function (BoeingMapLabelPriority) {
    BoeingMapLabelPriority[BoeingMapLabelPriority["TopOfDescent"] = 9999] = "TopOfDescent";
    BoeingMapLabelPriority[BoeingMapLabelPriority["FlightPlan"] = 999] = "FlightPlan";
    BoeingMapLabelPriority[BoeingMapLabelPriority["AirportsRunways"] = 10] = "AirportsRunways";
    BoeingMapLabelPriority[BoeingMapLabelPriority["Bottom"] = 0] = "Bottom";
})(BoeingMapLabelPriority || (BoeingMapLabelPriority = {}));
/**
 * Priorities for map waypoint icons on Boeings maps.
 * Higher numbers are rendered oin top of lower numbers if drawn on same canvas.
 */
var BoeingMapWaypointIconPriority;
(function (BoeingMapWaypointIconPriority) {
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["TopOfDescent"] = 9999] = "TopOfDescent";
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["FlightPlan"] = 999] = "FlightPlan";
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["AirportsRunways"] = 10] = "AirportsRunways";
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["Bottom"] = 0] = "Bottom";
})(BoeingMapWaypointIconPriority || (BoeingMapWaypointIconPriority = {}));
/** Features that a map format can support. */
var MapFormatFeatures;
(function (MapFormatFeatures) {
    MapFormatFeatures[MapFormatFeatures["None"] = 0] = "None";
    MapFormatFeatures[MapFormatFeatures["Weather"] = 1] = "Weather";
    MapFormatFeatures[MapFormatFeatures["Terrain"] = 2] = "Terrain";
    MapFormatFeatures[MapFormatFeatures["AltitudeArc"] = 4] = "AltitudeArc";
    MapFormatFeatures[MapFormatFeatures["PositionTrendVector"] = 8] = "PositionTrendVector";
})(MapFormatFeatures || (MapFormatFeatures = {}));
/** Info and function common across Boeing maps. */
class BoeingMapCommon {
}
BoeingMapCommon.COMPASS_FORMAT_COMMON_LAYER_KEYS = [
    BoeingMapKeys.OwnShipTriLayer,
    BoeingMapKeys.OwnShipXtkErrorLayer,
];
BoeingMapCommon.PLAN_FORMAT_COMMON_LAYER_KEYS = [
    BoeingMapKeys.OwnShipOutlineLayer,
];
BoeingMapCommon.COMPASS_DEFAULT_CONFIG = {
    rotationType: 'HdgOrTrkUp',
    ownAirplaneIconRotationType: MapOwnAirplaneIconOrientation.MapUp,
    features: MapFormatFeatures.Terrain | MapFormatFeatures.Weather | MapFormatFeatures.AltitudeArc | MapFormatFeatures.PositionTrendVector,
};
BoeingMapCommon.PLAN_DEFAULT_CONFIG = {
    rotationType: MapRotation.NorthUp,
    ownAirplaneIconRotationType: MapOwnAirplaneIconOrientation.HeadingUp,
    features: MapFormatFeatures.None,
};
BoeingMapCommon.tunedVorRole = 'tunedVorRole';
BoeingMapCommon.font = 'B787';

/**
 * A map system controller that controls the display settings of the various format
 * and terrain/wxr combinations.
 */
class BoeingMapFormatController extends MapSystemController {
    /**
     * Creates an instance of the BoeingMapFormatController.
     * @param context The map system context to use with this controller.
     * @param canvasScale The canvas scale.
     * @param currentMapFormatConfig A subscribable for the current map format config.
     * @param terrWxState A subscribable for the current terr wx state.
     */
    constructor(context, canvasScale, currentMapFormatConfig, terrWxState) {
        super(context);
        this.canvasScale = canvasScale;
        this.currentMapFormatConfig = currentMapFormatConfig;
        this.terrWxState = terrWxState;
        this.blankTerrainColors = BingComponent.createEarthColorsArray('#000000', [
            { elev: 0, color: '#000000' }
        ], 0, 30000, 1);
        this.terrModeTerrainColors = BingComponent.createEarthColorsArray('#000000', [
            { elev: 0, color: '#FF0000' },
            { elev: 500, color: '#FFFF00' },
            { elev: 1000, color: '#00FF00' },
            { elev: 2000, color: '#000000' }
        ]);
        this.boeingUserSettings = BoeingMsfsUserSettings.getManager(this.context.bus);
        this.isHdgUpMode = this.boeingUserSettings.getSetting('boeingMsfsNdHdgTrkUpMode').map(x => x === BoeingNdHdgTrkUpMode.HDG);
        this.terrainWeatherState = this.context.model.getModule(BoeingMapKeys.TerrainWeatherState);
        this.wxr = this.context.model.getModule(MapSystemKeys.Weather);
        this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
        this.altitudeArcModule = this.context.model.getModule(MapSystemKeys.AltitudeArc);
        this.positionTrendVectorModule = this.context.model.getModule(BoeingMapKeys.PositionTrendVector);
        this.ownAirplaneIconModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
        this.bingMapDebounceTimer = new DebounceTimer();
        this.bingLayer = this.context.getLayer(MapSystemKeys.Bing);
        this.sub = this.context.bus.getSubscriber();
        this.isOnGround = ConsumerSubject.create(this.sub.on('on_ground').whenChanged().atFrequency(0.2), true);
        this.currentFormatLayerKeys = [];
        this.wxr.weatherRadarArc.set(180);
        this.wxr.weatherRadarMode.set(EWeatherRadar.HORIZONTAL);
    }
    /** @inheritdoc */
    onWake() {
        // To prevent artifacts when switching eicas or changing map size
        this.tempHideBingMap();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        if (BitFlags.isAny(changeFlags, MapProjectionChangeType.ProjectedSize | MapProjectionChangeType.RangeEndpoints)) {
            // To prevent artifacts when switching eicas or changing map size
            this.tempHideBingMap();
        }
    }
    /** @inheritdoc */
    onAfterMapRender() {
        // Bing layer should always be visible so that you can use the airport map
        this.bingLayer.setVisible(true);
        this.isHdgUpMode.sub(this.handleFormatConfigChanged.bind(this));
        this.currentMapFormatConfig.sub(this.handleFormatConfigChanged.bind(this), true);
        this.terrWxState.pipe(this.terrainWeatherState.state);
        this.currentMapFormatConfig.sub(this.updateBingLayer.bind(this), true);
        this.isOnGround.sub(this.updateBingLayer.bind(this), true);
        this.terrWxState.sub(this.updateBingLayer.bind(this), true);
        // This hides any artifacting that occurs when wxr is toggled and imulate wxr/terr loading
        this.wxr.isEnabled.sub(() => this.tempHideBingMap());
        this.terrWxState.sub(() => this.tempHideBingMap());
    }
    /** Temporarily hides the bing map. */
    tempHideBingMap() {
        this.bingLayer.setVisible(false);
        this.bingMapDebounceTimer.schedule(() => {
            this.bingLayer.setVisible(true);
        }, 500);
    }
    /** Updates the bing layer according to the current terr wx state and format. */
    updateBingLayer() {
        const terrWxState = this.terrWxState.get();
        if (terrWxState === 'TERR') {
            this.handleTerr();
        }
        else if (terrWxState === 'WX') {
            this.handleWxr();
        }
        else {
            this.handleOff();
        }
    }
    /** Handles when the terrain system is on. */
    handleTerr() {
        this.wxr.isEnabled.set(false);
    }
    /** Handles when the WXR system is on. */
    handleWxr() {
        this.wxr.isEnabled.set(BitFlags.isAll(this.currentMapFormatConfig.get().features, MapFormatFeatures.Weather));
    }
    /** Handles when the terrain/wxr system is off. */
    handleOff() {
        this.wxr.isEnabled.set(false);
    }
    /** Handles the map format config changing. */
    handleFormatConfigChanged() {
        const mapFormatConfig = this.currentMapFormatConfig.get();
        this.context.projection.setQueued({ targetProjectedOffset: this.getOffset(mapFormatConfig) });
        this.context.projection.setQueued({ rangeEndpoints: this.getRangeEndpoints(mapFormatConfig) });
        const rotationType = mapFormatConfig.rotationType === 'HdgOrTrkUp'
            ? this.isHdgUpMode.get() ? MapRotation.HeadingUp : MapRotation.TrackUp
            : mapFormatConfig.rotationType;
        this.rotationModule.rotationType.set(rotationType);
        this.ownAirplaneIconModule.orientation.set(mapFormatConfig.ownAirplaneIconRotationType);
        this.altitudeArcModule.show.set(BitFlags.isAll(mapFormatConfig.features, MapFormatFeatures.AltitudeArc));
        this.positionTrendVectorModule.show.set(BitFlags.isAll(mapFormatConfig.features, MapFormatFeatures.PositionTrendVector));
        this.updateLayerVisibility();
    }
    /**
     * Sets the map target offset for the specified format.
     * @param formatConfig The format config to use.
     * @returns The target projected offset.
     */
    getOffset(formatConfig) {
        const offset = Vec2Math.create(0, formatConfig.targetProjectedOffsetUnscaledY);
        return Vec2Math.multScalar(offset, this.canvasScale, offset);
    }
    /**
     * Calculates the range endpoints for a given format config.
     * @param formatConfig The format config to use.
     * @returns The calculated range endpoints.
     */
    getRangeEndpoints(formatConfig) {
        const formatCenterY = (formatConfig.mapHeightUnscaled / 2) + formatConfig.targetProjectedOffsetUnscaledY;
        // With arc style formats, the lower endpoint is just the center
        const lowerEndpoint = formatConfig.compassType === 'arc'
            ? formatCenterY
            : formatCenterY + formatConfig.compassRadiusUnscaled;
        // Upper endpoint is same for both compass types
        const upperEndpoint = formatCenterY - formatConfig.compassRadiusUnscaled;
        // Divide by map height to make it a ratio
        // We put 0.5 for the x value because all the formats are centered horizontally
        const rangeEndpoints = VecNMath.create(4, 0.5, lowerEndpoint / formatConfig.mapHeightUnscaled, 0.5, upperEndpoint / formatConfig.mapHeightUnscaled);
        return rangeEndpoints;
    }
    /** Hides the layers for the previous format, and enbales the ones for the new format. */
    updateLayerVisibility() {
        const mapFormatConfig = this.currentMapFormatConfig.get();
        this.currentFormatLayerKeys.forEach(layerKey => {
            (this.context.getLayer(layerKey)).setVisible(false);
        });
        this.currentFormatLayerKeys = mapFormatConfig.layerKeys;
        this.currentFormatLayerKeys.forEach(layerKey => {
            (this.context.getLayer(layerKey)).setVisible(true);
        });
    }
}

/** A controller which handles map traffic settings. */
class BoeingMapTrafficController extends MapSystemController {
    /**
     * Constructor.
     * @param context The map system context to use with this controller.
     * @param ndDataProvider The ND data provider.
     * @param altitudeRestrictionFull The maximum restricted altitude in ft.
     */
    constructor(context, ndDataProvider, altitudeRestrictionFull) {
        super(context);
        this.ndDataProvider = ndDataProvider;
        this.altitudeRestrictionFull = altitudeRestrictionFull;
        this.trafficModule = this.context.model.getModule(MapSystemKeys.Traffic);
        this.trafficSettings = TrafficUserSettings.getManager(this.context.bus);
        this.subs = [];
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.wireSettings();
    }
    /**
     * Wires the controller to the settings manager.
     */
    wireSettings() {
        this.subs.push(this.ndDataProvider.showTfc.sub(show => {
            this.trafficModule.show.set(show);
        }, true), this.ndDataProvider.mapRange.sub(range => {
            this.trafficModule.offScaleRange.set(range, UnitType.NMILE);
        }, true), this.trafficSettings.getSetting('trafficAltitudeRelative').sub(isRelative => {
            this.trafficModule.isAltitudeRelative.set(isRelative);
        }, true), this.trafficSettings.getSetting('trafficShowAbove').sub(show => {
            this.trafficModule.altitudeRestrictionAbove.set(show
                ? this.altitudeRestrictionFull
                : BoeingMapTrafficController.ALTITUDE_RESTRICTION_NORMAL);
        }, true), this.trafficSettings.getSetting('trafficShowBelow').sub(show => {
            this.trafficModule.altitudeRestrictionBelow.set(show
                ? this.altitudeRestrictionFull
                : BoeingMapTrafficController.ALTITUDE_RESTRICTION_NORMAL);
        }, true));
    }
    /** @inheritdoc */
    onMapDestroyed() {
        this.destroy();
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.subs.forEach(sub => sub.destroy());
    }
}
BoeingMapTrafficController.ALTITUDE_RESTRICTION_NORMAL = UnitType.FOOT.createNumber(2700);

/** Util functions for boeing maps. */
class BoeingMapUtils {
    /**
     * Determines whether an altitude for a leg should be displayed on the map.
     * @param leg the leg def
     * @returns whther to show the altitude
     */
    static showAltitudeForLeg(leg) {
        if (leg.leg.fixIcao[0] === 'R') {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.CA:
            case LegType.VA:
                return false;
            default:
                return true;
        }
    }
}

/** Updates the VNavData module. */
class BoeingVNavDataController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
        this.vnavDataModule = this.context.model.getModule(BoeingMapKeys.VNavData);
        this.activeRoutePlanSubject = this.flightPlanModule.getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.activeRoutePlanSubject.activeLeg.sub(this.updateNextConstraint.bind(this));
        this.activeRoutePlanSubject.flightPlan.sub(this.updateNextConstraint.bind(this));
        this.activeRoutePlanSubject.planChanged.on(this.updateNextConstraint.bind(this));
        this.updateNextConstraint();
    }
    /** Updates the next constraint. */
    updateNextConstraint() {
        this.vnavDataModule.nextConstraintLegDefForMap.set(this.getNextConstraint());
    }
    /**
     * Gets the next constraint.
     * @returns the next constraint leg def.
     */
    getNextConstraint() {
        const planSubject = this.flightPlanModule.getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX);
        const activeLeg = planSubject.activeLeg.get();
        const plan = planSubject.flightPlan.get();
        if (!plan) {
            return undefined;
        }
        for (const leg of plan.legs(false, activeLeg)) {
            if (BoeingMapUtils.showAltitudeForLeg(leg) === false) {
                continue;
            }
            if (leg.verticalData.altDesc !== AltitudeRestrictionType.Unused) {
                return leg;
            }
        }
        return undefined;
    }
}

/**
 * A controller that handles map range settings.
 */
class MapRangeController extends MapSystemController {
    /**
     * Creates an instance of the MapRangeController.
     * @param context The map system context to use with this controller.
     * @param mapRange The map range.
     */
    constructor(context, mapRange) {
        super(context);
        this.mapRange = mapRange;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.wireSettings();
    }
    /**
     * Wires the controller to the settings manager.
     */
    wireSettings() {
        this.mapRange.sub(this.handleRangeChanged.bind(this), true);
    }
    /**
     * Handles when the range changes.
     * @param range The range of the map, in nautical miles.
     */
    handleRangeChanged(range) {
        this.context.projection.setQueued({ range: UnitType.NMILE.convertTo(range, UnitType.GA_RADIAN) });
    }
}

/**
 * GPWS operating modes.
 */
var GpwsOperatingMode;
(function (GpwsOperatingMode) {
    GpwsOperatingMode["Off"] = "Off";
    GpwsOperatingMode["Standby"] = "Standby";
    GpwsOperatingMode["Normal"] = "Normal";
    GpwsOperatingMode["Test"] = "Test";
    GpwsOperatingMode["Failed"] = "Failed";
})(GpwsOperatingMode || (GpwsOperatingMode = {}));

/**
 * Controls the display of terrain colors based on GPWS data.
 */
class MapTerrainColorsController extends MapSystemController {
    constructor() {
        super(...arguments);
        this.terrainWeatherStateModule = this.context.model.getModule(BoeingMapKeys.TerrainWeatherState);
        this.terrainColorsModule = this.context.model.getModule(MapSystemKeys.TerrainColors);
        this.noseGearPosition = ConsumerValue.create(null, 0);
        this.leftGearPosition = ConsumerValue.create(null, 0);
        this.rightGearPosition = ConsumerValue.create(null, 0);
        this.gpwsOperatingMode = ConsumerSubject.create(null, GpwsOperatingMode.Off);
        this.gpwsIsPosValid = ConsumerSubject.create(null, false);
        this.gpwsGeoAltitude = ConsumerValue.create(null, 0);
        this.gpwsGeoVs = ConsumerValue.create(null, 0);
        this.gpwsNearestRunwayAltitude = ConsumerValue.create(null, null);
        this.isActive = MappedSubject.create(([terrainWeatherState, gpwsOperatingMode, gpwsIsPosValid]) => terrainWeatherState === 'TERR' && gpwsOperatingMode === GpwsOperatingMode.Normal && gpwsIsPosValid, this.terrainWeatherStateModule.state, this.gpwsOperatingMode, this.gpwsIsPosValid).pause();
        // 100-foot steps from -1400 to 29000 feet (inclusive) = 305 terrain colors + 1 water color
        this.activeColorsArray = ArrayUtils.create(306, () => 0);
        this.isAltitudeLookaheadActive = false;
        this.lastUpdateTime = undefined;
        this.lastUpdateAltitude = undefined;
        this.lastUpdateNearestRunwayAltitude = undefined;
        this.lastUpdateGearUp = undefined;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        const sub = this.context.bus.getSubscriber();
        this.noseGearPosition.setConsumer(sub.on('gear_position_0'));
        this.leftGearPosition.setConsumer(sub.on('gear_position_1'));
        this.rightGearPosition.setConsumer(sub.on('gear_position_2'));
        this.gpwsOperatingMode.setConsumer(sub.on('gpws_operating_mode'));
        this.gpwsIsPosValid.setConsumer(sub.on('gpws_is_pos_valid'));
        this.gpwsGeoAltitude.setConsumer(sub.on('gpws_geo_altitude'));
        this.gpwsGeoVs.setConsumer(sub.on('gpws_geo_vertical_speed'));
        this.gpwsNearestRunwayAltitude.setConsumer(sub.on('gpws_nearest_runway_altitude'));
        this.terrainColorsModule.colorsElevationRange.set(MapTerrainColorsController.TERRAIN_ELEV_RANGE);
        this.isActive.resume();
        this.isActive.sub(isActive => {
            if (!isActive) {
                this.resetUpdateHistory();
                this.terrainColorsModule.colors.set(MapTerrainColorsController.BLANK_TERRAIN_COLORS);
            }
        }, true);
    }
    /** @inheritdoc */
    onSleep() {
        this.resetUpdateHistory();
    }
    /**
     * Resets this controller's active terrain color update history.
     */
    resetUpdateHistory() {
        this.isAltitudeLookaheadActive = false;
        this.lastUpdateTime = undefined;
        this.lastUpdateAltitude = undefined;
        this.lastUpdateNearestRunwayAltitude = undefined;
        this.lastUpdateGearUp = undefined;
    }
    /** @inheritdoc */
    onAfterUpdated(time) {
        var _a;
        if (!this.isActive.get()) {
            return;
        }
        if (this.lastUpdateTime !== undefined && this.lastUpdateTime > time) {
            this.lastUpdateTime = time;
        }
        if (this.lastUpdateTime !== undefined && time - this.lastUpdateTime < MapTerrainColorsController.UPDATE_PERIOD) {
            return;
        }
        this.lastUpdateTime = time;
        const altitude = this.gpwsGeoAltitude.get();
        const vs = this.gpwsGeoVs.get();
        const nearestRunwayAltitude = (_a = this.gpwsNearestRunwayAltitude.get()) !== null && _a !== void 0 ? _a : -10000;
        const isGearUp = this.noseGearPosition.get() < 1 || this.leftGearPosition.get() < 1 || this.rightGearPosition.get() < 1;
        // When descending at more than 1000 feet per minute, a 30-second altitude lookahead is activated.
        this.isAltitudeLookaheadActive = vs < (this.isAltitudeLookaheadActive ? -800 : -1000);
        const effectiveAltitude = this.isAltitudeLookaheadActive ? altitude + vs * 0.5 : altitude;
        // We can skip the update if...
        if (this.lastUpdateAltitude !== undefined
            && this.lastUpdateNearestRunwayAltitude !== undefined
            // ... the current gear state is the same as the last updated gear state and ...
            && isGearUp === this.lastUpdateGearUp
            // ... the current effective altitude is within 50 feet of the last updated effective altitude and...
            && Math.abs(effectiveAltitude - this.lastUpdateAltitude) < 50
            && (
            // ... the current nearest runway altitude is within 50 feet of the last updated nearest runway altitude...
            Math.abs(nearestRunwayAltitude - this.lastUpdateNearestRunwayAltitude) < 50
                || (
                // ... OR both the current and last updated nearest runway altitude were more than 2500 feet below their
                // respective effective altitudes (i.e. there does not exist any displayed terrain that is inhibited by the
                // nearest runway in this or the last update).
                nearestRunwayAltitude < effectiveAltitude - 2500
                    && this.lastUpdateNearestRunwayAltitude < this.lastUpdateAltitude - 2500))) {
            return;
        }
        this.lastUpdateAltitude = effectiveAltitude;
        this.lastUpdateNearestRunwayAltitude = nearestRunwayAltitude;
        this.lastUpdateGearUp = isGearUp;
        const colors = isGearUp ? MapTerrainColorsController.ACTIVE_TERRAIN_COLORS_GEAR_UP : MapTerrainColorsController.ACTIVE_TERRAIN_COLORS_GEAR_DOWN;
        // Find the closest elevation step to the elevation at which terrain is colored (2000 feet below the airplane's
        // effective altitude).
        const terrainColorStartIndex = MathUtils.round(MathUtils.lerp(effectiveAltitude - 2000, MapTerrainColorsController.TERRAIN_ELEV_RANGE[0], MapTerrainColorsController.TERRAIN_ELEV_RANGE[1], 1, // terrain colors start at index 1
        this.activeColorsArray.length - 1));
        // Find the closest elevation steps to +/-400 feet relative to the nearest runway elevation.
        const terrainColorNearestRunwayElevationBelowIndex = Math.ceil(MathUtils.lerp(nearestRunwayAltitude - 400, MapTerrainColorsController.TERRAIN_ELEV_RANGE[0], MapTerrainColorsController.TERRAIN_ELEV_RANGE[1], 1, // terrain colors start at index 1
        this.activeColorsArray.length - 1));
        const terrainColorNearestRunwayElevationAboveIndex = Math.floor(MathUtils.lerp(nearestRunwayAltitude + 400, MapTerrainColorsController.TERRAIN_ELEV_RANGE[0], MapTerrainColorsController.TERRAIN_ELEV_RANGE[1], 1, // terrain colors start at index 1
        this.activeColorsArray.length - 1));
        // Update the active terrain colors array.
        const startIndex = Math.max(terrainColorStartIndex, 1);
        // Terrain more than 2000 feet below the airplane is not displayed.
        this.activeColorsArray.fill(0, 1, startIndex);
        for (let i = startIndex; i < this.activeColorsArray.length; i++) {
            if (i >= terrainColorNearestRunwayElevationBelowIndex && i <= terrainColorNearestRunwayElevationAboveIndex) {
                // Inhibit display of terrain within 400 feet of nearest runway elevation.
                this.activeColorsArray[i] = 0;
            }
            else {
                this.activeColorsArray[i] = colors[Math.min(i - terrainColorStartIndex, colors.length - 1)];
            }
        }
        this.terrainColorsModule.colors.set(this.activeColorsArray);
    }
}
MapTerrainColorsController.BLANK_TERRAIN_COLORS = BingComponent.createEarthColorsArray('#000000', [
    { elev: -1400, color: '#000000' }
], -1400, 29000, 1);
MapTerrainColorsController.TERRAIN_ELEV_RANGE = Vec2Math.create(-1400, 29000);
MapTerrainColorsController.ACTIVE_TERRAIN_COLORS_GEAR_UP = BingComponent.createEarthColorsArray('#000000', [
    { elev: -2000, color: '#005700' },
    { elev: -1001, color: '#005700' },
    { elev: -1000, color: '#00ff00' },
    { elev: -501, color: '#00ff00' },
    { elev: -500, color: '#e4a000' },
    { elev: 999, color: '#e4a000' },
    { elev: 1000, color: '#ffcc33' },
    { elev: 1999, color: '#ffcc33' },
    { elev: 2000, color: '#fc0000' }
], -2000, 2000, 41).slice(1); // Remove water color entry.
MapTerrainColorsController.ACTIVE_TERRAIN_COLORS_GEAR_DOWN = BingComponent.createEarthColorsArray('#000000', [
    { elev: -2000, color: '#005700' },
    { elev: -1001, color: '#005700' },
    { elev: -1000, color: '#00ff00' },
    { elev: -301, color: '#00ff00' },
    // Technically the following breakpoint should be -250 feet, but doing 50-foot steps would double the active colors
    // array length to 611.
    { elev: -300, color: '#e4a000' },
    { elev: 999, color: '#e4a000' },
    { elev: 1000, color: '#ffcc33' },
    { elev: 1999, color: '#ffcc33' },
    { elev: 2000, color: '#fc0000' }
], -2000, 2000, 41).slice(1); // Remove water color entry.
MapTerrainColorsController.UPDATE_PERIOD = 5000;

/** A map system controller that controls the display settings of the nearest waypoints. */
class MapWaypointDisplayController extends MapSystemController {
    /**
     * Creates an instance of the WaypointDisplayController.
     * @param context The map system context to use with this controller.
     * @param mapWaypointsDisplay A subscribable MapWaypointsDisplay.
     * @param pfdOrMfd pfd or mfd.
     * @param fixInfo The fix info manager.
     */
    constructor(context, mapWaypointsDisplay, pfdOrMfd, fixInfo) {
        var _a;
        super(context);
        this.mapWaypointsDisplay = mapWaypointsDisplay;
        this.pfdOrMfd = pfdOrMfd;
        this.fixInfo = fixInfo;
        this.waypointsDisplayModule = this.context.model.getModule(MapSystemKeys.NearestWaypoints);
        // selectWaypointModule is only on the ND, not on the minimap
        this.selectWaypointModule = this.context.model.getModule(BoeingMapKeys.CtrWpt);
        this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
        this.navComSub = this.context.bus.getSubscriber();
        this.tunedVorIdents = ['', ''];
        this.waypointRenderer = this.context[MapSystemKeys.WaypointRenderer];
        this.systemWaypointRole = (_a = this.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.Normal)) !== null && _a !== void 0 ? _a : 0;
    }
    /** @inheritdoc */
    onAfterMapRender() {
        this.wireSettings();
        this.waypointsDisplayModule.airportsRange.set(1000, UnitType.NMILE);
        // FCOM says waypoints only show in ND ranges of 10, 20, and 40
        this.waypointsDisplayModule.intersectionsRange.set(40, UnitType.NMILE);
        this.waypointsDisplayModule.vorsRange.set(1000, UnitType.NMILE);
        this.waypointsDisplayModule.numAirports.set(100);
        this.waypointsDisplayModule.numIntersections.set(100);
        this.waypointsDisplayModule.numVors.set(100);
        this.waypointsDisplayModule.intersectionsFilter.set({
            typeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF), BitFlags.createFlag(IntersectionType.RNAV)),
            // 78 pilots say they don't think these would be shown
            showTerminalWaypoints: false,
        });
        this.waypointsDisplayModule.vorsFilter.set({
            typeMask: NearestVorSearchSession.Defaults.TypeMask,
            classMask: NearestVorSearchSession.Defaults.ClassMask,
        });
        this.waypointsDisplayModule.airportsFilter.set({
            classMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface)),
            showClosed: NearestAirportSearchSession.Defaults.ShowClosed,
        });
        this.waypointsDisplayModule.extendedAirportsFilter.set({
            runwaySurfaceTypeMask: NearestAirportSearchSession.Defaults.SurfaceTypeMask,
            approachTypeMask: NearestAirportSearchSession.Defaults.ApproachTypeMask,
            minimumRunwayLength: 2000,
            toweredMask: NearestAirportSearchSession.Defaults.ToweredMask,
        });
    }
    /**
     * Wires the settings system to the waypoint display controller.
     */
    wireSettings() {
        var _a;
        this.mapWaypointsDisplay.sub((v) => this.handleSettingsChanged(v), true);
        this.waypointsDisplayModule.waypointRoleSelector.set(w => {
            const facility = w.facility.get();
            const isVor = ICAO.isFacility(facility.icao, FacilityType.VOR);
            const identMatch = this.tunedVorIdents.includes(ICAO.getIdent(facility.icao));
            if (isVor && identMatch) {
                return BoeingMapCommon.tunedVorRole;
            }
            else {
                return MapSystemWaypointRoles.Normal;
            }
        });
        this.navComSub.on('nav_ident_1').whenChanged().handle(ident => {
            this.tunedVorIdents[0] = ident;
            this.waypointsDisplayModule.refreshWaypoints.notify();
        });
        this.navComSub.on('nav_ident_2').whenChanged().handle(ident => {
            this.tunedVorIdents[1] = ident;
            this.waypointsDisplayModule.refreshWaypoints.notify();
        });
        // selectWaypointModule is only on the ND, not on the minimap
        (_a = this.selectWaypointModule) === null || _a === void 0 ? void 0 : _a.facility.sub(this.updateDisplayWaypoint.bind(this));
    }
    /**
     * Determines if a map waypoint should be displayed because it is the selected facility.
     * @param shouldShow The current setting value for that facility type.
     * @returns A function that is checking if the waypoint is the selected waypoint.
     */
    shouldShowWaypoint(shouldShow) {
        return (w) => {
            if (FacilityWaypointUtils.isFacilityWaypoint(w)) {
                // Don't show waypoint if it's in the active plan
                const plan = this.flightPlanModule.getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX).flightPlan.get();
                if (plan) {
                    for (const leg of plan.legs()) {
                        if (leg.leg.fixIcao === w.facility.get().icao) {
                            return false;
                        }
                    }
                }
                // selectWaypointModule is only on the ND, not on the minimap
                // Show waypoint if it's selected by the MAP CTR functionality
                if (this.selectWaypointModule && w.facility.get().icao === this.selectWaypointModule.facilityIcao.get()) {
                    return true;
                }
                // Show waypoint if it's a fix info waypoint
                if (this.fixInfo && this.fixInfo.ndWaypoints.getArray().some(x => x.fixIcao === w.facility.get().icao)) {
                    return true;
                }
            }
            return this.pfdOrMfd === 'PFD' ? false : shouldShow;
        };
    }
    /**
     * Handles when the waypoint display settings mask has changed.
     * @param mask The waypoint display settings mask to apply.
     */
    handleSettingsChanged(mask) {
        this.waypointsDisplayModule.showAirports.set(this.shouldShowWaypoint(BitFlags.isAll(mask, MapWaypointsDisplay.Airports)));
        this.waypointsDisplayModule.showIntersections.set(this.shouldShowWaypoint(BitFlags.isAll(mask, MapWaypointsDisplay.Intersections)));
        // NDB's are not shown on the 787 with STA enabled, but we will show them when centered on with CTR ON
        this.waypointsDisplayModule.showNdbs.set(this.shouldShowWaypoint(false));
        this.waypointsDisplayModule.showVors.set(w => {
            if (this.tunedVorIdents.includes(ICAO.getIdent(w.facility.get().icao))) {
                return true;
            }
            return this.shouldShowWaypoint(BitFlags.isAny(mask, MapWaypointsDisplay.HiNavaids | MapWaypointsDisplay.LoNavaids))(w);
        });
    }
    /**
     * Updates the displayed facility.
     * @param facility The facility to display.
     */
    updateDisplayWaypoint(facility) {
        this.displayWaypoint && this.waypointRenderer.deregister(this.displayWaypoint, this.systemWaypointRole, 'waypoints-layer');
        if (facility !== null) {
            this.displayWaypoint = new BasicFacilityWaypoint(facility, this.context.bus);
            if (!this.waypointRenderer.isRegistered(this.displayWaypoint)) {
                this.waypointRenderer.register(this.displayWaypoint, this.systemWaypointRole, 'waypoints-layer');
            }
        }
    }
}
MapWaypointDisplayController.CtrWaypointRole = 'CtrWptRole';

/** Display modes for PlanAirportsLayer. */
var PlanAirportsLayerDisplayMode;
(function (PlanAirportsLayerDisplayMode) {
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["None"] = 1] = "None";
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["AirportMap"] = 2] = "AirportMap";
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["Near"] = 4] = "Near";
    PlanAirportsLayerDisplayMode[PlanAirportsLayerDisplayMode["Far"] = 8] = "Far";
})(PlanAirportsLayerDisplayMode || (PlanAirportsLayerDisplayMode = {}));
/** A module that controls display of airport runways. */
class AirportRunwayDisplayModule {
    constructor() {
        /** The current display mode of the plan airports layer */
        this.displayMode = Subject.create(PlanAirportsLayerDisplayMode.None);
        /** Whether or not runway labels should be displayed */
        this.displayLabels = Subject.create(true);
        /** Whether or not the runways themselves should be displayed. */
        this.displayRunways = Subject.create(true);
        /**
         * Highlights an airport which may not already be contained in the set of
         * nearest airports to already be displayed.
         */
        this.focusAirports = ArraySubject.create([]);
    }
}

/** A module that contains the map styles. */
class BoeingMapStylesModule {
    /**
     * Creates a new BoeingMapStylesModule.
     * @param styles The styles.
     */
    constructor(styles) {
        this.styles = styles;
    }
}

/** Provides vnav data. */
class BoeingVNavDataModule {
    constructor() {
        /** Holds the leg def for the next or current altitude constraint,
         * for the purposes of displaying the altitude constraitn on the map when DATA is off. */
        this.nextConstraintLegDefForMap = Subject.create(undefined);
    }
}

/**
 * A module which defines an icao to select.
 */
class MapFacilitySelectModule {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        /** The ICAO of the facility to select. */
        this.facilityIcao = Subject.create(null);
        this.facility = Subject.create(null);
        this.userFacility = Subject.create(null);
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(bus));
        this.facilityIcao.sub(this.updateFacility.bind(this), false);
        this.userFacility.sub(this.updateFacility.bind(this), false);
    }
    /** Updates the facility. */
    async updateFacility() {
        const facilityIcao = this.facilityIcao.get();
        const userFacility = this.userFacility.get();
        if (facilityIcao) {
            if (facilityIcao === (userFacility === null || userFacility === void 0 ? void 0 : userFacility.icao)) {
                this.facility.set(userFacility);
            }
            else {
                const facility = await this.facLoader.getFacility(ICAO.getFacilityType(facilityIcao), facilityIcao);
                this.facility.set(facility);
            }
        }
        else {
            this.facility.set(null);
        }
    }
}

/** A module describing the display of the position trend vector. */
class MapPositionTrendVectorModule {
    /**
     * MapPositionTrendVectorModule constructor.
     * @param show When passed, the `show` field will be initialized to this value.
     */
    constructor(show) {
        /** Whether to show the position trend vector. */
        this.show = Subject.create(false);
        if (show !== undefined) {
            this.show.set(show);
        }
    }
}

/**
 * A module describing the terrain/weather display state of the map.
 */
class MapTerrainWeatherStateModule {
    constructor() {
        /** The terrain/weather display state. */
        this.state = Subject.create('OFF');
    }
}

/** A map system controller that controls the display of airports and runways. */
class PlanAirportsRunwaysController extends MapSystemController {
    /**
     * Creates an instance of the PlanAirportsRunwaysController.
     * @param context The map system context to use with this controller.
     * @param facLoader The fac loader.
     * @param flightPlanner The flight planner.
     * @param ndDataProvider The ND Data Provider.
     * @param pfdOrMfd pfd or mfd.
     */
    constructor(context, facLoader, flightPlanner, ndDataProvider, pfdOrMfd) {
        super(context);
        this.context = context;
        this.facLoader = facLoader;
        this.flightPlanner = flightPlanner;
        this.ndDataProvider = ndDataProvider;
        this.pfdOrMfd = pfdOrMfd;
        this.module = this.context.model.getModule(BoeingMapKeys.PlanAirportsLayer);
        this.subs = [];
        // 2d array, outer array is by plan index, inner array is the active airport icaos that we want to render
        this.icaos = [];
        this.onRangeChanged = (range) => {
            if (range >= 80) {
                this.module.displayMode.set(PlanAirportsLayerDisplayMode.Far);
                // Manual says 10 NM and above but I have a photo showing it at 2 NM in PLAN
                // But maybe it's always visible in PLAN, who knows
            }
            else if (range >= 2) {
                this.module.displayMode.set(PlanAirportsLayerDisplayMode.Near);
            }
            else {
                this.module.displayMode.set(PlanAirportsLayerDisplayMode.AirportMap);
            }
        };
        this.handlePlanLoad = (event) => {
            this.syncPlanAirportsToMap(event.planIndex).then();
        };
        this.handlePlanCopied = (event) => {
            this.syncPlanAirportsToMap(event.targetPlanIndex).then();
        };
        this.loadExistingFlightPlans();
        const planSub = this.context.bus.getSubscriber();
        this.subs = [
            planSub.on('fplOriginDestChanged').handle(this.handlePlanLoad),
            planSub.on('fplCreated').handle(this.handlePlanLoad),
            planSub.on('fplLoaded').handle(this.handlePlanLoad),
            planSub.on('fplProcDetailsChanged').handle(this.handlePlanLoad),
            planSub.on('fplCopied').handle(this.handlePlanCopied),
        ];
        if (this.pfdOrMfd === 'MFD') {
            this.subs.push(this.ndDataProvider.mapRange.sub(this.onRangeChanged, true));
        }
        else {
            this.module.displayMode.set(PlanAirportsLayerDisplayMode.Near);
        }
    }
    /** Loads existing flight plans. */
    loadExistingFlightPlans() {
        [BoeingFms.ACT_RTE_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, BoeingFms.RTE_1_MOD_PLAN_INDEX].forEach(planIndex => {
            if (this.flightPlanner.hasFlightPlan(planIndex)) {
                this.syncPlanAirportsToMap(planIndex);
            }
        });
    }
    /**
     * Syncs flight plan airports to the plan airports module
     * @param planIndex The flight plan index to sync from.
     */
    async syncPlanAirportsToMap(planIndex) {
        this.icaos[planIndex] = [];
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        if (plan.originAirport && plan.destinationAirport && plan.originAirport === plan.destinationAirport) {
            this.icaos[planIndex].push(plan.originAirport);
        }
        else {
            if (plan.originAirport) {
                this.icaos[planIndex].push(plan.originAirport);
            }
            if (plan.destinationAirport) {
                this.icaos[planIndex].push(plan.destinationAirport);
            }
        }
        // Clear airports that should not be there
        this.module.focusAirports.getArray().forEach((focusAirport, i) => {
            if (focusAirport.planIndex === planIndex && !this.icaos[planIndex].includes(focusAirport.airport.facility.get().icao)) {
                this.module.focusAirports.removeAt(i);
            }
        });
        if (plan.originAirport && plan.destinationAirport && plan.originAirport === plan.destinationAirport) {
            await this.ensureAirportAndRunwayOnMap(planIndex, plan.originAirport, plan.procedureDetails.originRunway, plan.procedureDetails.destinationRunway);
        }
        else {
            if (plan.originAirport) {
                await this.ensureAirportAndRunwayOnMap(planIndex, plan.originAirport, plan.procedureDetails.originRunway, undefined);
            }
            if (plan.destinationAirport) {
                await this.ensureAirportAndRunwayOnMap(planIndex, plan.destinationAirport, undefined, plan.procedureDetails.destinationRunway);
            }
        }
    }
    /**
     * Ensures an airport is present in the plan airports module. Removes any existing instances before inserting
     * @param planIndex the flight plan index
     * @param airportIcao the airport icao
     * @param departureRunway the departure one way runway if applicable
     * @param arrivalRunway the arrival one way runway if applicable
     */
    async ensureAirportAndRunwayOnMap(planIndex, airportIcao, departureRunway, arrivalRunway) {
        const facility = await this.facLoader.getFacility(FacilityType.Airport, airportIcao);
        const wp = new BasicFacilityWaypoint(facility, this.context.bus);
        const array = this.module.focusAirports.getArray();
        const existingEntry = array.findIndex((item) => item.planIndex === planIndex && item.airport.facility.get().icao === airportIcao);
        if (existingEntry !== -1) {
            this.module.focusAirports.removeAt(existingEntry);
        }
        if (!this.icaos[planIndex].includes(airportIcao)) {
            // Because this is async, the airport could have been removed by now
            // so don't add it if it's not still in the icaos list
            return;
        }
        this.module.focusAirports.insert({ planIndex, airport: wp, departureRunway, arrivalRunway });
    }
    /** @inheritdoc */
    destroy() {
        super.destroy();
        this.subs.forEach(sub => sub.destroy());
    }
}

/** Creates a div with voerflow hidden, and an inner container to recenter things on. */
class MapCompassArcMask extends DisplayComponent {
    /** @inheritdoc */
    render() {
        if (this.props.isEnabled) {
            return (FSComponent.buildComponent("div", { class: "map-compass-offset-clipped", style: `position: absolute; top: 0px; width: 100%; height: ${this.props.maskHeightPx}px; overflow: hidden;` },
                FSComponent.buildComponent("div", { class: "map-compass-offset-clipped-inner", style: `position: absolute; top: 0px; width: 100%; height: ${this.props.innerHeightPx}px;
            display: flex; justify-content: center; align-items: center;` }, this.props.children)));
        }
        else {
            return FSComponent.buildComponent(FSComponent.Fragment, null, this.props.children);
        }
    }
}

/** Creates a div with the given compass svg size, and translates it to match the map projection offset. */
class MapCompassOffset extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.mapOffsetContainerStyles = ObjectSubject.create({
            'position': 'absolute',
            'display': 'flex',
            'justify-content': 'center',
            'align-items': 'center',
            'width': this.props.compassSvgSize ? (this.props.compassSvgSize + 'px') : '100%',
            'height': this.props.compassSvgSize ? (this.props.compassSvgSize + 'px') : '100%',
            'transform': `translate(0, ${this.props.targetProjectedOffsetY.get()}px)`,
        });
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.targetProjectedOffsetY.sub(offsetY => {
            this.mapOffsetContainerStyles.set('transform', `translate(0, ${offsetY}px)`);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-compass-offset", style: this.mapOffsetContainerStyles }, this.props.children));
    }
}

/**
 * A layer which shows the cross track error number of the airplane.
 * It is positioned below the projected location of the airplane.
 */
class MapCrossTrackErrorLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.xtkString = Subject.create('0.0');
        this.sub = this.props.bus.getSubscriber();
        this.rootStyle = ObjectSubject.create({
            'display': 'flex',
            'position': 'absolute',
            'left': -50 * this.props.canvasScale + 'px',
            'top': this.props.top * this.props.canvasScale + 'px',
            'min-width': 100 * this.props.canvasScale + 'px',
            'height': 100 * this.props.canvasScale + 'px',
            'color': 'white',
            'font-size': this.props.fontSize * this.props.canvasScale + 'px',
            'transform': 'translate3d(0, 0, 0)',
            'align-items': 'center',
            'justify-content': 'center',
            'margin': '0px',
            'padding': '0px 2px',
        });
        this.spanStyle = ObjectSubject.create({
            background: 'black',
            height: this.props.height * this.props.canvasScale + 'px',
            padding: this.props.padding * this.props.canvasScale + 'px',
        });
        this.ownAirplanePropsModule = this.props.model.getModule('ownAirplaneProps');
        this.ownAirplaneIconModule = this.props.model.getModule('ownAirplaneIcon');
        this.visibilityBounds = VecNMath.create(4);
        this.iconTransform = CssTransformBuilder.translate3d('px');
        this.showIcon = true;
        this.needUpdateVisibility = false;
        this.needUpdatePosition = false;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.xtkSub = this.sub.on('lnav_xtk').whenChangedBy(0.1).atFrequency(1).handle((v) => {
            const suffix = v <= -0.1 ? 'L' : v >= 0.1 ? 'R' : '';
            let xtkFixed = Math.abs(MathUtils.clamp(v, -99.99, 99.99)).toFixed(1);
            if (MathUtils.round(Math.abs(v * 10), 0.1) < 1) {
                xtkFixed = '0.0';
            }
            this.xtkString.set(`${xtkFixed}  ${suffix}`.trim());
        });
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.needUpdateVisibility = true;
        this.needUpdatePosition = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    /** @inheritdoc */
    onAttached() {
        this.showSub = this.ownAirplaneIconModule.show.sub((show) => {
            this.needUpdateVisibility = true;
            this.needUpdatePosition = this.showIcon = show && this.isVisible();
        }, true);
        this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
            this.needUpdatePosition = this.showIcon;
        }, true);
        this.needUpdateVisibility = true;
    }
    /** @inheritdoc */
    onMapProjectionChanged() {
        this.needUpdatePosition = this.showIcon;
    }
    /** @inheritdoc */
    onUpdated() {
        if (this.needUpdatePosition) {
            this.updateIconPosition();
            this.needUpdatePosition = false;
            this.needUpdateVisibility = false;
        }
        else if (this.needUpdateVisibility) {
            this.updateIconVisibility();
            this.needUpdateVisibility = false;
        }
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
        this.rootStyle.set('display', this.showIcon ? 'flex' : 'none');
    }
    /**
     * Updates the airplane icon's projected position.
     */
    updateIconPosition() {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapCrossTrackErrorLayer.vec2Cache[0]);
        this.iconTransform.set(projected[0], projected[1], 0, 0.1);
        this.rootStyle.set('transform', this.iconTransform.resolve());
        this.updateIconVisibility();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-cross-track-error-container", style: this.rootStyle },
            FSComponent.buildComponent("span", { style: this.spanStyle }, this.xtkString)));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e;
        (_a = this.xtkSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.showSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.positionSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.iconSizeSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.iconAnchorSub) === null || _e === void 0 ? void 0 : _e.destroy();
        super.destroy();
    }
}
MapCrossTrackErrorLayer.vec2Cache = [Vec2Math.create()];

/**
 * A map layer which displays a track vector.
 */
class MapPositionTrendVectorLayer extends MapLayer {
    constructor() {
        var _a, _b, _c, _d;
        super(...arguments);
        this.lookaheadTime = NumberUnitSubject.create(UnitType.SECOND.createNumber(90));
        this.canvasLayerRef = FSComponent.createRef();
        this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapPositionTrendVectorLayer.DEFAULT_STROKE_WIDTH;
        this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapPositionTrendVectorLayer.DEFAULT_STROKE_STYLE;
        this.outlineWidth = (_c = this.props.outlineWidth) !== null && _c !== void 0 ? _c : MapPositionTrendVectorLayer.DEFAULT_OUTLINE_WIDTH;
        this.outlineStyle = (_d = this.props.outlineStyle) !== null && _d !== void 0 ? _d : MapPositionTrendVectorLayer.DEFAULT_OUTLINE_STYLE;
        this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
        this.module = this.props.model.getModule(BoeingMapKeys.PositionTrendVector);
        this.arcTurnRateThreshold = !this.props.arcTurnRateThreshold
            ? undefined
            : (typeof this.props.arcTurnRateThreshold === 'object')
                ? this.props.arcTurnRateThreshold
                : Subject.create(this.props.arcTurnRateThreshold);
        this.arcMaxLookaheadTime = ('isSubscribable' in this.props.arcMaxLookaheadTime)
            ? this.props.arcMaxLookaheadTime
            : Subject.create(this.props.arcMaxLookaheadTime);
        this.projectedPlanePosition = Vec2Subject.createFromVector(new Float64Array(2));
        this.projectPlanePositionHandler = () => {
            const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapPositionTrendVectorLayer.vec2Cache[0]);
            this.projectedPlanePosition.set(projected);
        };
        this.turnRateSmoother = new ExpSmoother(500 / Math.LN2, undefined, 1000);
        this.needUpdate = false;
        this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        var _a, _b;
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
        }
    }
    /** @inheritdoc */
    onAttached() {
        var _a, _b, _c, _d;
        this.canvasLayerRef.instance.onAttached();
        this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
        const scheduleUpdate = () => { this.needUpdate = true; };
        const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
        this.isVectorVisible = MappedSubject.create(([show, isOnGround, isGpsValid, isHeadingValid, isAttitudeValid, isAdcValid, mapRange]) => {
            return show && !isOnGround && isGpsValid && isAdcValid && (isHeadingValid || isAttitudeValid) && mapRange >= this.props.minRangeVisible;
        }, this.module.show, this.ownAirplanePropsModule.isOnGround, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.headingSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true), (_c = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.attitudeSignalValid) !== null && _c !== void 0 ? _c : Subject.create(true), (_d = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _d !== void 0 ? _d : Subject.create(true), this.props.ndDataProvider.mapRange);
        this.isVectorVisible.sub(isVisible => { this.setVisible(isVisible); }, true);
        this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.turnRate.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.lookaheadTime.sub(scheduleUpdate), this.props.ndDataProvider.mapRange.sub(range => {
            if (range > 20 || this.props.alwaysShow3Segments) {
                this.lookaheadTime.set(90);
            }
            else if (range === 20) {
                this.lookaheadTime.set(60);
            }
            else {
                this.lookaheadTime.set(30);
            }
        }, true));
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
        this.projectPlanePositionHandler();
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const display = this.canvasLayerRef.instance.display;
        display.clear();
        const lookaheadTime = this.lookaheadTime.get();
        const track = this.ownAirplanePropsModule.trackTrue.get();
        const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
        const turnRate = this.turnRateSmoother.next(this.ownAirplanePropsModule.turnRate.get(), elapsed);
        const distanceNM = groundSpeed.asUnit(UnitType.KNOT) * lookaheadTime.asUnit(UnitType.HOUR);
        const distancePx = UnitType.NMILE.convertTo(distanceNM, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
        const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - Math.PI / 2;
        const projectedPlanePos = this.projectedPlanePosition.get();
        display.context.beginPath();
        display.context.moveTo(projectedPlanePos[0], projectedPlanePos[1]);
        let length = 0;
        if (this.arcTurnRateThreshold && Math.abs(turnRate) < this.arcTurnRateThreshold.get() || lookaheadTime.compare(this.arcMaxLookaheadTime.get()) > 0) {
            // draw a line
            const delta = Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapPositionTrendVectorLayer.vec2Cache[0]);
            display.context.lineTo(projectedPlanePos[0] + delta[0], projectedPlanePos[1] + delta[1]);
            length = distancePx;
        }
        else {
            // draw an arc
            const groundSpeedPxPerSec = UnitType.NMILE.convertTo(groundSpeed.asUnit(UnitType.KNOT) / 3600, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
            const turnRadius = groundSpeedPxPerSec / (turnRate * Avionics.Utils.DEG2RAD);
            const angularWidthDrawn = Utils.Clamp(distancePx / turnRadius, -Math.PI / 2, Math.PI / 2);
            const circleOffsetAngle = projectedTrackAngle + Math.PI / 2;
            const circleCenter = Vec2Math.add(Vec2Math.setFromPolar(turnRadius, circleOffsetAngle, MapPositionTrendVectorLayer.vec2Cache[0]), projectedPlanePos, MapPositionTrendVectorLayer.vec2Cache[0]);
            const startAngle = circleOffsetAngle + (turnRadius < 0 ? 0 : Math.PI);
            const endAngle = startAngle + angularWidthDrawn;
            display.context.arc(circleCenter[0], circleCenter[1], Math.abs(turnRadius), startAngle, endAngle, turnRadius < 0);
            length = turnRadius * angularWidthDrawn;
        }
        const gapSize = 8;
        const segmentCount = lookaheadTime.asUnit(UnitType.SECOND) / this.props.segmentLengthSeconds;
        const gapCount = Math.max(0, segmentCount - 1);
        display.context.setLineDash([((length - (gapSize * gapCount) - ((this.strokeWidth / 2) + this.outlineWidth)) / segmentCount), gapSize]);
        display.context.lineCap = 'round';
        display.context.lineWidth = this.strokeWidth + this.outlineWidth * 2;
        display.context.strokeStyle = this.outlineStyle;
        display.context.stroke();
        display.context.lineWidth = this.strokeWidth;
        display.context.strokeStyle = this.strokeStyle;
        display.context.stroke();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : '' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.isVectorVisible) === null || _a === void 0 ? void 0 : _a.destroy();
        this.subscriptions.forEach(sub => sub.destroy());
    }
}
MapPositionTrendVectorLayer.DEFAULT_STROKE_WIDTH = 2; // px
MapPositionTrendVectorLayer.DEFAULT_STROKE_STYLE = 'cyan';
MapPositionTrendVectorLayer.DEFAULT_OUTLINE_WIDTH = 1; // px
MapPositionTrendVectorLayer.DEFAULT_OUTLINE_STYLE = '#505050';
MapPositionTrendVectorLayer.vec2Cache = [new Float64Array(2)];

/** A waypoint icon factory for VNAV waypoints. */
class MapTodIconFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
        this.ICON_SIZE = Vec2Math.create(50 * this.mapStyles.canvasScale, 50 * this.mapStyles.canvasScale);
    }
    /** @inheritdoc */
    getIcon(role, waypoint) {
        return new MapTodIcon(waypoint, BoeingMapWaypointIconPriority.TopOfDescent, this.ICON_SIZE, { offset: new Float64Array([0, 0.5]) });
    }
}
/** A waypoint label factory for VNAV waypoints. */
class MapTocLabelFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        return new MapCullableLocationTextLabel('T/C', BoeingMapLabelPriority.TopOfDescent, waypoint.location, true, {
            fontSize: this.mapStyles.labelFontSize,
            fontColor: BoeingColors.green,
            font: 'B787',
            anchor: new Float64Array([-0.35, 0.4]),
            offset: new Float64Array([5 * this.mapStyles.canvasScale, 2 * this.mapStyles.canvasScale]),
            fontOutlineWidth: this.mapStyles.outlineWidth,
            fontOutlineColor: BoeingColors.black,
        });
    }
}
/** A waypoint label factory for VNAV waypoints. */
class MapTodLabelFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        return new MapCullableLocationTextLabel('T/D', BoeingMapLabelPriority.TopOfDescent, waypoint.location, true, {
            fontSize: this.mapStyles.labelFontSize,
            fontColor: BoeingColors.green,
            font: 'B787',
            anchor: new Float64Array([-0.35, 0.4]),
            offset: new Float64Array([5 * this.mapStyles.canvasScale, 2 * this.mapStyles.canvasScale]),
            fontOutlineWidth: this.mapStyles.outlineWidth,
            fontOutlineColor: BoeingColors.black,
        });
    }
}
/** A waypoint label factory for VNAV waypoints. */
class MapBodLabelFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
        return new MapCullableLocationTextLabel('E/D', BoeingMapLabelPriority.TopOfDescent, waypoint.location, true, {
            fontSize: this.mapStyles.labelFontSize,
            fontColor: BoeingColors.green,
            font: 'B787',
            anchor: new Float64Array([-0.35, 0.4]),
            offset: new Float64Array([5 * this.mapStyles.canvasScale, 2 * this.mapStyles.canvasScale]),
            fontOutlineWidth: this.mapStyles.outlineWidth,
            fontOutlineColor: BoeingColors.black,
        });
    }
}
/** A VNAV waypoint icon. */
class MapTodIcon extends MapWaypointImageIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param size The size of this icon, as `[width, height]` in pixels.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, size, options) {
        super(waypoint, priority, ImageCache.get('TOD'), size, options);
    }
}
/** A waypoint icon factory for fix info waypoints. */
class MapFixInfoIconFactory {
    /**
     * Creates a new MapTocLabelFactory.
     * @param mapStyles The map styles.
     * @param clipPathStream The clip path stream.
     */
    constructor(mapStyles, clipPathStream) {
        this.mapStyles = mapStyles;
        this.clipPathStream = clipPathStream;
    }
    /** @inheritdoc */
    getIcon(role, waypoint) {
        return new MapFixInfoWaypointIcon(waypoint, this.mapStyles, this.clipPathStream);
    }
}
/** A map text label used for fix info. */
class FixInfoTextLabel extends MapCullableLocationTextLabel {
    /**
     * Constructor.
     * @param fixInfoWaypoint The fix info waypoint.
     * @param text The text of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(fixInfoWaypoint, text, options) {
        super(text, BoeingMapLabelPriority.TopOfDescent, fixInfoWaypoint.location, true, options);
    }
}
/**
 * A map text label used for fix info distance circles.
 */
class FixInfoDistanceTextLabel extends FixInfoTextLabel {
    /**
     * Constructor.
     * @param fixInfoWaypoint The fix info waypoint.
     * @param mapStyles The map styles.
     * @param distanceMeters The distance in meters.
     */
    constructor(fixInfoWaypoint, mapStyles, distanceMeters) {
        const distanceLabelOffset = Vec2Subject.create(new Float64Array([0, 0]));
        const distanceNM = UnitType.METER.convertTo(distanceMeters, UnitType.NMILE);
        const text = Math.round(distanceNM).toFixed(0);
        super(fixInfoWaypoint, text, {
            fontSize: mapStyles.labelFontSize,
            font: BoeingMapCommon.font,
            fontColor: BoeingColors.green,
            offset: distanceLabelOffset,
            anchor: new Float64Array([0.5, 0.5]),
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: mapStyles.fontOutlineWidth,
        });
        this.distanceLabelOffset = distanceLabelOffset;
        this.mapStyles = mapStyles;
        this.fixInfo = fixInfoWaypoint.fixInfo;
        this.distanceMeters = distanceMeters;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const mapTargetProjected = mapProjection.getTargetProjected();
        const fixCenterProjected = mapProjection.project(this.fixInfo.location, FixInfoDistanceTextLabel.vec2Cache[0]);
        const fixToTargetVector = FixInfoDistanceTextLabel.vec2Cache[1];
        Vec2Math.sub(mapTargetProjected, fixCenterProjected, fixToTargetVector);
        Vec2Math.normalize(fixToTargetVector, fixToTargetVector);
        const gaRadians = UnitType.METER.convertTo(this.distanceMeters, UnitType.GA_RADIAN);
        const gaRadiansToPixels = mapProjection.getGeoProjection().getScaleFactor() * (1 / Math.cos(mapProjection.getTarget().lat * Avionics.Utils.DEG2RAD));
        const pixelOffset = 35 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale;
        const distancePixels = (gaRadians * gaRadiansToPixels) + pixelOffset;
        const offset = Vec2Math.multScalar(fixToTargetVector, distancePixels, fixToTargetVector);
        // TODO Less padding when on left or right side with less characters
        // TODO Less passing when on top and bottom
        this.distanceLabelOffset.set(offset[0], offset[1]);
        super.draw(context, mapProjection);
    }
}
FixInfoDistanceTextLabel.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A map text label used for fix info radials.
 */
class FixInfoRadialTextLabel extends FixInfoTextLabel {
    /**
     * Constructor.
     * @param fixInfoWaypoint The fix info waypoint.
     * @param mapStyles The map styles.
     * @param bearingDegreesTrue The true bearing/radial.
     */
    constructor(fixInfoWaypoint, mapStyles, bearingDegreesTrue) {
        const radialLabelOffset = Vec2Subject.create(new Float64Array([0, 0]));
        const bearingDegreesMagnetic = MagVar.trueToMagnetic(bearingDegreesTrue, fixInfoWaypoint.fixInfo.magVar);
        let rounded = Math.round(bearingDegreesMagnetic);
        rounded = rounded === 0 ? 360 : rounded;
        const text = rounded.toFixed(0).padStart(3, '0');
        super(fixInfoWaypoint, text, {
            fontSize: mapStyles.labelFontSize,
            font: BoeingMapCommon.font,
            fontColor: BoeingColors.green,
            offset: radialLabelOffset,
            anchor: new Float64Array([0.5, 0.5]),
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: mapStyles.fontOutlineWidth,
        });
        this.radialLabelOffset = radialLabelOffset;
        this.mapStyles = mapStyles;
        this.bearingDegreesTrue = bearingDegreesTrue;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const bearingRadians = UnitType.DEGREE.convertTo(this.bearingDegreesTrue, UnitType.RADIAN) + mapProjection.getRotation() - (0.5 * Math.PI);
        const distanceFromFixPixels = 200 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale;
        const offsetAngleRadians = -0.15;
        const offset = Vec2Math.setFromPolar(distanceFromFixPixels, bearingRadians + offsetAngleRadians, FixInfoRadialTextLabel.vec2Cache[0]);
        this.radialLabelOffset.set(offset[0], offset[1]);
        super.draw(context, mapProjection);
    }
}
FixInfoRadialTextLabel.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A map text label used for fix info abeam.
 */
class FixInfoAbeamTextLabel extends FixInfoTextLabel {
    /**
     * Constructor.
     * @param fixInfoWaypoint The fix info waypoint.
     * @param mapStyles The map styles.
     * @param abeamIntersection The abeam intersection.
     */
    constructor(fixInfoWaypoint, mapStyles, abeamIntersection) {
        const abeamLabelOffset = Vec2Subject.create(new Float64Array([0, 0]));
        const bearingText = Subject.create('');
        super(fixInfoWaypoint, bearingText, {
            fontSize: mapStyles.labelFontSize,
            font: BoeingMapCommon.font,
            fontColor: BoeingColors.green,
            offset: abeamLabelOffset,
            anchor: new Float64Array([0.5, 0.5]),
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: mapStyles.fontOutlineWidth,
        });
        this.lastBearingTrue = 0;
        this.abeamLabelOffset = abeamLabelOffset;
        this.bearingText = bearingText;
        this.mapStyles = mapStyles;
        this.abeamIntersection = abeamIntersection;
        this.fixInfo = fixInfoWaypoint.fixInfo;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const bearingDegreesTrue = this.fixInfo.location.bearingTo(this.abeamIntersection);
        // Only generate new strings if we need to
        // The bearing can change if the flight plan changes
        if (bearingDegreesTrue !== this.lastBearingTrue) {
            this.lastBearingTrue = bearingDegreesTrue;
            const bearingDegreesMagnetic = MagVar.trueToMagnetic(bearingDegreesTrue, this.fixInfo.magVar);
            let rounded = Math.round(bearingDegreesMagnetic);
            rounded = rounded === 0 ? 360 : rounded;
            this.bearingText.set(rounded.toFixed(0).padStart(3, '0'));
        }
        const bearingRadians = UnitType.DEGREE.convertTo(bearingDegreesTrue, UnitType.RADIAN) + mapProjection.getRotation() - (0.5 * Math.PI);
        const distanceFromFixPixels = 65 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale;
        const offsetAngleRadians = -0.4;
        const offset = Vec2Math.setFromPolar(distanceFromFixPixels, bearingRadians + offsetAngleRadians, FixInfoAbeamTextLabel.vec2Cache[0]);
        this.abeamLabelOffset.set(offset[0], offset[1]);
        super.draw(context, mapProjection);
    }
}
FixInfoAbeamTextLabel.vec2Cache = [new Float64Array(2), new Float64Array(2)];
/**
 * A map text label used for fix info markers.
 */
class FixInfoMarkerTextLabel extends MapCullableLocationTextLabel {
    /**
     * Constructor.
     * @param fixInfoMarker The fix info marker.
     * @param mapStyles The map styles.
     * @param altitudeInputFormatter Altitude formatter.
     * @param timeInputFormatter Time formatter.
     */
    constructor(fixInfoMarker, mapStyles, altitudeInputFormatter, timeInputFormatter) {
        const markerText = Subject.create('');
        super(markerText, BoeingMapLabelPriority.TopOfDescent, fixInfoMarker.location, true, {
            fontSize: mapStyles.labelFontSize,
            font: BoeingMapCommon.font,
            fontColor: BoeingColors.green,
            anchor: new Float64Array([-0.35, 0.4]),
            offset: new Float64Array([1 * mapStyles.canvasScale, 2 * mapStyles.canvasScale]),
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: mapStyles.fontOutlineWidth,
        });
        this.markerText = markerText;
        this.fixInfoMarker = fixInfoMarker;
        this.altitudeInputFormatter = altitudeInputFormatter;
        this.timeInputFormatter = timeInputFormatter;
        this.lastAltitude = null;
        this.lastEta = null;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        let needsUpdate = false;
        if (this.fixInfoMarker.altitude !== this.lastAltitude) {
            this.lastAltitude = this.fixInfoMarker.altitude;
            needsUpdate = true;
        }
        if (this.fixInfoMarker.estimatedTimeOfArrival !== this.lastEta) {
            this.lastEta = this.fixInfoMarker.estimatedTimeOfArrival;
            needsUpdate = true;
        }
        if (needsUpdate) {
            let labelText = '';
            if (this.fixInfoMarker.altitude !== null) {
                labelText = this.altitudeInputFormatter(this.fixInfoMarker.altitude);
            }
            else if (this.fixInfoMarker.estimatedTimeOfArrival !== null) {
                labelText = this.timeInputFormatter(this.fixInfoMarker.estimatedTimeOfArrival);
            }
            this.markerText.set(labelText);
        }
        super.draw(context, mapProjection);
    }
}
// TODO? Don't use MapWaypointIcon for this, there's no need for it
/**
 * An icon for a fix info waypoint.
 */
class MapFixInfoWaypointIcon extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint.
     * @param mapStyles The map styles.
     * @param clipPathStream The path stream to draw to.
     */
    constructor(waypoint, mapStyles, clipPathStream) {
        super(waypoint, BoeingMapWaypointIconPriority.TopOfDescent, MapFixInfoWaypointIcon.ICON_SIZE, { anchor: MapFixInfoWaypointIcon.anchor00 });
        this.mapStyles = mapStyles;
        this.clipPathStream = clipPathStream;
        this.distanceCircleDash = [
            25 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale,
            10 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale
        ];
        this.solidCircleDiameterPixels = 50 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale;
        if (waypoint instanceof FixInfoFacilityWaypoint) {
            this.fixInfo = waypoint.fixInfo;
        }
        else {
            throw new Error('only FixInfoFacilityWaypoint should be used with MapFixInfoWaypointIcon');
        }
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, x, y) {
        context.lineCap = 'round';
        context.setLineDash(this.distanceCircleDash);
        this.drawDistanceCircles(context, x, y, mapProjection);
        this.drawRadials(context, mapProjection, x, y);
        this.drawAbeams(context, mapProjection, x, y);
        context.setLineDash(MapFixInfoWaypointIcon.noLineDash);
        this.drawSolidCircle(context, x, y);
    }
    /**
     * Draws the radials, if required.
     * @param context The context to draw to.
     * @param mapProjection The map projection to use.
     * @param x The x position in pixels.
     * @param y The y position in pixels.
     */
    drawRadials(context, mapProjection, x, y) {
        if (this.fixInfo.bearings.length > 0) {
            this.clipPathStream.beginPath();
            for (let i = 0; i < this.fixInfo.bearings.length; i++) {
                const bearing = UnitType.DEGREE.convertTo(this.fixInfo.bearings[i], UnitType.RADIAN) + mapProjection.getRotation() - (0.5 * Math.PI);
                let rot = Vec2Math.setFromPolar(this.solidCircleDiameterPixels / 2, bearing, MapFixInfoWaypointIcon.vec2Cache[0]);
                let point = Vec2Math.set(x, y, MapFixInfoWaypointIcon.vec2Cache[1]);
                point = Vec2Math.add(rot, point, point);
                rot = Vec2Math.setFromPolar(mapProjection.getScaleFactor(), bearing, MapFixInfoWaypointIcon.vec2Cache[0]);
                this.clipPathStream.moveTo(point[0], point[1]);
                point = Vec2Math.add(rot, point, point);
                this.clipPathStream.lineTo(point[0], point[1]);
            }
            this.applyStrokes(context);
        }
    }
    /**
     * Draws the abeam lines, if required.
     * @param context The context to draw to.
     * @param mapProjection The map projection to use.
     * @param x The x position in pixels.
     * @param y The y position in pixels.
     */
    drawAbeams(context, mapProjection, x, y) {
        if (this.fixInfo.abeamIntersections.length > 0) {
            this.clipPathStream.beginPath();
            for (let i = 0; i < this.fixInfo.abeamIntersections.length; i++) {
                const bearing = UnitType.DEGREE.convertTo(this.fixInfo.location.bearingTo(this.fixInfo.abeamIntersections[i]), UnitType.RADIAN)
                    + mapProjection.getRotation() - (0.5 * Math.PI);
                const rot = Vec2Math.setFromPolar(this.solidCircleDiameterPixels / 2, bearing, MapFixInfoWaypointIcon.vec2Cache[0]);
                let point = Vec2Math.set(x, y, MapFixInfoWaypointIcon.vec2Cache[1]);
                point = Vec2Math.add(rot, point, point);
                this.clipPathStream.moveTo(point[0], point[1]);
                point = mapProjection.project(this.fixInfo.abeamIntersections[i], point);
                this.clipPathStream.lineTo(point[0], point[1]);
            }
            this.applyStrokes(context);
        }
    }
    /**
     * Draws a ring for this fix.
     * @param context  A canvas rendering context.
     * @param x The x position in pixels.
     * @param y The y position in pixels.
     */
    drawSolidCircle(context, x, y) {
        this.clipPathStream.beginPath();
        this.clipPathStream.arc(x, y, this.solidCircleDiameterPixels / 2, 0, (2 * Math.PI) - 0.001);
        this.applyStrokes(context);
    }
    /**
     * Draws the rings for this fix.
     * @param context  A canvas rendering context.
     * @param x The x position in pixels.
     * @param y The y position in pixels.
     * @param mapProjection The map projection.
     */
    drawDistanceCircles(context, x, y, mapProjection) {
        this.clipPathStream.beginPath();
        // For each BRG/DIS group, draw distance rings and bearing lines
        this.fixInfo.circleRadii.forEach(radiusMeters => this.drawDistanceCircle(context, radiusMeters, x, y, mapProjection));
        this.applyStrokes(context);
    }
    /**
     * Draws a ring for this fix.
     * @param context  A canvas rendering context.
     * @param radiusMeters The circle radius in meters.
     * @param x The x position in pixels.
     * @param y The y position in pixels.
     * @param mapProjection The map projection.
     */
    drawDistanceCircle(context, radiusMeters, x, y, mapProjection) {
        const gaRadians = UnitType.METER.convertTo(radiusMeters, UnitType.GA_RADIAN);
        const gaRadiansToPixels = Math.abs(mapProjection.getGeoProjection().getScaleFactor() * (1 / Math.cos(mapProjection.getTarget().lat * Avionics.Utils.DEG2RAD)));
        const radiusPixels = gaRadians * gaRadiansToPixels;
        this.clipPathStream.moveTo(x + radiusPixels, y);
        this.clipPathStream.arc(x, y, radiusPixels, 0, 2 * Math.PI);
    }
    /**
     * Applies outline and main stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     */
    applyStrokes(context) {
        if (this.mapStyles.outlineWidth > 0) {
            this.applyStroke(context, (this.mapStyles.strokeWidth + 2 * this.mapStyles.outlineWidth), BoeingColors.black);
        }
        this.applyStroke(context, this.mapStyles.strokeWidth, BoeingColors.green);
    }
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     * @param lineWidth The width of the stroke.
     * @param strokeStyle The style of the stroke.
     */
    applyStroke(context, lineWidth, strokeStyle) {
        context.lineWidth = lineWidth;
        context.strokeStyle = strokeStyle;
        context.stroke();
    }
}
// Icon size is 1 because we don't use it, because our anchor is (0, 0)
MapFixInfoWaypointIcon.ICON_SIZE = Vec2Math.create(1, 1);
MapFixInfoWaypointIcon.noLineDash = [];
MapFixInfoWaypointIcon.vec2Cache = [new Float64Array(2), new Float64Array(2)];
MapFixInfoWaypointIcon.geoPointCache = [new GeoPoint(NaN, NaN), new GeoPoint(NaN, NaN)];
MapFixInfoWaypointIcon.anchor00 = new Float64Array([0, 0]);
MapFixInfoWaypointIcon.rightVector = new Float64Array([1, 0]);
/**
 * A basic implementation of {@link FacilityWaypoint}.
 */
class FixInfoFacilityWaypoint extends BasicFacilityWaypoint {
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     * @param bus The event bus.
     * @param fixInfo The fix info.
     */
    constructor(facility, bus, fixInfo) {
        super(facility, bus);
        this.fixInfo = fixInfo;
    }
    /** @inheritdoc */
    get uid() {
        return this.facility.get().icao + '-fix-info';
    }
}
/**
 * A fix info marker waypoint.
 */
class FixInfoMarkerWaypoint extends AbstractWaypoint {
    /**
     * Constructor.
     * @param marker The fix info marker.
     * @param index The index of the marker.
     */
    constructor(marker, index) {
        super();
        this.marker = marker;
        this._uid = 'fix-info-marker-' + index.toFixed(0);
        this._location = GeoPointSubject.create(marker.location);
    }
    /** @inheritdoc */
    get type() { return WaypointTypes.VNAV; }
    /** @inheritdoc */
    get location() {
        return this._location;
    }
    /** @inheritdoc */
    get uid() {
        return this._uid;
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/** The map layer for displaying the Tod. */
class MapTodLayer extends MapSyncedCanvasLayer {
    constructor() {
        super(...arguments);
        this.TocWaypointRole = 'TocRole';
        this.TodWaypointRole = 'TodRole';
        this.BodWaypointRole = 'BodRole';
        this.FixInfoWaypointRole = 'FixInfoWaypointRole';
        this.FixInfoMarkerRole = 'FixInfoMarkerRole';
        this.vnavPathMode = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_path_mode').whenChanged(), VNavPathMode.None);
        this.vnavTocLegIndex = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_toc_global_leg_index').whenChanged(), -1);
        this.vnavTocLegDistance = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_toc_leg_distance').whenChanged(), -1);
        this.vnavDistanceToToc = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_toc_distance').whenChanged(), -1);
        this.vnavTodLegIndex = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_tod_global_leg_index').whenChanged(), -1);
        this.vnavTodLegDistance = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_tod_leg_distance').whenChanged(), -1);
        this.vnavDistanceToTod = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_tod_distance').whenChanged(), -1);
        this.vnavBodLegIndex = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_bod_global_leg_index').whenChanged(), -1);
        this.vnavDistanceToBod = ConsumerSubject.create(this.props.bus.getSubscriber().on('vnav_bod_distance').whenChanged(), -1);
        this.mapStyles = this.props.model.getModule(BoeingMapKeys.MapStyles).styles;
        this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
        this.boundsSub = VecNSubject.create(new Float64Array(4));
        this.clipPathStream = new ClippedPathStream(NullPathStream.INSTANCE, this.boundsSub);
        this.fixInfoWpEntries = new Map();
        this.fixInfoMarkerEntries = new Map();
        this.fmsOperatingPhase = ConsumerSubject.create(this.props.bus.getSubscriber().on('fms_operating_phase'), 0);
        this.transitionAltitudeOrLevel = this.props.activePerformancePlan && MappedSubject.create(([fmsPhase, transAlt, transLevel]) => fmsPhase < FmsOperatingPhase.CRUISE ? transAlt : transLevel, this.fmsOperatingPhase, this.props.activePerformancePlan.transitionAltitude, this.props.activePerformancePlan.transitionLevel);
        this.altitudeInputFormatter = this.transitionAltitudeOrLevel && B787FmcFormatters.Altitude('display', this.transitionAltitudeOrLevel);
        this.timeInputFormatter = B787FmcFormatters.UtcTime('display');
    }
    /** @inheritdoc */
    onAttached() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        super.onAttached();
        this.props.waypointRenderer.addRenderRole(this.TocWaypointRole);
        this.props.waypointRenderer.addRenderRole(this.TodWaypointRole);
        this.props.waypointRenderer.addRenderRole(this.BodWaypointRole);
        this.props.waypointRenderer.addRenderRole(this.FixInfoWaypointRole);
        this.props.waypointRenderer.addRenderRole(this.FixInfoMarkerRole);
        // ToC
        this.props.waypointRenderer.setCanvasContext((_a = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _a !== void 0 ? _a : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_b = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _b !== void 0 ? _b : 0, new MapTodIconFactory(this.mapStyles));
        this.props.waypointRenderer.setLabelFactory((_c = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _c !== void 0 ? _c : 0, new MapTocLabelFactory(this.mapStyles));
        // ToD
        this.props.waypointRenderer.setCanvasContext((_d = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _d !== void 0 ? _d : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_e = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _e !== void 0 ? _e : 0, new MapTodIconFactory(this.mapStyles));
        this.props.waypointRenderer.setLabelFactory((_f = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _f !== void 0 ? _f : 0, new MapTodLabelFactory(this.mapStyles));
        // BoD
        this.props.waypointRenderer.setCanvasContext((_g = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _g !== void 0 ? _g : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_h = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _h !== void 0 ? _h : 0, new MapTodIconFactory(this.mapStyles));
        this.props.waypointRenderer.setLabelFactory((_j = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _j !== void 0 ? _j : 0, new MapBodLabelFactory(this.mapStyles));
        // FixInfoWaypointRole
        this.props.waypointRenderer.setCanvasContext((_k = this.props.waypointRenderer.getRoleFromName(this.FixInfoWaypointRole)) !== null && _k !== void 0 ? _k : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_l = this.props.waypointRenderer.getRoleFromName(this.FixInfoWaypointRole)) !== null && _l !== void 0 ? _l : 0, new MapFixInfoIconFactory(this.mapStyles, this.clipPathStream));
        // FixInfoMarkerRole
        this.props.waypointRenderer.setCanvasContext((_m = this.props.waypointRenderer.getRoleFromName(this.FixInfoMarkerRole)) !== null && _m !== void 0 ? _m : 0, this.display.context);
        this.props.waypointRenderer.setIconFactory((_o = this.props.waypointRenderer.getRoleFromName(this.FixInfoMarkerRole)) !== null && _o !== void 0 ? _o : 0, new MapTodIconFactory(this.mapStyles));
        this.vnavPathMode.sub(() => { this.updateTodWaypoint(); });
        this.vnavTocLegIndex.sub(() => { this.updateTocWaypoint(); });
        this.vnavTocLegDistance.sub(() => { this.updateTocWaypoint(); });
        this.vnavDistanceToToc.sub(() => { this.updateTocWaypoint(); });
        this.vnavTodLegIndex.sub(() => { this.updateTodWaypoint(); });
        this.vnavTodLegDistance.sub(() => { this.updateTodWaypoint(); });
        this.vnavDistanceToTod.sub(() => { this.updateTodWaypoint(); });
        this.vnavBodLegIndex.sub(() => { this.updateBodWaypoint(); });
        this.vnavDistanceToBod.sub(() => { this.updateBodWaypoint(); });
        // We also update every `fplCalculated` so that we refresh with valid leg calculations
        this.props.bus.getSubscriber().on('fplCalculated').handle(() => {
            this.updateTocWaypoint();
            this.updateTodWaypoint();
            this.updateBodWaypoint();
        });
        if (this.props.fixInfo) {
            this.props.fixInfo.ndWaypoints.sub(async (index, type, item, array) => {
                switch (type) {
                    case SubscribableArrayEventType.Added: {
                        if (!item) {
                            return;
                        }
                        if ('fixIdent' in item) {
                            this.handleFixInfoWpAdded(item);
                        }
                        else {
                            item.forEach(x => this.handleFixInfoWpAdded(x));
                        }
                        break;
                    }
                    case SubscribableArrayEventType.Removed: {
                        if (!item) {
                            return;
                        }
                        if ('fixIdent' in item) {
                            this.handleFixInfoWpRemoved(item);
                        }
                        else {
                            item.forEach(x => this.handleFixInfoWpRemoved(x));
                        }
                        break;
                    }
                    case SubscribableArrayEventType.Cleared: {
                        this.fixInfoWpEntries.forEach(x => this.deregisterFixInfoWpEntry(x));
                        this.fixInfoWpEntries.clear();
                        break;
                    }
                }
            }, true);
            this.props.fixInfo.ndMarkers.sub(async (index, type, item, array) => {
                switch (type) {
                    case SubscribableArrayEventType.Added: {
                        if (!item) {
                            return;
                        }
                        if ('location' in item) {
                            this.handleFixInfoMarkerAdded(item, index);
                        }
                        else {
                            item.forEach((x, i) => this.handleFixInfoMarkerAdded(x, index + i));
                        }
                        break;
                    }
                    case SubscribableArrayEventType.Removed: {
                        if (!item) {
                            return;
                        }
                        if ('location' in item) {
                            this.handleFixInfoMarkerRemoved(item);
                        }
                        else {
                            item.forEach(x => this.handleFixInfoMarkerRemoved(x));
                        }
                        break;
                    }
                    case SubscribableArrayEventType.Cleared: {
                        this.fixInfoMarkerEntries.forEach(x => this.deregisterFixInfoMarkerEntry(x));
                        this.fixInfoMarkerEntries.clear();
                        break;
                    }
                }
            }, true);
        }
        const width = this.getWidth();
        const height = this.getHeight();
        this.boundsSub.set(-10, -10, width + 10, height + 10);
        this.clipPathStream.setConsumer(this.display.context);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        super.onMapProjectionChanged(mapProjection, changeFlags);
        if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
            const width = this.getWidth();
            const height = this.getHeight();
            this.boundsSub.set(-10, -10, width + 10, height + 10);
        }
    }
    /**
     * Handles a new fix info waypoint being added.
     * @param wp The new waypoint.
     */
    async handleFixInfoWpAdded(wp) {
        var _a, _b, _c;
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(wp.fixIcao), wp.fixIcao);
        if (((_a = this.props.fixInfo) === null || _a === void 0 ? void 0 : _a.ndWaypoints.getArray().includes(wp)) === false) {
            // If wp was removed while getting the fac, don't register it
            return;
        }
        const fixInfoWaypoint = new FixInfoFacilityWaypoint(facility, this.props.bus, wp);
        const basicFacWaypoint = new BasicFacilityWaypoint(facility, this.props.bus);
        const entry = {
            fixInfoWaypoint,
            basicFacWaypoint,
            labels: []
        };
        this.props.waypointRenderer.register(fixInfoWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(this.FixInfoWaypointRole)) !== null && _b !== void 0 ? _b : 0, 'fix-info-layer');
        this.props.waypointRenderer.register(basicFacWaypoint, (_c = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.Normal)) !== null && _c !== void 0 ? _c : 0, 'fix-info-layer');
        wp.circleRadii.forEach(radiusMeters => {
            const label = new FixInfoDistanceTextLabel(fixInfoWaypoint, this.mapStyles, radiusMeters);
            this.props.textManager.register(label);
            entry.labels.push(label);
        });
        wp.bearings.forEach(bearing => {
            const label = new FixInfoRadialTextLabel(fixInfoWaypoint, this.mapStyles, bearing);
            this.props.textManager.register(label);
            entry.labels.push(label);
        });
        wp.abeamIntersections.forEach(abeamIntersection => {
            const label = new FixInfoAbeamTextLabel(fixInfoWaypoint, this.mapStyles, abeamIntersection);
            this.props.textManager.register(label);
            entry.labels.push(label);
        });
        this.fixInfoWpEntries.set(wp, entry);
    }
    /**
     * Handles a new fix info waypoint being added.
     * @param marker The new marker.
     * @param index The fix info index, used for making the uid.
     */
    handleFixInfoMarkerAdded(marker, index) {
        var _a;
        const waypoint = new FixInfoMarkerWaypoint(marker, index);
        const entry = {
            waypoint,
            labels: []
        };
        this.props.waypointRenderer.register(waypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.FixInfoMarkerRole)) !== null && _a !== void 0 ? _a : 0, 'fix-info-layer');
        const label = new FixInfoMarkerTextLabel(marker, this.mapStyles, this.altitudeInputFormatter, this.timeInputFormatter);
        this.props.textManager.register(label);
        entry.labels.push(label);
        this.fixInfoMarkerEntries.set(marker, entry);
    }
    /**
     * Handles when fix info waypoints are removed.
     * @param wp The waypoint that was removed.
     */
    handleFixInfoWpRemoved(wp) {
        const entry = this.fixInfoWpEntries.get(wp);
        if (entry !== undefined) {
            this.deregisterFixInfoWpEntry(entry);
            this.fixInfoWpEntries.delete(wp);
        }
    }
    /**
     * Handles when fix info waypoints are removed.
     * @param marker The marker that was removed.
     */
    handleFixInfoMarkerRemoved(marker) {
        const entry = this.fixInfoMarkerEntries.get(marker);
        if (entry !== undefined) {
            this.deregisterFixInfoMarkerEntry(entry);
            this.fixInfoMarkerEntries.delete(marker);
        }
    }
    /**
     * Deregisters a fix info entry from the renderers.
     * @param entry The wp entry to deregister.
     */
    deregisterFixInfoWpEntry(entry) {
        var _a, _b;
        this.props.waypointRenderer.deregister(entry.fixInfoWaypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.FixInfoWaypointRole)) !== null && _a !== void 0 ? _a : 0, 'fix-info-layer');
        this.props.waypointRenderer.deregister(entry.basicFacWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.Normal)) !== null && _b !== void 0 ? _b : 0, 'fix-info-layer');
        for (let i = 0; i < entry.labels.length; i++) {
            this.props.textManager.deregister(entry.labels[i]);
        }
    }
    /**
     * Deregisters a fix info entry from the renderers.
     * @param entry The marker entry to deregister.
     */
    deregisterFixInfoMarkerEntry(entry) {
        var _a;
        this.props.waypointRenderer.deregister(entry.waypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.FixInfoMarkerRole)) !== null && _a !== void 0 ? _a : 0, 'fix-info-layer');
        for (let i = 0; i < entry.labels.length; i++) {
            this.props.textManager.deregister(entry.labels[i]);
        }
    }
    /** Updates the T/C waypoint. */
    updateTocWaypoint() {
        var _a, _b;
        this.tocWaypoint && this.props.waypointRenderer.deregister(this.tocWaypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _a !== void 0 ? _a : 0, 'toc-layer-toc');
        this.tocWaypoint = undefined;
        if (this.props.planner.hasActiveFlightPlan()) {
            const plan = this.props.planner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
            if (plan.segmentCount > 1 && this.vnavTocLegIndex.get() >= 0) {
                try {
                    const leg = plan.getLeg(this.vnavTocLegIndex.get());
                    this.tocWaypoint = new VNavWaypoint(leg, this.vnavTocLegDistance.get(), 'vnav-toc', 'T/C');
                    this.props.waypointRenderer.register(this.tocWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(this.TocWaypointRole)) !== null && _b !== void 0 ? _b : 0, 'toc-layer-toc');
                }
                catch (error) {
                    console.warn(`Invalid ToC leg at: ${this.vnavTocLegIndex.get()}`);
                }
            }
        }
    }
    /** Updates the T/D waypoint. */
    updateTodWaypoint() {
        var _a, _b;
        this.todWaypoint && this.props.waypointRenderer.deregister(this.todWaypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _a !== void 0 ? _a : 0, 'tod-layer-tod');
        this.todWaypoint = undefined;
        if (this.props.planner.hasActiveFlightPlan()) {
            const plan = this.props.planner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
            if (plan.segmentCount > 1 && this.vnavTodLegIndex.get() >= 0) {
                try {
                    const leg = plan.getLeg(this.vnavTodLegIndex.get());
                    this.todWaypoint = new VNavWaypoint(leg, this.vnavTodLegDistance.get(), 'vnav-tod', 'T/D');
                    this.props.waypointRenderer.register(this.todWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(this.TodWaypointRole)) !== null && _b !== void 0 ? _b : 0, 'tod-layer-tod');
                }
                catch (error) {
                    console.warn(`Invalid ToD leg at: ${this.vnavTodLegIndex.get()}`);
                }
            }
        }
    }
    /** Updates the E/D waypoint. */
    updateBodWaypoint() {
        var _a, _b;
        this.bodWaypoint && this.props.waypointRenderer.deregister(this.bodWaypoint, (_a = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _a !== void 0 ? _a : 0, 'bod-layer-bod');
        this.bodWaypoint = undefined;
        if (this.props.planner.hasActiveFlightPlan()) {
            const plan = this.props.planner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
            if (plan.segmentCount > 1 && this.vnavBodLegIndex.get() >= 0) {
                try {
                    const leg = plan.getLeg(this.vnavBodLegIndex.get());
                    this.bodWaypoint = new VNavWaypoint(leg, 0, 'vnav-bod', 'E/D');
                    this.props.waypointRenderer.register(this.bodWaypoint, (_b = this.props.waypointRenderer.getRoleFromName(this.BodWaypointRole)) !== null && _b !== void 0 ? _b : 0, 'bod-layer-bod');
                }
                catch (error) {
                    console.warn(`Invalid BoD leg at: ${this.vnavBodLegIndex.get()}`);
                }
            }
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/** Plan airports runways layer */
class PlanAirportsRunwaysLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.updateRequired = false;
        /** Map<planIndex, Map<wptUid, labels>> */
        this.runwayLabelsMap = new Map([
            [BoeingFms.ACT_RTE_PLAN_INDEX, new Map()],
            [BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, new Map()],
            [BoeingFms.RTE_1_MOD_PLAN_INDEX, new Map()],
        ]);
        this.vec2Cache = new Array(11).fill(0).map(() => new Float64Array(2));
        this.geoPointCache = new Array(6).fill(0).map(() => new GeoPoint(0, 0));
        this.stylesModule = this.props.model.getModule(BoeingMapKeys.MapStyles);
        this.displayModule = this.props.model.getModule(BoeingMapKeys.PlanAirportsLayer);
        this.displayModeSub = this.displayModule.displayMode.sub(() => this.updateRequired = true);
        this.runwaysDisplayedSub = this.displayModule.displayRunways.sub(() => this.updateRequired = true);
        this.labelsDisplayedSub = this.displayModule.displayLabels.sub(() => this.updateRequired = true);
        this.focusChangedSub = this.displayModule.focusAirports.sub((index, type, item) => {
            switch (type) {
                case SubscribableArrayEventType.Added:
                    if (item && 'airport' in item) {
                        const { planIndex, airport, departureRunway, arrivalRunway } = item;
                        this.onFocusAirportAdded(planIndex, airport, departureRunway, arrivalRunway);
                    }
                    break;
                case SubscribableArrayEventType.Removed:
                    if (item && 'airport' in item) {
                        const { planIndex, airport } = item;
                        this.onFocusAirportRemoved(planIndex, airport);
                    }
                    break;
                case SubscribableArrayEventType.Cleared:
                    this.onFocusAirportsCleared();
                    break;
            }
        });
        this.noLineDash = [];
        this.centerlineDash = [15, 10];
    }
    /** @inheritdoc */
    onAttached() {
        this.canvasLayerRef.instance.onAttached();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
        this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        this.canvasLayerRef.instance.onUpdated(time, elapsed);
        const displayMode = this.displayModule.displayMode.get();
        const performUpdate = this.isVisible() && (this.updateRequired || this.canvasLayerRef.instance.display.isInvalid);
        if (performUpdate) {
            this.canvasLayerRef.instance.display.syncWithMapProjection(this.props.mapProjection);
            this.canvasLayerRef.instance.display.clear();
            const context = this.canvasLayerRef.instance.display.context;
            const geoProjection = this.canvasLayerRef.instance.display.geoProjection;
            const runwaysVisible = displayMode !== PlanAirportsLayerDisplayMode.None;
            if (runwaysVisible) {
                if (this.displayModule.displayRunways.get()) {
                    for (const { airport, departureRunway, arrivalRunway } of this.displayModule.focusAirports.getArray()) {
                        const hasRunway = !!(departureRunway || arrivalRunway);
                        const drawRunway = hasRunway && (displayMode === PlanAirportsLayerDisplayMode.AirportMap || displayMode === PlanAirportsLayerDisplayMode.Near);
                        const drawAirportCircle = displayMode === PlanAirportsLayerDisplayMode.Far || !hasRunway;
                        if (drawRunway) {
                            if (departureRunway) {
                                this.drawRunway(departureRunway, geoProjection, context);
                            }
                            if (arrivalRunway) {
                                this.drawRunway(arrivalRunway, geoProjection, context);
                            }
                        }
                        else if (drawAirportCircle) {
                            this.drawAirportCircle(context, geoProjection, airport);
                        }
                    }
                }
            }
            else {
                context.clearRect(0, 0, this.canvasLayerRef.instance.getWidth(), this.canvasLayerRef.instance.getHeight());
            }
            this.updateRequired = false;
        }
    }
    /**
     * Draws a runway.
     * @param runway The runway to draw.
     * @param geoProjection The geoprojection from the canvas to draw against.
     * @param context The canvas rendering context to use.
     */
    drawRunway(runway, geoProjection, context) {
        context.lineCap = 'round';
        const runwayPos = this.geoPointCache[0].set(runway.latitude, runway.longitude);
        const forwardLength = UnitType.METER.convertTo(runway.length - runway.startThresholdLength, UnitType.GA_RADIAN);
        const backwardLength = UnitType.METER.convertTo(runway.startThresholdLength, UnitType.GA_RADIAN);
        const forwardBound = runwayPos.offset(runway.course, forwardLength, this.geoPointCache[2]);
        const backwardBound = runwayPos.offset(runway.course, -backwardLength, this.geoPointCache[3]);
        const pBack = geoProjection.project(backwardBound, this.vec2Cache[0]);
        const pForward = geoProjection.project(forwardBound, this.vec2Cache[1]);
        this.drawRunwayShape(context, pForward, pBack);
        this.drawExtendedDashedCenterline(context, pForward, pBack, forwardBound, backwardBound, geoProjection, runway);
    }
    /**
     * Draws the runway shape.
     * @param context The context.
     * @param pForward The forward projection.
     * @param pBack The backward projection.
     */
    drawRunwayShape(context, pForward, pBack) {
        const width = 7 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
        const theta = Vec2Math.theta(Vec2Math.sub(pForward, pBack, this.vec2Cache[2]));
        const pBackL = Vec2Math.add(Vec2Math.setFromPolar(width, theta - (Math.PI / 2), this.vec2Cache[2]), pBack, this.vec2Cache[3]);
        const pBackR = Vec2Math.add(Vec2Math.setFromPolar(width, theta + (Math.PI / 2), this.vec2Cache[2]), pBack, this.vec2Cache[4]);
        const pForwardL = Vec2Math.add(Vec2Math.setFromPolar(width, theta - (Math.PI / 2), this.vec2Cache[2]), pForward, this.vec2Cache[5]);
        const pForwardR = Vec2Math.add(Vec2Math.setFromPolar(width, theta + (Math.PI / 2), this.vec2Cache[2]), pForward, this.vec2Cache[6]);
        context.beginPath();
        context.moveTo(pBackL[0], pBackL[1]);
        context.lineTo(pForwardL[0], pForwardL[1]);
        context.moveTo(pBackR[0], pBackR[1]);
        context.lineTo(pForwardR[0], pForwardR[1]);
        context.setLineDash(this.noLineDash);
        context.strokeStyle = BoeingColors.black;
        context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.stroke();
        context.strokeStyle = BoeingColors.white;
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * Draws the dashed extended runway centerline.
     * @param context The context.
     * @param pForward The forward projection.
     * @param pBack The backward projection.
     * @param forwardBound The forward bound.
     * @param backwardBound The backward bound.
     * @param geoProjection The geo projection.
     * @param runway The runway.
     */
    drawExtendedDashedCenterline(context, pForward, pBack, forwardBound, backwardBound, geoProjection, runway) {
        const centrelineExtensionLength = UnitType.NMILE.convertTo(14.2, UnitType.GA_RADIAN);
        const cForwardBound = forwardBound.offset(runway.course, centrelineExtensionLength, this.geoPointCache[2]);
        const pCForward = geoProjection.project(cForwardBound, this.vec2Cache[7]);
        const cBackwardBound = backwardBound.offset(NavMath.normalizeHeading(runway.course + 180), centrelineExtensionLength, this.geoPointCache[3]);
        const pCBack = geoProjection.project(cBackwardBound, this.vec2Cache[8]);
        context.beginPath();
        context.moveTo(pForward[0], pForward[1]);
        context.lineTo(pCForward[0], pCForward[1]);
        context.moveTo(pBack[0], pBack[1]);
        context.lineTo(pCBack[0], pCBack[1]);
        context.setLineDash(this.centerlineDash);
        context.strokeStyle = BoeingColors.black;
        context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.stroke();
        context.strokeStyle = BoeingColors.white;
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * Draws the airport circle.
     * @param context The context.
     * @param geoProjection The geo projection.
     * @param airport The airport.
     */
    drawAirportCircle(context, geoProjection, airport) {
        const airportRef = airport.facility.get();
        const pAirport = geoProjection.project(airportRef, this.vec2Cache[10]);
        // This number is for MAX displays, the `maxToOldBoeingScale` var will scale it properly for older boeing displays
        const circleRadius = 15 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
        context.beginPath();
        context.ellipse(pAirport[0], pAirport[1], circleRadius, circleRadius, 0, 0, Math.PI * 2);
        context.setLineDash(this.noLineDash);
        context.strokeStyle = BoeingColors.black;
        context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.stroke();
        context.strokeStyle = BoeingColors.white;
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * A callback fired when the focused airport is added.
     * @param planIndex The flight plan index.
     * @param waypoint The waypoint representing the focused airport.
     * @param departureRunway The departure runway if applicable.
     * @param arrivalRunway The arrival runway if applicable.
     */
    onFocusAirportAdded(planIndex, waypoint, departureRunway, arrivalRunway) {
        this.addLabels(planIndex, waypoint, departureRunway, arrivalRunway);
        this.updateRequired = true;
    }
    /**
     * A callback fired when a focused airport is removed.
     * @param planIndex The flight plan index.
     * @param waypoint The waypoint representing the focused airport.
     */
    onFocusAirportRemoved(planIndex, waypoint) {
        const labels = this.runwayLabelsMap.get(planIndex).get(waypoint.uid);
        if (labels) {
            for (const l of labels) {
                this.props.textManager.deregister(l);
            }
        }
        this.runwayLabelsMap.get(planIndex).delete(waypoint.uid);
        this.updateRequired = true;
    }
    /** A callback fired when focused airports are cleared. */
    onFocusAirportsCleared() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const [planIndex, map2] of this.runwayLabelsMap.entries()) {
            for (const [uid, labels] of map2.entries()) {
                if (labels) {
                    for (const l of labels) {
                        this.props.textManager.deregister(l);
                    }
                }
                this.runwayLabelsMap.get(planIndex).delete(uid);
            }
        }
        this.updateRequired = true;
    }
    /**
     * Processes an airport waypoint to generate airport and runway labels.
     * @param planIndex The flight plan index.
     * @param waypoint The airport waypoint the runway belongs to.
     * @param departureRunway The departure runway if applicable.
     * @param arrivalRunway The arrival runway if applicable.
     */
    addLabels(planIndex, waypoint, departureRunway, arrivalRunway) {
        const refPointAirport = new GeoPoint(waypoint.facility.get().lat, waypoint.facility.get().lon);
        const labels = [];
        const modesVisible = departureRunway || arrivalRunway
            ? PlanAirportsLayerDisplayMode.Far
            : PlanAirportsLayerDisplayMode.Far | PlanAirportsLayerDisplayMode.Near;
        const airportLabel = new PlanAirportsRunwaysTextLabel(ICAO.getIdent(waypoint.facility.get().icao), refPointAirport, modesVisible, this.displayModule.displayMode, {
            fontSize: this.stylesModule.styles.labelFontSize,
            font: 'B787',
            fontColor: BoeingColors.white,
            offset: this.stylesModule.styles.bigLabelOffset,
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: this.stylesModule.styles.fontOutlineWidth,
        });
        this.props.textManager.register(airportLabel);
        labels.push(airportLabel);
        if (departureRunway) {
            // Only show departure runway label under airport label if the arrival runway isn't at the same airport
            // Otherwise, if origin and destination are same airport, we'll just only show the arrival runway label under the airport label
            this.addRunwayLabel(planIndex, departureRunway, refPointAirport, !arrivalRunway, labels);
        }
        if (arrivalRunway) {
            this.addRunwayLabel(planIndex, arrivalRunway, refPointAirport, true, labels);
        }
        this.runwayLabelsMap.get(planIndex).set(waypoint.uid, labels);
    }
    /**
     * Adds labels for a runway.
     * @param planIndex The plan index.
     * @param runway The runway.
     * @param refPointAirport The airport ref point.
     * @param showRunwayLabelUnderAirport Whether to make a label for the runway to show under the airport label when zoomed out.
     * @param labels The labels array to add to.
     */
    addRunwayLabel(planIndex, runway, refPointAirport, showRunwayLabelUnderAirport, labels) {
        // When near, draw runway label next to runway
        const refPointRunway = runway && new GeoPoint(runway.latitude, runway.longitude);
        const runwayLabelNear = new RunwayTextLabel(runway.designation, refPointRunway, runway.course, PlanAirportsLayerDisplayMode.Near, this.displayModule.displayMode, this.stylesModule.styles);
        this.props.textManager.register(runwayLabelNear);
        labels.push(runwayLabelNear);
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && showRunwayLabelUnderAirport) {
            // When far, and active plan, draw runway label under the airport label
            // We only draw this for active plan to avoid clashing runway labels from other plans
            const offsetY = 26 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
            const runwayLabelFar = new PlanAirportsRunwaysTextLabel(runway.designation, refPointAirport, PlanAirportsLayerDisplayMode.Far, this.displayModule.displayMode, {
                fontSize: this.stylesModule.styles.labelFontSize,
                font: 'B787',
                fontColor: BoeingColors.white,
                offset: new Float64Array([this.stylesModule.styles.bigLabelOffsetPx, this.stylesModule.styles.bigLabelOffsetPx + offsetY]),
                fontOutlineColor: BoeingColors.black,
                fontOutlineWidth: this.stylesModule.styles.fontOutlineWidth,
            });
            this.props.textManager.register(runwayLabelFar);
            labels.push(runwayLabelFar);
        }
    }
    /** @inheritdoc */
    onDetached() {
        this.displayModeSub.destroy();
        this.runwaysDisplayedSub.destroy();
        this.labelsDisplayedSub.destroy();
        this.focusChangedSub.destroy();
        this.canvasLayerRef.instance.onDetached();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2, class: "plan-airports-runways-canvas-layer" })));
    }
}
/** A map text label used for airports and runways. */
class PlanAirportsRunwaysTextLabel extends MapCullableLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param modesVisible Which modes this label should be displayed in.
     * @param displayMode The display mode subscribable.
     * @param options Options with which to initialize this label.
     */
    constructor(text, location, modesVisible, displayMode, options) {
        super(text, BoeingMapLabelPriority.AirportsRunways, location, true, options);
        this.modesVisible = modesVisible;
        this.displayMode = displayMode;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        if (BitFlags.isAny(this.modesVisible, this.displayMode.get())) {
            super.setTextStyle(context);
            super.draw(context, mapProjection);
        }
    }
}
/**
 * A map text label used for runway designations.
 */
class RunwayTextLabel extends PlanAirportsRunwaysTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param runwayDirection The direction of the runway, used to offset the label.
     * @param modesVisible Which modes this label should be displayed in.
     * @param displayMode The display mode subscribable.
     * @param mapStyles The map styles.
     */
    constructor(text, location, runwayDirection, modesVisible, displayMode, mapStyles) {
        const runwayLabelOffset = Vec2Subject.create(new Float64Array(2));
        super(text, location, modesVisible, displayMode, {
            fontSize: mapStyles.labelFontSize,
            font: 'B787',
            fontColor: BoeingColors.white,
            offset: runwayLabelOffset,
            anchor: new Float64Array([0.5, 0.5]),
            fontOutlineColor: BoeingColors.black,
            fontOutlineWidth: mapStyles.fontOutlineWidth,
        });
        this.runwayDirection = runwayDirection;
        this.runwayLabelOffset = runwayLabelOffset;
        this.mapStyles = mapStyles;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        const runwayDirectionRad = this.runwayDirection * Avionics.Utils.DEG2RAD;
        const mapRotationRad = mapProjection.getRotation();
        const relativeBearing = runwayDirectionRad + mapRotationRad;
        // Rotate 180 deg (pi) to put on other side of runway
        const theta = relativeBearing + Math.PI;
        // This is how far the label is from the runway
        const offsetMagnitude = 50 * this.mapStyles.maxToOldBoeingScale * this.mapStyles.canvasScale;
        const offsetVec = Vec2Math.setFromPolar(offsetMagnitude, theta, MapLocationTextLabel.tempVec2);
        // The label is much wider than it is tall, so we minimize the vertical offset, so when the runway is running left to right,
        // the label is on top or on bottom, and we don't want it to look too far away.
        const verticalOffsetFactor = 0.75;
        this.runwayLabelOffset.set(offsetVec[0], offsetVec[1] * verticalOffsetFactor);
        super.draw(context, mapProjection);
    }
}

/** The TcasRing component. */
class TcasRing extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.tcasSize = (this.props.compassRadius * 2) * 0.75;
        this.tcasRingRange = MappedSubject.create(([mapRange, tfcEnabled, isInertialHeadingDataValid]) => {
            if (isInertialHeadingDataValid && tfcEnabled) {
                if (this.props.fixedRange !== undefined) {
                    return this.props.fixedRange;
                }
                else if (this.props.centeredCompassMode) {
                    if (mapRange >= 10 && mapRange <= 80) {
                        return mapRange / 2;
                    }
                }
                else if (mapRange >= 5 && mapRange <= 80) {
                    return mapRange;
                }
            }
            return undefined;
        }, this.props.ndDataProvider.mapRange, this.props.ndDataProvider.isTfcEnabled, this.props.ndDataProvider.isInertialHeadingDataValid);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.tcasRingRange.sub(range => {
            this.svgRef.instance.innerHTML = '';
            if (range !== undefined) {
                FSComponent.render(FSComponent.buildComponent(FSComponent.Fragment, null, this.buildTcasRing(this.tcasSize / 2, this.tcasSize / 2, range, this.props.compassRadius)), this.svgRef.instance);
            }
        }, true);
        this.props.ndDataProvider.currentHeadingRotation.sub(hdg => {
            this.svgRef.instance.style.transform = `rotate3d(0, 0, 1, ${hdg * -1}deg)`;
        }, true);
    }
    /**
     * Builds the circles that make up the TCAS 3 mile ring.
     * @param cx center x position.
     * @param cy center y position.
     * @param compassRange The compass range.
     * @param compassRadius The compass radius.
     * @param isMiniMap Whether this is for the mini-map or not.
     * @returns the circle elements that make up the ring.
     */
    buildTcasRing(cx, cy, compassRange, compassRadius, isMiniMap = false) {
        const tcasRange = 3;
        const ringRadius = compassRadius * (tcasRange / compassRange);
        const lines = [];
        for (let i = 0; i < 360; i += 30) {
            const isLarge = i % 90 == 0;
            const radius = isLarge
                ? 4
                : isMiniMap
                    ? 2
                    : 1;
            const startX = cx + (ringRadius * Math.cos(i * Avionics.Utils.DEG2RAD));
            const startY = cy + (ringRadius * Math.sin(i * Avionics.Utils.DEG2RAD));
            lines.push(FSComponent.buildComponent("circle", { class: "nd-path-shadow", cx: startX, cy: startY, r: radius * this.props.ndDataProvider.canvasScale, stroke: this.props.ndDataProvider.black, fill: "none" }));
            lines.push(FSComponent.buildComponent("circle", { class: "", cx: startX, cy: startY, r: radius * this.props.ndDataProvider.canvasScale, fill: (isLarge && !isMiniMap) ? 'none' : this.props.ndDataProvider.white }));
        }
        return lines;
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: "tcas-ring", viewBox: `0 0 ${this.tcasSize} ${this.tcasSize}`, width: this.tcasSize, height: this.tcasSize, style: "position: absolute;" }));
    }
}

/**
 * Displays TRAFFIC and OFFSCALE messages on the top right of the ND map.
 * OFFSCALE in red when RA is beyond selected map range.
 * OFFSCALE in amber when TA is beyond selected map range.
 * TRAFFIC in red when RA is occuring.
 * TRAFFIC in amber when TA is occuring and RA is not occuring.
 * TRAFFIC alert messages display regardless ND modes / ranges / TFC on or not.
 */
class TcasAdvisoryStatus extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.trafficRef = FSComponent.createRef();
        this.offScaleRef = FSComponent.createRef();
        /**
         * Beside TA/RA conditions, only display OFFSCALE status when:
         * Plane is not on ground, and ND in MAP / MAP CTR, and TFC is not selected.
         */
        this.isOffScaleStatusHidden = MappedSubject.create(([tcasOffScaleStatus, isOnGround, isPlanFormat, isTfcEnabled,]) => {
            if (isOnGround
                || isPlanFormat
                || !isTfcEnabled
                || tcasOffScaleStatus === TcasAlertLevel.None
                || tcasOffScaleStatus === TcasAlertLevel.ProximityAdvisory) {
                return true;
            }
            return false;
        }, this.props.tcasOffScaleStatus, this.props.ndDataProvider.isOnGround, this.props.ndDataProvider.isPlanFormat, this.props.ndDataProvider.isTfcEnabled);
        this.isTrafficStatusHidden = MappedSubject.create(([tcasTrafficStatus, isOnGround]) => {
            if (isOnGround
                || tcasTrafficStatus === TcasAlertLevel.None
                || tcasTrafficStatus === TcasAlertLevel.ProximityAdvisory) {
                return true;
            }
            return false;
        }, this.props.ndDataProvider.tcasTrafficStatus, this.props.ndDataProvider.isOnGround);
        this.flagTextStyle = {
            background: 'black',
            'text-align': 'right',
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.offScaleStatusSub = this.props.tcasOffScaleStatus.sub((v) => {
            if (v === TcasAlertLevel.ResolutionAdvisory) {
                this.offScaleRef.instance.style.color = 'var(--boeing-colors-red)';
            }
            else if (v === TcasAlertLevel.TrafficAdvisory) {
                this.offScaleRef.instance.style.color = 'var(--boeing-colors-amber)';
            }
            else {
                this.offScaleRef.instance.style.color = 'var(--boeing-colors-white)';
            }
        }, true);
        this.trafficStatusSub = this.props.ndDataProvider.tcasTrafficStatus.sub((v) => {
            if (v === TcasAlertLevel.ResolutionAdvisory) {
                this.trafficRef.instance.style.color = 'var(--boeing-colors-red)';
            }
            else if (v === TcasAlertLevel.TrafficAdvisory) {
                this.trafficRef.instance.style.color = 'var(--boeing-colors-amber)';
            }
            else {
                this.trafficRef.instance.style.color = 'var(--boeing-colors-white)';
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "tcas-advisory-status-container" },
            FSComponent.buildComponent("div", { class: {
                    'tcas-off-scale-status': true,
                    'tcas-status-no-background-container': this.isOffScaleStatusHidden,
                }, style: this.flagTextStyle },
                FSComponent.buildComponent("span", { class: { 'hidden': this.isOffScaleStatusHidden }, ref: this.offScaleRef }, "OFFSCALE")),
            FSComponent.buildComponent("div", { class: {
                    'tcas-traffic-status': true,
                    'tcas-status-no-background-container': this.isTrafficStatusHidden,
                }, style: this.flagTextStyle },
                FSComponent.buildComponent("span", { class: { 'hidden': this.isTrafficStatusHidden }, ref: this.trafficRef }, "TRAFFIC"))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        (_a = this.offScaleStatusSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.trafficStatusSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

/** Colection of function to help build boeing map systems. */
class BoeingMapBuilder {
    /**
     * Creates a new BoeingMapBuilder.
     * @param bus the event bus.
     * @param ndDataProvider The nd data provider.
     * @param pfdOrMfd pfd or mfd.
     * @param facLoader the fac loader.
     * @param flightPlanner the flight planner.
     * @param activeRoutePredictor The active route predictor.
     * @param perfPlanRepository The perfPlanRepository.
     * @param tcas The Tcas instance.
     */
    constructor(bus, ndDataProvider, pfdOrMfd, facLoader, flightPlanner, activeRoutePredictor, perfPlanRepository, tcas) {
        this.bus = bus;
        this.ndDataProvider = ndDataProvider;
        this.pfdOrMfd = pfdOrMfd;
        this.facLoader = facLoader;
        this.flightPlanner = flightPlanner;
        this.activeRoutePredictor = activeRoutePredictor;
        this.perfPlanRepository = perfPlanRepository;
        this.tcas = tcas;
        /**
         * Add the plan airports and runways
         * @param builder The map system builder.
         * @param mapSystemConfig The map system config.
         * @returns The map system builder, after it has been configured.
         */
        this.withFlightPlans = (builder, mapSystemConfig) => {
            const vnavDataModule = new BoeingVNavDataModule();
            return builder
                .withInit('init-flight-plans', context => {
                if (this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX)) {
                    // Init the flight plans in case the plans already exist
                    context.model.getModule(MapSystemKeys.FlightPlan)
                        .getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX)
                        .flightPlan.set(this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX));
                    context.model.getModule(MapSystemKeys.FlightPlan)
                        .getPlanSubjects(BoeingFms.RTE_1_MOD_PLAN_INDEX)
                        .flightPlan.set(this.flightPlanner.getFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX));
                    context.model.getModule(MapSystemKeys.FlightPlan)
                        .getPlanSubjects(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX)
                        .flightPlan.set(this.flightPlanner.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX));
                }
            })
                .withFlightPlan(mapSystemConfig.configureInactiveFlightPlan(), this.flightPlanner, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, false, undefined, 'flight-plan-layer inactive-flight-plan-map-layer')
                .withFlightPlan(mapSystemConfig.configureModFlightPlan(this.bus), this.flightPlanner, BoeingFms.RTE_1_MOD_PLAN_INDEX, false, undefined, 'flight-plan-layer mod-flight-plan-map-layer')
                .withFlightPlan(mapSystemConfig.configureFlightPlan(this.bus, this.ndDataProvider, vnavDataModule, this.activeRoutePredictor, this.perfPlanRepository), this.flightPlanner, BoeingFms.ACT_RTE_PLAN_INDEX, false, undefined, 'flight-plan-layer active-flight-plan-map-layer')
                .withModule(BoeingMapKeys.VNavData, () => vnavDataModule)
                .withController(BoeingMapKeys.VNavData, context => new BoeingVNavDataController(context));
        };
        /**
         * The map builder for the airplane icon.
         * @param builder The map system builder.
         * @param crossTrackLayerProps The required props for the cross track layer.
         * @param ownshipTriPath File path to the triangle ownship icon.
         * @param ownshipOutlinePath File path to the outline ownship icon.
         * @param svgScale The svgScale to apply.
         * @returns The map system builder, after it has been configured.
         */
        this.withAirplaneIcon = (builder, crossTrackLayerProps, ownshipTriPath, ownshipOutlinePath, svgScale = 1) => {
            builder = builder
                .withOwnAirplanePropBindings([
                'position',
                'hdgTrue',
                'trackTrue',
                'altitude',
                'verticalSpeed',
                'groundSpeed',
                'isOnGround',
                'turnRate',
            ], 30)
                .withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule())
                .withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule())
                .withLayer(BoeingMapKeys.OwnShipXtkErrorLayer, (context) => {
                return (FSComponent.buildComponent(MapCrossTrackErrorLayer, Object.assign({ bus: context.bus, model: context.model, mapProjection: context.projection, canvasScale: this.ndDataProvider.canvasScale }, crossTrackLayerProps)));
            })
                .withLayer(BoeingMapKeys.OwnShipTriLayer, (context) => {
                return (FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: ownshipTriPath, iconSize: 92 * svgScale * this.ndDataProvider.canvasScale, iconAnchor: new Float64Array([0.5, 0.108]), class: 'airplane-symbol-tri' }));
            });
            if (this.pfdOrMfd === 'MFD') {
                // The PLAN format airplane icon
                builder = builder.withLayer(BoeingMapKeys.OwnShipOutlineLayer, (context) => {
                    return (FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: ownshipOutlinePath, iconSize: 84 * svgScale * this.ndDataProvider.canvasScale, iconAnchor: new Float64Array([0.5, 0.0]), class: 'airplane-symbol-outline' }));
                });
            }
            return builder;
        };
        /**
         * Configures a map builder to generate a map with a track vector.
         * @param mapBuilder The map builder to configure.
         * @param options The options.
         * @returns The map builder, after it has been configured.
         */
        this.positionTrendVector = (mapBuilder, options) => {
            return mapBuilder
                .withModule(BoeingMapKeys.PositionTrendVector, () => new MapPositionTrendVectorModule())
                .withLayer(BoeingMapKeys.PositionTrendVector, context => {
                return (FSComponent.buildComponent(MapPositionTrendVectorLayer, { model: context.model, mapProjection: context.projection, class: "position-trend-vector", arcMaxLookaheadTime: UnitType.SECOND.createNumber(90), segmentLengthSeconds: 30, strokeStyle: "white", outlineStyle: "black", minRangeVisible: options.minRangeVisible, strokeWidth: options.strokeWidth, outlineWidth: options.outlineWidth, ndDataProvider: this.ndDataProvider, alwaysShow3Segments: this.pfdOrMfd === 'PFD' }));
            });
        };
        /**
         * Add the altitude arc.
         * @param builder The map system builder.
         * @param options Altitude arc options.
         * @returns The map system builder, after it has been configured.
         */
        this.withAltitudeArc = (builder, options) => {
            return builder
                .withModule(MapSystemKeys.AltitudeArc, () => new MapAltitudeArcModule(true))
                .withLayer(MapSystemKeys.AltitudeArc, context => FSComponent.buildComponent(MapAltitudeArcLayer, { model: context.model, mapProjection: context.projection, renderMethod: "svg", verticalSpeedPrecision: UnitType.FPM.createNumber(10), verticalSpeedThreshold: UnitType.FPM.createNumber(150), altitudeDeviationThreshold: UnitType.FOOT.createNumber(750), arcRadius: options.arcRadius, arcAngularWidth: options.arcAngularWidth, strokeStyle: options.strokeStyle, strokeWidth: options.strokeWidth, strokeLineCap: "round", outlineWidth: options.outlineWidth, outlineStyle: "black", outlineLineCap: "round", class: "altitude-arc" }));
        };
        /**
         * Adds the terrain colors module.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withTerrainColors = (builder) => {
            return builder
                .withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule())
                .withModule(BoeingMapKeys.TerrainWeatherState, () => new MapTerrainWeatherStateModule())
                .withController(MapSystemKeys.TerrainColors, context => new MapTerrainColorsController(context));
        };
        /**
         * Add the plan airports and runways.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withPlanAirportsRunways = (builder) => {
            return builder
                .withModule(BoeingMapKeys.PlanAirportsLayer, () => new AirportRunwayDisplayModule())
                .withController(BoeingMapKeys.PlanAirportsLayer, context => new PlanAirportsRunwaysController(context, this.facLoader, this.flightPlanner, this.ndDataProvider, this.pfdOrMfd))
                .withLayer(BoeingMapKeys.PlanAirportsLayer, context => FSComponent.buildComponent(PlanAirportsRunwaysLayer, { model: context.model, mapProjection: context.projection, textManager: context.textManager }));
        };
        /**
         * Add the T/D, E/D, etc. to the map.
         * @param builder The map system builder.
         * @param fixInfo The fix info manager.
         * @returns The map system builder, after it has been configured.
         */
        this.withTopOfDescent = (builder, fixInfo) => {
            return builder
                .withLayer(BoeingMapKeys.Tod, context => FSComponent.buildComponent(MapTodLayer, { bus: context.bus, model: context.model, mapProjection: context.projection, waypointRenderer: context[MapSystemKeys.WaypointRenderer], textManager: context.textManager, planner: this.flightPlanner, activePerformancePlan: this.perfPlanRepository.getActivePlan(), fixInfo: fixInfo, class: "tod-layer" }));
        };
        /**
         * Add the map select waypoint module.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withMapSelectWpt = (builder) => {
            return builder
                .withModule(BoeingMapKeys.CtrWpt, () => new MapFacilitySelectModule(this.bus));
        };
        /**
         * Add the nearest waypoints layer.
         * @param builder The map system builder.
         * @param mapSystemConfig The map system config.
         * @returns The map system builder, after it has been configured.
         */
        this.withNearestWaypoints = (builder, mapSystemConfig) => {
            return builder
                .withNearestWaypoints(mapSystemConfig.configureMapWaypoints(), false, undefined, 'nearest-waypoints');
        };
        /**
         * Add the waypoint display controller.
         * @param builder The map system builder.
         * @param fixInfo The fix info manager.
         * @returns The map system builder, after it has been configured.
         */
        this.withWaypointDisplayController = (builder, fixInfo) => {
            return builder
                .withController(BoeingMapKeys.WaypointDisplayController, context => new MapWaypointDisplayController(context, this.ndDataProvider.mapWaypointsDisplay, this.pfdOrMfd, fixInfo));
        };
        /**
         * Add the map select waypoint layer.
         * @param builder The map system builder.
         * @param mapSystemConfig The map system config.
         * @param supportAdsbIn Whether to support the display of ADS-B In triangle icons.
         * @param mapSystemFactory A callback to pass MapSystemContext to the boeing plane's specific MapTrafficController.
         * @param offScaleTcasAlertLevel The offScaleTcasAlertLevel subject.
         * @returns The map system builder, after it has been configured.
         */
        this.withTraffic = (builder, mapSystemConfig, supportAdsbIn, mapSystemFactory, offScaleTcasAlertLevel) => {
            return builder
                .withTraffic(this.tcas, mapSystemConfig.createTrafficIntruderIcon({ supportAdsbIn }), mapSystemConfig.initTrafficLayerCanvasStyles, this.getOffScaleOobOptions(offScaleTcasAlertLevel), undefined, 'traffic')
                .withController(MapSystemKeys.Traffic, mapSystemFactory);
        };
        /**
         * Generates options for handling off-scale and out-of-bounds intruders.
         * @param offScaleTcasAlertLevel Mutable subscribale that receives updates when there is an off-scale TA/RA event.
         * @returns a TrafficOffScaleOobOptions object.
         */
        this.getOffScaleOobOptions = (offScaleTcasAlertLevel) => () => {
            const offScaleIntruders = SetSubject.create();
            const alertLevelSubs = new Map();
            const offScaleTAs = SetSubject.create();
            const offScaleRAs = SetSubject.create();
            const offScaleHandler = (_set, type, intruder) => {
                var _a;
                if (type === SubscribableSetEventType.Added) {
                    alertLevelSubs.set(intruder, intruder.alertLevel.sub(alertLevel => {
                        if (alertLevel === TcasAlertLevel.ResolutionAdvisory) {
                            offScaleRAs.add(intruder);
                            offScaleTAs.delete(intruder);
                        }
                        else if (alertLevel === TcasAlertLevel.TrafficAdvisory) {
                            offScaleTAs.add(intruder);
                            offScaleRAs.delete(intruder);
                        }
                        else {
                            offScaleTAs.delete(intruder);
                            offScaleRAs.delete(intruder);
                        }
                    }, true));
                }
                else {
                    (_a = alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
                    alertLevelSubs.delete(intruder);
                    offScaleTAs.delete(intruder);
                    offScaleRAs.delete(intruder);
                }
            };
            offScaleIntruders.sub(offScaleHandler);
            const raTAHandler = () => {
                if (offScaleRAs.get().size > 0) {
                    offScaleTcasAlertLevel.set(TcasAlertLevel.ResolutionAdvisory);
                }
                else if (offScaleTAs.get().size > 0) {
                    offScaleTcasAlertLevel.set(TcasAlertLevel.TrafficAdvisory);
                }
                else {
                    offScaleTcasAlertLevel.set(TcasAlertLevel.None);
                }
            };
            offScaleTAs.sub(raTAHandler);
            offScaleRAs.sub(raTAHandler);
            raTAHandler();
            return {
                offScaleIntruders,
            };
        };
    }
}

/** An animator driven by requestAnimationFrame designed for ND elements. */
class MapCompassAnimator {
    /** Creates a new NdAnimator.
     * @param speed Higher is faster, but it gets faster fast, try incerements of 0.5.
     * @param isRunning A subscribable boolean to control whether the animator is running.
     * @param inputValue A subscribable number to control the target value with.
     */
    constructor(speed = 5, isRunning = undefined, inputValue = undefined) {
        this.speed = speed;
        /** The animated value. */
        this._output = Subject.create(0);
        this.output = this._output;
        this.previousTimestamp = window.performance.now();
        this.animationFrameId = 0;
        this.targetValue = 0;
        this.started = false;
        this.subs = [];
        /** Sets the value that the output will be gradually animated towards.
         * @param value The value to animate towards. If null or undefined, the target value will not change.
         */
        this.setTargetValue = (value) => {
            if (value === undefined || value === null) {
                return;
            }
            this.targetValue = value;
        };
        /** Starts the requestAnimationFrame loop. */
        this.start = () => {
            if (!this.started) {
                this.started = true;
                this.previousTimestamp = window.performance.now();
                this.animationFrameId = window.requestAnimationFrame(this.update);
            }
        };
        /** Stops the requestAnimationFrame loop. */
        this.stop = () => {
            if (this.started) {
                this.started = false;
                window.cancelAnimationFrame(this.animationFrameId);
            }
        };
        /**
         * Starts or stops the animaton based on a boolean.
         * @param force If true, will start animation if not already running, else will stop animation.
         */
        this.toggle = (force) => {
            if (force) {
                this.start();
            }
            else {
                this.stop();
            }
        };
        this.update = (timestamp) => {
            const deltaTime = timestamp - this.previousTimestamp;
            this.previousTimestamp = timestamp;
            const currentValue = this.output.get();
            const delta = ((this.targetValue - currentValue + 540) % 360) - 180;
            // This makes it so it's not updating every frame after the value has settled
            if (Math.abs(delta) > 0.01) {
                const deltaToApply = Math.min(delta / 5, delta * (this.speed * (deltaTime / 1000)));
                const newValue = currentValue + deltaToApply;
                this._output.set(newValue);
            }
            else {
                this._output.set(this.targetValue);
            }
            this.animationFrameId = window.requestAnimationFrame(this.update);
        };
        this.subs = [
            isRunning === null || isRunning === void 0 ? void 0 : isRunning.sub(this.toggle.bind(this), true),
            inputValue === null || inputValue === void 0 ? void 0 : inputValue.sub(this.setTargetValue.bind(this), true),
        ];
    }
    /** Cleans up the component. */
    destroy() {
        this.stop();
        this.subs.forEach(sub => sub === null || sub === void 0 ? void 0 : sub.destroy());
    }
}

const RANGE_FORMATTER = NumberFormatter.create({ precision: .01, forceDecimalZeroes: false });
/** Provides data for the ND. */
class BoeingNdDataProvider {
    /**
     * Creates a new data provider.
     * @param bus The event bus.
     * @param navIndicators The nav indicators.
     * @param settings Boeing map settings.
     * @param boeingUserSettings Boeing user settings.
     */
    constructor(bus, navIndicators, settings, boeingUserSettings) {
        this.bus = bus;
        this.navIndicators = navIndicators;
        this.settings = settings;
        this.boeingUserSettings = boeingUserSettings;
        this.boeingType = 'change-me';
        // This is what honeywell airbus ADIRU uses, so probably close to real thing.
        this.trackHeadingGsThreshold = 50;
        this.white = BoeingColors.white;
        this.black = BoeingColors.black;
        this.green = BoeingColors.green;
        this.cyan = BoeingColors.cyan;
        this.magenta = BoeingColors.magenta;
        this.canvasScale = 1;
        this._targetProjectedOffsetY = Subject.create(0);
        this.targetProjectedOffsetY = this._targetProjectedOffsetY;
        this.isOnGround = ConsumerSubject.create(this.bus.getSubscriber().on('on_ground'), true);
        this.irsEvents = this.bus.getSubscriber();
        this.isHeadingDataValid = ConsumerSubject.create(this.irsEvents.on('irs_selector_heading_data_valid_1'), true);
        this.isInertialDataValid = ConsumerSubject.create(this.irsEvents.on('irs_selector_inertial_data_valid_1'), true);
        this.isInertialHeadingDataValid = ConsumerSubject.create(this.irsEvents.on('irs_selector_inertial_heading_data_valid_1'), true);
        this.isPositionDataValid = ConsumerSubject.create(this.irsEvents.on('irs_selector_position_data_valid_1'), true);
        this.lnavEvents = this.bus.getSubscriber();
        this.currentTrackDegMag = ConsumerSubject.create(this.bus.getSubscriber().on('track_deg_magnetic').withPrecision(2), 0);
        // TODO Use AhrsSystemEvents for heading once it works
        // private readonly currentHeadingMag = ConsumerSubject.create(
        //   this.bus.getSubscriber<AhrsSystemEvents>().on('ahrs_hdg_deg_1').withPrecision(2), 0);
        this.currentHeadingMag = ConsumerSubject.create(this.bus.getSubscriber().on('hdg_deg').withPrecision(2), 0);
        this.currentGroundSpeed = ConsumerSubject.create(this.bus.getSubscriber().on('ground_speed').atFrequency(1), 0);
        this.selectedHeadingAndTrack = ConsumerSubject.create(this.bus.getSubscriber().on('ap_heading_selected'), 0);
        this.fmaData = ConsumerSubject.create(this.bus.getSubscriber().on('fma_data'), BoeingFmaDataUtils.createBoeingFmaData());
        this.isHdgUpMode = this.boeingUserSettings.getSetting('boeingMsfsNdHdgTrkUpMode').map(x => x === BoeingNdHdgTrkUpMode.HDG);
        this.isMissedApproachActive = ConsumerSubject.create(this.lnavEvents.on('lnavdata_cdi_scale_label'), 0)
            .map(x => x === CDIScaleLabel.MissedApproach);
        this.compassRotation = MappedSubject.create(([track, heading, groundSpeed, isInertialHeadingDataValid, isHdgUpMode]) => {
            return isInertialHeadingDataValid
                ? groundSpeed < this.trackHeadingGsThreshold
                    ? heading
                    : isHdgUpMode ? heading : track
                : 0;
        }, this.currentTrackDegMag, this.currentHeadingMag, this.currentGroundSpeed, this.isInertialHeadingDataValid, this.isHdgUpMode);
        this.compassRotationAnimator = new MapCompassAnimator(undefined, undefined, this.compassRotation);
        this.compassRotationAnimated = this.compassRotationAnimator.output;
        this.vorLeftRotation = MappedSubject.create(([compassRotation, vorLeftBearing]) => {
            return vorLeftBearing === null ? 0 : compassRotation - vorLeftBearing;
        }, this.compassRotationAnimated, this.navIndicators.get('vorLeft').bearing);
        this.vorRightRotation = MappedSubject.create(([compassRotation, vorRightBearing]) => {
            return vorRightBearing === null ? 0 : compassRotation - vorRightBearing;
        }, this.compassRotationAnimated, this.navIndicators.get('vorRight').bearing);
        this.adfLeftRotation = MappedSubject.create(([compassRotation, adfLeftBearing]) => {
            return adfLeftBearing === null ? 0 : compassRotation - adfLeftBearing;
        }, this.compassRotationAnimated, this.navIndicators.get('adfLeft').bearing);
        this.adfRightRotation = MappedSubject.create(([compassRotation, adfRightBearing]) => {
            return adfRightBearing === null ? 0 : compassRotation - adfRightBearing;
        }, this.compassRotationAnimated, this.navIndicators.get('adfRight').bearing);
        this._navAidLeftState = Subject.create('OFF');
        this.navAidLeftState = this._navAidLeftState;
        this._navAidRightState = Subject.create('OFF');
        this.navAidRightState = this._navAidRightState;
        this.vorPointerLeftIsVisible = MappedSubject.create(([hasNav, isLoc, state, isInertialHeadingDataValid]) => {
            return !!hasNav && !isLoc && state === 'VOR' && isInertialHeadingDataValid;
        }, this.navIndicators.get('vorLeft').hasNav, this.navIndicators.get('vorLeft').isLocalizer, this.navAidLeftState, this.isInertialHeadingDataValid);
        this.vorPointerRightIsVisible = MappedSubject.create(([hasNav, isLoc, state, isInertialHeadingDataValid]) => {
            return !!hasNav && !isLoc && state === 'VOR' && isInertialHeadingDataValid;
        }, this.navIndicators.get('vorRight').hasNav, this.navIndicators.get('vorRight').isLocalizer, this.navAidRightState, this.isInertialHeadingDataValid);
        this.adfPointerLeftIsVisible = MappedSubject.create(([bearing, state, isInertialHeadingDataValid]) => {
            return bearing !== null && state === 'ADF' && isInertialHeadingDataValid;
        }, this.navIndicators.get('adfLeft').bearing, this.navAidLeftState, this.isInertialHeadingDataValid);
        this.adfPointerRightIsVisible = MappedSubject.create(([bearing, state, isInertialHeadingDataValid]) => {
            return bearing !== null && state === 'ADF' && isInertialHeadingDataValid;
        }, this.navIndicators.get('adfRight').bearing, this.navAidRightState, this.isInertialHeadingDataValid);
        this.vorLeftAnimator = new MapCompassAnimator(undefined, this.vorPointerLeftIsVisible, this.vorLeftRotation);
        this.vorRightAnimator = new MapCompassAnimator(undefined, this.vorPointerRightIsVisible, this.vorRightRotation);
        this.adfLeftAnimator = new MapCompassAnimator(undefined, this.adfPointerLeftIsVisible, this.adfLeftRotation);
        this.adfRightAnimator = new MapCompassAnimator(undefined, this.adfPointerRightIsVisible, this.adfRightRotation);
        this.vorLeftRotationAnimated = this.vorLeftAnimator.output;
        this.vorRightRotationAnimated = this.vorRightAnimator.output;
        this.adfLeftRotationAnimated = this.adfLeftAnimator.output;
        this.adfRightRotationAnimated = this.adfRightAnimator.output;
        this.currentHeadingRotation = MappedSubject.create(([compassRotation, hdg, isHdgUpMode]) => {
            return isHdgUpMode ? 0 : compassRotation - hdg;
        }, this.compassRotationAnimated, this.currentHeadingMag, this.isHdgUpMode);
        this.currentTrackRotation = MappedSubject.create(([compassRotation, trk, isHdgUpMode, groundSpeed, heading]) => {
            return isHdgUpMode
                ? groundSpeed < this.trackHeadingGsThreshold
                    ? compassRotation - heading
                    : compassRotation - trk
                : 0;
        }, this.compassRotationAnimated, this.currentTrackDegMag, this.isHdgUpMode, this.currentGroundSpeed, this.currentHeadingMag);
        this.selectedHeadingAndTrackRotation = MappedSubject.create(([compassRotation, selHdgTrk]) => {
            return compassRotation - selHdgTrk;
        }, this.compassRotationAnimated, this.selectedHeadingAndTrack);
        this.mapFormat = this.settings.getSetting('mapFormat');
        this.isPlanFormat = this.mapFormat.map(f => f === 'PLAN');
        this.hideWindVector = this.isPlanFormat;
        this.hideTrack = this.isPlanFormat;
        this.isWxrEnabled = this.settings.getSetting('terrWxState').map(x => x === 'WX');
        this.isTerrEnabled = this.settings.getSetting('terrWxState').map(x => x === 'TERR');
        this.isTfcEnabled = this.settings.getSetting('tfcEnabled');
        this.terrWxContrast = this.settings.getSetting('terrWxContrast');
        this.tcasTrafficStatus = MappedSubject.create(([taIntruderCount, raIntruderCount]) => {
            if (raIntruderCount > 0) {
                return TcasAlertLevel.ResolutionAdvisory;
            }
            else if (taIntruderCount > 0) {
                return TcasAlertLevel.TrafficAdvisory;
            }
            return TcasAlertLevel.None;
        }, ConsumerSubject.create(this.bus.getSubscriber().on('tcas_ta_intruder_count'), 0), ConsumerSubject.create(this.bus.getSubscriber().on('tcas_ra_intruder_count'), 0));
        this.isWxrSupported = this.mapFormat.map(x => x !== 'PLAN');
        this.isTerrSupported = this.isWxrSupported;
        this.isTfcSupported = this.isWxrSupported;
        this.isVorSupported = this.isWxrSupported;
        this.isAdfSupported = this.isWxrSupported;
        this.isNavPerfSupported = this.isWxrSupported;
        this.isClockSupported = this.mapFormat.map(x => x !== 'PLAN');
        this.showWxr = MappedSubject.create(([isWxrEnabled, isWxrSupported]) => isWxrEnabled && isWxrSupported, this.isWxrEnabled, this.isWxrSupported);
        this.showTerr = MappedSubject.create(([isTerrEnabled, isTerrSupported]) => isTerrEnabled && isTerrSupported, this.isTerrEnabled, this.isTerrSupported);
        this.showTfc = MappedSubject.create(([isTfcEnabled, isTfcSupported]) => isTfcEnabled && isTfcSupported, this.isTfcEnabled, this.isTfcSupported);
        this.mapRange = this.settings.getSetting('mapRange');
        this.mapWaypointsDisplay = this.settings.getSetting('mapWaypointsDisplay');
        this.halfRangeNumber = this.mapRange.map(x => RANGE_FORMATTER(x / 2));
        this.quarterRangeNumber = this.mapRange.map(x => RANGE_FORMATTER(x / 4));
        this._selHdgOrTrk = Subject.create('heading');
        this.selHdgOrTrk = this._selHdgOrTrk;
        this.isHeadingSelectActive = this.fmaData.map(x => x.lateralActive === APLateralModes.HEADING);
        this.isTrackSelectActive = this.fmaData.map(x => x.lateralActive === APLateralModes.TRACK);
        this.hdgTrkWasSelectedInLast10Seconds = Subject.create(false);
        this.showSelHdgTrkLine = MappedSubject.create(([hdgSelectActive, trkSelectActive, selectionRecentlyChanged]) => {
            return hdgSelectActive || trkSelectActive || selectionRecentlyChanged;
        }, this.isHeadingSelectActive, this.isTrackSelectActive, this.hdgTrkWasSelectedInLast10Seconds);
        this.anIrsIsOperating = ConsumerSubject.create(this.bus.getSubscriber().on('an_irs_system_is_operating'), false);
        this.anIrsIsAligning = ConsumerSubject.create(this.bus.getSubscriber().on('an_irs_is_aligning'), false);
        this.showTimeToAlign = MappedSubject.create(([anIrsIsOperating, anIrsIsAligning]) => anIrsIsOperating ? false : anIrsIsAligning, this.anIrsIsOperating, this.anIrsIsAligning);
        this.hasWindData = MappedSubject.create(([tas, isInertialDataValid, showTimeToAlign]) => showTimeToAlign ? false : isInertialDataValid ? tas >= 100 : false, ConsumerSubject.create(this.bus.getSubscriber().on('tas').withPrecision(0), 0), this.isInertialDataValid, this.showTimeToAlign);
        /** Called n seconds after selected hdg/trk was last changed. */
        this.handleSelectedHdgTrkTimeoutCompleted = () => {
            this.hdgTrkWasSelectedInLast10Seconds.set(false);
            this.selectedHdgTrkTimeout = undefined;
        };
        // Selected hdg/trk timeout
        this.selectedHeadingAndTrack.sub(() => this.startSelectedHdgTrkTimeout(), false);
        this.compassRotationAnimator.start();
    }
    /** Keeps track of how long ago the selected hdg/trk was last changed. */
    startSelectedHdgTrkTimeout() {
        this.hdgTrkWasSelectedInLast10Seconds.set(true);
        if (this.selectedHdgTrkTimeout) {
            clearTimeout(this.selectedHdgTrkTimeout);
        }
        this.selectedHdgTrkTimeout = window.setTimeout(this.handleSelectedHdgTrkTimeoutCompleted, 10 * 1000);
    }
    /**
     * Set the map projection once map system is created.
     * @param mapProjection The map projection.
     */
    initMapProjection(mapProjection) {
        this._targetProjectedOffsetY.set(mapProjection.getTargetProjectedOffset()[1]);
        mapProjection.addChangeListener((projection, changeFlags) => {
            if (BitFlags.isAny(changeFlags, MapProjectionChangeType.TargetProjected)) {
                this._targetProjectedOffsetY.set(projection.getTargetProjectedOffset()[1]);
            }
        });
    }
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * Renders 2 elements, both with the passed class, and the first element with the outlineClass.
 * Saves you from having to write out 2 elements everytime you want an outline in svg.
 */
class OutlinedElement extends DisplayComponent {
    /** @inheritdoc*/
    render() {
        const _a = this.props, { tag, className, outlineClass } = _a, other = __rest(_a, ["tag", "className", "outlineClass"]);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const OutlinedTag = tag;
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(OutlinedTag, Object.assign({ class: (className !== null && className !== void 0 ? className : '') + ' ' + (outlineClass !== null && outlineClass !== void 0 ? outlineClass : '') }, other)),
            FSComponent.buildComponent(OutlinedTag, Object.assign({ class: className !== null && className !== void 0 ? className : '' }, other))));
    }
}

const pathMap = {
    VOR: {
        left: {
            head: 'l 0 66 l 0 -4 l -16 0 l 32 0 l -16 0 l 0 -86 l 0 0 l -8 8 l 8 -8 l 8 8',
            tail: 'l 0 18 l 0 -12 l -16 4.57 l 16 -4.57 l 16 4.57 l -16 -4.57 l 0 -85',
        },
        right: {
            head: 'l 0 -24 l -7 8 l 0 72 l -14 0 l 0 12 l 43 0 l 0 -12 l -15 0 l 0 -72 l -7 -8 z',
            tail: 'm 0 -78 l -7 8 l 0 72 l -14 4 l 0 12 l 21 -6 l 21 6 l 0 -12 l -21 -6 l -7 2 l 7 -2 l 0 12 l 0 -12 l 7 2 l 0 -72 l -7 -8 z',
        },
    },
    ADF: {
        left: {
            head: 'l 0 66 l 0 -4 l -16 0 l 32 0 l -16 0 l 0 -86 l 0 0 l -8 8 l 8 -8 l 8 8',
            tail: 'l 0 18 l 0 -12 l -16 4.57 l 16 -4.57 l 16 4.57 l -16 -4.57 l 0 -85',
        },
        right: {
            head: 'l 0 -24 l -7 8 l 0 72 l -14 0 l 0 12 l 43 0 l 0 -12 l -15 0 l 0 -72 l -7 -8 z',
            tail: 'm 0 -78 l -7 8 l 0 72 l -14 4 l 0 12 l 21 -6 l 21 6 l 0 -12 l -21 -6 l -7 2 l 7 -2 l 0 12 l 0 -12 l 7 2 l 0 -72 l -7 -8 z',
        },
    },
};
/** The BearingPointer component. */
class BearingPointer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.isVisible.sub(isVisible => {
            this.svgRef.instance.classList.toggle('hidden', !isVisible);
        }, true);
        this.props.rotation.sub(rotation => {
            this.svgRef.instance.style.transform = `rotate3d(0, 0, 1, ${rotation * -1}deg)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        const width = 60;
        const halfHeight = this.props.heightUnscaled / 2;
        const headY = halfHeight - this.props.compassRadiusUnscaled;
        const tailY = halfHeight + this.props.compassRadiusUnscaled;
        const { svgScale } = this.props;
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: `bearing-pointer bearing-pointer-${this.props.type} bearing-pointer-${this.props.leftOrRight}`, viewBox: `0 0 ${width} ${this.props.heightUnscaled}`, width: width * this.props.canvasScale, height: this.props.heightUnscaled * this.props.canvasScale, style: "position: absolute;" },
            FSComponent.buildComponent("g", { transform: `translate(${width / 2} ${headY}) scale(${svgScale !== null && svgScale !== void 0 ? svgScale : 1})` },
                FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", "vector-effect": "non-scaling-stroke", stroke: this.props.color, d: `M 0 0 ${pathMap[this.props.type][this.props.leftOrRight]['head']}` })),
            FSComponent.buildComponent("g", { transform: `translate(${width / 2} ${tailY}) scale(${svgScale !== null && svgScale !== void 0 ? svgScale : 1})` },
                FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", "vector-effect": "non-scaling-stroke", stroke: this.props.color, d: `M 0 0 ${pathMap[this.props.type][this.props.leftOrRight]['tail']}` }))));
    }
}

/** A compass rose display component. */
class CompassRoseTicks extends DisplayComponent {
    /** Builds the compass rose tick marks.
     * @returns A collection of rose tick line elements. */
    buildRoseTicks() {
        const { svgViewBoxSize, ticksRadius, shortTickLength, longTickLength, tickDirection, degreesPerTick, degreesPerBigTick = 10, } = this.props;
        const half = svgViewBoxSize / 2;
        const direction = tickDirection === 'Inwards' ? 1 : -1;
        const radialOffset = tickDirection === 'Inwards' ? 0 : 1;
        let path = '';
        for (let deg = 0; deg < 360; deg += degreesPerTick) {
            const length = (deg % degreesPerBigTick == 0 ? longTickLength : shortTickLength) * direction;
            const startX = half + (ticksRadius - length + radialOffset) * Math.sin(deg * Avionics.Utils.DEG2RAD);
            const startY = half + (ticksRadius - length + radialOffset) * -Math.cos(deg * Avionics.Utils.DEG2RAD);
            const endX = startX + (length * Math.sin(deg * Avionics.Utils.DEG2RAD));
            const endY = startY + (length * -Math.cos(deg * Avionics.Utils.DEG2RAD));
            path += `M ${startX} ${startY} L ${endX} ${endY} `;
        }
        return path;
    }
    /** @inheritdoc */
    render() {
        const ticksPath = this.buildRoseTicks();
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            this.props.withCircle && FSComponent.buildComponent("circle", { class: "compass-circle nd-path-shadow", cx: "50%", cy: "50%", r: this.props.ticksRadius + 1 }),
            FSComponent.buildComponent("path", { class: "nd-path-shadow", d: ticksPath }),
            this.props.withCircle && FSComponent.buildComponent("circle", { class: "compass-circle", cx: "50%", cy: "50%", r: this.props.ticksRadius + 1 }),
            FSComponent.buildComponent("path", { d: ticksPath })));
    }
}
/** A compass rose display component. */
class CompassRoseNumbers extends DisplayComponent {
    /** Builds the compass rose letter markings.
     * @returns A collection of letter marking text elements. */
    buildRoseNumbers() {
        const { svgViewBoxSize, numbersRadius, numbersRadiusBigNumber = numbersRadius, degreesPerNumber = 30, degreesPerBigNumber = degreesPerNumber, fontSize, fontSizeBig = fontSize, } = this.props;
        const half = svgViewBoxSize / 2;
        const texts = [];
        for (let deg = degreesPerNumber; deg <= 360; deg += degreesPerNumber) {
            const isBigNumber = deg % degreesPerBigNumber === 0;
            const finalFontSize = isBigNumber
                ? fontSizeBig
                : fontSize;
            const finalRadius = isBigNumber
                ? numbersRadiusBigNumber
                : numbersRadius;
            texts.push(this.buildNumber(half, finalRadius, deg, Math.round(deg / 10).toFixed(0), finalFontSize));
        }
        return texts;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    buildNumber(half, radius, angle, text, fontSize) {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("text", { x: half, y: half - radius, transform: `rotate(${angle}, ${half}, ${half})`, fill: "var(--boeing-colors-black)", "text-anchor": "middle", "font-size": fontSize, stroke: "var(--boeing-colors-black)", "stroke-width": this.props.strokeWidth }, text),
            FSComponent.buildComponent("text", { x: half, y: half - radius, transform: `rotate(${angle}, ${half}, ${half})`, fill: "var(--boeing-colors-white)", "text-anchor": "middle", "font-size": fontSize, stroke: "none" }, text)));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("g", { class: "compass-numbers" }, this.buildRoseNumbers()));
    }
}

/** The CurrentHeadingTriangle component. */
class CurrentHeadingTriangle extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.currentHeadingRotation.sub(hdg => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${hdg * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /**
     * Builds a current heading triangle element.
     * @param compassRadius The compass radius.
     * @param ref The ref to use.
     * @param canvasScale The canvas scale to use, defaults to 1.
     * @param svgScale the svg scale to use, defaults to 1.
     * @returns the heading triangle svg element.
     */
    static build(compassRadius, ref, canvasScale = 1, svgScale = 1) {
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: ref, class: "current-heading-triangle", viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * canvasScale, height: sizeUnscaled * canvasScale, style: `position: absolute; transform: translateY(${compassRadius * -1}px)` },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M -13 -26 l 13 26 l 13 -26 z", "vector-effect": "non-scaling-stroke", transform: `scale(${svgScale})` })));
    }
    /** @inheritdoc */
    render() {
        return CurrentHeadingTriangle.build(this.props.compassRadius, this.svgRef, this.props.ndDataProvider.canvasScale, this.props.svgScale);
    }
}

/** The SelectedHeadingBug component. */
class SelectedHeadingBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isInertialHeadingDataValid, selHdgOrTrk]) => {
            const isVisible = isInertialHeadingDataValid && selHdgOrTrk === 'heading';
            return !isVisible;
        }, this.props.ndDataProvider.isInertialHeadingDataValid, this.props.ndDataProvider.selHdgOrTrk);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /**
     * Builds a selected heading bug element.
     * @param ref The ref to use.
     * @param canvasScale The canvas scale to use, defaults to 1.
     * @param svgScale the svg scale to use, defaults to 1.
     * @param isHidden Whether bug should be hidden or not. Defaults to false.
     * @returns the selected heading bug svg element.
     */
    static build(ref, canvasScale = 1, svgScale = 1, isHidden) {
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: ref, class: {
                'selected-heading-bug': true,
                'hidden': isHidden !== null && isHidden !== void 0 ? isHidden : false,
            }, viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * canvasScale, height: sizeUnscaled * canvasScale, style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M 0 0 l -23 0 l 0 -18 l 10 0 l 10 18 l 6 0 l 10 -18 l 10 0 l 0 18 z", stroke: BoeingColors.magenta, "vector-effect": "non-scaling-stroke", transform: `scale(${svgScale})` })));
    }
    /** @inheritdoc */
    render() {
        return SelectedHeadingBug.build(this.svgRef, this.props.ndDataProvider.canvasScale, this.props.svgScale, this.isHidden);
    }
}

/** The SelectedHeadingLine component. */
class SelectedHeadingLine extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isInertialHeadingDataValid, selHdgOrTrk, showSelHdgTrkLine]) => {
            const isVisible = isInertialHeadingDataValid && selHdgOrTrk === 'heading' && showSelHdgTrkLine;
            return !isVisible;
        }, this.props.ndDataProvider.isInertialHeadingDataValid, this.props.ndDataProvider.selHdgOrTrk, this.props.ndDataProvider.showSelHdgTrkLine);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${(this.props.compassRadius * -0.5) + (1 * this.props.ndDataProvider.canvasScale)}px)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: {
                'selected-heading-line': true,
                'hidden': this.isHidden,
            }, viewBox: `-5 0 10 ${(this.props.compassRadius / this.props.ndDataProvider.canvasScale) + 10}`, width: 10 * this.props.ndDataProvider.canvasScale, height: this.props.compassRadius + (10 * this.props.ndDataProvider.canvasScale), style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "line", outlineClass: "nd-path-shadow", x1: 0, y1: this.props.compassRadius / this.props.ndDataProvider.canvasScale, x2: 0, y2: 4, stroke: this.props.ndDataProvider.magenta, "stroke-dasharray": `${19 * this.props.ndDataProvider.canvasScale} ${44 * this.props.ndDataProvider.canvasScale}`, "vector-effect": "non-scaling-stroke" })));
    }
}

/** The SelectedTrackBug component. */
class SelectedTrackBug extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isInertialHeadingDataValid, selHdgOrTrk]) => {
            const isVisible = isInertialHeadingDataValid && selHdgOrTrk === 'track';
            return !isVisible;
        }, this.props.ndDataProvider.isInertialHeadingDataValid, this.props.ndDataProvider.selHdgOrTrk);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${this.props.compassRadius * -1}px)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        var _a;
        const sizeUnscaled = 60;
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: {
                'selected-track-bug': true,
                'hidden': this.isHidden,
            }, viewBox: `${-sizeUnscaled / 2} ${-sizeUnscaled / 2} ${sizeUnscaled} ${sizeUnscaled}`, width: sizeUnscaled * this.props.ndDataProvider.canvasScale, height: sizeUnscaled * this.props.ndDataProvider.canvasScale, style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "path", outlineClass: "nd-path-shadow", d: "M 0 0 l -23 0 l 0 8 l 23 12 l 23 -12 l 0 -8 l -23 0 l 0 20", stroke: this.props.ndDataProvider.magenta, "vector-effect": "non-scaling-stroke", transform: `scale(${(_a = this.props.svgScale) !== null && _a !== void 0 ? _a : 1})` })));
    }
}

/** The SelectedTrackLine component. */
class SelectedTrackLine extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.isHidden = MappedSubject.create(([isInertialHeadingDataValid, selHdgOrTrk, showSelHdgTrkLine]) => {
            const isVisible = isInertialHeadingDataValid && selHdgOrTrk === 'track' && showSelHdgTrkLine;
            return !isVisible;
        }, this.props.ndDataProvider.isInertialHeadingDataValid, this.props.ndDataProvider.selHdgOrTrk, this.props.ndDataProvider.showSelHdgTrkLine);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.selectedHeadingAndTrackRotation.sub(rotation => {
            this.svgRef.instance.style.transform =
                `rotate3d(0, 0, 1, ${rotation * -1}deg) translateY(${(this.props.compassRadius * -0.5) + (1 * this.props.ndDataProvider.canvasScale)}px)`;
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { ref: this.svgRef, class: {
                'selected-heading-line': true,
                'hidden': this.isHidden,
            }, viewBox: `-5 0 10 ${(this.props.compassRadius / this.props.ndDataProvider.canvasScale) + 10}`, width: 10 * this.props.ndDataProvider.canvasScale, height: this.props.compassRadius + (10 * this.props.ndDataProvider.canvasScale), style: "position: absolute;" },
            FSComponent.buildComponent(OutlinedElement, { tag: "line", outlineClass: "nd-path-shadow", x1: 0, y1: this.props.compassRadius / this.props.ndDataProvider.canvasScale, x2: 0, y2: 4, stroke: this.props.ndDataProvider.magenta, "stroke-dasharray": `${18 * this.props.ndDataProvider.canvasScale} ${44 * this.props.ndDataProvider.canvasScale}`, "vector-effect": "non-scaling-stroke" })));
    }
}

const whiteSpaceRegex = /\s/g;
const FL = 'FL';
const EMPTY = '';
/**
 * A map flightplan waypoint label for Boeings.
 * Capable of showing speed and altitude restrictions.
 */
class FlightPathWaypointLabel extends MapCullableLocationTextLabel {
    /**
     * Ctor
     * @param waypoint The map waypoint object to display.
     * @param displaySetting The map display settings object.
     * @param options The label options.
     * @param canvasScale The canvas scale.
     * @param lineHeight The amount of pixels to offset each line by vertically.
     * @param vnavDataModule The vnav data module.
     * @param activeRoutePredictor The active route predictor.
     * @param activeRoutePlan The active route plan subject.
     * @param perfPlanRepository The perfPlanRepository.
     */
    constructor(waypoint, displaySetting, options, canvasScale, lineHeight, vnavDataModule, activeRoutePredictor, activeRoutePlan, perfPlanRepository) {
        super(waypoint.ident.replace(whiteSpaceRegex, ''), BoeingMapLabelPriority.FlightPlan, waypoint.location, true, options);
        this.waypoint = waypoint;
        this.canvasScale = canvasScale;
        this.lineHeight = lineHeight;
        this.vnavDataModule = vnavDataModule;
        this.activeRoutePredictor = activeRoutePredictor;
        this.activeRoutePlan = activeRoutePlan;
        this.perfPlanRepository = perfPlanRepository;
        this.timeFormatter = DateTimeFormatter.create('{HH}{mm}Z');
        this.altDesc = AltitudeRestrictionType.Unused;
        this.altitude1 = -1;
        this.altitude2 = -1;
        this.phase = VerticalFlightPhase.Climb;
        this.transitionAltitude = -1;
        this.transitionLevel = -1;
        this.altitudeText = '';
        this.eta = undefined;
        this.etaText = '';
        this.isDisplayed = true;
        this.showAltRestrictions = false;
        this.showEta = false;
        if (displaySetting) {
            this.displaySettingSub = displaySetting.sub(v => {
                this.showAltRestrictions = BitFlags.isAll(v, MapWaypointsDisplay.Altitude);
                this.showEta = BitFlags.isAll(v, MapWaypointsDisplay.ETA);
            }, true);
        }
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.displaySettingSub) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
    /**
     * Sets whether or not the label is displayed.
     * @param isDisplayed Whether or not the label is displayed.
     */
    setDisplayed(isDisplayed) {
        this.isDisplayed = isDisplayed;
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
        if (this.isDisplayed) {
            this.setTextStyle(context);
            context.textBaseline = 'top';
            context.textAlign = 'left';
            const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
            const centerX = pos[0];
            const centerY = pos[1];
            this.drawText(context, centerX, centerY);
        }
    }
    /** @inheritdoc */
    drawText(context, centerX, centerY) {
        // IDENT
        // Ident is always line 1
        this.renderText(context, centerX, centerY, this.text.get());
        // ALTITUDE
        const isNextConstraint = this.vnavDataModule
            ? this.waypoint.leg === this.vnavDataModule.nextConstraintLegDefForMap.get()
            : false;
        const renderAltitudeLabel = (isNextConstraint || this.showAltRestrictions === true) && BoeingMapUtils.showAltitudeForLeg(this.waypoint.leg);
        if (renderAltitudeLabel) {
            this.updateAltitudeText();
        }
        if (renderAltitudeLabel && this.altitudeText) {
            // Altitude is always line 2
            const offsetY = this.lineHeight;
            this.renderText(context, centerX, centerY + offsetY, this.altitudeText);
        }
        // ETA
        if (this.showEta) {
            this.updateEtaText();
        }
        if (this.showEta && this.etaText) {
            // ETA could be line 2 or 3
            const offsetY = (this.altitudeText ? this.lineHeight * 2 : this.lineHeight);
            this.renderText(context, centerX, centerY + offsetY, this.etaText);
        }
    }
    /**
     * Renders text for the label
     * @param context the context
     * @param centerX the cneter x position
     * @param centerY the center y position
     * @param text the text to render
     */
    renderText(context, centerX, centerY, text) {
        const fontOutlineWidth = this.fontOutlineWidth.get();
        if (fontOutlineWidth > 0) {
            context.lineWidth = fontOutlineWidth * 2;
            context.strokeStyle = this.fontOutlineColor.get();
            context.strokeText(text, centerX, centerY);
        }
        context.fillStyle = this.fontColor.get();
        context.fillText(text, centerX, centerY);
    }
    /** Updates the ETA text if anything changed. */
    updateEtaText() {
        var _a, _b, _c;
        const globalLegIndex = (_b = (_a = this.activeRoutePlan) === null || _a === void 0 ? void 0 : _a.get()) === null || _b === void 0 ? void 0 : _b.getLegIndexFromLeg(this.waypoint.leg);
        let predictions;
        if (globalLegIndex !== undefined) {
            predictions = (_c = this.activeRoutePredictor) === null || _c === void 0 ? void 0 : _c.getPredictionsForLeg(globalLegIndex);
        }
        let needsUpdate = false;
        if ((predictions === null || predictions === void 0 ? void 0 : predictions.estimatedTimeOfArrival) !== this.eta) {
            this.eta = predictions === null || predictions === void 0 ? void 0 : predictions.estimatedTimeOfArrival;
            needsUpdate = true;
        }
        if (needsUpdate) {
            this.etaText = this.eta !== undefined && !Number.isNaN(this.eta)
                ? this.timeFormatter(this.eta * 1000)
                : EMPTY;
        }
    }
    /** Updates the altitude text if anything changed. */
    updateAltitudeText() {
        var _a;
        const legVerticalData = this.waypoint.leg.verticalData;
        const activePerfPlan = (_a = this.perfPlanRepository) === null || _a === void 0 ? void 0 : _a.getActivePlan();
        if (!activePerfPlan) {
            return;
        }
        let needsUpdate = false;
        if (legVerticalData.altDesc !== this.altDesc) {
            this.altDesc = legVerticalData.altDesc;
            needsUpdate = true;
        }
        if (legVerticalData.altitude1 !== this.altitude1) {
            this.altitude1 = legVerticalData.altitude1;
            needsUpdate = true;
        }
        if (legVerticalData.altitude2 !== this.altitude2) {
            this.altitude2 = legVerticalData.altitude2;
            needsUpdate = true;
        }
        if (legVerticalData.phase !== this.phase) {
            this.phase = legVerticalData.phase;
            needsUpdate = true;
        }
        if (activePerfPlan.transitionAltitude.get() !== this.transitionAltitude) {
            this.transitionAltitude = activePerfPlan.transitionAltitude.get();
            needsUpdate = true;
        }
        if (activePerfPlan.transitionLevel.get() !== this.transitionLevel) {
            this.transitionLevel = activePerfPlan.transitionLevel.get();
            needsUpdate = true;
        }
        if (needsUpdate) {
            this.altitudeText = this.formatAltitudeConstraint();
        }
    }
    /**
     * Formats an altitude constraint for display on a waypoint label.
     * @returns A formatted altitude constraint text.
     */
    formatAltitudeConstraint() {
        const alt1Feet = UnitType.FOOT.convertFrom(this.altitude1, UnitType.METER);
        const alt2Feet = UnitType.FOOT.convertFrom(this.altitude2, UnitType.METER);
        const isAlt1FL = alt1Feet > (this.phase === VerticalFlightPhase.Climb ? this.transitionAltitude : this.transitionLevel);
        const isAlt2FL = alt2Feet > (this.phase === VerticalFlightPhase.Climb ? this.transitionAltitude : this.transitionLevel);
        const alt1FlString = isAlt1FL ? FL : EMPTY;
        const alt2FlString = isAlt2FL ? FL : EMPTY;
        const alt1String = (alt1Feet / (isAlt1FL ? 100 : 1)).toFixed(0);
        const alt2String = (alt2Feet / (isAlt2FL ? 100 : 1)).toFixed(0);
        switch (this.altDesc) {
            case AltitudeRestrictionType.At:
                return `${alt1FlString}${alt1String}`;
            case AltitudeRestrictionType.AtOrAbove:
                return `${alt1FlString}${alt1String}A`;
            case AltitudeRestrictionType.AtOrBelow:
                return `${alt1FlString}${alt1String}B`;
            case AltitudeRestrictionType.Between:
                return this.phase === VerticalFlightPhase.Climb
                    ? `${alt2FlString}${alt2String}A${alt1FlString}${alt1String}B`
                    : `${alt1FlString}${alt1String}B${alt2FlString}${alt2String}A`;
            case AltitudeRestrictionType.Unused: {
                return EMPTY;
            }
        }
    }
}

const ETA_FORMATTER = DurationFormatter.create('{hh}{mm.m}', UnitType.MILLISECOND, 6000, '------');
const DISTANCE_FORMATTER = NumberFormatter.create({ precision: 0.1, maxDigits: 3, forceDecimalZeroes: true, nanString: '----' });
const MSEC_PER_DAY = 1000 * 60 * 60 * 24;
/** The ActiveWaypointDataBlock component. */
class ActiveWaypointDataBlock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.date = new Date(0);
        this.lNavDataSub = this.props.bus.getSubscriber();
        this.clockSub = this.props.bus.getSubscriber();
        this.activeLegPrediction = Subject.create(null);
        this.currentSimTime = ConsumerSubject.create(this.clockSub.on('simTime').atFrequency(1), 0);
        this.activeLegIndex = ConsumerSubject.create(this.lNavDataSub.on('lnavdata_nominal_leg_index'), -1);
        this.activeLegIdent = ConsumerSubject.create(this.lNavDataSub.on('lnavdata_waypoint_ident'), '');
        this.activeLegDistance = ConsumerSubject.create(this.lNavDataSub.on('lnavdata_waypoint_distance').withPrecision(1), 0);
        this.waypointIdent = MappedSubject.create(([activeLegIdent]) => {
            if (activeLegIdent.trim().length === 0) {
                return '(-----)';
            }
            else {
                // Don't remove whitespace here, the real thing will display alt legs like (3500 ), so that's expected
                return activeLegIdent;
            }
        }, this.activeLegIdent);
        this.eta = MappedSubject.create(([activeLegPrediction, simTime]) => {
            if (!activeLegPrediction) {
                return ETA_FORMATTER(NaN);
            }
            const unixDayStartMs = simTime - (simTime % (MSEC_PER_DAY));
            const eta = unixDayStartMs + activeLegPrediction.estimatedTimeOfArrival * 1000;
            this.date.setTime(eta);
            const etaTimeMs = eta - this.date.setUTCHours(0, 0, 0, 0);
            return ETA_FORMATTER(etaTimeMs);
        }, this.activeLegPrediction, this.currentSimTime);
        this.distance = MappedSubject.create(([distance, activeLegIdent]) => {
            return (activeLegIdent.trim().length > 0
                ? DISTANCE_FORMATTER(distance)
                : '----').padStart(this.props.distancePad, ' ');
        }, this.activeLegDistance, this.activeLegIdent);
        this.subs = [];
    }
    /** @inheritDoc */
    onAfterRender() {
        this.subs = [
            this.props.activeRoutePredictor.onPredictionsUpdated.on(this.updatePrediction.bind(this)),
            this.activeLegIndex.sub(this.updatePrediction.bind(this)),
        ];
    }
    /** Update predictions after updating flight plan predictor. */
    updatePrediction() {
        const activeLegIndex = this.activeLegIndex.get();
        const hasActiveLeg = activeLegIndex !== -1;
        const hasActiveRoutePlan = this.props.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        if (hasActiveRoutePlan && hasActiveLeg) {
            const predictions = this.props.activeRoutePredictor.iteratePredictions(activeLegIndex);
            const activeLegPredictions = predictions.next();
            if (activeLegPredictions.value) {
                this.activeLegPrediction.set(activeLegPredictions.value);
                this.activeLegPrediction.notify();
            }
            else {
                this.activeLegPrediction.set(null);
            }
        }
        else {
            this.activeLegPrediction.set(null);
        }
    }
    /** @inheritDoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "active-waypoint-data-block-container" },
            FSComponent.buildComponent("div", { class: "waypoint-ident" }, this.waypointIdent),
            FSComponent.buildComponent("div", { class: "waypoint-estimated-arrival-time" },
                FSComponent.buildComponent("span", null, this.eta),
                FSComponent.buildComponent("span", { class: "s-text" }, "Z")),
            FSComponent.buildComponent("div", { class: "waypoint-distance" },
                this.distance,
                FSComponent.buildComponent("span", { class: "s-text" }, "NM"))));
    }
    /** @inheritdoc */
    destroy() {
        this.subs.map((sub) => sub.destroy());
    }
}

/** The AdfDisplay component. */
class AdfDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.adfSectionRef = FSComponent.createRef();
        this.adfLeftRef = FSComponent.createRef();
        this.adfRightRef = FSComponent.createRef();
        this.navComSub = this.props.bus.getSubscriber();
        this.adfFreq1 = ConsumerSubject.create(this.navComSub.on('adf_active_frequency_1').withPrecision(1), 0);
        this.adfFreq2 = ConsumerSubject.create(this.navComSub.on('adf_active_frequency_2').withPrecision(1), 0);
        this.adfIdent1 = ConsumerSubject.create(this.navComSub.on('adf_ident_1').whenChanged(), '');
        this.adfIdent2 = ConsumerSubject.create(this.navComSub.on('adf_ident_2').whenChanged(), '');
        this.adfSignal1 = ConsumerSubject.create(this.navComSub.on('adf_signal_1').atFrequency(1), 0);
        this.adfSignal2 = ConsumerSubject.create(this.navComSub.on('adf_signal_2').atFrequency(1), 0);
        this.formatAdfData = ([freq, ident, signal]) => {
            if (signal > 0 && ident !== '') {
                return ident;
            }
            else if (freq) {
                return freq.toFixed(1);
            }
            else {
                return '---.-';
            }
        };
        this.adfLeftData = MappedSubject.create(this.adfFreq1, this.adfIdent1, this.adfSignal1).map(this.formatAdfData);
        this.adfRightData = MappedSubject.create(this.adfFreq2, this.adfIdent2, this.adfSignal2).map(this.formatAdfData);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.navAidLeftState.sub(state => {
            this.adfLeftRef.instance.classList.toggle('hidden', state !== 'ADF');
        }, true);
        this.props.ndDataProvider.navAidRightState.sub(state => {
            this.adfRightRef.instance.classList.toggle('hidden', state !== 'ADF');
        }, true);
        this.props.ndDataProvider.isAdfSupported.sub(isAdfSupported => {
            this.adfSectionRef.instance.classList.toggle('hidden', !isAdfSupported);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "adf-display", ref: this.adfSectionRef },
            FSComponent.buildComponent("div", { class: "data-block-left", ref: this.adfLeftRef },
                FSComponent.buildComponent("div", null, "ADF L"),
                FSComponent.buildComponent("div", null, this.adfLeftData)),
            FSComponent.buildComponent("div", { class: "data-block-right", ref: this.adfRightRef },
                FSComponent.buildComponent("div", null, "ADF R"),
                FSComponent.buildComponent("div", null, this.adfRightData))));
    }
}

/** The GroundAirSpeed component. */
class GroundAirSpeed extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.sub = this.props.bus.getSubscriber();
        this.tasRef = FSComponent.createRef();
        this.trueAirSpeed = MappedSubject.create(([tas, isInertialDataValid]) => isInertialDataValid ? tas : 0, ConsumerSubject.create(this.sub.on('tas').withPrecision(0).atFrequency(5), 0), this.props.ndDataProvider.isInertialDataValid);
        this.isTasInvalid = this.trueAirSpeed.map(tas => tas < 100);
        this.groundSpeed = MappedSubject.create(([gs, isInertialDataValid]) => (isInertialDataValid ? gs : 0).toFixed(0).padStart(2, ' '), ConsumerSubject.create(this.sub.on('ground_speed').withPrecision(0).atFrequency(5), 0), this.props.ndDataProvider.isInertialDataValid);
    }
    /** @inheritDoc */
    onAfterRender() {
        this.isTasInvalid.sub((value) => {
            this.tasRef.instance.classList.toggle('hidden', value);
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "ground-air-speed-container" },
            FSComponent.buildComponent("span", { class: "ground-speed" },
                FSComponent.buildComponent("span", { class: "s-text" }, "GS"),
                FSComponent.buildComponent("span", null, this.groundSpeed)),
            FSComponent.buildComponent("span", { class: "true-air-speed", ref: this.tasRef },
                FSComponent.buildComponent("span", { class: "s-text" }, "TAS"),
                FSComponent.buildComponent("span", null, this.trueAirSpeed))));
    }
}

/** The MapFailureFlag component. */
class MapFailureFlags extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-failure-flags-container" },
            FSComponent.buildComponent("div", { class: {
                    'map-failure-flag': true,
                    'hidden': this.props.ndDataProvider.isInertialHeadingDataValid,
                } }, "MAP")));
    }
}

/** The MapRange component. */
class MapRange extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-range-container" },
            FSComponent.buildComponent("div", { class: "s-text" }, "RANGE"),
            FSComponent.buildComponent("div", { class: "text" }, this.props.ndDataProvider.mapRange)));
    }
}

/** The WindVector component. Indicates wind bearing, speed, and direction with respect to heading / track reference.
 * Arrow not displayed in PLAN mode. */
class WindVector extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.windArrowRef = FSComponent.createRef();
        /** Plane track in degrees true. */
        this.magVar = ConsumerSubject.create(null, 0);
        this.sub = this.props.bus.getSubscriber();
        this.trackDegTrue = ConsumerSubject.create(this.sub.on('track_deg_true').withPrecision(1), 0);
        this.windDirectionDegTrue = ConsumerSubject.create(this.sub.on('ambient_wind_direction').withPrecision(0).atFrequency(5), 0);
        this.windSpeedKnots = ConsumerSubject.create(this.sub.on('ambient_wind_velocity').withPrecision(0).atFrequency(5), 0);
        this.groundSpeed = ConsumerSubject.create(this.sub.on('ground_speed').withPrecision(0).atFrequency(5), 0);
        // FIXME wind vector can reference to heading/track, not only heading.
        this.windArrowRotation = MappedSubject.create(([windDirTrue, track]) => {
            return windDirTrue - track - 180;
        }, this.windDirectionDegTrue, this.trackDegTrue);
        this.windArrowAnimator = new MapCompassAnimator(4.5, undefined, this.windArrowRotation);
        // FIXME should take into consideration TRUE/MAG reference if implemented
        this.windDirectionString = MappedSubject.create(([windDirTrue, magVar]) => MagVar.trueToMagnetic(windDirTrue, magVar).toFixed(0).padStart(3, '0'), this.windDirectionDegTrue, this.magVar);
        this.speedValid = this.windSpeedKnots.map((windSpeed, prevValue) => {
            const speedThresh = prevValue ? 5 : 7;
            return windSpeed >= speedThresh;
        });
        this.groundSpeedValid = this.groundSpeed.map((groundSpeed, prevValue) => {
            const groundSpeedThresh = prevValue ? 36 : 40;
            return groundSpeed >= groundSpeedThresh;
        });
        this.isArrowVisible = MappedSubject.create(([hideWindVector, speedValid, groundSpeedValid]) => {
            if (hideWindVector) {
                return false;
            }
            return Boolean(speedValid && groundSpeedValid);
        }, this.props.ndDataProvider.hideWindVector, this.speedValid, this.groundSpeedValid);
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.magVar.setConsumer(sub.on('magvar').withPrecision(1));
        this.windArrowAnimator.output.sub(rotation => {
            this.windArrowRef.instance.style.transform = `rotate3d(0,0,1, ${rotation}deg)`;
        }, true);
        this.windArrowAnimator.start();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'hsi-wind-container': true,
                'hidden': this.props.ndDataProvider.hasWindData.map(x => !x),
            } },
            FSComponent.buildComponent("div", { class: "hsi-wind-direction-speed" },
                this.windDirectionString,
                "\u00B0/",
                FSComponent.buildComponent("span", { class: "hsi-wind-speed" }, this.windSpeedKnots)),
            FSComponent.buildComponent("svg", { class: {
                    'hsi-wind-arrow': true,
                    'hidden': this.isArrowVisible.map(x => !x),
                }, ref: this.windArrowRef, viewBox: "-15 -90 30 90", fill: "none", "stroke-linecap": "round", "stroke-linejoin": "round" },
                FSComponent.buildComponent("path", { class: "wind-arrow-outline", d: "M 0 -10 l 0 -70 m -8 9 l 8 -9 l 8 9", "vector-effect": "non-scaling-stroke" }),
                FSComponent.buildComponent("path", { d: "M 0 -10 l 0 -70 m -8 9 l 8 -9 l 8 9", "vector-effect": "non-scaling-stroke" }))));
    }
    /** @inheritdoc */
    destroy() {
        this.trackDegTrue.destroy();
        this.windDirectionDegTrue.destroy();
        this.windSpeedKnots.destroy();
        this.groundSpeed.destroy();
    }
}

/**
 * The SpeedWindRangeInfoBlock component.
 * When using this component, make sure to copy the `SpeedWindRangeInfoBlock.css` file from another project
 * and import it where you import this component.
 */
class SpeedWindRangeInfoBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "speed-wind-range-info-block" },
            FSComponent.buildComponent("div", { class: "ground-air-wind-container" },
                FSComponent.buildComponent(GroundAirSpeed, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider }),
                FSComponent.buildComponent(WindVector, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider })),
            this.props.showRange && FSComponent.buildComponent(MapRange, { ndDataProvider: this.props.ndDataProvider })));
    }
}

/**
 * The TimeToAlign component.
 * When using this component, make sure to copy the `TimeToAlign.css` file from another project
 * and import it where you import this component.
 */
class TimeToAlign extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.timeToAlignSeconds = ConsumerSubject.create(this.props.bus.getSubscriber().on('min_irs_align_seconds_remaining'), null);
        this.timeToAlignNumberText = this.timeToAlignSeconds.map(seconds => {
            if (seconds === null) {
                return '--';
            }
            const minutes = seconds / 60;
            const minutesCeiled = Math.ceil(minutes);
            if (minutesCeiled > TimeToAlign.UPPER_THRESHOLD_MINUTES) {
                return (TimeToAlign.UPPER_THRESHOLD_MINUTES.toFixed(0) + '+').padStart(3, ' ');
            }
            else {
                return minutesCeiled.toFixed(0).padStart(2, ' ');
            }
        });
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'time-to-align': true,
                'hidden': this.props.ndDataProvider.showTimeToAlign.map(x => !x),
            } },
            FSComponent.buildComponent("div", null, "TIME TO"),
            FSComponent.buildComponent("div", null, "ALIGN"),
            FSComponent.buildComponent("div", null, this.timeToAlignNumberText)));
    }
}
TimeToAlign.UPPER_THRESHOLD_MINUTES = 7;

/** AirportWaypointStationBlockBlock component.
 * Displays ARPT / WPT / STA flag when the respective setting is set in the ND Menu.
 */
class MapSymbolsSettingBlock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.airportTextRef = FSComponent.createRef();
        this.waypointTextRef = FSComponent.createRef();
        this.stationTextRef = FSComponent.createRef();
        this.mapSymbolsSetting = this.props.ndDataProvider.mapWaypointsDisplay;
    }
    /** @inheritdoc */
    onAfterRender() {
        this.mapSymbolsSettingSub = this.mapSymbolsSetting.sub(currentValue => {
            this.airportTextRef.instance.classList.toggle('visibility-hidden', !(BitFlags.isAny(currentValue, MapWaypointsDisplay.Airports)));
            this.waypointTextRef.instance.classList.toggle('visibility-hidden', !(BitFlags.isAny(currentValue, MapWaypointsDisplay.Intersections)));
            this.stationTextRef.instance.classList.toggle('visibility-hidden', !(BitFlags.isAny(currentValue, MapWaypointsDisplay.HiNavaids)) || !(BitFlags.isAny(currentValue, MapWaypointsDisplay.LoNavaids)) || !(BitFlags.isAny(currentValue, MapWaypointsDisplay.NDBs)));
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "map-symbols-setting-block-container" },
            FSComponent.buildComponent("div", { class: "map-symbols-setting", ref: this.airportTextRef }, "ARPT"),
            FSComponent.buildComponent("div", { class: "map-symbols-setting", ref: this.waypointTextRef }, "WPT"),
            FSComponent.buildComponent("div", { class: "map-symbols-setting", ref: this.stationTextRef }, "STA")));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.mapSymbolsSettingSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/** The TcasBlock component. Displays TCAS / TFC modes in cyan and amber colors at the bottom left side of the ND display. */
class TcasBlock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.tcasModeOffOrFailedContainerRef = FSComponent.createRef();
        this.tcasModeOffOrFailedTextRef = FSComponent.createRef();
        this.tcasModeRef = FSComponent.createRef();
        this.tfcModeRef = FSComponent.createRef();
        this.subscriptions = [];
        this.tcasConditions = MappedSubject.create(([isTfcSupported, tcasOperatingMode]) => {
            return [isTfcSupported, tcasOperatingMode];
        }, this.props.ndDataProvider.isTfcSupported, ConsumerSubject.create(this.props.bus.getSubscriber().on('tcas_operating_mode'), TcasOperatingMode.Off));
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subscriptions = [
            this.props.ndDataProvider.showTfc.sub(isTfcOn => {
                this.tfcModeRef.instance.classList.toggle('visibility-hidden', !isTfcOn);
            }, true),
            this.tcasConditions.sub(([isTfcSupported, tcasOperatingMode]) => {
                const isTcasOff = tcasOperatingMode < TcasOperatingMode.TAOnly || tcasOperatingMode === TcasOperatingMode.Failed;
                this.tcasModeOffOrFailedTextRef.instance.classList.toggle('hidden', !(isTcasOff && isTfcSupported));
                this.tcasModeRef.instance.classList.toggle('hidden', isTcasOff);
                switch (tcasOperatingMode) {
                    case TcasOperatingMode.Off:
                    case TcasOperatingMode.Standby:
                        this.tcasModeOffOrFailedTextRef.instance.textContent = 'TCAS OFF';
                        this.tcasModeOffOrFailedContainerRef.instance.classList.remove('hidden');
                        return;
                    case TcasOperatingMode.Failed:
                        this.tcasModeOffOrFailedTextRef.instance.textContent = 'TCAS FAIL';
                        this.tcasModeOffOrFailedContainerRef.instance.classList.remove('hidden');
                        return;
                    case TcasOperatingMode.Test:
                        this.tcasModeOffOrFailedContainerRef.instance.classList.add('hidden');
                        this.tcasModeRef.instance.textContent = 'TCAS TEST';
                        return;
                    case TcasOperatingMode.TAOnly:
                        this.tcasModeOffOrFailedContainerRef.instance.classList.add('hidden');
                        this.tcasModeRef.instance.textContent = 'TA ONLY';
                        return;
                    case TcasOperatingMode.TA_RA:
                        this.tcasModeOffOrFailedContainerRef.instance.classList.add('hidden');
                        this.tcasModeRef.instance.textContent = '';
                        return;
                    default:
                        console.warn('Undefined TCAS operating mode', tcasOperatingMode);
                        return;
                }
            }, true),
        ];
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "tcas-block-container" },
            FSComponent.buildComponent("div", { class: "tcas-mode-off hidden", ref: this.tcasModeOffOrFailedContainerRef },
                FSComponent.buildComponent("span", { ref: this.tcasModeOffOrFailedTextRef }, "TCAS OFF")),
            FSComponent.buildComponent("div", { class: "tfc-mode", ref: this.tfcModeRef }, "TFC"),
            FSComponent.buildComponent("div", { class: "tcas-mode", ref: this.tcasModeRef })));
    }
    /** @inheritdoc */
    destroy() {
        this.subscriptions.map((sub) => sub === null || sub === void 0 ? void 0 : sub.destroy());
    }
}

/**
 * The TerrainBlock component.
 * TERR has normal (turned on) mode and TEST mode (not implemented);
 * Has FAIL/OVRD/POS status as alerts in amber.
 */
class TerrainBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'terr-block-container': true,
                'hidden': this.props.ndDataProvider.showTerr.map(x => !x),
            } },
            FSComponent.buildComponent("div", { class: "terr-status fixed-double-line hidden" },
                FSComponent.buildComponent("span", { class: "hidden" },
                    "TERR",
                    FSComponent.buildComponent("br", null),
                    "OVRD")),
            FSComponent.buildComponent("div", { class: "terr-status fixed-double-line hidden" },
                FSComponent.buildComponent("span", { class: "hidden" },
                    "TERR",
                    FSComponent.buildComponent("br", null),
                    "FAIL")),
            FSComponent.buildComponent("div", { class: "terr-status fixed-double-line hidden" },
                FSComponent.buildComponent("span", { class: "hidden" },
                    "TERR",
                    FSComponent.buildComponent("br", null),
                    "POS")),
            FSComponent.buildComponent("div", { class: "terr-mode" },
                FSComponent.buildComponent("span", null, "TERR")),
            FSComponent.buildComponent("div", { class: "terr-mode no-width" },
                FSComponent.buildComponent("span", null, "\u00A0")),
            FSComponent.buildComponent("div", { class: "terr-mode no-width" },
                FSComponent.buildComponent("span", null, "\u00A0"))));
    }
}

/**
 * The TcasBlock component.
 * Displays TCAS / TFC modes in cyan and amber colors at the bottom left side of the ND display.
 */
class WeatherRadarBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'wxr-block-container': true,
                'hidden': this.props.ndDataProvider.showWxr.map(x => !x),
            } },
            FSComponent.buildComponent("div", { class: "wxr-mode" }, "WX"),
            FSComponent.buildComponent("div", { class: "wxr-mode radar-tilt" }, "- 2.50A"),
            FSComponent.buildComponent("div", { class: "wxr-mode radar-gain" }, "\u00A00")));
    }
}

/**
 * The WxTerrTfcDataBlock component.
 * Displays mode/status annunciations of the weather radar,
 * terrain display, and TFC/TCAS at the bottom left side of the ND display.
 */
class WxTerrTfcDataBlock extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "wx-terr-tfc-data-block-container" },
            this.props.showMapSymbolsBlock && FSComponent.buildComponent(MapSymbolsSettingBlock, { ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(WeatherRadarBlock, { ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(TerrainBlock, { ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(TcasBlock, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider })));
    }
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * A view representation of a TCAS intruder for MapTrafficIntruderLayer.
 */
class MapTrafficIntruderIcon extends AbstractMapTrafficIntruderIcon {
    /**
     * Constructor.
     * @param intruder This view's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The own airplane properties module for this icon's parent map.
     * @param stylesModule The map styles module.
     * @param options Configuration options for this icon.
     */
    constructor(intruder, trafficModule, ownshipModule, stylesModule, options) {
        super(intruder, trafficModule, ownshipModule);
        this.stylesModule = stylesModule;
        this.options = options;
        this.iconSize = 28 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
        this.altitudeText = '';
    }
    /** @inheritdoc */
    drawIcon(projection, context, projectedPos, isOffScale) {
        if (!projection.isInProjectedBounds(projectedPos)) {
            return;
        }
        const alertLevel = this.intruder.alertLevel.get();
        const isTARA = alertLevel === TcasAlertLevel.TrafficAdvisory || alertLevel === TcasAlertLevel.ResolutionAdvisory;
        if (isOffScale) {
            return;
        }
        if (!isTARA) {
            const altitudeMeters = this.intruder.relativePositionVec[2];
            if (altitudeMeters > this.trafficModule.altitudeRestrictionAbove.get().asUnit(UnitType.METER)
                || altitudeMeters < -this.trafficModule.altitudeRestrictionBelow.get().asUnit(UnitType.METER)) {
                return;
            }
        }
        context.translate(projectedPos[0], projectedPos[1]);
        this.drawIconVSArrow(context, alertLevel);
        this.drawIconAltitudeLabel(context, alertLevel);
        if (this.options.supportAdsbIn) {
            this.drawArrowIcon(context, projection, alertLevel);
        }
        else {
            this.drawNoArrowIcon(context, alertLevel);
        }
        context.resetTransform();
    }
    /**
     * Draws the icon without a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawNoArrowIcon(context, alertLevel) {
        context.setLineDash(MapTrafficIntruderIcon.EMPTY_LINE_DASH);
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                this.drawDiamondIcon(context, alertLevel === TcasAlertLevel.ProximityAdvisory);
                break;
            case TcasAlertLevel.TrafficAdvisory:
                this.drawCircleIcon(context);
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                this.drawSquareIcon(context);
                break;
        }
    }
    /**
     * Draws a diamond icon.
     * @param context The canvas rendering context to which to draw the icon.
     * @param isFilled Whether the diamond should be filled.
     */
    drawDiamondIcon(context, isFilled) {
        const size = 0.35 * this.iconSize;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.beginPath();
        context.moveTo(0, -size);
        context.lineTo(size, 0);
        context.lineTo(0, size);
        context.lineTo(-size, 0);
        context.closePath();
        context.strokeStyle = 'black';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = 'white';
        context.fill();
        context.stroke();
        if (!isFilled) {
            context.beginPath();
            context.moveTo(0, -size * 0.6);
            context.lineTo(size * 0.6, 0);
            context.lineTo(0, size * 0.6);
            context.lineTo(-size * 0.6, 0);
            context.closePath();
            context.fillStyle = 'black';
            context.fill();
        }
    }
    /**
     * Draws a circle icon for TAs.
     * @param context The canvas rendering context to which to draw the icon.
     */
    drawCircleIcon(context) {
        context.beginPath();
        context.arc(0, 0, 0.35 * this.iconSize, 0, MathUtils.TWO_PI);
        context.strokeStyle = 'black';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
        context.fill();
        context.stroke();
    }
    /**
     * Draws a square icon for RAs.
     * @param context The canvas rendering context to which to draw the icon.
     */
    drawSquareIcon(context) {
        const size = 0.35 * this.iconSize;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.beginPath();
        context.moveTo(-size, -size);
        context.lineTo(size, -size);
        context.lineTo(size, size);
        context.lineTo(-size, size);
        context.closePath();
        context.strokeStyle = 'black';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
        context.fill();
        context.stroke();
    }
    /**
     * Draws the icon with a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawArrowIcon(context, projection, alertLevel) {
        this.drawArrowIconBackground(context, alertLevel);
        this.drawIconArrow(context, projection, alertLevel);
    }
    /**
     * Draws the icon's background when it has a directional arrow display.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawArrowIconBackground(context, alertLevel) {
        if (alertLevel === TcasAlertLevel.None || alertLevel === TcasAlertLevel.ProximityAdvisory) {
            return;
        }
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.strokeStyle = '#1a1d21';
        context.lineWidth = Math.max(1, 0.05 * this.iconSize);
        context.fillStyle = alertLevel === TcasAlertLevel.ResolutionAdvisory ? MapTrafficIntruderIcon.RA_COLOR : MapTrafficIntruderIcon.TA_COLOR;
        context.beginPath();
        const size = 0.65 * this.iconSize;
        if (alertLevel === TcasAlertLevel.ResolutionAdvisory) {
            // RA
            context.rect(-size, -size, size * 2, size * 2);
        }
        else {
            // TA
            context.arc(0, 0, size, 0, MathUtils.TWO_PI);
        }
        context.fill();
    }
    /**
     * Draws the icon's directional arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrow(context, projection, alertLevel) {
        context.save();
        context.rotate(this.intruder.groundTrack * Avionics.Utils.DEG2RAD + projection.getRotation());
        this.drawIconArrowOutline(context, alertLevel);
        context.restore();
    }
    /**
     * Draws the icon's directional arrow outline.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconArrowOutline(context, alertLevel) {
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.beginPath();
        context.moveTo(0, -0.65 * this.iconSize);
        context.lineTo(0.37 * this.iconSize, 0.55 * this.iconSize);
        context.lineTo(0, 0.25 * this.iconSize);
        context.lineTo(-0.37 * this.iconSize, 0.55 * this.iconSize);
        context.closePath();
        if (alertLevel === TcasAlertLevel.None || alertLevel === TcasAlertLevel.ProximityAdvisory) {
            // Outline
            context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
            context.strokeStyle = 'black';
            context.stroke();
        }
        switch (alertLevel) {
            case TcasAlertLevel.None:
                context.strokeStyle = 'white';
                context.fillStyle = 'transparent';
                break;
            case TcasAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'white';
                context.fillStyle = 'white';
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.strokeStyle = 'transparent';
                context.fillStyle = 'black';
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.strokeStyle = 'transparent';
                context.fillStyle = 'black';
                break;
        }
        if (alertLevel !== TcasAlertLevel.None) {
            context.fill();
        }
        context.lineWidth = this.stylesModule.styles.strokeWidth;
        context.stroke();
    }
    /**
     * Draws the icon's vertical speed indicator arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconVSArrow(context, alertLevel) {
        const showArrow = MapTrafficIntruderIcon.VERTICAL_SPEED_THRESHOLD.compare(Math.abs(this.intruder.velocityVec[2]), UnitType.MPS) <= 0;
        if (!showArrow) {
            return;
        }
        const vsSign = Math.sign(this.intruder.velocityVec[2]);
        context.lineCap = 'round';
        context.lineJoin = 'round';
        const offsetX = 0.4;
        context.beginPath();
        context.moveTo((0.75 + offsetX) * this.iconSize, -0.35 * this.iconSize * vsSign);
        context.lineTo((0.75 + offsetX) * this.iconSize, 0.40 * this.iconSize * vsSign);
        context.moveTo((0.55 + offsetX) * this.iconSize, -0.15 * this.iconSize * vsSign);
        context.lineTo((0.75 + offsetX) * this.iconSize, -0.40 * this.iconSize * vsSign);
        context.lineTo((0.95 + offsetX) * this.iconSize, -0.15 * this.iconSize * vsSign);
        // black outline
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.strokeStyle = 'black';
        context.stroke();
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth;
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.strokeStyle = 'white';
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.strokeStyle = MapTrafficIntruderIcon.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.strokeStyle = MapTrafficIntruderIcon.RA_COLOR;
                break;
        }
        context.stroke();
    }
    /**
     * Draws the icon's altitude label.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconAltitudeLabel(context, alertLevel) {
        const isRelative = this.trafficModule.isAltitudeRelative.get();
        const isAltitudeAbove = this.intruder.relativePositionVec[2] >= 0;
        const altitudeFeet = this.trafficModule.isAltitudeRelative.get()
            ? UnitType.METER.convertTo(this.intruder.relativePositionVec[2], UnitType.FOOT)
            : this.intruder.altitude.asUnit(UnitType.FOOT);
        const altitudeRounded = Math.round(altitudeFeet / 100);
        const altitudeAbs = Math.abs(altitudeRounded);
        const prefix = altitudeRounded < 0
            ? '-'
            : isRelative
                ? '+'
                : '';
        if (altitudeAbs !== this.lastDrawnAltitudeValue || prefix !== this.lastDrawnAltitudePrefix) {
            this.lastDrawnAltitudeValue = altitudeAbs;
            this.lastDrawnAltitudePrefix = prefix;
            this.altitudeText = `${prefix}${altitudeAbs}`;
        }
        // black outline
        context.lineWidth = this.stylesModule.styles.fontOutlineWidth * 2;
        context.strokeStyle = 'black';
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.strokeText(this.altitudeText, 0, -0.7 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.strokeText(this.altitudeText, 0, 0.9 * this.iconSize);
        }
        // draw text
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.fillStyle = 'white';
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderIcon.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderIcon.RA_COLOR;
                break;
        }
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.fillText(this.altitudeText, 0, -0.7 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.fillText(this.altitudeText, 0, 0.9 * this.iconSize);
        }
    }
}
MapTrafficIntruderIcon.VERTICAL_SPEED_THRESHOLD = UnitType.FPM.createNumber(500);
MapTrafficIntruderIcon.TA_COLOR = BoeingColors.amber;
MapTrafficIntruderIcon.RA_COLOR = BoeingColors.red;
MapTrafficIntruderIcon.EMPTY_LINE_DASH = [];

/**
 * A traffic intruder icon for Boeings. No support for ADS-B In. The icon includes a symbol that is chosen based on the intruder's alert
 * level, an altitude label displaying either the intruder's relative or absolute altitude to the nearest hundreds of
 * feet, and a vertical speed direction arrow which is only visible when the magnitude of the intruder's vertical speed
 * is greater than 500 FPM.
 */
class MapTrafficIntruderIconOld extends AbstractMapTrafficIntruderIcon {
    /**
     * Constructor.
     * @param intruder This icon's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The ownship module for this icon's parent map.
     * @param stylesModule The map styles module.
     */
    constructor(intruder, trafficModule, ownshipModule, stylesModule) {
        super(intruder, trafficModule, ownshipModule);
        this.stylesModule = stylesModule;
        this.iconSize = 28 * this.stylesModule.styles.maxToOldBoeingScale * this.stylesModule.styles.canvasScale;
    }
    /** @inheritdoc */
    drawIcon(projection, context, projectedPos, isOffScale) {
        const alertLevel = this.intruder.alertLevel.get();
        if (!projection.isInProjectedBounds(projectedPos)) {
            return;
        }
        if (alertLevel !== TcasAlertLevel.ResolutionAdvisory && alertLevel !== TcasAlertLevel.TrafficAdvisory) {
            if (isOffScale) {
                return;
            }
            const altitudeMeters = this.intruder.relativePositionVec[2];
            if (altitudeMeters > this.trafficModule.altitudeRestrictionAbove.get().asUnit(UnitType.METER)
                || altitudeMeters < -this.trafficModule.altitudeRestrictionBelow.get().asUnit(UnitType.METER)) {
                return;
            }
        }
        context.translate(projectedPos[0], projectedPos[1]);
        this.drawIconVSArrow(context, alertLevel);
        this.drawIconAltitudeLabel(context, alertLevel);
        this.drawIconSymbol(context, projection, projectedPos, alertLevel, isOffScale);
        context.resetTransform();
    }
    /**
     * Draws this icon's symbol.
     * @param context The canvas rendering context to which to draw the icon.
     * @param projection The map projection.
     * @param projectedPos The projected position of this icon's intruder.
     * @param alertLevel The alert level assigned to this icon's intruder.
     * @param isOffScale Whether this icon's intruder is off-scale.
     */
    drawIconSymbol(context, projection, projectedPos, alertLevel, isOffScale) {
        let needRestoreContextState = false;
        if (isOffScale) {
            context.save();
            needRestoreContextState = true;
            const projectedAngle = Vec2Math.theta(Vec2Math.sub(projectedPos, projection.getTargetProjected(), MapTrafficIntruderIconOld.vec2Cache[0]));
            context.beginPath();
            context.arc(0, 0, 0.5 * this.iconSize, projectedAngle - MathUtils.HALF_PI, projectedAngle + MathUtils.HALF_PI);
            context.closePath();
            context.clip();
        }
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.beginPath();
                context.moveTo(0, -0.4 * this.iconSize);
                context.lineTo(0.3 * this.iconSize, 0);
                context.lineTo(0, 0.4 * this.iconSize);
                context.lineTo(-0.3 * this.iconSize, 0);
                context.closePath();
                // black outline
                context.lineWidth = this.stylesModule.styles.strokeWidth + (this.stylesModule.styles.outlineWidth * 2);
                context.lineJoin = 'round';
                context.strokeStyle = 'black';
                context.stroke();
                context.lineWidth = this.stylesModule.styles.strokeWidth;
                context.lineJoin = 'round';
                context.strokeStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                context.stroke();
                if (alertLevel === TcasAlertLevel.ProximityAdvisory) {
                    context.fillStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                    context.fill();
                }
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.beginPath();
                context.moveTo(0.5 * this.iconSize, 0);
                context.arc(0, 0, 0.5 * this.iconSize, 0, MathUtils.TWO_PI);
                context.lineWidth = this.stylesModule.styles.outlineWidth * 2;
                context.strokeStyle = 'black';
                context.stroke();
                context.fillStyle = MapTrafficIntruderIconOld.TA_COLOR;
                context.fill();
                break;
            case TcasAlertLevel.ResolutionAdvisory: {
                const size = this.iconSize * Math.SQRT1_2;
                context.lineWidth = this.stylesModule.styles.outlineWidth * 2;
                context.strokeStyle = 'black';
                context.strokeRect(-0.5 * size, -0.5 * size, size, size);
                context.fillStyle = MapTrafficIntruderIconOld.RA_COLOR;
                context.fillRect(-0.5 * size, -0.5 * size, size, size);
                break;
            }
        }
        if (needRestoreContextState) {
            context.restore();
        }
    }
    /**
     * Draws the icon's vertical speed indicator arrow.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconVSArrow(context, alertLevel) {
        const showArrow = MapTrafficIntruderIconOld.VERTICAL_SPEED_THRESHOLD.compare(Math.abs(this.intruder.velocityVec[2]), UnitType.MPS) <= 0;
        if (!showArrow) {
            return;
        }
        const vsSign = Math.sign(this.intruder.velocityVec[2]);
        context.lineCap = 'round';
        context.beginPath();
        context.moveTo(0.75 * this.iconSize, -0.35 * this.iconSize * vsSign);
        context.lineTo(0.75 * this.iconSize, 0.40 * this.iconSize * vsSign);
        context.moveTo(0.55 * this.iconSize, -0.05 * this.iconSize * vsSign);
        context.lineTo(0.75 * this.iconSize, -0.40 * this.iconSize * vsSign);
        context.lineTo(0.95 * this.iconSize, -0.05 * this.iconSize * vsSign);
        // black outline
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth + (this.stylesModule.styles.outlineWidth * 2);
        context.strokeStyle = 'black';
        context.stroke();
        context.lineWidth = this.stylesModule.styles.arrowStrokeWidth;
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.strokeStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.strokeStyle = MapTrafficIntruderIconOld.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.strokeStyle = MapTrafficIntruderIconOld.RA_COLOR;
                break;
        }
        context.stroke();
    }
    /**
     * Draws the icon's altitude label.
     * @param context The canvas rendering context to which to draw the icon.
     * @param alertLevel The alert level assigned to this view's intruder.
     */
    drawIconAltitudeLabel(context, alertLevel) {
        const isRelative = this.trafficModule.isAltitudeRelative.get();
        const isAltitudeAbove = this.intruder.relativePositionVec[2] >= 0;
        const altitudeFeet = this.trafficModule.isAltitudeRelative.get()
            ? UnitType.METER.convertTo(this.intruder.relativePositionVec[2], UnitType.FOOT)
            : this.intruder.altitude.asUnit(UnitType.FOOT);
        const altitudeRounded = Utils.Clamp(Math.round(altitudeFeet / 100), isRelative ? -99 : -Infinity, isRelative ? 99 : 999);
        const altitudeAbs = Math.abs(altitudeRounded);
        const prefix = isRelative
            ? altitudeRounded < 0
                ? '-'
                : '+'
            : '';
        const altitudeText = !isRelative && altitudeRounded < 0 ? 'XXX' : `${prefix}${altitudeAbs.toFixed(0).padStart(isRelative ? 2 : 3, '0')}`;
        // black outline
        context.lineWidth = this.stylesModule.styles.fontOutlineWidth * 2;
        context.strokeStyle = 'black';
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.strokeText(altitudeText, 0, -0.5 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.strokeText(altitudeText, 0, 0.7 * this.iconSize);
        }
        switch (alertLevel) {
            case TcasAlertLevel.None:
            case TcasAlertLevel.ProximityAdvisory:
                context.fillStyle = MapTrafficIntruderIconOld.PA_OTHER_COLOR;
                break;
            case TcasAlertLevel.TrafficAdvisory:
                context.fillStyle = MapTrafficIntruderIconOld.TA_COLOR;
                break;
            case TcasAlertLevel.ResolutionAdvisory:
                context.fillStyle = MapTrafficIntruderIconOld.RA_COLOR;
                break;
        }
        if (isAltitudeAbove) {
            context.textBaseline = 'bottom';
            context.fillText(altitudeText, 0, -0.5 * this.iconSize);
        }
        else {
            context.textBaseline = 'top';
            context.fillText(altitudeText, 0, 0.7 * this.iconSize);
        }
    }
}
MapTrafficIntruderIconOld.VERTICAL_SPEED_THRESHOLD = UnitType.FPM.createNumber(500);
MapTrafficIntruderIconOld.PA_OTHER_COLOR = BoeingColors.white;
MapTrafficIntruderIconOld.TA_COLOR = BoeingColors.amber;
MapTrafficIntruderIconOld.RA_COLOR = BoeingColors.red;
MapTrafficIntruderIconOld.vec2Cache = [new Float64Array(2)];

/* eslint-disable jsdoc/require-jsdoc */
const nonFixLegTypes = [LegType.CA, LegType.CI, LegType.CR, LegType.FA, LegType.FM, LegType.VA, LegType.VI, LegType.VM, LegType.VR];
/**
 * A map system config for Boeing maps.
 */
class MapSystemConfig {
    /**
     * Creates a new map system config.
     * @param mapStyles the boeing map styles.
     */
    constructor(mapStyles) {
        this.mapStyles = mapStyles;
        this.ICON_SIZE = Vec2Math.create(this.mapStyles.mapIconSize, this.mapStyles.mapIconSize);
        this.MagentaPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.magenta,
            outlineWidth: this.mapStyles.outlineWidth,
        };
        this.WhitePath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.white,
            outlineWidth: this.mapStyles.outlineWidth,
        };
        this.WhiteDashedPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.white,
            dash: [14, 10],
            outlineWidth: this.mapStyles.outlineWidth,
            lineCap: 'round',
        };
        this.CyanDashedPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.cyan,
            dash: [24, 10],
            outlineWidth: this.mapStyles.outlineWidth,
            lineCap: 'round',
        };
        this.CyanPath = {
            isDisplayed: true,
            width: this.mapStyles.strokeWidth,
            style: BoeingColors.cyan,
            outlineWidth: this.mapStyles.outlineWidth,
        };
        this.HoldLegWhitePath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildWhiteHoldStyle.bind(this)
        };
        this.HoldLegMagentaPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildMagentaHoldStyle.bind(this)
        };
        this.HoldLegCyanPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildCyanHoldStyle.bind(this)
        };
        this.HoldLegWhiteDashedPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildWhiteDashedHoldStyle.bind(this)
        };
        this.HoldLegCyanDashedPath = {
            partsToRender: FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Ingress,
            styleBuilder: this.buildCyanDashedHoldStyle.bind(this)
        };
        this.FlightPathWaypointLabelOptions = {
            fontSize: this.mapStyles.labelFontSize,
            font: 'B787',
            fontOutlineWidth: this.mapStyles.fontOutlineWidth,
            fontOutlineColor: BoeingColors.black,
            offset: this.mapStyles.bigLabelOffset,
        };
        /**
         * Configures the map waypoint display layer.
         * @returns A builder function to configure the waypoint display system.
         */
        this.configureMapWaypoints = () => {
            return (builder) => {
                builder.registerRole(BoeingMapCommon.tunedVorRole);
                builder.withSearchCenter('target');
                this.configWptRoles(MapSystemWaypointRoles.Normal, builder);
            };
        };
        /**
         * Configures the map flight plan display layer.
         * @param bus The event bus to use.
         * @param ndDataProvider The ND data provider.
         * @param vnavDataModule The vnav data module.
         * @param activeRoutePredictor The active route predictor.
         * @param perfPlanRepository The perfPlanRepository.
         * @returns A builder function to configure the flight plan display system.
         */
        this.configureFlightPlan = (bus, ndDataProvider, vnavDataModule, activeRoutePredictor, perfPlanRepository) => {
            return (builder, context) => {
                const activeRoutePlanSubject = context.model.getModule(MapSystemKeys.FlightPlan).getPlanSubjects(BoeingFms.ACT_RTE_PLAN_INDEX);
                const flightPlanLabelArgs = [ndDataProvider.mapWaypointsDisplay, vnavDataModule, activeRoutePredictor, activeRoutePlanSubject.flightPlan, perfPlanRepository];
                const effectiveLegIndex = Subject.create(-1);
                const sub = bus.getSubscriber();
                sub.on('lnavdata_nominal_leg_index').handle(effectiveLegIndex.set.bind(effectiveLegIndex));
                builder.registerRole(PlanWaypointRoles.Active_Star)
                    .registerRole(PlanWaypointRoles.Active_Circle)
                    .registerRole(PlanWaypointRoles.Inactive_Star)
                    .registerRole(PlanWaypointRoles.Inactive_Circle)
                    .addDefaultIcon(PlanWaypointRoles.Active_Star, this.buildActiveWaypointIcon('FLIGHTPLAN_M', 999))
                    .addDefaultIcon(PlanWaypointRoles.Active_Circle, this.buildActiveWaypointIcon('FLIGHTPLAN_CIRCLE_MAGENTA', 999))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Star, this.buildIcon('FLIGHTPLAN', 999))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Circle, this.buildIcon('FLIGHTPLAN_CIRCLE_WHITE', 999))
                    // 787 does show DATA for all legs in active route
                    .addLabel(PlanWaypointRoles.Active_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.magenta, ...flightPlanLabelArgs))
                    .addLabel(PlanWaypointRoles.Active_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.magenta, ...flightPlanLabelArgs))
                    .addLabel(PlanWaypointRoles.Inactive_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white, ...flightPlanLabelArgs))
                    .addLabel(PlanWaypointRoles.Inactive_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white, ...flightPlanLabelArgs))
                    .withAnticipationTurns(true)
                    .withLegPathStyles((plan, leg, activeLeg, legIndex) => {
                    const isMissedApproachLeg = BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach);
                    const isHoldLeg = (leg.leg.type === LegType.HF || leg.leg.type === LegType.HA);
                    if (isMissedApproachLeg) {
                        // We only want the MAP legs to be in cyan if we are not already in the missed approach
                        if (!ndDataProvider.isMissedApproachActive.get()) {
                            return isHoldLeg ? this.HoldLegCyanPath : this.CyanPath;
                        }
                    }
                    if (legIndex > effectiveLegIndex.get()) {
                        return isHoldLeg ? this.HoldLegMagentaPath : this.MagentaPath;
                    }
                    else if (legIndex === effectiveLegIndex.get()) {
                        return isHoldLeg ? this.HoldLegMagentaPath : this.MagentaPath;
                    }
                    else if (legIndex === effectiveLegIndex.get() - 1) {
                        return isHoldLeg ? this.HoldLegMagentaPath : this.MagentaPath;
                    }
                    return FlightPathRenderStyle.Hidden;
                })
                    .withLegWaypointRoles((plan, leg, activeLeg, legIndex) => {
                    if (this.isOriginDestOrRunwayLeg(plan, leg)) {
                        return 0;
                    }
                    // Legs with no fix are shown as a circle
                    const useCircleIcon = nonFixLegTypes.includes(leg.leg.type);
                    if (legIndex > effectiveLegIndex.get()) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                    }
                    else if (legIndex === effectiveLegIndex.get()) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Active_Circle : PlanWaypointRoles.Active_Star);
                    }
                    else if (legIndex === effectiveLegIndex.get() - 1) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                    }
                    return 0;
                });
            };
        };
        /**
         * Configures the map flight plan display layer for the mod flight plan.
         * @param bus The event bus to use.
         * @returns A builder function to configure the mod flight plan display system.
         */
        this.configureModFlightPlan = (bus) => {
            return (builder) => {
                const isMissedApproachActive = Subject.create(false);
                bus.getSubscriber().on('lnavdata_cdi_scale_label')
                    .handle(x => isMissedApproachActive.set(x === CDIScaleLabel.MissedApproach));
                const currentlyInMod = Subject.create(false);
                bus.getSubscriber().on('fmcExecActive').handle(active => currentlyInMod.set(active === 1));
                builder
                    .registerRole(PlanWaypointRoles.Inactive_Star)
                    .registerRole(PlanWaypointRoles.Inactive_Circle)
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Star, this.buildIcon('FLIGHTPLAN'))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Circle, this.buildIcon('FLIGHTPLAN_CIRCLE_WHITE'))
                    // 787 does not show DATA for mod or inactive routes
                    .addLabel(PlanWaypointRoles.Inactive_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white))
                    .addLabel(PlanWaypointRoles.Inactive_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white));
                builder.withAnticipationTurns(true);
                builder.withLegPathStyles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    if (legIndex >= activeLegIndex && currentlyInMod.get()) {
                        const isHoldLeg = (leg.leg.type === LegType.HF || leg.leg.type === LegType.HA);
                        const isHoldToManualTerminationLeg = (leg.leg.type === LegType.HM);
                        return isHoldLeg
                            ? this.HoldLegWhiteDashedPath
                            : isHoldToManualTerminationLeg
                                ? this.WhitePath
                                : this.WhiteDashedPath;
                    }
                    return FlightPathRenderStyle.Hidden;
                });
                builder.withLegWaypointRoles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    if (this.isOriginDestOrRunwayLeg(plan, leg)) {
                        return 0;
                    }
                    // Legs with no fix are shown as a circle
                    const useCircleIcon = nonFixLegTypes.includes(leg.leg.type);
                    if (legIndex >= activeLegIndex && currentlyInMod.get()) {
                        return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                    }
                    return 0;
                });
            };
        };
        /**
         * Configures the map flight plan display layer for the inactive route flight plan.
         * @returns A builder function to configure the inactive route flight plan display system.
         */
        this.configureInactiveFlightPlan = () => {
            return (builder) => {
                builder
                    .registerRole(PlanWaypointRoles.Inactive_Star)
                    .registerRole(PlanWaypointRoles.Inactive_Circle)
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Star, this.buildIcon('FLIGHTPLAN'))
                    .addDefaultIcon(PlanWaypointRoles.Inactive_Circle, this.buildIcon('FLIGHTPLAN_CIRCLE_WHITE'))
                    // 787 does not show DATA for mod or inactive routes
                    .addLabel(PlanWaypointRoles.Inactive_Star, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white))
                    .addLabel(PlanWaypointRoles.Inactive_Circle, WaypointTypes.FlightPlan, this.buildFlightPlanLabel(BoeingColors.white));
                builder.withAnticipationTurns(true);
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                builder.withLegPathStyles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    const isHoldLeg = (leg.leg.type === LegType.HF || leg.leg.type === LegType.HA);
                    const isHoldToManualTerminationLeg = (leg.leg.type === LegType.HM);
                    return isHoldLeg
                        ? this.HoldLegCyanDashedPath
                        : isHoldToManualTerminationLeg
                            ? this.CyanPath
                            : this.CyanDashedPath;
                });
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                builder.withLegWaypointRoles((plan, leg, activeLeg, legIndex, activeLegIndex) => {
                    if (this.isOriginDestOrRunwayLeg(plan, leg)) {
                        return 0;
                    }
                    // Legs with no fix are shown as a circle
                    const useCircleIcon = nonFixLegTypes.includes(leg.leg.type);
                    return builder.getRoleId(useCircleIcon ? PlanWaypointRoles.Inactive_Circle : PlanWaypointRoles.Inactive_Star);
                });
            };
        };
        this.createTrafficIntruderIcon = (options) => (intruder, context) => {
            if (options.supportAdsbIn) {
                return new MapTrafficIntruderIcon(intruder, context.model.getModule(MapSystemKeys.Traffic), context.model.getModule(MapSystemKeys.OwnAirplaneProps), context.model.getModule(BoeingMapKeys.MapStyles), options);
            }
            else {
                // Kind of temporary until someone updates the diamond icons in the new icon class
                return new MapTrafficIntruderIconOld(intruder, context.model.getModule(MapSystemKeys.Traffic), context.model.getModule(MapSystemKeys.OwnAirplaneProps), context.model.getModule(BoeingMapKeys.MapStyles));
            }
        };
        /**
         * Initializes global canvas styles for the traffic layer.
         * @param context The canvas rendering context for which to initialize styles.
         */
        this.initTrafficLayerCanvasStyles = (context) => {
            context.textAlign = 'center';
            context.font = this.mapStyles.labelFontSize + 'px B787';
        };
    }
    /**
     * Builds non-active leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildWhiteHoldStyle() {
        return this.WhitePath;
    }
    /**
     * Builds active leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildMagentaHoldStyle() {
        return this.MagentaPath;
    }
    /**
     * Builds leg style for hold legs on the missed approach.
     * @returns The appropriate hold leg display style.
     */
    buildCyanHoldStyle() {
        return this.CyanPath;
    }
    /**
     * Builds mod leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildWhiteDashedHoldStyle() {
        return this.WhiteDashedPath;
    }
    /**
     * Builds inactive plan leg style for hold legs.
     * @returns The appropriate hold leg display style.
     */
    buildCyanDashedHoldStyle() {
        return this.CyanDashedPath;
    }
    /**
     * Builds a label for facility waypoints.
     * @param color The color of the label.
     * @param bigIcon Whether this is for a big icon.
     * @returns A new factory that will create the label.
     */
    buildFacilityLabel(color, bigIcon) {
        return (w) => {
            // Default offset
            let offset = this.mapStyles.smallLabelOffset;
            if (bigIcon) {
                offset = this.mapStyles.bigLabelOffset;
            }
            return new MapCullableLocationTextLabel(ICAO.getIdent(w.facility.get().icao), BoeingMapLabelPriority.Bottom, w.location, false, {
                fontSize: this.mapStyles.labelFontSize,
                fontColor: color,
                font: 'B787',
                fontOutlineWidth: this.mapStyles.fontOutlineWidth,
                fontOutlineColor: BoeingColors.black,
                offset,
            });
        };
    }
    /**
     * Builds a label for flight plan waypoints.
     * @param fontColor The color of the label.
     * @param displaySetting The 'mapWaypointsDisplay' setting.
     * @param vnavDataModule The vnav data module.
     * @param activeRoutePredictor The active route predictor.
     * @param activeRoutePlan The active route plan subject.
     * @param perfPlanRepository The perfPlanRepository.
     * @returns A new factory that will create the label.
     */
    buildFlightPlanLabel(fontColor, displaySetting, vnavDataModule, activeRoutePredictor, activeRoutePlan, perfPlanRepository) {
        return w => new FlightPathWaypointLabel(w, displaySetting, Object.assign({ fontColor }, this.FlightPathWaypointLabelOptions), this.mapStyles.canvasScale, this.mapStyles.labelLineHeight, vnavDataModule, activeRoutePredictor, activeRoutePlan, perfPlanRepository);
    }
    /**
     * Builds an icon for a waypoint.
     * @param id The ID of the icon.
     * @param priority he render priority of this icon.
     * @returns A factory that builds the image icon.
     */
    buildIcon(id, priority = 0) {
        return (w) => new MapWaypointImageIcon(w, priority, ImageCache.get(id), this.ICON_SIZE);
    }
    /**
     * Builds an icon for a waypoint.
     * @param id The ID of the icon.
     * @param priority he render priority of this icon.
     * @returns A factory that builds the image icon.
     */
    buildActiveWaypointIcon(id, priority = 0) {
        return (w) => new ActiveWaypointIcon(w, priority, ImageCache.get(id), this.ICON_SIZE);
    }
    /**
     * Configures the map waypoint role styles.
     * @param role The role to configure.
     * @param builder The waypoint display builder
     */
    configWptRoles(role, builder) {
        builder.addDefaultIcon(role, this.buildIcon('INTERSECTION'))
            .addDefaultLabel(role, this.buildFacilityLabel(BoeingColors.cyan, false))
            .addIcon(role, WaypointTypes.Airport, this.buildIcon('AIRPORT'))
            // NDB's are not displayed on the ND, but we will show them when centered on with CTR ON
            .addIcon(role, WaypointTypes.NDB, this.buildIcon('STA_NDB'))
            .addIcon(role, WaypointTypes.VOR, (w) => {
            switch (w.facility.get().type) {
                case VorType.VOR:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('STA_VOR'), this.ICON_SIZE);
                case VorType.VORDME:
                case VorType.DME:
                case VorType.TACAN:
                    // DME's are displayed with TACAN icon
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('STA_TACAN'), this.ICON_SIZE);
                default:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('STA_VORTAC'), this.ICON_SIZE);
            }
        })
            .addLabel(BoeingMapCommon.tunedVorRole, WaypointTypes.VOR, this.buildFacilityLabel(BoeingColors.green, true))
            .addIcon(BoeingMapCommon.tunedVorRole, WaypointTypes.VOR, (w) => {
            switch (w.facility.get().type) {
                case VorType.VOR:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('VOR'), this.ICON_SIZE);
                case VorType.VORDME:
                case VorType.DME:
                case VorType.TACAN:
                    // DME's are displayed with TACAN icon
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('TACAN'), this.ICON_SIZE);
                default:
                    return new MapWaypointImageIcon(w, 0, ImageCache.get('VORTAC'), this.ICON_SIZE);
            }
        });
    }
    /**
     * Checks if leg is the origin or destination airport leg or runway leg.
     * @param plan the plan.
     * @param leg the leg.
     * @returns Whether leg is the origin or destination airport leg or runway leg.
     */
    isOriginDestOrRunwayLeg(plan, leg) {
        const isOriginOrDestinationAirportLeg = leg.leg.fixIcao === plan.originAirport || leg.leg.fixIcao === plan.destinationAirport;
        const isRunwayLeg = ICAO.isFacility(leg.leg.fixIcao, FacilityType.RWY);
        return isOriginOrDestinationAirportLeg || isRunwayLeg;
    }
}
var PlanWaypointRoles;
(function (PlanWaypointRoles) {
    PlanWaypointRoles["Inactive_Star"] = "FlightPlan_Inactive_Star";
    PlanWaypointRoles["Active_Star"] = "FlightPlan_Active_Star";
    PlanWaypointRoles["Inactive_Circle"] = "FlightPlan_Inactive_Circle";
    PlanWaypointRoles["Active_Circle"] = "FlightPlan_Active_Circle";
})(PlanWaypointRoles || (PlanWaypointRoles = {}));

/**
 * A Boeing PFD attitude indicator airplane symbol.
 */
class PfdAirplaneSymbol extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.style = ObjectSubject.create({
            display: '',
            position: 'absolute',
            left: '0px',
            top: '0px',
            transform: 'translate(-50%, -50%)',
            overflow: 'visible'
        });
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.style.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.updatePosition();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updatePosition();
        }
    }
    /**
     * Updates this symbol's position.
     */
    updatePosition() {
        const offsetCenter = this.props.projection.getOffsetCenterProjected();
        this.style.set('left', `${offsetCenter[0]}px`);
        this.style.set('top', `${offsetCenter[1]}px`);
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("svg", { viewBox: '-192 -30 384 60', preserveAspectRatio: 'none', class: 'pfd-airplane-symbol', style: this.style },
                FSComponent.buildComponent("path", { d: 'M -192 -7 l 101 0 l 0 37 l -14 0 l 0 -23 l -87 0 z M 192 -7 l -101 0 l 0 37 l 14 0 l 0 -23 l 87 0 z', class: 'pfd-airplane-symbol-wings shadow', "stroke-linejoin": 'round' }),
                FSComponent.buildComponent("path", { d: 'M -192 -7 l 101 0 l 0 37 l -14 0 l 0 -23 l -87 0 z M 192 -7 l -101 0 l 0 37 l 14 0 l 0 -23 l 87 0 z', class: 'pfd-airplane-symbol-wings', "stroke-linejoin": 'round' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        super.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}

/**
 * A Boeing PFD artificial horizon. Displays sky and ground boxes.
 */
class PfdArtificialHorizon extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.canvasLayerRef = FSComponent.createRef();
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.horizonLineConformalBounds, true);
        this.pitchResolution = 0; // pixels per degree
        this.vec2Cache = [Vec2Math.create(), Vec2Math.create(), Vec2Math.create(), Vec2Math.create()];
        this.windowTransform = new Transform2D();
        this.windowTransformInverse = new Transform2D();
        this.horizonProjected = Vec2Math.create();
        this.horizonOffset = Vec2Math.create();
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.canvasLayerRef.instance.setVisible(isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.canvasLayerRef.instance.onAttached();
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.conformalBoundsSub = this.conformalBounds.sub(() => {
            this.needUpdate = true;
        });
        this.updatePitchResolution();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        this.canvasLayerRef.instance.onProjectionChanged(projection, changeFlags);
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.PitchScaleFactor)) {
            this.updatePitchResolution();
        }
        this.needUpdate = true;
    }
    /**
     * Updates the pitch resolution used to draw this horizon.
     */
    updatePitchResolution() {
        this.pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov() * this.props.projection.getPitchScaleFactor();
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        // Approximate translation due to pitch using a constant pitch resolution (pixels per degree of pitch) derived
        // from the projection's current field of view. The error of this approximation increases with the absolute
        // deviation of the pitch angle from 0 degrees. We do this instead of simply projecting the true horizon line
        // because we need to keep the line in sync with the pitch ladder, which uses the same approximation.
        const center = this.props.projection.getOffsetCenterProjected();
        const roll = this.props.projection.getRoll();
        Vec2Math.set(0, 0, this.horizonProjected);
        this.windowTransform
            .toTranslation(0, this.pitchResolution * this.props.projection.getPitch())
            .addRotation(-roll * Avionics.Utils.DEG2RAD)
            .addTranslation(center[0], center[1])
            .apply(this.horizonProjected, this.horizonProjected);
        this.updateOffset();
        this.drawHorizonRects();
    }
    /**
     * Updates the offset to apply to this horizon line's projection to keep it within the conformal bounds.
     */
    updateOffset() {
        const bounds = this.conformalBounds.get();
        if (this.props.projection.isInProjectedBounds(this.horizonProjected, bounds)) {
            // The horizon line is within the conformal bounds.
            Vec2Math.set(0, 0, this.horizonOffset);
        }
        else {
            // The horizon line is not within the conformal bounds. Find the smallest offset toward the center of the
            // projection that brings it within the conformal bounds.
            const center = this.props.projection.getOffsetCenterProjected();
            const conformalX = this.horizonProjected[0];
            const conformalY = this.horizonProjected[1];
            let displayX = conformalX;
            let displayY = conformalY;
            if (displayX < bounds[0]) {
                displayY = MathUtils.lerp(bounds[0], center[0], displayX, center[1], displayY);
                displayX = bounds[0];
            }
            else if (displayX > bounds[2]) {
                displayY = MathUtils.lerp(bounds[2], center[0], displayX, center[1], displayY);
                displayX = bounds[2];
            }
            if (displayY < bounds[1]) {
                displayX = MathUtils.lerp(bounds[1], center[1], displayY, center[0], displayX);
                displayY = bounds[1];
            }
            else if (displayY > bounds[3]) {
                displayX = MathUtils.lerp(bounds[3], center[1], displayY, center[0], displayX);
                displayY = bounds[3];
            }
            Vec2Math.set(displayX - conformalX, displayY - conformalY, this.horizonOffset);
        }
    }
    /**
     * Draws the horizon rects to the canvas.
     */
    drawHorizonRects() {
        const context = this.canvasLayerRef.instance.display.context;
        const projectedSize = this.props.projection.getProjectedSize();
        context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
        // windowTransform applies a transformation to move a horizon centered at (0, 0) to its conformal projected
        // position and rotation. Before we use it to draw the rects we need to add the offset to bring the horizon within
        // the conformal bounds.
        const transform = this.windowTransform
            .addTranslation(this.horizonOffset[0], this.horizonOffset[1]);
        const inverse = this.windowTransformInverse
            .set(this.windowTransform)
            .invert();
        const windowUl = inverse.apply(Vec2Math.set(0, 0, this.vec2Cache[0]), this.vec2Cache[0]);
        const windowUr = inverse.apply(Vec2Math.set(projectedSize[0], 0, this.vec2Cache[1]), this.vec2Cache[1]);
        const windowLl = inverse.apply(Vec2Math.set(0, projectedSize[1], this.vec2Cache[2]), this.vec2Cache[2]);
        const windowLr = inverse.apply(Vec2Math.set(projectedSize[0], projectedSize[1], this.vec2Cache[3]), this.vec2Cache[3]);
        const minX = Math.min(windowUl[0], windowUr[0], windowLl[0], windowLr[0]);
        const maxX = Math.max(windowUl[0], windowUr[0], windowLl[0], windowLr[0]);
        const minY = Math.min(windowUl[1], windowUr[1], windowLl[1], windowLr[1]);
        const maxY = Math.max(windowUl[1], windowUr[1], windowLl[1], windowLr[1]);
        if (maxY > 0) {
            context.beginPath();
            let p = transform.apply(Vec2Math.set(minX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.moveTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, maxY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(minX, maxY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            context.closePath();
            context.fillStyle = this.props.options.groundColor;
            context.fill();
        }
        if (minY < 0) {
            context.beginPath();
            let p = transform.apply(Vec2Math.set(minX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.moveTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, 0, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(maxX, minY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            p = transform.apply(Vec2Math.set(minX, minY, this.vec2Cache[0]), this.vec2Cache[0]);
            context.lineTo(p[0], p[1]);
            context.closePath();
            context.fillStyle = this.props.options.skyColor;
            context.fill();
        }
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(HorizonSyncedCanvasLayer, { ref: this.canvasLayerRef, projection: this.props.projection, class: 'pfd-artificial-horizon' }));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.conformalBoundsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.canvasLayerRef.getOrDefault()) === null || _c === void 0 ? void 0 : _c.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD bank indicator. Displays a bank scale, bank pointer, and slip-skid indicator.
 */
class PfdBankIndicator extends HorizonLayer {
    constructor() {
        // NOTE: Everything in this component is referenced to a coordinate system with the horizon projection projected
        // center as the origin and axes aligned with the horizon projection.
        super(...arguments);
        this.rootStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
        });
        this.pointerTransform = CssTransformSubject.create(CssTransformBuilder.rotate3d('deg'));
        this.slipSkidTransform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.slipSkidTranslateScale = 0;
        this.pointerHidden = this.props.showPointer.map(SubscribableMapFunctions.not());
        this.isBankAlertActive = Subject.create(false);
        this.isSlipSkidAlertActive = Subject.create(false);
        this.needUpdateBank = false;
        this.needUpdateSlipSkid = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.rootStyle.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.turnCoordinatorBallSub = this.props.turnCoordinatorBall.sub(() => { this.needUpdateSlipSkid = true; });
        this.updateRootPosition();
        this.needUpdateBank = true;
        this.needUpdateSlipSkid = true;
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updateRootPosition();
        }
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Roll)) {
            this.needUpdateBank = true;
        }
    }
    /**
     * Updates this indicator's root container position.
     */
    updateRootPosition() {
        const offsetCenter = this.props.projection.getOffsetCenterProjected();
        this.rootStyle.set('left', `${offsetCenter[0]}px`);
        this.rootStyle.set('top', `${offsetCenter[1]}px`);
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (!this.props.showPointer.get()) {
            return;
        }
        if (this.needUpdateBank) {
            this.updatePointer();
            this.needUpdateBank = false;
        }
        if (this.needUpdateSlipSkid) {
            this.updateSlipSkid();
            this.needUpdateSlipSkid = false;
        }
    }
    /**
     * Updates the rotation of the bank pointer and slip/skid indicator.
     */
    updatePointer() {
        const bank = this.props.projection.getRoll();
        this.pointerTransform.transform.set(0, 0, 1, -bank, 0.1);
        this.pointerTransform.resolve();
        this.isBankAlertActive.set(Math.abs(bank) >= 35);
    }
    /**
     * Updates the position of the slip/skid indicator.
     */
    updateSlipSkid() {
        const ball = this.props.turnCoordinatorBall.get();
        this.slipSkidTransform.transform.set(ball * this.slipSkidTranslateScale, 0, 0, 0.1);
        this.slipSkidTransform.resolve();
        this.isSlipSkidAlertActive.set(Math.abs(ball) === 1);
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-bank-indicator': true,
                'pfd-bank-indicator-bank-alert': this.isBankAlertActive,
                'pfd-bank-indicator-slip-skid-alert': this.isSlipSkidAlertActive
            }, style: this.rootStyle },
            this.renderScale(),
            this.renderPointerContainer()));
    }
    /**
     * Renders the bank scale, which includes the bank reference pointer and the scale ticks.
     * @returns The bank scale, as a VNode.
     */
    renderScale() {
        const { radius, majorTickLength, mediumTickLength, minorTickLength } = this.props.options;
        const svgPathStream = new SvgPathStream(0.01);
        const transformPathStream = new AffineTransformPathStream(svgPathStream);
        transformPathStream.addTranslation(0, -radius);
        transformPathStream.beginPath();
        // zero-bank reference pointer
        const halfWidth = minorTickLength / MathUtils.SQRT3;
        transformPathStream.moveTo(0, 0);
        transformPathStream.lineTo(-halfWidth, -minorTickLength);
        transformPathStream.lineTo(halfWidth, -minorTickLength);
        transformPathStream.closePath();
        const pointerPath = svgPathStream.getSvgPath();
        transformPathStream.beginPath();
        // 10, 20, 45-degree ticks
        transformPathStream.addRotation(-30 * Avionics.Utils.DEG2RAD);
        for (const angle of [10, 20, 45]) {
            transformPathStream.resetTransform();
            transformPathStream.addRotation(-angle * Avionics.Utils.DEG2RAD);
            transformPathStream.moveTo(0, -radius);
            transformPathStream.lineTo(0, -radius - minorTickLength);
            transformPathStream.addRotation(2 * angle * Avionics.Utils.DEG2RAD);
            transformPathStream.moveTo(0, -radius);
            transformPathStream.lineTo(0, -radius - minorTickLength);
        }
        // 30-degree ticks
        transformPathStream.resetTransform();
        transformPathStream.addRotation(-30 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - majorTickLength);
        transformPathStream.addRotation(60 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - majorTickLength);
        // 60-degree ticks
        transformPathStream.resetTransform();
        transformPathStream.addRotation(-60 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - mediumTickLength);
        transformPathStream.addRotation(120 * Avionics.Utils.DEG2RAD);
        transformPathStream.moveTo(0, -radius);
        transformPathStream.lineTo(0, -radius - mediumTickLength);
        const ticksPath = svgPathStream.getSvgPath();
        const left = -radius * MathUtils.SQRT3 / 2;
        const top = -radius;
        const width = -left * 2;
        const height = radius / 2;
        return (FSComponent.buildComponent("svg", { viewBox: `${left.toFixed(2)} ${top.toFixed(2)} ${width.toFixed(2)} ${height.toFixed(2)}`, class: 'pfd-bank-indicator-scale', style: `position: absolute; left: ${left.toFixed(2)}px; top: ${top.toFixed(2)}px; width: ${width.toFixed(2)}px; height: ${height.toFixed(2)}px; overflow: visible;` },
            FSComponent.buildComponent("path", { d: pointerPath, fill: 'none', "stroke-linejoin": 'round', class: 'pfd-bank-indicator-scale-pointer shadow' }),
            FSComponent.buildComponent("path", { d: ticksPath, fill: 'none', "stroke-linecap": 'round', class: 'pfd-bank-indicator-scale-ticks shadow' }),
            FSComponent.buildComponent("path", { d: pointerPath, "stroke-linejoin": 'round', class: 'pfd-bank-indicator-scale-pointer' }),
            FSComponent.buildComponent("path", { d: ticksPath, fill: 'none', "stroke-linecap": 'round', class: 'pfd-bank-indicator-scale-ticks' })));
    }
    /**
     * Renders the bank pointer and slip/skid indicator.
     * @returns The bank pointer and slip/skid indicator, as a VNode.
     */
    renderPointerContainer() {
        const pointerSize = this.props.options.pointerSize;
        const pointerTipRadius = this.props.options.radius - this.props.options.pointerOffset;
        const pointerHalfWidth = pointerSize[0] / 2;
        const pointerLeft = -pointerHalfWidth;
        const pointerTop = -pointerTipRadius;
        const pointerWidth = pointerHalfWidth * 2;
        const pointerHeight = pointerSize[1];
        const pointerPath = `M 0 ${-pointerTipRadius} l ${pointerLeft} ${pointerHeight} l ${pointerWidth} 0 Z`;
        const slipSkidHalfWidth = pointerHalfWidth;
        this.slipSkidTranslateScale = slipSkidHalfWidth;
        const slipSkidLeft = -slipSkidHalfWidth;
        const slipSkidTop = -pointerTipRadius + pointerHeight + Math.max(0, this.props.options.slipSkidIndicatorOffset);
        const slipSkidWidth = slipSkidHalfWidth * 2;
        const slipSkidHeight = this.props.options.slipSkidIndicatorHeight;
        const slipSkidPath = `M ${slipSkidLeft} ${slipSkidTop} l ${slipSkidWidth} 0 l 0 ${slipSkidHeight} l ${-slipSkidWidth} 0 Z`;
        return (FSComponent.buildComponent("div", { class: { 'hidden': this.pointerHidden }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px',
                'width': '0px',
                'height': '0px',
                'transform': this.pointerTransform
            } },
            FSComponent.buildComponent("svg", { viewBox: `${pointerLeft} ${pointerTop} ${pointerWidth} ${pointerHeight}`, class: 'pfd-bank-indicator-pointer shadow', style: `position: absolute; left: ${pointerLeft}px; top: ${pointerTop}px; width: ${pointerWidth}px; height: ${pointerHeight}px; overflow: visible;` },
                FSComponent.buildComponent("path", { d: pointerPath, fill: 'none', "stroke-linejoin": 'round' })),
            FSComponent.buildComponent("svg", { viewBox: `${slipSkidLeft} ${slipSkidTop} ${slipSkidWidth} ${slipSkidHeight}`, class: 'pfd-bank-indicator-slip-skid shadow', style: {
                    'position': 'absolute',
                    'left': `${slipSkidLeft}px`,
                    'top': `${slipSkidTop}px`,
                    'width': `${slipSkidWidth}px`,
                    'height': `${slipSkidHeight}px`,
                    'transform': this.slipSkidTransform,
                    'overflow': 'visible'
                } },
                FSComponent.buildComponent("path", { d: slipSkidPath, fill: 'none', "stroke-linejoin": 'round' })),
            FSComponent.buildComponent("svg", { viewBox: `${pointerLeft} ${pointerTop} ${pointerWidth} ${pointerHeight}`, class: 'pfd-bank-indicator-pointer', style: `position: absolute; left: ${pointerLeft}px; top: ${pointerTop}px; width: ${pointerWidth}px; height: ${pointerHeight}px; overflow: visible;` },
                FSComponent.buildComponent("path", { d: pointerPath, "stroke-linejoin": 'round' })),
            FSComponent.buildComponent("svg", { viewBox: `${slipSkidLeft} ${slipSkidTop} ${slipSkidWidth} ${slipSkidHeight}`, class: 'pfd-bank-indicator-slip-skid', style: {
                    'position': 'absolute',
                    'left': `${slipSkidLeft}px`,
                    'top': `${slipSkidTop}px`,
                    'width': `${slipSkidWidth}px`,
                    'height': `${slipSkidHeight}px`,
                    'transform': this.slipSkidTransform,
                    'overflow': 'visible'
                } },
                FSComponent.buildComponent("path", { d: slipSkidPath, "stroke-linejoin": 'round' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.pointerHidden.destroy();
        (_a = this.turnCoordinatorBallSub) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD flight director.
 */
class PfdFlightDirector extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.rootStyle = ObjectSubject.create({
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'display': '',
        });
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.pitchTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.bankTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.pitchErrorFactor = SubscribableUtils.toSubscribable(this.props.pitchErrorFactor, true);
        this.bankErrorFactor = SubscribableUtils.toSubscribable(this.props.bankErrorFactor, true);
        this.takeoffDeviationFactor = SubscribableUtils.toSubscribable(this.props.takeoffDeviationFactor, true);
        this.isTakeoffDeviationNull = this.props.fdTakeoffDeviation.map(deviation => deviation === null);
        this.pitchBarHidden = MappedSubject.create(([show, fmaData, isFdActive]) => {
            if (!show || (fmaData && (fmaData.verticalDegraded || fmaData.verticalActive === APVerticalModes.NONE))) {
                return true;
            }
            return !isFdActive;
        }, this.props.showCommandBars, this.props.fmaData, this.props.isFdActive);
        this.bankBarHidden = MappedSubject.create(([show, fmaData, isFdActive, isTakeoffDeviationNull]) => {
            if (!show
                || (fmaData && (fmaData.lateralDegraded
                    || fmaData.lateralActive === APLateralModes.NONE
                    || (fmaData.lateralActive === APLateralModes.TO_LOC && isTakeoffDeviationNull)))) {
                return true;
            }
            return !isFdActive;
        }, this.props.showCommandBars, this.props.fmaData, this.props.isFdActive, this.isTakeoffDeviationNull);
        this.pitchErrorSmoother = new ExpSmoother(500 / Math.LN2);
        this.bankErrorSmoother = new ExpSmoother(500 / Math.LN2);
        this.takeoffDeviationSmoother = new ExpSmoother(500 / Math.LN2);
        this.isTakeoffLocModeActive = this.props.fmaData.map(fmaData => fmaData !== null && fmaData.lateralActive === APLateralModes.TO_LOC);
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.rootStyle.set('display', isVisible ? '' : 'none');
        if (!isVisible) {
            this.pitchErrorSmoother.reset();
            this.bankErrorSmoother.reset();
            this.takeoffDeviationSmoother.reset();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.pitchTransform.transform.getChild(0).set(-50, -50);
        this.bankTransform.transform.getChild(0).set(-50, -50);
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.updatePosition();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updatePosition();
        }
    }
    /**
     * Updates this symbol's position.
     */
    updatePosition() {
        const offsetCenter = this.props.projection.getOffsetCenterProjected();
        this.rootStyle.set('left', `${offsetCenter[0]}px`);
        this.rootStyle.set('top', `${offsetCenter[1]}px`);
    }
    /** @inheritdoc */
    onSleep() {
        this.pitchErrorSmoother.reset();
        this.bankErrorSmoother.reset();
        this.takeoffDeviationSmoother.reset();
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        var _a;
        if (!this.isVisible()) {
            return;
        }
        const center = this.props.projection.getOffsetCenterProjected();
        const bounds = this.conformalBounds.get();
        if (this.bankBarHidden.get()) {
            this.bankErrorSmoother.reset();
            this.takeoffDeviationSmoother.reset();
        }
        else {
            let offset;
            if (this.isTakeoffLocModeActive.get()) {
                this.bankErrorSmoother.reset();
                const deviation = this.takeoffDeviationSmoother.next(((_a = this.props.fdTakeoffDeviation.get()) !== null && _a !== void 0 ? _a : 0), elapsed);
                offset = -deviation * this.takeoffDeviationFactor.get();
            }
            else {
                this.takeoffDeviationSmoother.reset();
                const bankError = this.bankErrorSmoother.next(this.props.fdBank.get() - this.props.projection.getRoll(), elapsed);
                offset = bankError * this.bankErrorFactor.get();
            }
            const x = MathUtils.clamp(offset, bounds[0] - center[0], bounds[2] - center[0]);
            this.bankTransform.transform.getChild(1).set(x, 0, 0, 0.1, 0.1);
            this.bankTransform.resolve();
        }
        if (this.pitchBarHidden.get()) {
            this.pitchErrorSmoother.reset();
        }
        else {
            const pitchError = this.pitchErrorSmoother.next(this.props.fdPitch.get() - this.props.projection.getPitch(), elapsed);
            const y = MathUtils.clamp(-pitchError * this.pitchErrorFactor.get(), bounds[1] - center[1], bounds[3] - center[1]);
            this.pitchTransform.transform.getChild(1).set(0, y, 0, 0.1, 0.1);
            this.pitchTransform.resolve();
        }
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'pfd-fd-container', style: this.rootStyle },
            FSComponent.buildComponent("div", { class: { 'pfd-fd-command-bar': true, 'pfd-fd-command-bar-pitch': true, 'hidden': this.pitchBarHidden }, style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'transform': this.pitchTransform
                } }),
            FSComponent.buildComponent("div", { class: { 'pfd-fd-command-bar': true, 'pfd-fd-command-bar-bank': true, 'hidden': this.bankBarHidden }, style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'transform': this.bankTransform
                } }),
            FSComponent.buildComponent("svg", { viewBox: '-7 -7 14 14', class: 'pfd-fd-reference', style: 'position: absolute; left: 0px; top: 0px; transform: translate(-50%, -50%); overflow: visible;' },
                FSComponent.buildComponent("path", { d: 'M -7 -7 l 14 0 l 0 14 l -14 0 z', fill: 'none', "stroke-linejoin": 'round', class: 'pfd-fd-reference-stroke shadow' }),
                FSComponent.buildComponent("path", { d: 'M -7 -7 l 14 0 l 0 14 l -14 0 z', fill: 'none', "stroke-linejoin": 'round', class: 'pfd-fd-reference-stroke' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        this.isTakeoffDeviationNull.destroy();
        this.bankBarHidden.destroy();
        this.pitchBarHidden.destroy();
        this.isTakeoffLocModeActive.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.isFdActiveSub) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD flight path vector symbol.
 */
class PfdFlightPathVector extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.cssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.transform = new Transform2D();
        this.projectedPosition = Vec2Math.create();
        this.hidden = Subject.create(false);
        this.isNonConformal = Subject.create(false);
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        if (isVisible) {
            this.needUpdate = true;
        }
        else {
            this.hidden.set(true);
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.cssTransform.transform.getChild(0).set(-50, -50);
        const scheduleUpdatePosition = () => { this.needUpdate = true; };
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.trackSub = this.props.track.sub(scheduleUpdatePosition);
        this.pitchSub = this.props.pitch.sub(scheduleUpdatePosition);
        this.boundsSub = this.conformalBounds.sub(scheduleUpdatePosition);
    }
    /** @inheritdoc */
    onProjectionChanged() {
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const fpvPitch = this.props.pitch.get();
        const fpvTrack = this.props.track.get();
        if (!isFinite(fpvPitch) || !isFinite(fpvTrack)) {
            this.hidden.set(true);
            this.needUpdate = false;
            return;
        }
        const projection = this.props.projection;
        const center = projection.getOffsetCenterProjected();
        const pitchResolution = projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor();
        const headingResolution = projection.getScaleFactor() / projection.getFov() * projection.getHeadingScaleFactor();
        const pitchError = fpvPitch - projection.getPitch();
        const headingError = (MathUtils.diffAngleDeg(projection.getHeading(), fpvTrack) + 180) % 360 - 180;
        Vec2Math.set(0, 0, this.projectedPosition);
        this.transform
            .toTranslation(headingError * headingResolution, -pitchError * pitchResolution)
            .addRotation(-projection.getRoll() * Avionics.Utils.DEG2RAD)
            .addTranslation(center[0], center[1])
            .apply(this.projectedPosition, this.projectedPosition);
        const conformalBounds = this.conformalBounds.get();
        const conformalX = this.projectedPosition[0];
        const conformalY = this.projectedPosition[1];
        const x = MathUtils.clamp(conformalX, conformalBounds[0], conformalBounds[2]);
        const y = MathUtils.clamp(conformalY, conformalBounds[1], conformalBounds[3]);
        this.isNonConformal.set(x !== conformalX || y !== conformalY);
        this.cssTransform.transform.getChild(1).set(x, y, 0, 0.1, 0.1);
        this.cssTransform.resolve();
        this.hidden.set(false);
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { viewBox: '-50 -26 100 52', preserveAspectRatio: 'none', class: {
                'pfd-fpv': true,
                'hidden': this.hidden,
                'pfd-fpv-nonconformal': this.isNonConformal
            }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px',
                'display': '',
                'transform': this.cssTransform,
                'overflow': 'visible'
            } },
            FSComponent.buildComponent("path", { d: 'M -14 0 a 14 14 0 1 0 28 0 a 14 14 0 1 0 -28 0 ', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-circle shadow' }),
            FSComponent.buildComponent("path", { d: 'M 0 -14 l 0 -12', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-top shadow' }),
            FSComponent.buildComponent("path", { d: 'M 14 0 l 36 0 M -14 0 l -36 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-side shadow' }),
            FSComponent.buildComponent("path", { d: 'M -14 0 a 14 14 0 1 0 28 0 a 14 14 0 1 0 -28 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-circle' }),
            FSComponent.buildComponent("path", { d: 'M 0 -14 l 0 -12', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-top' }),
            FSComponent.buildComponent("path", { d: 'M 14 0 l 36 0 M -14 0 l -36 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-fpv-stroke pfd-fpv-stroke-line-side' })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.trackSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.pitchSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.boundsSub) === null || _d === void 0 ? void 0 : _d.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD horizon line.
 */
class PfdHorizonLine extends HorizonLayer {
    constructor() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super(...arguments);
        this.rebuildTapeFlags = this.props.showHeadingLabels !== false && this.props.options.clipYBounds
            ? 0
            : HorizonProjectionChangeType.ProjectedOffset | HorizonProjectionChangeType.ProjectedSize;
        this.majorTickLength = (_a = this.props.options.headingMajorTickLength) !== null && _a !== void 0 ? _a : 0;
        this.minorTickLength = (_b = this.props.options.headingMinorTickLength) !== null && _b !== void 0 ? _b : 0;
        this.tickStrokeWidth = (_c = this.props.options.headingTickWidth) !== null && _c !== void 0 ? _c : PfdHorizonLine.DEFAULT_TICK_STROKE_WIDTH;
        this.tickStrokeColor = (_d = this.props.options.headingTickColor) !== null && _d !== void 0 ? _d : PfdHorizonLine.DEFAULT_TICK_STROKE_COLOR;
        this.font = `${(_e = this.props.options.headingLabelFontSize) !== null && _e !== void 0 ? _e : PfdHorizonLine.DEFAULT_FONT_SIZE}px ${(_f = this.props.options.headingLabelFont) !== null && _f !== void 0 ? _f : PfdHorizonLine.DEFAULT_FONT}`;
        this.fontColor = (_g = this.props.options.headingLabelFontColor) !== null && _g !== void 0 ? _g : PfdHorizonLine.DEFAULT_FONT_COLOR;
        this.fontOutlineWidth = (_h = this.props.options.headingLabelFontOutlineWidth) !== null && _h !== void 0 ? _h : PfdHorizonLine.DEFAULT_FONT_OUTLINE_WIDTH;
        this.fontOutlineColor = (_j = this.props.options.headingLabelFontOutlineColor) !== null && _j !== void 0 ? _j : PfdHorizonLine.DEFAULT_FONT_OUTLINE_COLOR;
        this.labelOffset = (_k = this.props.options.headingLabelOffset) !== null && _k !== void 0 ? _k : 0;
        this.length = SubscribableUtils.toSubscribable(this.props.options.length, true);
        this.showHeadingLabels = this.props.showHeadingLabels === false ? false : SubscribableUtils.toSubscribable(this.props.showHeadingLabels, true);
        this.useMagneticHeading = SubscribableUtils.toSubscribable((_l = this.props.useMagneticHeading) !== null && _l !== void 0 ? _l : true, true);
        this.magVar = SubscribableUtils.toSubscribable((_m = this.props.magVar) !== null && _m !== void 0 ? _m : 0, true);
        this.headingTapeRef = FSComponent.createRef();
        this.hidden = Subject.create(false);
        this.rootCssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('deg')));
        this.lineWidth = this.length.map(length => `${length}px`);
        this.pitchResolution = 0; // pixels per degree
        this.transform = new Transform2D();
        this.projected = Vec2Math.create();
        this.tapeYOffset = 0;
        this.needUpdatePosition = true;
        this.needRebuildHeadingTape = false;
        this.needUpdateHeadingTape = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.hidden.set(!isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        if (this.showHeadingLabels !== false) {
            this.headingTapeRef.instance.onAttached();
            this.showHeadingLabelsSub = this.showHeadingLabels.sub(this.headingTapeRef.instance.setVisible.bind(this.headingTapeRef.instance), true);
            this.useMagneticHeadingSub = this.useMagneticHeading.sub(() => { this.needUpdateHeadingTape = true; });
            this.magVarSub = this.magVar.sub(() => { this.needUpdateHeadingTape || (this.needUpdateHeadingTape = this.useMagneticHeading.get()); });
            this.lengthSub = this.length.sub(() => { this.needRebuildHeadingTape = true; });
            this.needRebuildHeadingTape = true;
        }
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.updatePitchResolution();
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, PfdHorizonLine.UPDATE_PITCH_RESOLUTION_FLAGS)) {
            this.updatePitchResolution();
        }
        if (this.showHeadingLabels !== false) {
            if (BitFlags.isAny(changeFlags, this.rebuildTapeFlags)) {
                this.needRebuildHeadingTape = true;
            }
            if (BitFlags.isAny(changeFlags, PfdHorizonLine.UPDATE_HEADING_FLAGS)) {
                this.needUpdateHeadingTape = true;
            }
        }
        this.needUpdatePosition = true;
    }
    /**
     * Updates the pitch resolution used by this horizon line to position itself.
     */
    updatePitchResolution() {
        this.pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov() * this.props.projection.getPitchScaleFactor();
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (this.needUpdatePosition) {
            this.updatePosition();
            this.needUpdatePosition = false;
        }
        if (this.showHeadingLabels !== false && this.showHeadingLabels.get()) {
            if (this.needRebuildHeadingTape) {
                this.buildHeadingTape();
                this.needRebuildHeadingTape = false;
            }
            if (this.needUpdateHeadingTape) {
                this.updateHeadingTape();
                this.needUpdateHeadingTape = false;
            }
        }
    }
    /**
     * Updates the position and rotation of this horizon line.
     */
    updatePosition() {
        // Approximate translation due to pitch using a constant pitch resolution (pixels per degree of pitch) derived
        // from the projection's current field of view. The error of this approximation increases with the absolute
        // deviation of the pitch angle from 0 degrees. We do this instead of simply projecting the true horizon line
        // because we need to keep the line in sync with the pitch ladder, which uses the same approximation.
        const roll = this.props.projection.getRoll();
        Vec2Math.set(0, 0, this.projected);
        this.transform
            .toTranslation(0, this.pitchResolution * this.props.projection.getPitch())
            .addRotation(-roll * Avionics.Utils.DEG2RAD)
            .apply(this.projected, this.projected);
        Vec2Math.add(this.projected, this.props.projection.getOffsetCenterProjected(), this.projected);
        this.rootCssTransform.transform.getChild(0).set(this.projected[0], this.projected[1], 0, 0.1, 0.1);
        this.rootCssTransform.transform.getChild(1).set(-roll);
        this.rootCssTransform.resolve();
    }
    /**
     * Updates this horizon line's heading tape.
     */
    updateHeadingTape() {
        const projection = this.props.projection;
        const trueHeading = projection.getHeading();
        const heading = this.useMagneticHeading.get() ? MagVar.trueToMagnetic(trueHeading, this.magVar.get()) : trueHeading;
        const headingResolution = projection.getScaleFactor() / projection.getFov() * projection.getHeadingScaleFactor();
        const display = this.headingTapeRef.instance.display;
        const context = display.context;
        display.clear();
        const tapeLength = this.length.get();
        const tapeXCenter = tapeLength * 0.5;
        const tapeXMin = tapeLength * -0.5;
        const tapeXMax = tapeLength * 1.5;
        const labelCount = PfdHorizonLine.TAPE_LABELS.length;
        const tickCount = labelCount * PfdHorizonLine.TAPE_TICK_FACTOR;
        const tickInterval = PfdHorizonLine.TAPE_LABEL_INTERVAL / PfdHorizonLine.TAPE_TICK_FACTOR;
        context.beginPath();
        // Ticks
        for (let i = 0; i < tickCount; i++) {
            const tickHeading = i * tickInterval;
            const tickHeadingDiff = (NavMath.diffAngle(heading, tickHeading) + 180) % 360 - 180; // -180 to 180
            const tickX = tickHeadingDiff * headingResolution + tapeXCenter;
            if (tickX >= tapeXMin && tickX <= tapeXMax) {
                const tickLength = i % PfdHorizonLine.TAPE_TICK_FACTOR === 0 ? this.majorTickLength : this.minorTickLength;
                context.moveTo(tickX, this.tapeYOffset);
                context.lineTo(tickX, this.tapeYOffset - tickLength);
            }
        }
        this.strokePath(context, this.tickStrokeWidth, this.tickStrokeColor);
        // Labels
        for (let i = 0; i < labelCount; i++) {
            const labelHeading = i * PfdHorizonLine.TAPE_LABEL_INTERVAL;
            const labelHeadingDiff = (NavMath.diffAngle(heading, labelHeading) + 180) % 360 - 180; // -180 to 180
            const headingX = labelHeadingDiff * headingResolution + tapeXCenter;
            if (headingX >= tapeXMin && headingX <= tapeXMax) {
                context.rotate(0.001); // Need to apply some rotation to activate sub-pixel text rendering.
                context.translate(headingX, this.tapeYOffset + this.labelOffset);
                if (this.fontOutlineWidth > 0) {
                    context.lineWidth = this.fontOutlineWidth * 2;
                    context.strokeStyle = this.fontOutlineColor;
                    context.strokeText(PfdHorizonLine.TAPE_LABELS[i], 0, 0);
                }
                context.fillText(PfdHorizonLine.TAPE_LABELS[i], 0, 0);
                context.resetTransform();
            }
        }
    }
    /**
     * Strokes a path on a canvas.
     * @param context The canvas rendering context with which to stroke the path.
     * @param strokeWidth The width of the stroke.
     * @param strokeStyle The style of the stroke.
     * @param outlineWidth The outline width of the stroke. Defaults to `0`.
     * @param outlineStyle The outline style of the stroke. Required to draw an outline.
     */
    strokePath(context, strokeWidth, strokeStyle, outlineWidth = 0, outlineStyle) {
        if (outlineWidth > 0 && outlineStyle !== undefined) {
            context.lineWidth = strokeWidth + 2 * outlineWidth;
            context.strokeStyle = outlineStyle;
            context.stroke();
        }
        context.lineWidth = strokeWidth;
        context.strokeStyle = strokeStyle;
        context.stroke();
    }
    /**
     * Builds the ticks and labels for this horizon line's heading tape.
     */
    buildHeadingTape() {
        const length = this.length.get();
        let height;
        let top;
        if (this.props.options.clipYBounds) {
            height = this.props.options.clipYBounds[1] - this.props.options.clipYBounds[0];
            top = this.props.options.clipYBounds[0];
        }
        else {
            const projection = this.props.projection;
            height = projection.getProjectedSize()[1];
            top = -projection.getOffsetCenterProjected()[1];
        }
        this.headingTapeRef.instance.setWidth(length);
        this.headingTapeRef.instance.setHeight(height);
        this.headingTapeRef.instance.display.canvas.style.left = `${-length / 2}px`;
        this.headingTapeRef.instance.display.canvas.style.top = `${top}px`;
        this.headingTapeRef.instance.display.context.font = this.font;
        this.headingTapeRef.instance.display.context.textAlign = 'center';
        this.headingTapeRef.instance.display.context.textBaseline = 'top';
        this.headingTapeRef.instance.display.context.fillStyle = this.fontColor;
        this.headingTapeRef.instance.display.context.lineCap = 'round';
        this.tapeYOffset = -top;
        this.needUpdateHeadingTape = true;
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'pfd-horizon-line-container': true, 'hidden': this.hidden }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px;',
                'transform': this.rootCssTransform
            } },
            FSComponent.buildComponent("div", { class: 'pfd-horizon-line', style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px;',
                    'width': this.lineWidth,
                    'transform': 'translate(-50%, -50%)'
                } }),
            this.showHeadingLabels !== false && (FSComponent.buildComponent(HorizonCanvasLayer, { ref: this.headingTapeRef, projection: this.props.projection, class: 'pfd-horizon-line-hdg-tape' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f;
        this.lineWidth.destroy();
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.showHeadingLabelsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.useMagneticHeadingSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.magVarSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.lengthSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.headingTapeRef.getOrDefault()) === null || _f === void 0 ? void 0 : _f.destroy();
        super.destroy();
    }
}
PfdHorizonLine.TAPE_LABEL_INTERVAL = 10; // degrees per label
PfdHorizonLine.TAPE_TICK_FACTOR = 2; // number of ticks per label
PfdHorizonLine.TAPE_LABELS = ArrayUtils.create(Math.floor(360 / PfdHorizonLine.TAPE_LABEL_INTERVAL), index => {
    const rounded = Math.round(index * PfdHorizonLine.TAPE_LABEL_INTERVAL / 10);
    return rounded === 0 ? '36' : rounded.toString().padStart(2, '0');
});
PfdHorizonLine.UPDATE_PITCH_RESOLUTION_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.PitchScaleFactor;
PfdHorizonLine.UPDATE_HEADING_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.HeadingScaleFactor
    | HorizonProjectionChangeType.Heading;
PfdHorizonLine.DEFAULT_TICK_STROKE_WIDTH = 1; // pixels
PfdHorizonLine.DEFAULT_TICK_STROKE_COLOR = 'white';
PfdHorizonLine.DEFAULT_FONT = 'sans-serif';
PfdHorizonLine.DEFAULT_FONT_SIZE = 10;
PfdHorizonLine.DEFAULT_FONT_COLOR = 'white';
PfdHorizonLine.DEFAULT_FONT_OUTLINE_WIDTH = 1;
PfdHorizonLine.DEFAULT_FONT_OUTLINE_COLOR = 'black';

/**
 * A Boeing PFD pitch ladder.
 */
class PfdPitchLadder extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.svgRef = FSComponent.createRef();
        this.rootStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'overflow': 'hidden'
        });
        this.transform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate3d('px'), CssTransformBuilder.rotate('deg'), CssTransformBuilder.translateY('px')));
        this.clipBounds = SubscribableUtils.toSubscribable(this.props.clipBounds, true);
        this.pitchResolution = 0; // pixels per degree
        this.needUpdateClip = true;
        this.needRebuildLadder = true;
        this.needReposition = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.rootStyle.set('display', isVisible ? '' : 'none');
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.clipBoundsSub = this.clipBounds.sub(() => {
            this.needUpdateClip = true;
        });
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.PitchScaleFactor)) {
            this.needRebuildLadder = true;
        }
        this.needReposition = true;
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (this.needUpdateClip) {
            this.updateClip();
            this.needUpdateClip = false;
        }
        if (this.needRebuildLadder) {
            this.rebuildLadder();
            this.needRebuildLadder = false;
        }
        if (this.needReposition) {
            this.repositionLadder();
            this.needReposition = false;
        }
    }
    /**
     * Updates this ladder's clipping boundaries.
     */
    updateClip() {
        const bounds = this.clipBounds.get();
        this.rootStyle.set('left', `${bounds[0]}px`);
        this.rootStyle.set('top', `${bounds[1]}px`);
        this.rootStyle.set('width', `${bounds[2] - bounds[0]}px`);
        this.rootStyle.set('height', `${bounds[3] - bounds[1]}px`);
        // After we update the clip bounds we need to update the positioning of the ladder, because the ladder is
        // positioned relative to the clip bounds.
        this.needReposition = true;
    }
    /**
     * Repositions this ladder based on the current pitch and bank.
     */
    repositionLadder() {
        const center = this.props.projection.getOffsetCenterProjected();
        const bounds = this.clipBounds.get();
        const pitchOffset = this.props.projection.getPitch() * this.pitchResolution;
        const x = center[0] - bounds[0];
        const y = center[1] - bounds[1];
        this.transform.transform.getChild(0).set(x, y, 0, 0.1, 0.1);
        this.transform.transform.getChild(1).set(-this.props.projection.getRoll());
        this.transform.transform.getChild(2).set(pitchOffset, 0.1);
        this.transform.resolve();
    }
    /**
     * Rebuilds this ladder.
     */
    rebuildLadder() {
        var _a, _b;
        this.pitchResolution = this.props.projection.getScaleFactor() / this.props.projection.getFov() * this.props.projection.getPitchScaleFactor();
        const options = this.props.options;
        this.svgRef.instance.innerHTML = '';
        const minorFactor = options.minorLineFactor * options.mediumLineFactor;
        const minorIncrement = options.majorLineIncrement / minorFactor;
        const len = Math.floor(90 / minorIncrement);
        for (let i = 1; i <= len; i++) {
            const pitch = i * minorIncrement;
            const y = pitch * this.pitchResolution;
            let lineLength;
            let showNumber = false;
            if (i % minorFactor === 0) {
                // major line
                lineLength = options.majorLineLength;
                showNumber = options.majorLineShowLabel;
            }
            else if (i % options.minorLineFactor === 0 && (options.mediumLineMaxPitch === undefined || pitch <= options.mediumLineMaxPitch)) {
                // medium line
                lineLength = options.mediumLineLength;
                showNumber = (_a = options.mediumLineShowLabel) !== null && _a !== void 0 ? _a : false;
            }
            else if (options.minorLineMaxPitch === undefined || pitch <= options.minorLineMaxPitch) {
                // minor line
                lineLength = options.minorLineLength;
                showNumber = (_b = options.minorLineShowLabel) !== null && _b !== void 0 ? _b : false;
            }
            if (lineLength !== undefined) {
                if (lineLength > 0) {
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: -y, x2: lineLength / 2, y2: -y, class: "pfd-pitch-ladder-line shadow" }, "."), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: -y, x2: lineLength / 2, y2: -y, class: "pfd-pitch-ladder-line" }, "."), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: y, x2: lineLength / 2, y2: y, class: "pfd-pitch-ladder-line shadow" }, "."), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("line", { x1: -lineLength / 2, y1: y, x2: lineLength / 2, y2: y, class: "pfd-pitch-ladder-line" }, "."), this.svgRef.instance);
                }
                if (showNumber) {
                    const pitchText = pitch.toString();
                    const leftAnchorX = -lineLength / 2 - options.labelMargin;
                    const rightAnchorX = lineLength / 2 + options.labelMargin;
                    FSComponent.render(FSComponent.buildComponent("text", { x: leftAnchorX, y: -y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("text", { x: rightAnchorX, y: -y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("text", { x: leftAnchorX, y: y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                    FSComponent.render(FSComponent.buildComponent("text", { x: rightAnchorX, y: y + options.labelOffsetY, "text-anchor": 'middle', "dominant-baseline": 'central', class: "pfd-pitch-ladder-label" }, pitchText), this.svgRef.instance);
                }
            }
        }
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'pfd-pitch-ladder-container', style: this.rootStyle },
            FSComponent.buildComponent("svg", { ref: this.svgRef, class: 'pfd-pitch-ladder', style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'transform': this.transform,
                    'transform-origin': '0px 0px',
                    'stroke-linecap': 'round',
                    'overflow': 'visible'
                } })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.clipBoundsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD pitch limit indicator.
 */
class PfdPitchLimitIndicator extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.cssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.hidden = Subject.create(false);
        this.isNonConformal = Subject.create(false);
        this.needUpdate = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.hidden.set(!isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.cssTransform.transform.getChild(0).set(-50, -50);
        const scheduleUpdatePosition = () => { this.needUpdate = true; };
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.aoaSub = this.props.aoa.sub(scheduleUpdatePosition);
        this.aoaLimitSub = this.props.aoaLimit.sub(scheduleUpdatePosition);
        this.boundsSub = this.conformalBounds.sub(scheduleUpdatePosition);
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, PfdPitchLimitIndicator.UPDATE_FLAGS)) {
            this.needUpdate = true;
        }
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.needUpdate || !this.isVisible()) {
            return;
        }
        const projection = this.props.projection;
        const center = projection.getOffsetCenterProjected();
        const pitchResolution = projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor();
        const conformalBounds = this.conformalBounds.get();
        const aoaMargin = Math.min(this.props.aoaLimit.get() - this.props.aoa.get(), this.props.options.maxPitch - projection.getPitch());
        const conformalY = center[1] - aoaMargin * pitchResolution;
        const x = center[0];
        const y = MathUtils.clamp(conformalY, conformalBounds[0], conformalBounds[1]);
        this.isNonConformal.set(y !== conformalY);
        this.cssTransform.transform.getChild(1).set(x, y, 0, 0.1, 0.1);
        this.cssTransform.resolve();
        this.needUpdate = false;
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("svg", { viewBox: '-120 -19 240 38', preserveAspectRatio: 'none', class: {
                'pfd-pitch-limit': true,
                'hidden': this.hidden,
                'pfd-pitch-limit-nonconformal': this.isNonConformal
            }, style: {
                'position': 'absolute',
                'left': '0px',
                'top': '0px',
                'display': '',
                'transform': this.cssTransform,
                'overflow': 'visible'
            } },
            FSComponent.buildComponent("path", { d: 'M -120 0 h 40 v 12.6 M 120 0 h -40 v 12.6', "stroke-linecap": "round", "stroke-linejoin": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thick shadow' }),
            FSComponent.buildComponent("path", { d: 'M -120 -18.9 l 9.7196 18.9 m 10.4139 0 l -10.4139 -18.9 m 20.8278 18.9 l -10.4139 -18.9 M 120 -18.9 l -9.7196 18.9 m -9.7197 0 l 9.7197 -18.9 m -19.4393 18.9 l 9.7196 -18.9', "stroke-linecap": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thin shadow' }),
            FSComponent.buildComponent("path", { d: 'M -120 0 h 40 v 12.6 M 120 0 h -40 v 12.6', "stroke-linecap": "round", "stroke-linejoin": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thick' }),
            FSComponent.buildComponent("path", { d: 'M -120 -18.9 l 9.7196 18.9 m 10.4139 0 l -10.4139 -18.9 m 20.8278 18.9 l -10.4139 -18.9 M 120 -18.9 l -9.7196 18.9 m -9.7197 0 l 9.7197 -18.9 m -19.4393 18.9 l 9.7196 -18.9', "stroke-linecap": "round", fill: 'none', class: 'pfd-pitch-limit-stroke pfd-pitch-limit-stroke-thin' })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.aoaSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.aoaLimitSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.boundsSub) === null || _d === void 0 ? void 0 : _d.destroy();
        super.destroy();
    }
}
PfdPitchLimitIndicator.UPDATE_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.PitchScaleFactor
    | HorizonProjectionChangeType.OffsetCenterProjected
    | HorizonProjectionChangeType.Pitch;

/**
 * A Boeing PFD selected flight path angle symbol.
 */
class PfdSelectedFlightPathAngle extends HorizonLayer {
    constructor() {
        super(...arguments);
        this.clipBounds = SubscribableUtils.toSubscribable(this.props.clipBounds, true);
        this.rootStyle = ObjectSubject.create({
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'overflow': 'hidden'
        });
        this.cssTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.translate('%'), CssTransformBuilder.translate3d('px')));
        this.hidden = Subject.create(false);
        this.needUpdateClipBounds = true;
        this.needUpdatePosition = true;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.hidden.set(!isVisible);
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.cssTransform.transform.getChild(0).set(-50, -50);
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.angleSub = this.props.angle.sub(() => { this.needUpdatePosition = true; });
        this.clipBoundsSub = this.clipBounds.sub(() => { this.needUpdateClipBounds = true; });
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, PfdSelectedFlightPathAngle.UPDATE_FLAGS)) {
            this.needUpdatePosition = true;
        }
    }
    /** @inheritdoc */
    onUpdated() {
        if (!this.isVisible()) {
            return;
        }
        if (this.needUpdateClipBounds) {
            this.updateClipBounds();
            this.needUpdateClipBounds = false;
        }
        if (this.needUpdatePosition) {
            this.updatePosition();
            this.needUpdatePosition = false;
        }
    }
    /**
     * Updates this symbol's clipping boundaries.
     */
    updateClipBounds() {
        const bounds = this.clipBounds.get();
        this.rootStyle.set('left', `${bounds[0]}px`);
        this.rootStyle.set('top', `${bounds[1]}px`);
        this.rootStyle.set('width', `${bounds[2] - bounds[0]}px`);
        this.rootStyle.set('height', `${bounds[3] - bounds[1]}px`);
        // After we update the clipping boundaries, we need to also update the position of the symbol because it is
        // defined relative to the clipping boundaries.
        this.needUpdatePosition = true;
    }
    /**
     * Updates this symbol's position.
     */
    updatePosition() {
        const bounds = this.clipBounds.get();
        const projection = this.props.projection;
        const center = projection.getOffsetCenterProjected();
        const pitchResolution = projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor();
        const pitchError = this.props.angle.get() - projection.getPitch();
        const x = center[0] - bounds[0];
        const y = center[1] - bounds[1] - pitchError * pitchResolution;
        this.cssTransform.transform.getChild(1).set(x, y, 0, 0.1, 0.1);
        this.cssTransform.resolve();
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'hidden': this.hidden }, style: this.rootStyle },
            FSComponent.buildComponent("svg", { viewBox: '-64 -4 128 8', preserveAspectRatio: 'none', class: 'pfd-sel-fpa', style: {
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'display': '',
                    'transform': this.cssTransform,
                    'overflow': 'visible'
                } },
                FSComponent.buildComponent("path", { d: 'M -64 -4 l 28 0 m -28 8 l 28 0 m 72 0 l 28 0 m -28 -8 l 28 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-sel-fpa-stroke shadow' }),
                FSComponent.buildComponent("path", { d: 'M -64 -4 l 28 0 m -28 8 l 28 0 m 72 0 l 28 0 m -28 -8 l 28 0', "stroke-linecap": "round", fill: 'none', class: 'pfd-sel-fpa-stroke' }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.angleSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.clipBoundsSub) === null || _c === void 0 ? void 0 : _c.destroy();
        super.destroy();
    }
}
PfdSelectedFlightPathAngle.UPDATE_FLAGS = HorizonProjectionChangeType.Fov
    | HorizonProjectionChangeType.ScaleFactor
    | HorizonProjectionChangeType.PitchScaleFactor
    | HorizonProjectionChangeType.OffsetCenterProjected
    | HorizonProjectionChangeType.Pitch;

/**
 * A PFD TCAS-II resolution advisory pitch cue layer.
 */
class PfdTcasRaPitchCueLayer extends HorizonLayer {
    constructor() {
        var _a, _b;
        super(...arguments);
        this.clipBounds = SubscribableUtils.toSubscribable(this.props.clipBounds, true);
        this.conformalBounds = SubscribableUtils.toSubscribable(this.props.conformalBounds, true);
        this.rootStyle = ObjectSubject.create({
            'display': '',
            'position': 'absolute',
            'left': '0px',
            'top': '0px',
            'width': '0px',
            'height': '0px',
            'overflow': 'hidden'
        });
        this.clipCenterX = Subject.create('');
        this.clipCenterY = Subject.create('');
        this.noflyAboveHidden = Subject.create(false);
        this.noflyAboveTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.rotate('deg'), CssTransformBuilder.translate3d('px'), CssTransformBuilder.translate('%')));
        this.noflyBelowHidden = Subject.create(false);
        this.noflyBelowTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.rotate('deg'), CssTransformBuilder.translate3d('px'), CssTransformBuilder.translate('%')));
        this.tasSmoother = new ExpSmoother((_a = this.props.tasSmoothingTau) !== null && _a !== void 0 ? _a : 2000 / Math.LN2);
        this.pitchSmoother = new ExpSmoother((_b = this.props.pitchSmoothingTau) !== null && _b !== void 0 ? _b : 2000 / Math.LN2);
        this.smoothedTas = Subject.create(0);
        this.smoothedPitch = Subject.create(0);
        this.needUpdateClipBounds = false;
        this.needUpdateNoflyAbove = false;
        this.needUpdateNoflyBelow = false;
        this.pauseable = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        if (isVisible) {
            this.rootStyle.set('display', '');
            for (const pauseable of this.pauseable) {
                pauseable.resume();
            }
            this.checkNeedUpdateCues();
        }
        else {
            this.rootStyle.set('display', 'none');
            for (const pauseable of this.pauseable) {
                pauseable.pause();
            }
            this.tasSmoother.reset();
            this.pitchSmoother.reset();
        }
    }
    /** @inheritdoc */
    onAttached() {
        super.onAttached();
        this.noflyAboveTransform.transform.getChild(2).set(-50, -100);
        this.noflyBelowTransform.transform.getChild(2).set(-50, 0);
        this.clipBoundsSub = this.clipBounds.sub(() => { this.needUpdateClipBounds = true; });
        const checkNeedUpdateCues = this.checkNeedUpdateCues.bind(this);
        const paused = !this.isVisible();
        this.pauseable.push(this.props.dataProvider.raMaxVs.sub(() => { this.needUpdateNoflyAbove = true; }, false, paused), this.props.dataProvider.raMinVs.sub(() => { this.needUpdateNoflyBelow = true; }, false, paused), this.smoothedTas.sub(checkNeedUpdateCues, false, paused), this.smoothedPitch.sub(checkNeedUpdateCues, false, paused), this.conformalBounds.sub(() => {
            this.needUpdateNoflyAbove = true;
            this.needUpdateNoflyBelow = true;
        }, false, paused));
        this.showSub = this.props.show.sub(this.setVisible.bind(this), true);
        this.needUpdateClipBounds = true;
        this.needUpdateNoflyAbove = true;
        this.needUpdateNoflyBelow = true;
    }
    /**
     * Checks whether any of this layer's cues are visible, and if so, marks them to be updated.
     */
    checkNeedUpdateCues() {
        this.needUpdateNoflyAbove || (this.needUpdateNoflyAbove = this.props.dataProvider.raMaxVs.get() !== null);
        this.needUpdateNoflyBelow || (this.needUpdateNoflyBelow = this.props.dataProvider.raMinVs.get() !== null);
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
        this.needUpdateClipBounds || (this.needUpdateClipBounds = BitFlags.isAny(changeFlags, HorizonProjectionChangeType.OffsetCenterProjected));
        if (BitFlags.isAny(changeFlags, ~HorizonProjectionChangeType.Position)) {
            this.checkNeedUpdateCues();
        }
    }
    /** @inheritdoc */
    onSleep() {
        this.tasSmoother.reset();
        this.pitchSmoother.reset();
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
        if (!this.isVisible()) {
            return;
        }
        this.updateSmoothedValues(elapsed);
        if (this.needUpdateClipBounds) {
            this.updateClipBounds();
            this.needUpdateClipBounds = false;
        }
        if (this.needUpdateNoflyAbove) {
            this.updateNoflyCue(1, this.props.dataProvider.raMaxVs.get(), this.noflyAboveHidden, this.noflyAboveTransform);
            this.needUpdateNoflyAbove = false;
        }
        if (this.needUpdateNoflyBelow) {
            this.updateNoflyCue(-1, this.props.dataProvider.raMinVs.get(), this.noflyBelowHidden, this.noflyBelowTransform);
            this.needUpdateNoflyBelow = false;
        }
    }
    /**
     * Updates this layer's smoothed true airspeed and pitch values.
     * @param elapsed The elapsed time since the last update, in milliseconds.
     */
    updateSmoothedValues(elapsed) {
        const tas = this.props.tas.get();
        const dt = elapsed * this.props.simRate.get();
        if (dt > 0) {
            this.smoothedTas.set(this.tasSmoother.next(tas, dt));
            this.smoothedPitch.set(this.pitchSmoother.next(this.props.projection.getPitch(), dt));
        }
        else {
            this.smoothedTas.set(this.tasSmoother.reset(tas));
            this.smoothedPitch.set(this.pitchSmoother.reset(this.props.projection.getPitch()));
        }
    }
    /**
     * Updates this layer's clipping bounds.
     */
    updateClipBounds() {
        const center = this.props.projection.getOffsetCenterProjected();
        const bounds = this.clipBounds.get();
        const width = bounds[2] - bounds[0];
        const height = bounds[3] - bounds[1];
        this.rootStyle.set('left', `${center[0] + bounds[0]}px`);
        this.rootStyle.set('top', `${center[1] + bounds[1]}px`);
        this.rootStyle.set('width', `${width}px`);
        this.rootStyle.set('height', `${height}px`);
        this.clipCenterX.set(`${width / 2}px`);
        this.clipCenterY.set(`${height / 2}px`);
        this.checkNeedUpdateCues();
    }
    /**
     * Updates one of this layer's no-fly pitch cues.
     * @param direction The direction of the no-fly cue: +1 for above and -1 for below.
     * @param vsLimit The vertical speed limit, in feet per minute, commanded by the currently active resolution
     * advisory, or `null` if there is no such limit.
     * @param hidden The hidden state of the no-fly cue.
     * @param transform The CSS transform of the no-fly cue.
     */
    updateNoflyCue(direction, vsLimit, hidden, transform) {
        const currentTas = this.smoothedTas.get();
        if (currentTas < 1 || vsLimit === null) {
            hidden.set(true);
            return;
        }
        const currentVs = this.props.verticalSpeed.get();
        const projection = this.props.projection;
        const angularResolution = projection.getScaleFactor() / projection.getFov();
        const roll = projection.getRoll();
        const rotation = (-roll + 540) % 360 - 180; // -180 to 180
        const conformalBounds = this.conformalBounds.get();
        let minPitchOffsetPx;
        let maxPitchOffsetPx;
        if (direction === 1) {
            minPitchOffsetPx = -Infinity;
            if (rotation >= 90) {
                maxPitchOffsetPx = MathUtils.lerp(rotation, 90, 180, -conformalBounds[0], -conformalBounds[1]);
            }
            else if (rotation >= 0) {
                maxPitchOffsetPx = MathUtils.lerp(rotation, 0, 90, conformalBounds[3], -conformalBounds[0]);
            }
            else if (rotation >= -90) {
                maxPitchOffsetPx = MathUtils.lerp(rotation, -90, 0, conformalBounds[2], conformalBounds[3]);
            }
            else {
                maxPitchOffsetPx = MathUtils.lerp(rotation, -180, -90, -conformalBounds[1], conformalBounds[2]);
            }
        }
        else {
            maxPitchOffsetPx = Infinity;
            if (rotation >= 90) {
                minPitchOffsetPx = MathUtils.lerp(rotation, 90, 180, -conformalBounds[2], -conformalBounds[3]);
            }
            else if (rotation >= 0) {
                minPitchOffsetPx = MathUtils.lerp(rotation, 0, 90, conformalBounds[1], -conformalBounds[2]);
            }
            else if (rotation >= -90) {
                minPitchOffsetPx = MathUtils.lerp(rotation, -90, 0, conformalBounds[0], conformalBounds[1]);
            }
            else {
                minPitchOffsetPx = MathUtils.lerp(rotation, -180, -90, -conformalBounds[3], conformalBounds[0]);
            }
        }
        const deltaVs = vsLimit - currentVs;
        const deltaPitch = Math.asin(MathUtils.clamp(deltaVs / UnitType.KNOT.convertTo(currentTas, UnitType.FPM), -1, 1)) * Avionics.Utils.RAD2DEG;
        const pitchOffsetPx = MathUtils.clamp((this.smoothedPitch.get() - projection.getPitch() + deltaPitch) * -angularResolution, minPitchOffsetPx, maxPitchOffsetPx);
        transform.transform.getChild(0).set(rotation, 0.1);
        transform.transform.getChild(1).set(0, pitchOffsetPx, 0, 0.1, 0.1);
        transform.resolve();
        hidden.set(false);
    }
    /** @inheritdoc */
    onDetached() {
        super.onDetached();
        this.destroy();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: 'pfd-tcas-ra-pitch', style: this.rootStyle },
            this.renderNoflyPitchCue('above', this.noflyAboveHidden, this.noflyAboveTransform),
            this.renderNoflyPitchCue('below', this.noflyBelowHidden, this.noflyBelowTransform)));
    }
    /**
     * Renders a no-fly pitch cue.
     * @param direction The direction of the cue.
     * @param hidden The hidden state of the cue.
     * @param transform The CSS transform of the cue.
     * @returns A no-fly pitch cue, as a VNode.
     */
    renderNoflyPitchCue(direction, hidden, transform) {
        const { noflyCueHeight: height, noflyCueClosedWidth: closedWidth, noflyCueOpenWidth: openWidth, cueStrokeWidth: strokeWidth, cueOutlineWidth: outlineWidth } = this.props.options;
        const halfStrokeWidth = strokeWidth / 2;
        const sign = direction === 'above' ? 1 : -1;
        const path = `M ${-openWidth / 2} ${-height * sign} L ${-closedWidth / 2} ${-halfStrokeWidth * sign} L ${closedWidth / 2} ${-halfStrokeWidth * sign} L ${openWidth / 2} ${-height * sign}`;
        const svgWidth = Math.ceil(Math.max(closedWidth, openWidth));
        const svgHeight = Math.ceil(height);
        const viewBoxTop = direction === 'above' ? -svgHeight : 0;
        return (FSComponent.buildComponent("svg", { viewBox: `${-svgWidth / 2} ${viewBoxTop} ${svgWidth} ${svgHeight}`, class: {
                'pfd-tcas-ra-pitch-nofly': true,
                [`pfd-tcas-ra-pitch-nofly-${direction}`]: true,
                'hidden': hidden
            }, style: {
                'position': 'absolute',
                'left': this.clipCenterX,
                'top': this.clipCenterY,
                'width': `${svgWidth}px`,
                'height': `${svgHeight}px`,
                'transform': transform,
                'transform-origin': '0px 0px',
                'overflow': 'visible'
            } },
            FSComponent.buildComponent("path", { d: path, class: 'pfd-tcas-ra-pitch-nofly-stroke shadow', fill: 'none', "stroke-width": strokeWidth + outlineWidth / 2, "stroke-linecap": 'round' }),
            FSComponent.buildComponent("path", { d: path, class: 'pfd-tcas-ra-pitch-nofly-stroke', fill: 'none', "stroke-width": strokeWidth, "stroke-linecap": 'round' })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
        (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.clipBoundsSub) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}

/**
 * A Boeing PFD horizon display.
 */
class PfdHorizonDisplay extends DisplayComponent {
    constructor() {
        var _a;
        super(...arguments);
        this.horizonRef = FSComponent.createRef();
        this.projectionParams = {
            heading: 0,
            pitch: 0,
            roll: 0,
            pitchScaleFactor: 1
        };
        this.adcAirspeedSelectorIndex = SubscribableUtils.toSubscribable(this.props.adcAirspeedSelectorIndex, true);
        this.adcAirspeedIndex = ConsumerSubject.create(null, -1);
        this.adcAltitudeSelectorIndex = SubscribableUtils.toSubscribable(this.props.adcAirspeedSelectorIndex, true);
        this.adcAltitudeIndex = ConsumerSubject.create(null, -1);
        this.irsSelectorIndex = SubscribableUtils.toSubscribable(this.props.irsSelectorIndex, true);
        this.irsIndex = ConsumerSubject.create(null, -1);
        this.heading = ConsumerSubject.create(null, 0).pause();
        this.pitch = ConsumerSubject.create(null, 0).pause();
        this.roll = ConsumerSubject.create(null, 0).pause();
        this.paramSubjects = [
            this.heading,
            this.pitch,
            this.roll
        ];
        this.isAirspeedDataValid = ConsumerSubject.create(null, true).pause();
        this.isAltitudeDataValid = ConsumerSubject.create(null, true).pause();
        this.isHeadingDataValid = ConsumerSubject.create(null, true).pause();
        this.isAttitudeDataValid = ConsumerSubject.create(null, true).pause();
        this.isInertialDataValid = ConsumerSubject.create(null, true).pause();
        this.simTime = ConsumerValue.create(null, 0);
        this.simRate = ConsumerSubject.create(null, 1);
        this.isOnGround = ConsumerSubject.create(null, false);
        this.verticalSpeed = ConsumerSubject.create(null, 0).pause();
        this.tas = ConsumerSubject.create(null, 0).pause();
        this.turnCoordinatorBall = ConsumerSubject.create(null, 0);
        this.magVar = ConsumerSubject.create(null, 0).pause();
        this.track = ConsumerValue.create(null, 0);
        this.gs = ConsumerValue.create(null, 0);
        this.inertialVs = ConsumerValue.create(null, 0);
        this.accel = ConsumerValue.create(null, 0);
        this.flapsPosition = ConsumerSubject.create(null, 0);
        this.fmaData = ConsumerSubject.create(null, null);
        this.fmsOperatingPhase = ConsumerValue.create(null, FmsOperatingPhase.PREFLIGHT);
        this.isFdActive = ConsumerSubject.create(null, false);
        this.fdPitch = Subject.create(0);
        this.fdBank = Subject.create(0);
        this.fdTakeoffDeviation = ConsumerSubject.create(null, null);
        this.fdPitchErrorFactor = Subject.create(0);
        this.fdBankErrorFactor = Subject.create(0);
        this.fdTakeoffDeviationFactor = Subject.create(0);
        this.showTcasRaPitchCueLayer = MappedSubject.create(SubscribableMapFunctions.and(), this.isAttitudeDataValid, this.isAirspeedDataValid, this.isAltitudeDataValid).pause();
        this.tcasRaPitchCueDefaultBounds = this.props.tcasRaPitchCueClipBounds === undefined || this.props.tcasRaPitchCueConformalBounds === undefined
            ? VecNSubject.create(VecNMath.create(4))
            : undefined;
        this.fpvComputer = new FlightPathVectorComputer(500 / Math.LN2, 500 / Math.LN2, 500 / Math.LN2, 500 / Math.LN2);
        this.showFpv = MappedSubject.create(SubscribableMapFunctions.and(), this.props.showFpv, this.isInertialDataValid).pause();
        this.showSelectedFpa = this.props.showSelectedFpa === false
            ? undefined
            : MappedSubject.create(([show, fmaData, isAttitudeDataValid]) => {
                return show
                    && isAttitudeDataValid
                    && fmaData !== null
                    && (fmaData.verticalActive === APVerticalModes.FPA || fmaData.verticalArmed === APVerticalModes.FPA);
            }, SubscribableUtils.toSubscribable(this.props.showSelectedFpa, true), this.fmaData, this.isAttitudeDataValid).pause();
        this.selectedFpa = this.showSelectedFpa ? ConsumerSubject.create(null, 0).pause() : undefined;
        this.selectedFpaDefaultClipBounds = this.showSelectedFpa && this.props.selectedFpaClipBounds === undefined
            ? VecNSubject.create(VecNMath.create(4))
            : undefined;
        this.selectedFpaClipBounds = this.showSelectedFpa ? ((_a = this.props.selectedFpaClipBounds) !== null && _a !== void 0 ? _a : this.selectedFpaDefaultClipBounds) : undefined;
        this.aoa = Subject.create(0);
        this.aoaLimit = ConsumerSubject.create(null, 0).pause();
        this.showPitchLimit = Subject.create(false);
        this.aoaTransitionState = undefined;
        this.fdFlagHidden = this.props.showFdFailureFlagWhenAttFail ? this.isAttitudeDataValid : Subject.create(true);
        this.fpvFlagHidden = MappedSubject.create(([show, isDataValid]) => !show || isDataValid, this.props.showFpv, this.isInertialDataValid).pause();
        this.updateFreq = SubscribableUtils.toSubscribable(this.props.updateFreq, true);
        this.lastUpdateTime = undefined;
        this.lastUpdateSimTime = undefined;
        this.isAlive = true;
        this.isAwake = false;
        this.pauseable = [
            this.isAirspeedDataValid,
            this.isAltitudeDataValid,
            this.isAttitudeDataValid,
            this.isHeadingDataValid,
            this.isInertialDataValid,
            this.verticalSpeed,
            this.tas,
            this.magVar,
            this.showTcasRaPitchCueLayer,
            this.showFpv,
            this.showSelectedFpa,
            this.selectedFpa,
            this.aoaLimit,
            this.fpvFlagHidden
        ];
        this.updateCycleHandler = this.onUpdated.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        var _a, _b;
        if (!this.isAwake) {
            this.horizonRef.instance.sleep();
        }
        const sub = this.props.bus.getSubscriber();
        this.headingSub = this.heading.sub(heading => {
            this.projectionParams.heading = heading;
        }, true);
        this.pitchSub = this.pitch.sub(pitch => {
            this.projectionParams.pitch = -pitch;
        }, true);
        this.rollSub = this.roll.sub(roll => {
            this.projectionParams.roll = -roll;
        }, true);
        this.isAttitudeDataValid.sub(isValid => {
            var _a, _b, _c, _d, _e, _f;
            if (isValid) {
                (_a = this.headingSub) === null || _a === void 0 ? void 0 : _a.resume(true);
                (_b = this.pitchSub) === null || _b === void 0 ? void 0 : _b.resume(true);
                (_c = this.rollSub) === null || _c === void 0 ? void 0 : _c.resume(true);
            }
            else {
                (_d = this.headingSub) === null || _d === void 0 ? void 0 : _d.pause();
                (_e = this.pitchSub) === null || _e === void 0 ? void 0 : _e.pause();
                (_f = this.rollSub) === null || _f === void 0 ? void 0 : _f.pause();
                this.projectionParams.heading = 0;
                this.projectionParams.pitch = 0;
                this.projectionParams.roll = 0;
            }
        }, true);
        this.adcAirspeedSelectorIndexSub = this.adcAirspeedSelectorIndex.sub(index => {
            this.adcAirspeedIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
            this.isAirspeedDataValid.setConsumer(sub.on(`adc_selector_speed_data_valid_${index}`));
        }, true);
        this.adcAirspeedIndex.sub(index => {
            if (index < 0) {
                this.tas.setConsumer(null);
            }
            else {
                this.tas.setConsumer(sub.on(`adc_tas_${index}`));
            }
        }, true);
        this.adcAltitudeSelectorIndexSub = this.adcAltitudeSelectorIndex.sub(index => {
            this.adcAltitudeIndex.setConsumer(sub.on(`adc_selector_selected_index_${index}`));
            this.isAltitudeDataValid.setConsumer(sub.on(`adc_selector_altitude_data_valid_${index}`));
        }, true);
        this.adcAltitudeIndex.sub(index => {
            if (index < 0) {
                this.verticalSpeed.setConsumer(null);
            }
            else {
                this.verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
            }
        }, true);
        this.irsSelectorIndexSub = this.irsSelectorIndex.sub(index => {
            this.irsIndex.setConsumer(sub.on(`irs_selector_selected_index_${index}`));
            this.isHeadingDataValid.setConsumer(sub.on(`irs_selector_heading_data_valid_${index}`));
            this.isAttitudeDataValid.setConsumer(sub.on(`irs_selector_attitude_data_valid_${index}`));
            this.isInertialDataValid.setConsumer(sub.on(`irs_selector_inertial_data_valid_${index}`));
        }, true);
        this.irsIndex.sub(index => {
            if (index < 0) {
                this.heading.setConsumer(null);
                this.pitch.setConsumer(null);
                this.roll.setConsumer(null);
                this.turnCoordinatorBall.setConsumer(null);
                this.track.setConsumer(null);
                this.gs.setConsumer(null);
                this.inertialVs.setConsumer(null);
                this.accel.setConsumer(null);
            }
            else {
                this.heading.setConsumer(sub.on(`irs_hdg_deg_true_${index}`));
                this.pitch.setConsumer(sub.on(`irs_pitch_deg_${index}`));
                this.roll.setConsumer(sub.on(`irs_roll_deg_${index}`));
                this.turnCoordinatorBall.setConsumer(sub.on(`irs_turn_coordinator_ball_${index}`));
                this.track.setConsumer(sub.on(`irs_track_deg_true_${index}`));
                this.gs.setConsumer(sub.on(`irs_ground_speed_${index}`));
                this.inertialVs.setConsumer(sub.on(`irs_inertial_vertical_speed_${index}`));
                this.accel.setConsumer(sub.on(`irs_inertial_track_acceleration_${index}`));
            }
        }, true);
        this.simTime.setConsumer(sub.on('simTime'));
        this.simRate.setConsumer(sub.on('simRate'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.magVar.setConsumer(sub.on('magvar'));
        this.flapsPosition.setConsumer(sub.on('flap_computer_interpolated_position'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this.isFdActive.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.fdPitchSub = sub.on('fd_target_pitch').handle(pitch => { this.fdPitch.set(-pitch); });
        this.fdBankSub = sub.on('fd_target_bank').handle(bank => { this.fdBank.set(-bank); });
        this.fdTakeoffDeviation.setConsumer(sub.on('fd_takeoff_deviation'));
        (_a = this.selectedFpa) === null || _a === void 0 ? void 0 : _a.setConsumer(sub.on('ap_fpa_selected'));
        this.aoaLimit.setConsumer(sub.on('speedlimit_min_speed_aoa'));
        const projection = this.horizonRef.instance.projection;
        this.updateFdPitchErrorFactor(projection);
        this.updateFdBankErrorFactor(projection);
        this.selectedFpaDefaultClipBounds && this.updateSelectedFpaDefaultClipBounds(projection, this.selectedFpaDefaultClipBounds);
        this.tcasRaPitchCueDefaultBounds && this.updateTcasRaPitchCueDefaultBounds(projection, this.tcasRaPitchCueDefaultBounds);
        this.updateFreqSub = (_b = this.updateFreq) === null || _b === void 0 ? void 0 : _b.sub(freq => {
            var _a;
            (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.updateCycleSub = sub
                .on('realTime')
                .atFrequency(freq)
                .handle(this.updateCycleHandler);
        }, true);
    }
    /**
     * Wakes this horizon display. While awake, this display will be updated.
     * @throws Error if this horizon display has been destroyed.
     */
    wake() {
        var _a;
        if (!this.isAlive) {
            throw new Error('PfdHorizonDisplay: cannot wake a dead display');
        }
        if (this.isAwake) {
            return;
        }
        this.isAwake = true;
        for (const subject of this.paramSubjects) {
            subject.resume();
        }
        for (const pauseable of this.pauseable) {
            pauseable === null || pauseable === void 0 ? void 0 : pauseable.resume();
        }
        (_a = this.horizonRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.wake();
    }
    /**
     * Puts this horizon display to sleep. While asleep, this display will not be updated.
     * @throws Error if this horizon display has been destroyed.
     */
    sleep() {
        var _a;
        if (!this.isAlive) {
            throw new Error('PfdHorizonDisplay: cannot sleep a dead display');
        }
        if (!this.isAwake) {
            return;
        }
        this.isAwake = false;
        for (const subject of this.paramSubjects) {
            subject.pause();
        }
        for (const pauseable of this.pauseable) {
            pauseable === null || pauseable === void 0 ? void 0 : pauseable.pause();
        }
        (_a = this.horizonRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.sleep();
        this.fpvComputer.reset();
        this.aoaTransitionState = undefined;
    }
    /**
     * Responds to when this display's horizon projection changes.
     * @param projection This display's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection, changeFlags) {
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.PitchScaleFactor)) {
            this.updateFdPitchErrorFactor(projection);
        }
        if (BitFlags.isAny(changeFlags, HorizonProjectionChangeType.Fov | HorizonProjectionChangeType.ScaleFactor | HorizonProjectionChangeType.HeadingScaleFactor)) {
            this.updateFdBankErrorFactor(projection);
        }
        if (this.selectedFpaDefaultClipBounds && BitFlags.isAny(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
            this.updateSelectedFpaDefaultClipBounds(projection, this.selectedFpaDefaultClipBounds);
        }
        if (this.tcasRaPitchCueDefaultBounds && BitFlags.isAny(changeFlags, HorizonProjectionChangeType.ProjectedSize | HorizonProjectionChangeType.OffsetCenterProjected)) {
            this.updateTcasRaPitchCueDefaultBounds(projection, this.tcasRaPitchCueDefaultBounds);
        }
    }
    /**
     * Updates the pitch error factor of this display's flight director command bars.
     * @param projection This display's horizon projection.
     */
    updateFdPitchErrorFactor(projection) {
        this.fdPitchErrorFactor.set(projection.getScaleFactor() / projection.getFov() * projection.getPitchScaleFactor());
    }
    /**
     * Updates the bank error and takeoff deviation factors of this display's flight director command bars.
     * @param projection This display's horizon projection.
     */
    updateFdBankErrorFactor(projection) {
        const headingResolution = projection.getScaleFactor() / projection.getFov() * projection.getHeadingScaleFactor();
        this.fdBankErrorFactor.set(headingResolution * 0.5);
        this.fdTakeoffDeviationFactor.set(headingResolution * 0.5);
    }
    /**
     * Updates the default clipping boundaries for this display's selected flight path angle symbol.
     * @param projection This display's horizon projection.
     * @param bounds The default clipping boundaries for this display's selected flight path angle symbol.
     */
    updateSelectedFpaDefaultClipBounds(projection, bounds) {
        const size = projection.getProjectedSize();
        bounds.set(0, 0, size[0], size[1]);
    }
    /**
     * Updates the default boundaries for this display's TCAS resolution advisory pitch cue layer.
     * @param projection This display's horizon projection.
     * @param bounds The default boundaries for this display's TCAS resolution advisory pitch cue layer.
     */
    updateTcasRaPitchCueDefaultBounds(projection, bounds) {
        const size = projection.getProjectedSize();
        const center = projection.getOffsetCenterProjected();
        bounds.set(-center[0], -center[1], size[0] - center[0], size[1] - center[1]);
    }
    /**
     * This method is called every update cycle.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    onUpdated(time) {
        var _a, _b;
        const dt = time - ((_a = this.lastUpdateTime) !== null && _a !== void 0 ? _a : time);
        this.lastUpdateTime = time;
        const simTime = this.simTime.get();
        const simDt = Math.max(0, simTime - ((_b = this.lastUpdateSimTime) !== null && _b !== void 0 ? _b : simTime));
        this.lastUpdateSimTime = simTime;
        this.doUpdate(time, dt, simTime, simDt);
        this.doWakingUpdate(time, dt);
    }
    /**
     * Perform update tasks that are run when the display is either awake or asleep.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     * @param dt The elapsed real time since the last update, in milliseconds.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param simDt The elapsed sim time since the last update, in milliseconds.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    doUpdate(time, dt, simTime, simDt) {
        // noop
    }
    /**
     * Performs update tasks that are only run when the display is awake.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     * @param dt The elapsed real time since the last update, in milliseconds.
     */
    doWakingUpdate(time, dt) {
        const projection = this.horizonRef.instance.projection;
        projection.set(this.projectionParams);
        if (this.isInertialDataValid.get()) {
            this.fpvComputer.update(projection.getHeading(), this.track.get(), this.gs.get(), this.inertialVs.get(), UnitType.MPS_PER_SEC.convertTo(this.accel.get(), UnitType.KNOT_PER_SEC), dt);
        }
        else {
            this.fpvComputer.reset();
        }
        if (this.isOnGround.get()) {
            if (this.aoaTransitionState === undefined) {
                this.aoaTransitionState = 0;
            }
            else {
                this.aoaTransitionState = Math.max(0, this.aoaTransitionState - dt / 1000);
            }
        }
        else {
            if (this.aoaTransitionState === undefined) {
                this.aoaTransitionState = 1;
            }
            else {
                this.aoaTransitionState = Math.min(1, this.aoaTransitionState + dt / 1000);
            }
        }
        // The sim's reported AoA on the ground can be weird sometimes, so we force the AoA to be equal to pitch while on
        // the ground (remember that sim pitch is positive-down). During the transition between on-ground and in-air, we
        // will blend the pitch and AoA for continuity.
        const aoa = MathUtils.lerp(this.aoaTransitionState, 0, 1, -this.pitch.get(), this.props.aoaDataProvider.aoa.get());
        this.aoa.set(aoa);
        // Show the pitch limit indicator when attitude data is valid, flaps are out of up, or when the limit is less than
        // 5 degrees above the current airplane pitch.
        this.showPitchLimit.set(this.isAttitudeDataValid.get()
            && (this.flapsPosition.get() > 0
                || aoa - this.aoaLimit.get() >= -5));
        this.horizonRef.instance.update(time);
    }
    /** @inheritdoc */
    render() {
        var _a, _b;
        const projection = new HorizonProjection(100, 100, 30);
        projection.onChange(this.onProjectionChanged.bind(this));
        return (FSComponent.buildComponent(HorizonComponent, { ref: this.horizonRef, projection: projection, projectedSize: this.props.projectedSize, fov: this.props.fov, fovEndpoints: this.props.fovEndpoints, projectedOffset: this.props.projectedOffset, class: 'pfd-horizon-display' },
            FSComponent.buildComponent(PfdArtificialHorizon, { projection: projection, show: this.isAttitudeDataValid, horizonLineConformalBounds: this.props.horizonLineConformalBounds, options: this.props.artificialHorizonOptions }),
            FSComponent.buildComponent(PfdPitchLadder, { projection: projection, show: this.isAttitudeDataValid, clipBounds: this.props.pitchLadderClipBounds, options: this.props.pitchLadderOptions }),
            FSComponent.buildComponent(PfdHorizonLine, { projection: projection, show: this.isAttitudeDataValid, showHeadingLabels: this.props.horizonLineSupportHeadingLabels ? this.showFpv : false, useMagneticHeading: true, magVar: this.magVar, options: this.props.horizonLineOptions }),
            FSComponent.buildComponent(PfdTcasRaPitchCueLayer, { projection: projection, show: this.showTcasRaPitchCueLayer, dataProvider: this.props.tcasRaCommandDataProvider, verticalSpeed: this.verticalSpeed, tas: this.tas, simRate: this.simRate, clipBounds: ((_a = this.props.tcasRaPitchCueClipBounds) !== null && _a !== void 0 ? _a : this.tcasRaPitchCueDefaultBounds), conformalBounds: ((_b = this.props.tcasRaPitchCueConformalBounds) !== null && _b !== void 0 ? _b : this.tcasRaPitchCueDefaultBounds), options: this.props.tcasRaPitchCueOptions }),
            FSComponent.buildComponent(PfdBankIndicator, { projection: projection, turnCoordinatorBall: this.turnCoordinatorBall, showPointer: this.isAttitudeDataValid, options: this.props.bankIndicatorOptions }),
            this.showSelectedFpa !== undefined && this.selectedFpa !== undefined && this.selectedFpaClipBounds !== undefined && (FSComponent.buildComponent(PfdSelectedFlightPathAngle, { projection: projection, show: this.showSelectedFpa, angle: this.selectedFpa, clipBounds: this.selectedFpaClipBounds })),
            FSComponent.buildComponent(PfdFlightPathVector, { projection: projection, show: this.showFpv, track: this.fpvComputer.fpTrack, pitch: this.fpvComputer.fpPitch, conformalBounds: this.props.fpvConformalBounds }),
            FSComponent.buildComponent("div", { class: { 'pfd-horizon-failure-flag': true, 'pfd-horizon-fpv-flag': true, 'hidden': this.fpvFlagHidden } }, "FPV"),
            FSComponent.buildComponent(PfdAirplaneSymbol, { projection: projection, show: Subject.create(true) }),
            FSComponent.buildComponent(PfdPitchLimitIndicator, { projection: projection, show: this.showPitchLimit, aoa: this.aoa, aoaLimit: this.aoaLimit, conformalBounds: this.props.pitchLimitConformalBounds, options: this.props.pitchLimitOptions }),
            FSComponent.buildComponent(PfdFlightDirector, { projection: projection, show: Subject.create(true), showCommandBars: this.isAttitudeDataValid, fmaData: this.fmaData, isFdActive: this.isFdActive, fdPitch: this.fdPitch, fdBank: this.fdBank, fdTakeoffDeviation: this.fdTakeoffDeviation, pitchErrorFactor: this.fdPitchErrorFactor, bankErrorFactor: this.fdBankErrorFactor, takeoffDeviationFactor: this.fdTakeoffDeviationFactor, conformalBounds: this.props.fdConformalBounds }),
            FSComponent.buildComponent("div", { class: { 'pfd-horizon-failure-flag': true, 'pfd-horizon-att-flag': true, 'hidden': this.isAttitudeDataValid } }, "ATT"),
            FSComponent.buildComponent("div", { class: { 'pfd-horizon-failure-flag': true, 'pfd-horizon-fd-flag': true, 'hidden': this.fdFlagHidden } }, "FD")));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.isAlive = false;
        this.paramSubjects.forEach(subject => { subject.destroy(); });
        this.adcAirspeedIndex.destroy();
        this.adcAltitudeIndex.destroy();
        this.irsIndex.destroy();
        this.isAirspeedDataValid.destroy();
        this.isAltitudeDataValid.destroy();
        this.isHeadingDataValid.destroy();
        this.isAttitudeDataValid.destroy();
        this.isInertialDataValid.destroy();
        this.simTime.destroy();
        this.simRate.destroy();
        this.isOnGround.destroy();
        this.verticalSpeed.destroy();
        this.tas.destroy();
        this.turnCoordinatorBall.destroy();
        this.magVar.destroy();
        this.track.destroy();
        this.gs.destroy();
        this.inertialVs.destroy();
        this.accel.destroy();
        this.flapsPosition.destroy();
        this.fmaData.destroy();
        this.fmsOperatingPhase.destroy();
        this.isFdActive.destroy();
        this.fdTakeoffDeviation.destroy();
        this.showFpv.destroy();
        (_a = this.showSelectedFpa) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.selectedFpa) === null || _b === void 0 ? void 0 : _b.destroy();
        this.fpvFlagHidden.destroy();
        (_c = this.adcAirspeedSelectorIndexSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.adcAltitudeSelectorIndexSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.irsSelectorIndexSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.updateFreqSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.updateCycleSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.fdPitchSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.fdBankSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.horizonRef.getOrDefault()) === null || _k === void 0 ? void 0 : _k.destroy();
        super.destroy();
    }
}

/**
 * A default implementation of {@link FlapRetractionDataProvider}.
 */
class DefaultFlapRetractionDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this._isFirstFlapRetractionStarted = Subject.create(false);
        /** @inheritdoc */
        this.isFirstFlapRetractionStarted = this._isFirstFlapRetractionStarted;
        this.flapsPosition = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.firstFlapsRetractionArmedPosition = 0;
        this.pauseable = [
            this.flapsPosition,
            this.isOnGround
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultFlapRetractionDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.flapsPosition.setConsumer(sub.on('flap_computer_interpolated_position'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultFlapRetractionDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultFlapRetractionDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.pause();
    }
    /**
     * Executes this data provider's periodic updates.
     */
    update() {
        const flapsPosition = this.flapsPosition.get();
        if (this.isOnGround.get()) {
            this.firstFlapsRetractionArmedPosition = flapsPosition;
            this._isFirstFlapRetractionStarted.set(false);
        }
        else if (!this._isFirstFlapRetractionStarted.get()) {
            this._isFirstFlapRetractionStarted.set(flapsPosition === 0 || (flapsPosition < this.firstFlapsRetractionArmedPosition));
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/**
 * FMS positioning system data modes.
 */
var FmsPositionMode;
(function (FmsPositionMode) {
    /** No position data is available. */
    FmsPositionMode["None"] = "None";
    /** Position data is sourced from GPS. */
    FmsPositionMode["Gps"] = "Gps";
    /** Position data is sourced from DME/DME. */
    FmsPositionMode["Dme"] = "Dme";
    /** Position data is sourced from HNS (hybrid inertial navigation). */
    FmsPositionMode["Hns"] = "Hns";
    /** Position data is sourced from dead reckoning. */
    FmsPositionMode["DeadReckoning"] = "DeadReckoning";
    /** Position data is sourced from dead reckoning and more than 20 minutes have elapsed since the last accurate position fix. */
    FmsPositionMode["DeadReckoningExpired"] = "DeadReckoningExpired";
})(FmsPositionMode || (FmsPositionMode = {}));
/**
 * A Boeing FMS geo-positioning system.
 */
class FmsPositionSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an FMS geo-positioning system.
     * @param index The index of the FMS geo-positioning system.
     * @param bus An instance of the event bus.
     * @param gpsReceiverIndex The index of the GPS receiver used by this system. No GPS data will be used if the index
     * is negative.
     * @param adcIndex The index of the ADC used by this system in dead reckoning mode to obtain airspeed data.
     * @param ahrsIndex The index of the AHRS used by this system in dead reckoning mode to obtain heading data.
     * @param hnsIndex The index of the HNS used by this system. No HNS data will be used if the index is negative.
     * Defaults to `-1`.
     * @param dmeIndex The index of the DME/DME navigation system used by this system. No DME/DME data will be used if
     * the index is negative. Defaults to `-1`.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsReceiverIndex, adcIndex, ahrsIndex, hnsIndex, dmeIndex, powerSource) {
        super(index, bus, `fms_pos_state_${index}`);
        this.initializationTime = 0;
        this.gnssDataSourceTopicMap = {
            [`fms_pos_gps-position_${this.index}`]: 'gps-position',
            [`fms_pos_ground_speed_${this.index}`]: 'ground_speed',
            [`fms_pos_track_deg_true_${this.index}`]: 'track_deg_true',
            [`fms_pos_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.modeTopic = `fms_pos_mode_${this.index}`;
        this.gpsIndexTopic = `fms_pos_gps_index_${this.index}`;
        this.hnsIndexTopic = `fms_pos_hns_index_${this.index}`;
        this.iruAnpTopic = `fms_pos_iru_anp_${this.index}`;
        this.gpsAnpTopic = `fms_pos_gps_anp_${this.index}`;
        this.radioAnpTopic = `fms_pos_radio_anp_${this.index}`;
        this.anpTopic = `fms_pos_anp_${this.index}`;
        this.verticalAnpTopic = `fms_pos_vertical_anp_${this.index}`;
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), 0);
        this.gpsStateSource = ConsumerSubject.create(null, GPSSystemState.Searching);
        this.gpsState = Subject.create(GPSSystemState.Searching);
        this.gpsPdop = ConsumerSubject.create(null, -1);
        this.gpsGroundSpeed = ConsumerSubject.create(null, -1);
        this.adcSystemState = ConsumerSubject.create(null, null);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.pitch = 0;
        /** filtered pitch rate in degrees per second */
        this.pitchRate = Subject.create(0);
        this.verticalAnp = MappedSubject.create(([zp, pitchRate]) => MathUtils.round(MathUtils.clamp(2.6 * zp ** 3 * Math.pow(10, -12) + 49, 49, 169) + 6 * Math.abs(pitchRate)), this.pressureAlt, this.pitchRate);
        this.mode = FmsPositionMode.None;
        this.lastFixTime = undefined;
        this.gpsIndex = SubscribableUtils.toSubscribable(gpsReceiverIndex, true);
        this.hnsIndex = SubscribableUtils.toSubscribable(-1, true);
        this.dmeIndex = SubscribableUtils.toSubscribable(-1, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        this.ahrsIndex = SubscribableUtils.toSubscribable(ahrsIndex, true);
        this.publisher.pub(this.modeTopic, this.mode, false, true);
        this.publisher.pub(this.iruAnpTopic, -1, false, true);
        this.publisher.pub(this.gpsAnpTopic, -1, false, true);
        this.publisher.pub(this.radioAnpTopic, -1, false, true);
        this.publisher.pub(this.anpTopic, -1, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.gnssDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onGnssTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.gnssDataSourceTopicMap) {
                this.onGnssTopicSubscribed(topic);
            }
        });
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.gpsIndex.sub(index => this.publisher.pub(this.gpsIndexTopic, index, false, true), !paused, paused));
        this.dataSubs.push(this.hnsIndex.sub(index => this.publisher.pub(this.hnsIndexTopic, index, false, true), !paused, paused));
        const gpsStatePipe = this.gpsStateSource.pipe(this.gpsState, true);
        this.gpsIndex.sub(index => {
            if (index < 0) {
                this.gpsStateSource.setConsumer(null);
                gpsStatePipe.pause();
                this.gpsState.set(GPSSystemState.Searching);
            }
            else {
                this.gpsStateSource.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_state_changed_${index}`));
                gpsStatePipe.resume(true);
            }
        }, true);
        this.dataSubs.push(this.gpsPdop.sub(this.updateAnp.bind(this), !paused, paused));
        this.verticalAnpSub = this.verticalAnp.sub((verAnp) => this.publisher.pub(this.verticalAnpTopic, verAnp, false, true));
        this.dataSubs.push(this.dataSourceSubscriber.on('actual_pitch_deg').atFrequency(5).handle((pitch) => {
            this.pitchRate.set(0.8 * this.pitchRate.get() + 0.2 * 5 * (pitch - this.pitch));
            this.pitch = pitch;
        }));
        this.adcSystemState.sub(this.updateAdcSystemState.bind(this));
        this.dataSubs.push(this.gpsIndex.sub((index) => this.gpsPdop.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_pdop_${index}`)), !paused, paused));
        this.gpsGroundSpeed.setConsumer(this.dataSourceSubscriber.on('ground_speed').withPrecision(0));
        this.dataSubs.push(this.adcIndex.sub((index) => this.pressureAlt.setConsumer(this.dataSourceSubscriber.on(`adc_pressure_alt_${index}`).withPrecision(-2)), !paused, paused));
        this.dataSubs.push(this.adcIndex.sub((index) => this.adcSystemState.setConsumer(this.dataSourceSubscriber.on(`adc_state_${index}`)), !paused, paused));
    }
    /**
     * Responds to when someone first subscribes to one of this system's GNSS-sourced data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onGnssTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.gnssDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.setMode(FmsPositionMode.None);
            this.lastFixTime = undefined;
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.updateMode();
        }
    }
    /**
     * Updates this system's data mode.
     */
    updateMode() {
        const gpsState = this.gpsState.get();
        if (gpsState === GPSSystemState.SolutionAcquired || gpsState === GPSSystemState.DiffSolutionAcquired) {
            this.setMode(FmsPositionMode.Gps);
            this.lastFixTime = this.simTime.get();
        }
        else if (this.lastFixTime !== undefined) {
            if (this.simTime.get() - this.lastFixTime > FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME) {
                this.setMode(FmsPositionMode.DeadReckoningExpired);
            }
            else {
                this.setMode(FmsPositionMode.DeadReckoning);
            }
        }
        else {
            this.setMode(FmsPositionMode.None);
        }
    }
    /**
     * Sets this system's data mode, and publishes the new value to the event bus if it differs from the current value.
     * @param mode The new data mode.
     */
    setMode(mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this.publisher.pub(this.modeTopic, this.mode, false, true);
    }
    /** Update the ANP from data sources */
    updateAnp() {
        // The Boeing ANP includes navigation system error (aka position uncertainty),
        // but excludes Flight Technical Error (this is shown on the EFIS as a function of ANP and RNP),
        // and excludes path computation error as this is assumed negligable
        // https://www.boeing.com/commercial/aeromagazine/aero_16/navigation_story.html
        const pdop = this.gpsPdop.get();
        if (pdop >= 0) {
            const anp = FmsPositionSystem.ANP(pdop);
            this.publisher.pub(this.gpsAnpTopic, anp, false, true);
            this.publisher.pub(this.anpTopic, anp, false, true);
        }
        else {
            this.publisher.pub(this.gpsAnpTopic, pdop, false, true);
            this.publisher.pub(this.anpTopic, pdop, false, true);
        }
        // TODO IRU and radio position
    }
    /**
     * Updates the ADC derived values when the ADC system state changes
     * @param state ADC system state event
     */
    updateAdcSystemState(state) {
        var _a, _b;
        if ((state === null || state === void 0 ? void 0 : state.current) === AvionicsSystemState.On) {
            (_a = this.verticalAnpSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        }
        else {
            (_b = this.verticalAnpSub) === null || _b === void 0 ? void 0 : _b.pause();
            this.publisher.pub(this.verticalAnpTopic, -1, false, true);
        }
    }
}
FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME = UnitType.MINUTE.convertTo(20, UnitType.MILLISECOND);
/** Calculates the ANP as the circle radius where the airplane position is estimated to be within 95% of the time.
 * Uses the statistic formula of estimating a 95% confidence interval with a (hypothetical) sample size of 1.
 * @param pdop The geometric dilution of precision computation (GDOP).
 * @returns The estimated ANP.
 */
FmsPositionSystem.ANP = (pdop) => {
    /** In meters. Used for calculating the ANP. Sets at 222 under the assumption that airplane cruises at 800 km/h,
     * hence if gps position is updated every second, the deviation would be 222 m/s.
     * Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR = 222;
    /** In meters. Used for calculating the ANP. Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const ESTIMATED_NUMERICAL_ERROR = 200;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL = 1.96;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const HYPOTHETICAL_SAMPLE_SIZE = 1;
    const STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS = () => {
        return Math.sqrt((pdop * STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR) ^ 2 + ESTIMATED_NUMERICAL_ERROR ^ 2);
    };
    const anpMeter = Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL * STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS() / Math.sqrt(HYPOTHETICAL_SAMPLE_SIZE);
    return MathUtils.round(UnitType.NMILE.convertFrom(anpMeter, UnitType.METER), 0.01);
};

/**
 * A controller that listens to H Events sent for Minimums Indications.
 * Sends Key Events to MinimumsManager.
 */
class BoeingMinimumsStateController {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param minimumsModeSub Minimums mode subscribable.
     */
    constructor(bus, minimumsModeSub) {
        this.bus = bus;
        this.minimumsModeSub = minimumsModeSub;
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.bus);
        this.minsPub = this.bus.getPublisher();
        this.alertSub = this.bus.getSubscriber();
        this.isAlerting = ConsumerSubject.create(this.alertSub.on('minimums_alert').whenChanged(), false);
        /** The minimums mode that is set in the cockpit. Can only be RA or BARO */
        this.cockpitSetMinsMode = MinimumsMode.OFF;
        this.minimumsIsOn = Subject.create(false);
        this.currentRadioMinimumsValue = 0;
        this.currentBaroMinimumsValue = 0;
        this.setSimVarTopic = 'set_decision_altitude_feet';
        this.lastTimeKnobUsed = null;
        this.knobHits = 0;
        this.knobIncrementValue = 10;
        this.init();
    }
    /**
     * Initializes this controller. Once initialized, this will continuously listen to H Events that interact with the minimums,
     * and send MinimumsControllerEvent-s to MinimumsManager until destroyed.
     */
    init() {
        const efisEventSub = this.bus.getSubscriber();
        const minsSub = this.bus.getSubscriber();
        const decisionHeightSub = ConsumerSubject.create(minsSub.on('decision_height_feet').whenChanged(), 0);
        const decisionAltitudeSub = ConsumerSubject.create(minsSub.on('decision_altitude_feet').whenChanged(), 0);
        this.minimumsModeSub.sub((mode) => {
            this.cockpitSetMinsMode = mode === 0 ? MinimumsMode.RA : MinimumsMode.BARO;
            this.setSimVarTopic = this.cockpitSetMinsMode === MinimumsMode.RA ? 'set_decision_height_feet' : 'set_decision_altitude_feet';
            this.setMinsModeSetting();
            this.setMinsValueSetting();
            // Re-sync minimums value after mode is changed
            const minimumsValue = this.cockpitSetMinsMode === MinimumsMode.RA ? this.currentRadioMinimumsValue : this.currentBaroMinimumsValue;
            this.minsPub.pub(this.setSimVarTopic, minimumsValue);
        }, true);
        decisionHeightSub.sub((dh) => {
            this.currentRadioMinimumsValue = dh;
            this.cockpitUserSettings.getSetting('decisionHeightFeet').set(dh);
        }, true);
        decisionAltitudeSub.sub((da) => {
            this.currentBaroMinimumsValue = da;
            this.cockpitUserSettings.getSetting('decisionAltitudeFeet').set(da);
        }, true);
        this.minimumsIsOn.sub(() => this.setMinsModeSetting(), true);
        efisEventSub.on('EFIS.MINS_INC').handle(() => { this.handleMinsChangeEvent(true); });
        efisEventSub.on('EFIS.MINS_DEC').handle(() => { this.handleMinsChangeEvent(false); });
        efisEventSub.on('EFIS.MINS_PRESS').handle(() => { this.handleMinsPressEvent(); });
        this.cockpitUserSettings.getSetting('minimumsMode').sub(mode => {
            SimVar.SetSimVarValue('L:WT_BOEING_MINIMUMS_MODE', SimVarValueType.Number, mode);
        }, true);
    }
    /**
     * Handles the minimums increase and decrease events.
     * @param isIncrease Whether the minimums should be increased or decreased.
     */
    handleMinsChangeEvent(isIncrease) {
        this.minimumsIsOn.set(true);
        this.adjustKnobVelocity();
        const direction = isIncrease ? 'up' : 'down';
        const baseValue = this.cockpitSetMinsMode === MinimumsMode.RA
            ? this.currentRadioMinimumsValue
            : this.currentBaroMinimumsValue;
        const nextMinimumsValue = MathUtils.clamp(baseValue + this.knobIncrementValue * (direction === 'up' ? 1 : -1), 0, 99999);
        this.minsPub.pub(this.setSimVarTopic, nextMinimumsValue);
    }
    /** Handles the Minimums Press (reset) event.
     * Only reset / turn off minimums indicator when it is not in ALERTING state.
     */
    handleMinsPressEvent() {
        if (!this.isAlerting.get()) {
            this.minimumsIsOn.set(false);
            this.minsPub.pub('set_decision_height_feet', 0);
            this.minsPub.pub('set_decision_altitude_feet', 0);
        }
    }
    /** Set minimums mode setting in CockpitUserSettings. */
    setMinsModeSetting() {
        this.cockpitUserSettings.getSetting('minimumsMode').set(this.minimumsIsOn.get() ? this.cockpitSetMinsMode : MinimumsMode.OFF);
    }
    /** Sets minimums value setting in CockpitUserSettings. */
    setMinsValueSetting() {
        if (this.cockpitSetMinsMode === MinimumsMode.RA) {
            this.cockpitUserSettings.getSetting('decisionHeightFeet').set(this.currentRadioMinimumsValue);
        }
        else {
            this.cockpitUserSettings.getSetting('decisionAltitudeFeet').set(this.currentBaroMinimumsValue);
        }
    }
    /**
     * Increase knob velocity according to frequency of use.
     */
    adjustKnobVelocity() {
        if (!this.lastTimeKnobUsed) {
            this.lastTimeKnobUsed = Date.now();
        }
        else {
            if (Date.now() - this.lastTimeKnobUsed < 300) {
                if (this.knobHits < 5) {
                    this.knobIncrementValue = 1;
                }
                else if (this.knobHits <= 10) {
                    this.knobIncrementValue = 10;
                }
                else {
                    this.knobIncrementValue = 100;
                }
                this.knobHits++;
            }
            else {
                this.knobIncrementValue = 1;
                this.knobHits = 0;
            }
            this.lastTimeKnobUsed = Date.now();
        }
    }
}

/**
 * A Boeing ADC system.
 */
class AdcSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an ADC system.
     * @param index The index of the ADC.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this ADC derives its data.
     * @param altimeterIndex The index of the sim altimeter from which this ADC derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, airspeedIndicatorIndex, altimeterIndex, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.airspeedIndicatorIndex = airspeedIndicatorIndex;
        this.altimeterIndex = altimeterIndex;
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_ias_${this.index}`]: `ias_${this.airspeedIndicatorIndex}`,
            [`adc_tas_${this.index}`]: `tas_${this.airspeedIndicatorIndex}`,
            [`adc_mach_to_kias_factor_${this.index}`]: `mach_to_kias_factor_${this.airspeedIndicatorIndex}`,
            [`adc_indicated_alt_${this.index}`]: `indicated_alt_${this.altimeterIndex}`,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: `altimeter_baro_setting_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: `altimeter_baro_preselect_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: `altimeter_baro_preselect_mb_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: `altimeter_baro_preselect_raw_${this.altimeterIndex}`,
            [`adc_altimeter_baro_is_std_${this.index}`]: `altimeter_baro_is_std_${this.altimeterIndex}`,
            [`adc_mach_number_${this.index}`]: 'mach_number',
            [`adc_pressure_alt_${this.index}`]: 'pressure_alt',
            [`adc_vertical_speed_${this.index}`]: 'vertical_speed',
            [`adc_ambient_density_${this.index}`]: 'ambient_density',
            [`adc_ambient_temp_c_${this.index}`]: 'ambient_temp_c',
            [`adc_ambient_pressure_inhg_${this.index}`]: 'ambient_pressure_inhg',
            [`adc_isa_temp_c_${this.index}`]: 'isa_temp_c',
            [`adc_ram_air_temp_c_${this.index}`]: 'ram_air_temp_c'
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, true, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing ADC data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.dataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.speedDataValidTopic, true, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.speedDataValidTopic, false, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, false, false, true);
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best ADC from a set of candidates based on the current states of all systems. System state
 * desiribility depends on whether it is providing valid airspeed and altitude data.
 */
class AdcSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the ADC systems from which to select.
     * @param systemPriorities The priorities for selecting individual ADC systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of ADC system indexes or a map of
     * ADC system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     * @param dataBias Whether to bias system desirability toward valid airspeed data, valid altitude data, or neither.
     * Defaults to `'none'`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities, dataBias) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isSpeedDataValid = Subject.create(false);
        this.isAltitudeDataValid = Subject.create(false);
        this.adcEntries = new Map();
        this.adcOrder = [];
        this.adcComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        switch (dataBias) {
            case 'airspeed':
                this.adcStateComparator = (a, b) => (Number(b[0]) * 1.5 + Number(b[1])) - (Number(a[0]) * 1.5 + Number(a[1]));
                break;
            case 'airspeed-only':
                this.adcStateComparator = (a, b) => Number(b[0]) - Number(a[0]);
                break;
            case 'altitude':
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1]) * 1.5) - (Number(a[0]) + Number(a[1]) * 1.5);
                break;
            case 'altitude-only':
                this.adcStateComparator = (a, b) => Number(b[1]) - Number(a[1]);
                break;
            default:
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1])) - (Number(a[0]) + Number(a[1]));
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `adc_selector_selected_index_${index}`), true);
        this.isSpeedDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_speed_data_valid_${index}`), true);
        this.isAltitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_altitude_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best ADC among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('AdcSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.adcEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`adc_speed_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`adc_altitude_data_valid_${key}`), false),
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.adcEntries.set(key, entry);
                // When there is a change in an ADC state, we don't reselect immediately because the ADC could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.adcEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the ADC with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.adcEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.adcEntries.size === 1) {
            const entry = this.adcEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.adcOrder.length = 0;
            for (const index of this.adcEntries.keys()) {
                this.adcOrder.push(index);
            }
            this.adcOrder.sort(this.adcComparator);
            bestIndex = -1;
            for (let i = 0; i < this.adcOrder.length; i++) {
                const index = this.adcOrder[i];
                const state = this.adcEntries.get(index).state.get();
                if (!bestState || this.adcStateComparator(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isSpeedDataValid.set(bestState[0]);
            this.isAltitudeDataValid.set(bestState[1]);
        }
        else {
            this.isSpeedDataValid.set(false);
            this.isAltitudeDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.adcEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}

/**
 * A Boeing angle of attack computer system.
 */
class AoaSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an angle of attack computer system.
     * @param index The index of the AoA computer.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `aoa_state_${index}`);
        this.initializationTime = 15000;
        this.simVarPublisher = new SimVarPublisher(new Map([
            [`aoa_load_factor_${this.index}`, { name: 'SEMIBODY LOADFACTOR Y', type: SimVarValueType.Number }]
        ]), this.bus);
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.isAoaSubbed = false;
        this.isStallAoaSubbed = false;
        this.isZeroLiftAoaSubbed = false;
        this.normAoaTopic = `aoa_norm_aoa_${this.index}`;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing angle of attack data on the event bus.
     */
    startDataPublish() {
        const topics = [
            `aoa_aoa_${this.index}`,
            `aoa_stall_aoa_${this.index}`,
            `aoa_zero_lift_aoa_${this.index}`,
            `aoa_norm_aoa_${this.index}`
        ];
        for (const topic of topics) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topics.includes(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
        this.simVarPublisher.startPublish();
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        let shouldSubAoa = false;
        let shouldSubStallAoa = false;
        let shouldSubZeroLiftAoa = false;
        switch (topic) {
            case `aoa_aoa_${this.index}`:
                shouldSubAoa = true;
                break;
            case `aoa_stall_aoa_${this.index}`:
                shouldSubStallAoa = true;
                break;
            case `aoa_zero_lift_aoa_${this.index}`:
                shouldSubZeroLiftAoa = true;
                break;
            case `aoa_norm_aoa_${this.index}`:
                shouldSubAoa = true;
                shouldSubStallAoa = true;
                shouldSubZeroLiftAoa = true;
                break;
        }
        if (shouldSubAoa && !this.isAoaSubbed) {
            this.isAoaSubbed = true;
            const pubTopic = `aoa_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('aoa').handle(val => {
                this.aoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubStallAoa && !this.isStallAoaSubbed) {
            this.isStallAoaSubbed = true;
            const pubTopic = `aoa_stall_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('stall_aoa').handle(val => {
                this.stallAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubZeroLiftAoa && !this.isZeroLiftAoaSubbed) {
            this.isZeroLiftAoaSubbed = true;
            const pubTopic = `aoa_zero_lift_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('zero_lift_aoa').handle(val => {
                this.zeroLiftAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.Failed
            || this._state === AvionicsSystemState.Off
            || this.aoa === undefined
            || this.stallAoa === undefined
            || this.zeroLiftAoa === undefined) {
            return;
        }
        this.publisher.pub(this.normAoaTopic, (this.aoa - this.zeroLiftAoa) / (this.stallAoa - this.zeroLiftAoa), false, true);
        this.simVarPublisher.onUpdate();
    }
}

/**
 * A publisher that publishes Boeing Game Units events.
 */
class BoeingGameUnitsPublisher extends GameVarPublisher {
    /**
     * Creates an instance of the BoeingGameUnitsPublisher.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        super(BoeingGameUnitsPublisher.gamevars, bus);
    }
}
BoeingGameUnitsPublisher.gamevars = new Map([
    ['game_units_metric', { name: 'GAME UNIT IS METRIC', type: SimVarValueType.Bool }],
]);

/**
 * Automatically selects the best GPS receiver from a set of candidates based on the current states of all receivers.
 * Receivers that have computed a 3D position solution with differential corrections are favored over those that have
 * computed a 3D solution without corrections, and either of these are favored over those that have not computed any
 * position solution.
 */
class GpsReceiverSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param enabledReceiverIndexes The indexes of the GPS receivers from which to select.
     * @param preferredReceiverIndex The index of this selector's preferred GPS receiver, or `-1` if there is no such
     * receiver. This selector is guaranteed to select the preferred GPS receiver if its state is at least as desirable
     * as the state of all other receivers from which to select. Defaults to `-1`.
     */
    constructor(bus, enabledReceiverIndexes, preferredReceiverIndex) {
        this.bus = bus;
        this._selectedIndex = Subject.create(-1);
        this.selectedIndex = this._selectedIndex;
        this.gpsStates = new Map();
        this.isAlive = true;
        this.isInit = false;
        this.enabledReceiverIndexes = 'isSubscribableSet' in enabledReceiverIndexes ? enabledReceiverIndexes : SetSubject.create(enabledReceiverIndexes);
        this.preferredReceiverIndex = SubscribableUtils.toSubscribable(preferredReceiverIndex !== null && preferredReceiverIndex !== void 0 ? preferredReceiverIndex : -1, true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best GPS receiver among
     * its candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('GpsReceiverSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const selectIndex = this.selectIndex.bind(this);
        this.enabledReceiverIndexesSub = this.enabledReceiverIndexes.sub((set, type, key) => {
            var _a;
            (_a = this.gpsStates.get(key)) === null || _a === void 0 ? void 0 : _a.destroy();
            if (type === SubscribableSetEventType.Added) {
                const gpsState = ConsumerSubject.create(sub.on(`gps_rec_gps_system_state_changed_${key}`), GPSSystemState.Acquiring);
                this.gpsStates.set(key, gpsState);
                gpsState.sub(selectIndex);
            }
            else {
                this.gpsStates.delete(key);
            }
            selectIndex();
        }, true);
        this.preferredReceiverIndexSub = this.preferredReceiverIndex.sub(selectIndex);
    }
    /**
     * Selects the index of the GPS receiver with the most desirable state.
     */
    selectIndex() {
        var _a, _b;
        if (this.gpsStates.size === 0) {
            this._selectedIndex.set(-1);
            return;
        }
        if (this.gpsStates.size === 1) {
            this._selectedIndex.set(this.gpsStates.keys().next().value);
            return;
        }
        let bestIndex = this._selectedIndex.get();
        let bestState = (_a = this.gpsStates.get(bestIndex)) === null || _a === void 0 ? void 0 : _a.get();
        for (const index of this.gpsStates.keys()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const state = this.gpsStates.get(index).get();
            if (bestIndex < 0 || !bestState || GpsReceiverSelector.compareGpsState(state, bestState) < 0) {
                bestIndex = index;
                bestState = state;
            }
        }
        const preferredIndex = this.preferredReceiverIndex.get();
        if (preferredIndex >= 0) {
            const preferredIndexState = (_b = this.gpsStates.get(preferredIndex)) === null || _b === void 0 ? void 0 : _b.get();
            if (preferredIndexState !== undefined && GpsReceiverSelector.compareGpsState(preferredIndexState, bestState) <= 0) {
                bestIndex = preferredIndex;
            }
        }
        this._selectedIndex.set(bestIndex);
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        for (const state of this.gpsStates.values()) {
            state.destroy();
        }
        (_a = this.enabledReceiverIndexesSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.preferredReceiverIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
    /**
     * Compares two GPS system states and returns a number whose sign indicates which one is more desirable.
     * @param a The first GPS system state to compare.
     * @param b The second GPS system state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareGpsState(a, b) {
        return GpsReceiverSelector.GPS_STATE_PRIORITIES[a] - GpsReceiverSelector.GPS_STATE_PRIORITIES[b];
    }
}
GpsReceiverSelector.GPS_STATE_PRIORITIES = {
    [GPSSystemState.DiffSolutionAcquired]: 0,
    [GPSSystemState.SolutionAcquired]: 1,
    [GPSSystemState.Acquiring]: 2,
    [GPSSystemState.Searching]: 2
};

/**
 * A Garmin GPS receiver system.
 */
class GpsReceiverSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a GPS receiver system.
     * @param index The index of the GPS receiver.
     * @param bus An instance of the event bus.
     * @param gpsSatComputer This system's GPS computer system.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsSatComputer, powerSource) {
        super(index, bus, `gps_rec_state_${index}`);
        this.gpsSatComputer = gpsSatComputer;
        this.initializationTime = 0;
        this.cachedDataSourceTopicMap = {
            [`gps_rec_gps_system_state_changed_${this.index}`]: `gps_system_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_sbas_state_changed_${this.index}`]: `gps_system_sbas_state_changed_${this.gpsSatComputer.index}`
        };
        this.uncachedDataSourceTopicMap = {
            [`gps_rec_gps_sat_state_changed_${this.index}`]: `gps_sat_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_sat_pos_calculated_${this.index}`]: `gps_sat_pos_calculated_${this.gpsSatComputer.index}`
        };
        this.dopDataSourceTopicMap = {
            [`gps_rec_gps_system_pdop_${this.index}`]: `gps_system_pdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_hdop_${this.index}`]: `gps_system_hdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_vdop_${this.index}`]: `gps_system_vdop_${this.gpsSatComputer.index}`
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.dopSources = [];
        this.sbasState = ConsumerSubject.create(null, GPSSystemSBASState.Disabled);
        gpsSatComputer.init();
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        else if (gpsSatComputer.syncRole !== 'replica') {
            // If our power source is undefined, then the system is always considered to be in the on state. Therefore we
            // will force the GPS to immediately acquire and use all the satellites it can since a system that is always on
            // never needs to initialize.
            gpsSatComputer.acquireAndUseSatellites();
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.cachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.cachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, true);
            }));
        }
        for (const topic of Object.keys(this.uncachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.uncachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, false);
            }));
        }
        // Garmin seems to halve DOP values when SBAS is active. It could be a trainer-specific behavior, but in the
        // absence of any other information, we will implement it here.
        this.sbasState.setConsumer(this.dataSourceSubscriber.on(`gps_system_sbas_state_changed_${this.gpsSatComputer.index}`));
        for (const topic of Object.keys(this.dopDataSourceTopicMap)) {
            const dopSource = ConsumerSubject.create(this.dataSourceSubscriber.on(this.dopDataSourceTopicMap[topic]), -1);
            this.dopSources.push(dopSource);
            const processedDop = MappedSubject.create(([dop, sbasState]) => dop <= 0 ? dop : dop * (sbasState === GPSSystemSBASState.Active ? 0.5 : 1), dopSource, this.sbasState);
            this.dataSubs.push(processedDop.sub(dop => {
                this.publisher.pub(topic, dop, false, false);
            }, true));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        // If this is the first time we are setting our state and the state is on, then we assume that the system was on at
        // flight load, in which case we will force the GPS to immediately acquire and use all the satellites it can so
        // that we don't force people to wait for satellite acquisition when loading onto the runway/in the air.
        if (previousState === undefined && currentState === AvionicsSystemState.On && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.acquireAndUseSatellites();
        }
        // Reset the GPS sat computer if the system is not operating and its receiver is not a replica (a replica receiver
        // will get the reset command from its primary).
        if ((currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.reset();
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.gpsSatComputer.onUpdate();
        }
    }
}

/**
 * IRS operating modes.
 */
var IrsSystemOperatingMode;
(function (IrsSystemOperatingMode) {
    /** The IRS is not operating. */
    IrsSystemOperatingMode["Off"] = "Off";
    /** The IRS is in Standby mode. No data are available. */
    IrsSystemOperatingMode["Standby"] = "Standby";
    /** The IRS is performing a full alignment. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlign"] = "FullAlign";
    /** The IRS has completed a full alignment but is awaiting a position input. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlignPositionPending"] = "FullAlignPositionPending";
    /** The IRS is in Navigation mode. All data are available. */
    IrsSystemOperatingMode["Navigation"] = "Navigation";
    /** The IRS is performing a realignment. All data are available. */
    IrsSystemOperatingMode["Realign"] = "Realign";
    /** The IRS is performing an attitude alignment. No data are available. */
    IrsSystemOperatingMode["AttitudeAlign"] = "AttitudeAlign";
    /** The IRS is in Attitude mode. Attitude and heading data are available. */
    IrsSystemOperatingMode["Attitude"] = "Attitude";
})(IrsSystemOperatingMode || (IrsSystemOperatingMode = {}));
/**
 * IRS system operating mode setting commands.
 */
var IrsSystemOperatingModeSetting;
(function (IrsSystemOperatingModeSetting) {
    /** Forces the IRS into Off mode. */
    IrsSystemOperatingModeSetting["Off"] = "Off";
    /** Commands Navigation mode. The IRS will perform a full alignment (if required), then enter Navigation mode. */
    IrsSystemOperatingModeSetting["Navigation"] = "Navigation";
    /**
     * Arms IRS realignment. If the IRS is in Navigation mode, then the next time Navigation mode is selected and the
     * airplane is on the ground and not moving, it will attempt an realignment.
     */
    IrsSystemOperatingModeSetting["Align"] = "Align";
    /** Commands Attitude mode. The IRS will perform an attitude alignment (if required), then enter Attitude mode. */
    IrsSystemOperatingModeSetting["Attitude"] = "Attitude";
})(IrsSystemOperatingModeSetting || (IrsSystemOperatingModeSetting = {}));
/**
 * A Boeing inertial reference system (IRS). Provides attitude, heading, and inertial (position, velocity,
 * acceleration) data.
 */
class IrsSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an IRS system.
     * @param index The index of the IRS.
     * @param bus An instance of the event bus.
     * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this IRS derives its data.
     * @param directionIndicatorIndex The index of the sim direction indicator from which this IRS derives its data.
     * @param supportInFlightAlign Whether this IRS supports full alignment while in flight. In-flight full alignment
     * requires position input from GPS receivers.
     * @param operatingModeSetting The operating mode setting commanded for this IRS.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     * @param gpsReceiverIndexes The indexes of the GPS receiver systems from which the IRS receives position input data.
     * If no indexes are supplied, then the IRS will not automatically initialize its position from GPS and will require
     * manual position input during alignment.
     * @param attitudeAlignDuration The duration, in milliseconds, required for this IRS to complete attitude alignment.
     * Defaults to 30000 milliseconds.
     * @param fullAlignDuration The duration, in milliseconds, required for this IRS to complete a full alignment. If not
     * defined, full alignment duration will be simulated based on the airplane's current latitude.
     * @param realignDuration The duration, in milliseconds, required for this IRS to complete realignment. Defaults to
     * 30000 milliseconds.
     */
    constructor(index, bus, attitudeIndicatorIndex, directionIndicatorIndex, supportInFlightAlign, operatingModeSetting, powerSource, gpsReceiverIndexes, attitudeAlignDuration, fullAlignDuration, realignDuration) {
        var _a;
        super(index, bus, `irs_state_${index}`);
        this.attitudeIndicatorIndex = attitudeIndicatorIndex;
        this.directionIndicatorIndex = directionIndicatorIndex;
        this.supportInFlightAlign = supportInFlightAlign;
        this.operatingModeSetting = operatingModeSetting;
        this.powerSource = powerSource;
        this.initializationTime = 0;
        this.simulatedFullAlignDuration = Subject.create(0);
        this.operatingModeTopic = `irs_operating_mode_${this.index}`;
        this.headingDataValidTopic = `irs_heading_data_valid_${this.index}`;
        this.attitudeDataValidTopic = `irs_attitude_data_valid_${this.index}`;
        this.inertialDataValidTopic = `irs_inertial_data_valid_${this.index}`;
        this.positionDataValidTopic = `irs_position_data_valid_${this.index}`;
        this.acceptingPositionTopic = `irs_is_accepting_position_${this.index}`;
        this.requestingPositionTopic = `irs_is_requesting_position_${this.index}`;
        this.fullAlignTimeTopic = `irs_full_align_time_remaining_${this.index}`;
        this.attitudeAlignTimeTopic = `irs_att_align_time_remaining_${this.index}`;
        this.operatingMode = IrsSystemOperatingMode.Navigation;
        this.isHeadingDataValid = true;
        this.isAttitudeDataValid = true;
        this.isInertialDataValid = true;
        this.isInertialHeadingDataValid = true;
        this.isPositionDataValid = true;
        this.isPositionInit = Subject.create(true);
        // When true, the next time isAcceptingPosition becomes true, isPositionInit will automatically be set to true
        this.autoPositionInit = false;
        this.isAcceptingPosition = Subject.create(false);
        this.isRealignArmed = false;
        this.attitudeAlignTime = 0;
        this.fullAlignTime = 0;
        this.realignTime = 0;
        this.publishedFullAlignTimeRemaining = undefined;
        this.publishedAttitudeAlignTimeRemaining = undefined;
        this.lastUpdateSimTime = undefined;
        this.simTime = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.speed = ConsumerValue.create(null, 0);
        this.position = ConsumerValue.create(null, new LatLongAlt(0, 0, 0));
        this.headingDataSourceTopicMap = {
            [`irs_hdg_deg_${this.index}`]: `hdg_deg_${this.directionIndicatorIndex}`,
            [`irs_hdg_deg_true_${this.index}`]: `hdg_deg_true_${this.directionIndicatorIndex}`
        };
        this.attitudeDataSourceTopicMap = {
            [`irs_delta_heading_rate_${this.index}`]: `delta_heading_rate_${this.attitudeIndicatorIndex}`,
            [`irs_pitch_deg_${this.index}`]: `pitch_deg_${this.attitudeIndicatorIndex}`,
            [`irs_roll_deg_${this.index}`]: `roll_deg_${this.attitudeIndicatorIndex}`,
            [`irs_turn_coordinator_ball_${this.index}`]: 'turn_coordinator_ball'
        };
        this.inertialDataSourceTopicMap = {
            [`irs_inertial_speed_${this.index}`]: 'inertial_speed',
            [`irs_inertial_vertical_speed_${this.index}`]: 'inertial_vertical_speed',
            [`irs_inertial_acceleration_${this.index}`]: 'inertial_acceleration',
            [`irs_inertial_track_acceleration_${this.index}`]: 'inertial_track_acceleration',
            [`irs_ground_speed_${this.index}`]: 'ground_speed'
        };
        this.inertialHeadingDataSourceTopicMap = {
            [`irs_track_deg_true_${this.index}`]: 'track_deg_true',
            [`irs_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.positionDataSourceTopicMap = {
            [`irs_gps-position_${this.index}`]: 'gps-position',
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.headingDataSubs = [];
        this.attitudeDataSubs = [];
        this.inertialDataSubs = [];
        this.inertialHeadingDataSubs = [];
        this.positionDataSubs = [];
        this.overrideAttitudeAlignDuration = SubscribableUtils.toSubscribable(attitudeAlignDuration, true);
        this.overrideFullAlignDuration = SubscribableUtils.toSubscribable(fullAlignDuration, true);
        this.overrideRealignDuration = SubscribableUtils.toSubscribable(realignDuration, true);
        this.attitudeAlignDuration = this.overrideAttitudeAlignDuration.map(duration => duration === undefined ? IrsSystem.ATTITUDE_ALIGN_DURATION : duration);
        this.fullAlignDuration = MappedSubject.create(([simulated, override, attitudeAlign]) => Math.max(override === undefined ? simulated : override, attitudeAlign), this.simulatedFullAlignDuration, this.overrideFullAlignDuration, this.attitudeAlignDuration);
        this.realignDuration = this.overrideRealignDuration.map(duration => duration === undefined ? IrsSystem.REALIGN_DURATION : duration);
        if (this.powerSource !== undefined) {
            this.connectToPower(this.powerSource);
        }
        // Initialize some cached topics.
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid);
        this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid);
        this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid);
        this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid);
        this.publishFullAlignTimeRemaining(null);
        this.publishAttitudeAlignTimeRemaining(null);
        // Set up automatic position initialization from GPS.
        const gpsReceiverIndexArray = Array.from(new Set(gpsReceiverIndexes)); // Ensure no duplicates
        if (gpsReceiverIndexArray.length > 0) {
            const gpsSub = bus.getSubscriber();
            this.isGpsAvailable = MappedSubject.create(states => states.includes(GPSSystemState.SolutionAcquired) || states.includes(GPSSystemState.DiffSolutionAcquired), ...gpsReceiverIndexArray.map(gpsReceiverIndex => ConsumerSubject.create(gpsSub.on(`gps_rec_gps_system_state_changed_${gpsReceiverIndex}`), GPSSystemState.Searching)));
            this.gpsPositionSub = this.isGpsAvailable.sub(isAvail => {
                if (isAvail) {
                    this.isPositionInit.set(true);
                }
            }, false, true);
        }
        const sub = bus.getSubscriber();
        this.simTime.setConsumer(sub.on('simTime'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.speed.setConsumer(sub.on('inertial_speed'));
        this.position.setConsumer(sub.on('gps-position'));
        this.setPositionSub = sub.on(`irs_set_position_${index}`).handle(() => {
            this.isPositionInit.set(true);
        }, true);
        this.autoSetPositionSub = sub.on('hEvent').handle(hEvent => {
            if (hEvent === 'WT_AUTO_SET_IRS_POS') {
                if (this.isAcceptingPosition.get()) {
                    this.isPositionInit.set(true);
                }
                else {
                    this.autoPositionInit = true;
                }
            }
        });
        this.isAcceptingPosition.sub(val => {
            var _a, _b;
            if (val) {
                this.setPositionSub.resume();
                (_a = this.gpsPositionSub) === null || _a === void 0 ? void 0 : _a.resume(true);
                if (this.autoPositionInit) {
                    this.isPositionInit.set(true);
                    this.autoPositionInit = false;
                }
            }
            else {
                this.setPositionSub.pause();
                (_b = this.gpsPositionSub) === null || _b === void 0 ? void 0 : _b.pause();
            }
            this.publisher.pub(this.acceptingPositionTopic, val);
        }, true);
        // Request manual position input when the system is accepting position inputs, has not received a position input
        // yet, and GPS position is not available.
        this.isRequestingPosition = MappedSubject.create(([isAccepting, isInit, isGpsAvail]) => isAccepting && !isInit && !isGpsAvail, this.isAcceptingPosition, this.isPositionInit, (_a = this.isGpsAvailable) !== null && _a !== void 0 ? _a : Subject.create(false));
        this.isPositionInit.sub(isInit => {
            SimVar.SetSimVarValue(`L:WT_IRS_POS_SET_${this.index}`, SimVarValueType.Bool, isInit);
        }, true);
        this.isRequestingPosition.sub(val => { this.publisher.pub(this.requestingPositionTopic, val); }, true);
        this.startDataPublish();
    }
    /**
     * Starts publishing IRS data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.headingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.attitudeDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onAttitudeTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialHeadingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.positionDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onPositionTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.headingDataSourceTopicMap) {
                this.onHeadingTopicSubscribed(topic);
            }
            else if (topic in this.attitudeDataSourceTopicMap) {
                this.onAttitudeTopicSubscribed(topic);
            }
            else if (topic in this.inertialDataSourceTopicMap) {
                this.onInertialTopicSubscribed(topic);
            }
            else if (topic in this.inertialHeadingDataSourceTopicMap) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
            else if (topic in this.positionDataSourceTopicMap) {
                this.onPositionTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onHeadingTopicSubscribed(topic) {
        this.headingDataSubs.push(this.dataSourceSubscriber.on(this.headingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's attitude data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onAttitudeTopicSubscribed(topic) {
        this.attitudeDataSubs.push(this.dataSourceSubscriber.on(this.attitudeDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isAttitudeDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialTopicSubscribed(topic) {
        this.inertialDataSubs.push(this.dataSourceSubscriber.on(this.inertialDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial/heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialHeadingTopicSubscribed(topic) {
        this.inertialHeadingDataSubs.push(this.dataSourceSubscriber.on(this.inertialHeadingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid || !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onPositionTopicSubscribed(topic) {
        this.positionDataSubs.push(this.dataSourceSubscriber.on(this.positionDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isPositionDataValid));
    }
    /**
     * Publishes the time remaining for full alignment to complete.
     * @param time The time to publish, in seconds, or `null` if full alignment is not in process.
     */
    publishFullAlignTimeRemaining(time) {
        if (time === this.publishedFullAlignTimeRemaining) {
            return;
        }
        this.publishedFullAlignTimeRemaining = time;
        this.publisher.pub(this.fullAlignTimeTopic, time, false, true);
    }
    /**
     * Publishes the time remaining for attitude alignment to complete.
     * @param time The time to publish, in seconds, or `null` if attitude alignment is not in process.
     */
    publishAttitudeAlignTimeRemaining(time) {
        if (time === this.publishedAttitudeAlignTimeRemaining) {
            return;
        }
        this.publishedAttitudeAlignTimeRemaining = time;
        this.publisher.pub(this.attitudeAlignTimeTopic, time, false, true);
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        this.isPowered = isPowered;
        this.setState(isPowered ? AvionicsSystemState.On : AvionicsSystemState.Off);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Off) {
            this.setOperatingMode(IrsSystemOperatingMode.Off);
        }
    }
    /**
     * Sets this system's operating mode.
     * @param mode The operating mode to set.
     */
    setOperatingMode(mode) {
        if (this.operatingMode === mode) {
            return;
        }
        this.operatingMode = mode;
        let resetRealignTime = true;
        let disarmRealign = true;
        switch (mode) {
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                this.fullAlignTime = 0;
                this.attitudeAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.publishAttitudeAlignTimeRemaining(null);
            // fallthrough
            case IrsSystemOperatingMode.AttitudeAlign:
                this.fullAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.publishFullAlignTimeRemaining(0);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Navigation:
                disarmRealign = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Realign:
                this.isAcceptingPosition.set(true);
                resetRealignTime = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
        }
        if (resetRealignTime) {
            this.realignTime = 0;
        }
        if (disarmRealign) {
            this.isRealignArmed = false;
        }
        this.isRealignArmed = false;
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.updateHeadingDataState();
        this.updateAttitudeDataState();
        this.updateInertialDataState();
        this.updateInertialHeadingDataState();
        this.updatePositionDataState();
    }
    /**
     * Updates the validity state of this system's heading data. If heading data is valid, this system will start
     * publishing heading data. If heading data is invalid, this system will stop publishing heading data.
     */
    updateHeadingDataState() {
        // TODO: Heading data requires manual heading input in Attitude mode if the IRS does not have an AHRU component.
        let isHeadingDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isHeadingDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isHeadingDataValid = false;
                break;
            default:
                isHeadingDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isHeadingDataValid !== this.isHeadingDataValid) {
            this.isHeadingDataValid = isHeadingDataValid;
            if (isHeadingDataValid) {
                for (const sub of this.headingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.headingDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's attitude data. If attitude data is valid, this system will start
     * publishing attitude data. If attitude data is invalid, this system will stop publishing attitude data.
     */
    updateAttitudeDataState() {
        let isAttitudeDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isAttitudeDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isAttitudeDataValid = false;
                break;
            default:
                isAttitudeDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isAttitudeDataValid !== this.isAttitudeDataValid) {
            this.isAttitudeDataValid = isAttitudeDataValid;
            if (isAttitudeDataValid) {
                for (const sub of this.attitudeDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.attitudeDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial data. If inertial data is valid, this system will start
     * publishing inertial data. If inertial data is invalid, this system will stop publishing inertial data.
     */
    updateInertialDataState() {
        const isInertialDataValid = this.operatingMode === IrsSystemOperatingMode.Navigation
            || this.operatingMode === IrsSystemOperatingMode.Realign;
        if (isInertialDataValid !== this.isInertialDataValid) {
            this.isInertialDataValid = isInertialDataValid;
            if (isInertialDataValid) {
                for (const sub of this.inertialDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial/heading data. If inertial/heading data is valid, this system
     * will start publishing inertial/heading data. If inertial/heading data is invalid, this system will stop publishing
     * inertial/heading data.
     */
    updateInertialHeadingDataState() {
        const isInertialHeadingDataValid = this.isHeadingDataValid && this.isInertialDataValid;
        if (isInertialHeadingDataValid !== this.isInertialHeadingDataValid) {
            this.isInertialHeadingDataValid = isInertialHeadingDataValid;
            if (isInertialHeadingDataValid) {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.pause();
                }
            }
        }
    }
    /**
     * Updates the validity state of this system's position data. If position data is valid, this system will start
     * publishing position data. If position data is invalid, this system will stop publishing position data.
     */
    updatePositionDataState() {
        const isPositionDataValid = this.isInertialDataValid;
        if (isPositionDataValid !== this.isPositionDataValid) {
            this.isPositionDataValid = isPositionDataValid;
            if (isPositionDataValid) {
                for (const sub of this.positionDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.positionDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.state === AvionicsSystemState.Off) {
            return;
        }
        const simTime = this.simTime.get();
        const dt = this.lastUpdateSimTime === undefined ? 0 : Math.max(0, simTime - this.lastUpdateSimTime);
        this.lastUpdateSimTime = simTime;
        this.updateSimulatedFullAlignDuration();
        const modeSetting = this.operatingModeSetting.get();
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Off:
                this.updateOff(modeSetting);
                break;
            case IrsSystemOperatingMode.Standby:
                this.updateStandby(modeSetting);
                break;
            case IrsSystemOperatingMode.FullAlign:
                this.updateFullAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.updateFullAlignPositionPending(modeSetting);
                break;
            case IrsSystemOperatingMode.Navigation:
                this.updateNavigation(modeSetting);
                break;
            case IrsSystemOperatingMode.Realign:
                this.updateRealign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.AttitudeAlign:
                this.updateAttitudeAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.updateAttitude(modeSetting);
                break;
        }
    }
    /**
     * Updates the simulated time required to complete a full alignment.
     */
    updateSimulatedFullAlignDuration() {
        // 5 min at equator, 17 min at 70 degrees latitude
        this.simulatedFullAlignDuration.set(MathUtils.lerp(Math.cos(this.position.get().lat * Avionics.Utils.DEG2RAD), 1, 0.342, 300e3, 1020e3, true, true));
    }
    /**
     * Attempts to start a new full or attitude alignment cycle.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @returns Whether a new alignment cycle was started.
     */
    tryStartFreshAlign(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isOnGround.get()) {
                    if (this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                        return true;
                    }
                }
                else if (this.supportInFlightAlign && this.isGpsAvailable && this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
                    this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                    return true;
                }
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                return true;
        }
        return false;
    }
    /**
     * Updates this system while it is in the Off operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateOff(modeSetting) {
        if (this.tryStartFreshAlign(modeSetting)) {
            return;
        }
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                break;
            default:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
        }
    }
    /**
     * Updates this system while it is in the Standby operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateStandby(modeSetting) {
        this.tryStartFreshAlign(modeSetting);
    }
    /**
     * Updates this system while it is in the FullAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateFullAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                if (this.attitudeAlignTime >= IrsSystem.ATTITUDE_ALIGN_DURATION) {
                    this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                }
                else {
                    this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                }
                return;
        }
        let isInFlightAlign = false;
        if (this.isOnGround.get()) {
            this.isAcceptingPosition.set(true);
            if (this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
                this.fullAlignTime = 0;
            }
        }
        else if (!this.supportInFlightAlign || !this.isGpsAvailable || !this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
            this.setOperatingMode(IrsSystemOperatingMode.Standby);
            return;
        }
        else {
            this.isAcceptingPosition.set(false);
            isInFlightAlign = true;
        }
        this.attitudeAlignTime += dt;
        this.fullAlignTime += dt;
        const fullAlignDuration = this.fullAlignDuration.get();
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration
            && (!this.isAttitudeDataValid || !this.isHeadingDataValid)) {
            this.updateAttitudeDataState();
            this.updateHeadingDataState();
        }
        if (this.fullAlignTime >= fullAlignDuration) {
            if (this.isPositionInit.get() || isInFlightAlign) {
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            }
            else {
                this.setOperatingMode(IrsSystemOperatingMode.FullAlignPositionPending);
            }
        }
        else {
            if (this.attitudeAlignTime >= attitudeAlignDuration) {
                this.publishAttitudeAlignTimeRemaining(null);
            }
            else {
                this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
            }
            this.publishFullAlignTimeRemaining((fullAlignDuration - this.fullAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the FullAlignPositionPending operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateFullAlignPositionPending(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        if (this.isPositionInit.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the Navigation operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateNavigation(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.isAcceptingPosition.set(true);
                this.isRealignArmed = true;
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isRealignArmed) {
                    // Realignment requires the airplane be on the ground and not moving.
                    if (this.isOnGround.get() && this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.Realign);
                        return;
                    }
                    else {
                        this.isRealignArmed = false;
                    }
                }
                this.isAcceptingPosition.set(false);
                break;
        }
    }
    /**
     * Updates this system while it is in the Realign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateRealign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        // Realignment requires the airplane be on the ground and not moving.
        if (!this.isOnGround.get() || this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            return;
        }
        this.realignTime += dt;
        if (this.realignTime >= this.realignDuration.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the AttitudeAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateAttitudeAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                return;
        }
        this.attitudeAlignTime += dt;
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration) {
            this.setOperatingMode(IrsSystemOperatingMode.Attitude);
        }
        else {
            this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the Attitude operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateAttitude(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                break;
        }
    }
}
IrsSystem.ATTITUDE_ALIGN_DURATION = 30000; // milliseconds
IrsSystem.REALIGN_DURATION = 30000; // milliseconds
IrsSystem.ALIGN_SPEED_THRESHOLD = 1; // meters per second

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best IRS from a set of candidates based on the current states of all systems. System state
 * desiribility is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class IrsSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the IRS systems from which to select.
     * @param systemPriorities The priorities for selecting individual IRS systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of IRS system indexes or a map of
     * IRS system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isAttitudeDataValid = Subject.create(false);
        this.isHeadingDataValid = Subject.create(false);
        this.isInertialDataValid = Subject.create(false);
        this.isInertialHeadingDataValid = Subject.create(false);
        this.isPositionDataValid = Subject.create(false);
        this.irsEntries = new Map();
        this.irsOrder = [];
        this.irsComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `irs_selector_selected_index_${index}`), true);
        this.isAttitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_attitude_data_valid_${index}`), true);
        this.isHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_heading_data_valid_${index}`), true);
        this.isInertialDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_data_valid_${index}`), true);
        this.isInertialHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_heading_data_valid_${index}`), true);
        this.isPositionDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_position_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.irsEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`irs_attitude_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_heading_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_inertial_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_position_data_valid_${key}`), false)
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.irsEntries.set(key, entry);
                // When there is a change in an IRS state, we don't reselect immediately because the IRS could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.irsEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the IRS with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.irsEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.irsEntries.size === 1) {
            const entry = this.irsEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.irsOrder.length = 0;
            for (const index of this.irsEntries.keys()) {
                this.irsOrder.push(index);
            }
            this.irsOrder.sort(this.irsComparator);
            bestIndex = -1;
            for (let i = 0; i < this.irsOrder.length; i++) {
                const index = this.irsOrder[i];
                const state = this.irsEntries.get(index).state.get();
                if (!bestState || IrsSystemSelector.compareIrsState(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isAttitudeDataValid.set(bestState[0]);
            this.isHeadingDataValid.set(bestState[1]);
            this.isInertialDataValid.set(bestState[2]);
            this.isInertialHeadingDataValid.set(bestState[1] && bestState[2]);
            this.isPositionDataValid.set(bestState[3]);
        }
        else {
            this.isAttitudeDataValid.set(false);
            this.isHeadingDataValid.set(false);
            this.isInertialDataValid.set(false);
            this.isInertialHeadingDataValid.set(false);
            this.isPositionDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.irsEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
    /**
     * Compares two IRS states and returns a number whose sign indicates which one is more desirable.
     * @param a The first IRS state to compare.
     * @param b The second IRS state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareIrsState(a, b) {
        // The data validity flags within the state array are ordered such that a false flag cannot precede a true flag,
        // so we can exploit this fact.
        return b.lastIndexOf(true) - a.lastIndexOf(true);
    }
}

/**
 * The GMU44 magnetometer system.
 */
class MagnetometerSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the MagnetometerSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `magnetometer_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.initializationTime = 5000;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
}

/**
 * The Radio Altimeter system.
 */
class RASystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the RASystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param radioAltOffset The radio altimeter offset.
     * @param powerSource The power source.
     */
    constructor(index, bus, radioAltOffset, powerSource) {
        super(index, bus, `ra_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.radioAltOffset = radioAltOffset;
        this.powerSource = powerSource;
        this.initializationTime = 7000;
        const radioAltTopic = `ra_radio_alt_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's radar altitude data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `ra_radio_alt_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.radioAltSub = this.bus.getSubscriber().on('radio_alt').atFrequency(3).handle(val => {
            this.publisher.pub(topic, val + this.radioAltOffset);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.radioAltSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.radioAltSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

/** A class to publish events related to all IRS systems as a whole. */
class IrsSystemGroupStatusPublisher {
    /** @inheritDoc */
    constructor(bus, irsCount) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        const sub = bus.getSubscriber();
        MappedSubject.create(modes => {
            for (let i = 0; i < modes.length; i++) {
                if (modes[i] !== IrsSystemOperatingMode.Navigation && modes[i] !== IrsSystemOperatingMode.Realign) {
                    return false;
                }
            }
            return true;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_operating_mode_${index + 1}`), IrsSystemOperatingMode.Off))).sub(allOperating => this.publisher.pub('all_irs_systems_operating', allOperating), true);
        const anIrsIsAcceptingPos = MappedSubject.create(irsSystemIsAcceptingPos => {
            for (let i = 0; i < irsSystemIsAcceptingPos.length; i++) {
                if (irsSystemIsAcceptingPos[i]) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_is_accepting_position_${index + 1}`), false)));
        const anIrsIsRequestingPos = MappedSubject.create(irsSystemIsRequestingPos => {
            for (let i = 0; i < irsSystemIsRequestingPos.length; i++) {
                if (irsSystemIsRequestingPos[i]) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_is_requesting_position_${index + 1}`), false)));
        anIrsIsAcceptingPos.sub(acceptingPos => this.publisher.pub('an_irs_is_accepting_pos', acceptingPos), true);
        anIrsIsRequestingPos.sub(requestingPos => this.publisher.pub('an_irs_is_requesting_pos', requestingPos), true);
        MappedSubject.create(([isAccepting, isRequesting]) => isAccepting || isRequesting, anIrsIsAcceptingPos, anIrsIsRequestingPos).sub(accOrReqPos => this.publisher.pub('an_irs_is_accepting_or_requesting_pos', accOrReqPos), true);
        const anIrsIsOperating = MappedSubject.create((irsOperatingMode) => {
            for (let i = 0; i < irsOperatingMode.length; i++) {
                if (irsOperatingMode[i] === IrsSystemOperatingMode.Navigation || irsOperatingMode[i] === IrsSystemOperatingMode.Realign) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_operating_mode_${index + 1}`), IrsSystemOperatingMode.Navigation)));
        anIrsIsOperating.sub(isAnyOperating => this.publisher.pub('an_irs_system_is_operating', isAnyOperating), true);
        const maxIrsAlignSecondsRemaining = MappedSubject.create((irsFullAlignSecondsRemaining) => {
            let maxSeconds = null;
            for (let i = 0; i < irsFullAlignSecondsRemaining.length; i++) {
                const remaining = irsFullAlignSecondsRemaining[i];
                if (remaining !== null) {
                    if (maxSeconds === null || remaining > maxSeconds) {
                        maxSeconds = remaining;
                    }
                }
            }
            return maxSeconds;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_full_align_time_remaining_${index + 1}`), null)));
        maxIrsAlignSecondsRemaining.sub(maxRemaining => this.publisher.pub('max_irs_align_seconds_remaining', maxRemaining), true);
        const minIrsAlignSecondsRemaining = MappedSubject.create((irsFullAlignSecondsRemaining) => {
            let minSeconds = null;
            for (let i = 0; i < irsFullAlignSecondsRemaining.length; i++) {
                const remaining = irsFullAlignSecondsRemaining[i];
                if (remaining !== null) {
                    if (minSeconds === null || remaining < minSeconds) {
                        minSeconds = remaining;
                    }
                }
            }
            return minSeconds;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_full_align_time_remaining_${index + 1}`), null)));
        minIrsAlignSecondsRemaining.sub(minRemaining => this.publisher.pub('min_irs_align_seconds_remaining', minRemaining), true);
        const anIrsIsAligning = maxIrsAlignSecondsRemaining.map(x => x !== null);
        anIrsIsAligning.sub(isAligning => this.publisher.pub('an_irs_is_aligning', isAligning), true);
    }
}

/**
 * A publisher of Boeing airplane speed limits.
 *
 * The publisher requires a functioning `AdcSystem` and `AoaSystem` and that the topics defined by
 * `ControlSurfacesEvents` and `FlapComputerEvents` are published to the event bus.
 */
class SpeedLimitPublisher extends BasePublisher {
    /**
     * Creates a new instance of SpeedLimitPublisher.
     * @param bus The event bus to which to publish.
     * @param speedProvider A provider of airplane reference speed data.
     * @param aoaIndex The index of the AoA system that is the source of this publisher's data.
     * @param adcIndex The index of the ADC system that is the source of this publisher's data.
     * @param stickShakerNormAoa The normalized angle of attack at which the stick shaker activates. Defaults to 0.95.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, speedProvider, aoaIndex, adcIndex, stickShakerNormAoa = 0.95, pacer) {
        super(bus, pacer);
        this.speedProvider = speedProvider;
        this.stickShakerNormAoa = stickShakerNormAoa;
        this.isOnGround = ConsumerValue.create(null, false).pause();
        this.zeroLiftAoa = ConsumerValue.create(null, 0).pause();
        this.stallAoa = ConsumerValue.create(null, 0).pause();
        this.normAoa = ConsumerValue.create(null, 0).pause();
        this.ias = ConsumerValue.create(null, 0).pause();
        this.pressureAltitude = ConsumerValue.create(null, 0).pause();
        this.machToKiasFactorSource = ConsumerValue.create(null, 1).pause();
        this.machToKiasFactorSmoother = new ExpSmoother(SpeedLimitPublisher.MACH_KIAS_SMOOTHING_TAU);
        this.aoaCoefSmoother = new ExpSmoother(SpeedLimitPublisher.AOA_COEF_SMOOTHING_TAU);
        this.loadFactorSource = ConsumerValue.create(null, 1).pause();
        this.loadFactorSmoother = new ExpSmoother(SpeedLimitPublisher.LOAD_FACTOR_SMOOTHING_TAU);
        this.gearPosition = ConsumerValue.create(null, 0).pause();
        this.flapSpeedLimit = ConsumerValue.create(null, 0).pause();
        this.aoaSystemState = ConsumerValue.create(null, undefined).pause();
        this.adcSystemState = ConsumerValue.create(null, undefined).pause();
        this.pauseable = [
            this.isOnGround,
            this.zeroLiftAoa,
            this.stallAoa,
            this.normAoa,
            this.ias,
            this.pressureAltitude,
            this.machToKiasFactorSource,
            this.loadFactorSource,
            this.gearPosition,
            this.flapSpeedLimit,
            this.aoaSystemState,
            this.adcSystemState
        ];
        this.isAltBelow20k = false;
        this.lastUpdateTime = undefined;
        this.aoaIndex = SubscribableUtils.toSubscribable(aoaIndex, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        const sub = bus.getSubscriber();
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.aoaIndex.sub(index => {
            this.zeroLiftAoa.setConsumer(sub.on(`aoa_zero_lift_aoa_${index}`));
            this.stallAoa.setConsumer(sub.on(`aoa_stall_aoa_${index}`));
            this.normAoa.setConsumer(sub.on(`aoa_norm_aoa_${index}`));
            this.loadFactorSource.setConsumer(sub.on(`aoa_load_factor_${index}`));
            this.aoaSystemState.setConsumer(sub.on(`aoa_state_${index}`));
        }, true);
        this.adcIndex.sub(index => {
            this.ias.setConsumer(sub.on(`adc_ias_${index}`));
            this.machToKiasFactorSource.setConsumer(sub.on(`adc_mach_to_kias_factor_${index}`));
            this.pressureAltitude.setConsumer(sub.on(`adc_pressure_alt_${index}`));
            this.adcSystemState.setConsumer(sub.on(`adc_state_${index}`));
        }, true);
        this.gearPosition.setConsumer(sub.on('gear_position_2'));
        this.flapSpeedLimit.setConsumer(sub.on('flap_computer_interpolated_limit_speed'));
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
        this.lastUpdateTime = undefined;
        this.machToKiasFactorSmoother.reset();
        this.aoaCoefSmoother.reset();
        this.loadFactorSmoother.reset();
        this.isAltBelow20k = false;
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isPublishing()) {
            return;
        }
        const time = Date.now();
        const dt = this.lastUpdateTime === undefined ? 0 : Math.max(0, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
        const pressureAlt = this.pressureAltitude.get();
        // ------- Maximum speed -------
        // Maximum speed is defined as the lowest of Vmo, Mmo, landing gear placard speed (if extended), and placard speed
        // for the current flaps setting.
        const vmo = this.speedProvider.getVmo(pressureAlt);
        const mmo = this.speedProvider.getMmo();
        const flapLimit = this.flapSpeedLimit.get();
        const gearLimit = this.speedProvider.getGearLimitSpeed();
        let maxIas = Math.min(vmo, mmo * this.machToKiasFactorSmoother.next(this.machToKiasFactorSource.get(), dt), flapLimit < 0 ? Infinity : flapLimit);
        if (gearLimit < maxIas) {
            const gearPosition = this.gearPosition.get();
            maxIas = MathUtils.lerp(gearPosition, 0, 1, maxIas, gearLimit);
        }
        this.publish('speedlimit_max_ias', maxIas);
        // ------- Minimum speed AoA -------
        // Minimum speed is defined as the speed at which stick shaker activation occurs.
        const minSpeedAoa = MathUtils.lerp(this.stickShakerNormAoa, 0, 1, this.zeroLiftAoa.get(), this.stallAoa.get());
        this.publish('speedlimit_min_speed_aoa', minSpeedAoa);
        if (this.isOnGround.get()
            || SpeedLimitPublisher.isSystemFailed(this.aoaSystemState.get())
            || SpeedLimitPublisher.isSystemFailed(this.adcSystemState.get())) {
            this.aoaCoefSmoother.reset();
            this.loadFactorSmoother.reset();
            this.publish('speedlimit_min_ias', null);
            this.publish('speedlimit_min_maneuver_ias', null);
            this.publish('speedlimit_stall_ias', null);
            return;
        }
        const normAoa = this.normAoa.get();
        const ias = this.ias.get();
        const iasSquared = ias * ias;
        const coef = normAoa * iasSquared;
        const aoaCoef = this.aoaCoefSmoother.next(coef, dt);
        const loadFactor = this.loadFactorSmoother.next(this.loadFactorSource.get(), dt);
        // ------- Minimum speed -------
        // Minimum speed is defined as the speed at which stick shaker activation occurs.
        const minIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, this.stickShakerNormAoa, 1);
        this.publish('speedlimit_min_ias', isFinite(minIas) ? minIas : null);
        // ------- Minimum maneuvering speed -------
        // Minimum maneuvering speed is defined as the minimum speed at which the airplane can be flown at 1.3g load factor
        // before triggering stick shaker (below 20k feet) or before encountering low speed buffet (above 20k feet).
        let minManeuverIas;
        if (pressureAlt < (this.isAltBelow20k ? 20100 : 19900)) {
            minManeuverIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, this.stickShakerNormAoa, 1.3 / loadFactor);
            this.isAltBelow20k = true;
        }
        else {
            minManeuverIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, 1, 1.3 / loadFactor);
            this.isAltBelow20k = false;
        }
        this.publish('speedlimit_min_maneuver_ias', isFinite(minManeuverIas) ? minManeuverIas : null);
        // ------- Stall speed -------
        const stallIas = SpeedLimitPublisher.estimateIasFromNormAoa(aoaCoef, 1, 1);
        this.publish('speedlimit_stall_ias', isFinite(stallIas) ? stallIas : null);
    }
    /**
     * Estimates an indicated airspeed, in knots, required to maintain a given normalized angle of attack at a specific
     * load factor.
     * @param coef The correlation coefficient between normalized angle of attack and the square of indicated airspeed,
     * such that `k = alpha * v^2`, where `k` is the coefficient, `alpha` is normalized AoA, and `v` is indicated
     * airspeed in knots.
     * @param normAoa The normalized angle of attack at which to estimate the airspeed.
     * @param loadFactorRatio The ratio of the load factor at which to estimate the airspeed to the load factor used to
     * obtain `coef`.
     * @returns The estimatd indicated airspeed, in knots, required to maintain the specified normalized angle of attack
     * at the specified load factor.
     */
    static estimateIasFromNormAoa(coef, normAoa, loadFactorRatio) {
        return Math.sqrt(coef * loadFactorRatio / normAoa);
    }
    /**
     * Checks whether an avionics system state is a failed state.
     * @param state The avionics system state to check.
     * @returns Whether the specified avionics system state is a failed state.
     */
    static isSystemFailed(state) {
        return state === undefined || (state.current !== undefined && state.current !== AvionicsSystemState.On);
    }
}
SpeedLimitPublisher.MACH_KIAS_SMOOTHING_TAU = 1000 / Math.LN2;
SpeedLimitPublisher.AOA_COEF_SMOOTHING_TAU = 2000 / Math.LN2;
SpeedLimitPublisher.LOAD_FACTOR_SMOOTHING_TAU = 2000 / Math.LN2;

// TODO Add FMS LVars to field jsdocs
/** These are the fields that should be exposed by NavSources and NavIndicators.
 * Not all fields will be used by all the different Nav Sources.
 * To add a new field, just add it to NavBaseFields,
 * then add some code to each of the different NavSources to keep that field updated.
 * Don't use this class directly.
 * Every Subject should be able to be set to null, so that when the source is set to null, all the fields cna be nulled.
 * This isn't abstract so that we can instantiate it in one place to help generate setters. */
class NavBaseFields {
    constructor() {
        /** Signal strength received from the reference. A value of zero indicates no signal. */
        this.signalStrength = Subject.create(null);
        /** Always points to the curently tuned station or next waypoint/fix.
         * NAV RADIAL, ADF RADIAL */
        this.bearing = Subject.create(null);
        /** Either points towards the next waypoint (GPS/FMS),
         * displays the course selected by the course knob (VOR),
         * or displays the fixed course of a localizer (ILS).
         * NAV OBS, L:WTAP_LNav_DTK_Mag */
        this.course = Subject.create(null);
        /** The fixed course of a localizer when available (ILS).
         * Is null when `hasLocalizer` is false.
         * Only for NAV source types.
         * NAV LOCALIZER */
        this.localizerCourse = Subject.create(null);
        /** Whether the tuned station is a localizer or not.
         * This can be true even if `hasLocalizer` is false,
         * because this can be based on the frequency alone.
         * Only for NAV source types.
         * NAV LOCALIZER. */
        this.isLocalizer = Subject.create(null);
        /** Whether the nav source is receiving a valid localizer signal.
         * Only for NAV source types.
         * NAV HAS LOCALIZER */
        this.hasLocalizer = Subject.create(null);
        /** DME, distance to the station or next waypoint.
         * Is null when source is NAV and `hasDme` is false.
         * NAV DME, ADF DISTANCE, L:WTAP_LNav_DIS */
        this.distance = Subject.create(null);
        /** Whether the source is receiving a valid DME signal.
         * Only for NAV source types.
         * NAV HAS DME */
        this.hasDme = Subject.create(null);
        /** The ICAO ident of the station or waypoint.
         * NAV IDENT, or flight plan */
        this.ident = Subject.create(null);
        /** Whether the source is receiving a nav signal.
         * Only for NAV source types.
         * NAV HAS NAV. */
        this.hasNav = Subject.create(null);
        /** The active frequency that the nav source is tuned to.
         * Only for NAV and ADF source types.
         * NAV ACTIVE FREQUENCY, ADF ACTIVE FREQUENCY. */
        this.activeFrequency = Subject.create(null);
        /** Normalized and scaled lateral deviation (-1, 1).
         * NAV CDI, L:WTAP_LNav_XTK */
        this.lateralDeviation = Subject.create(null);
        /** Normalized and scaled vertical deviation (-1, 1).
         * NAV GLIDE SLOPE ERROR, L:WTAP_VNav_Vertical_Deviation, L:WTAP_LPV_Vertical_Deviation */
        this.verticalDeviation = Subject.create(null);
        /** Whether the source is receiving glideslope information.
         * Only for NAV source types.
         * NAV HAS GLIDE SLOPE. */
        this.hasGlideSlope = Subject.create(null);
        /** TTG, estimated time remaining until aircraft reaches next fix. // TODO Implement this */
        this.timeToGo = Subject.create(null);
        /** Whether course is pointing TO or FROM the station (VOR),
         * or if the aircraft heading is within 90 degress of the desired track (GPS).
         * NAV TOFROM, // TODO FMS VAR? */
        this.toFrom = Subject.create(null);
        /** The current CDI scale, in nautical miles.
         * Only for GPS source types.
         * L:WTAP_LNav_CDI_Scale */
        this.lateralDeviationScaling = Subject.create(null);
        /** A readable string/enum that shows the name of current scaling being applied to lateral deviation.
         * Only for GPS source types.
         * L:WTAP_LNav_CDI_Scale_Label */
        this.lateralDeviationScalingLabel = Subject.create(null);
    }
}
/** Base class for NavSourceBase and NavIndicator. */
class NavBase extends NavBaseFields {
    /** Creates a Map of setters to make unsubbing and subbing easy. */
    constructor() {
        super();
        /** An automatically generated map of setters to make it easy to set, sub, and unsub,
         * getting around having to call .bind(). */
        this.setters = new Map();
        Object.keys(new NavBaseFields()).forEach((key) => {
            this.setters.set(key, this[key].set.bind(this[key]));
        });
    }
}

/* eslint-disable @typescript-eslint/ban-types */
/** Represent a navigation indicator, like a course needle or bearing pointer.
 * Can only be pointed to 1 nav source at a time.
 * Gives visual components a single thing to subscribe to, while the actual source can be easily changed. */
class NavIndicator extends NavBase {
    /** NavIndicator constructor.
     * @param navSources The possible nav sources that could be pointed to.
     * @param sourceName The initial source to use, if any.
     */
    constructor(navSources, sourceName = null) {
        super();
        this.navSources = navSources;
        this._source = Subject.create(null);
        /** The nav source that is feeding data into the indicator fields.
         * Can only be changed with the {@link setSource} function. */
        this.source = this._source;
        this.setSource(sourceName);
    }
    /** Changes the source of this indicator.
     * All subjects will be republished with the current info from the new source.
     * @param newSourceName Name of new source, if any.
     */
    setSource(newSourceName) {
        const oldSource = this.source.get();
        if (oldSource && oldSource.name === newSourceName) {
            return;
        }
        if (oldSource === null && newSourceName === null) {
            return;
        }
        const newSource = (newSourceName ? this.navSources.get(newSourceName) : null);
        if (oldSource) {
            this.setters.forEach((setter, key) => {
                oldSource[key].unsub(setter);
            });
        }
        this._source.set(newSource);
        if (newSource) {
            this.setters.forEach((setter, key) => {
                newSource[key].sub(setter, true);
            });
        }
        else {
            this.setters.forEach((setter) => {
                setter(null);
            });
        }
    }
}
/** Holds the nav indicators. */
class NavIndicators {
    /** NavIndicators constructor.
     * @param indicators The nav indicators to hold. */
    constructor(indicators = new Map()) {
        this.indicators = indicators;
    }
    /** @inheritdoc */
    init() {
        // todo
    }
    /** @inheritdoc */
    onUpdate() {
        // todo
    }
    /** Gets a nav indicator.
     * @param key The name of the indicator to get.
     * @returns The indicator.
     * @throws Error if indicator not found.
     */
    get(key) {
        const indicator = this.indicators.get(key);
        if (!indicator) {
            throw new Error('no nav indicator exists with given key: ' + key);
        }
        else {
            return indicator;
        }
    }
}

/** Base class for NavSources that are meant to be used by NavIndicators.
 * A NavSource subscribes to SimVars and updates the NavBaseFields accordingly. */
class NavSourceBase extends NavBase {
    /** The NavSourceBase constructor.
     * @param bus The event bus.
     * NavSources need to tell the publisher what to subscribe to.
     * @param name The name of the nav source. Ex: NAV1, ADF, FMS2.
     * @param index The index of the nav source. Ex: 1 for NAV1, or 2 for FMS2, or 1 for ADF.
     */
    constructor(bus, name, index) {
        super();
        this.bus = bus;
        this.name = name;
        this.index = index;
    }
}
// TODO Does this need to be an instrument?
/** Holds the available Nav Sources that NavIndicators can use. */
class NavSources {
    /** NavSources constructor.
     * @param sources The nav sources. */
    constructor(...sources) {
        this.sources = sources;
    }
    /** @inheritdoc */
    init() {
        // TODO
    }
    /** @inheritdoc */
    onUpdate() {
        // TODO
    }
    /** Gets a nav source.
     * @param name Name of source.
     * @returns The source.
     * @throws Error if name not found.
     */
    get(name) {
        const indicator = this.sources.find(x => x.name === name);
        if (!indicator) {
            throw new Error('no nav source exists with given name: ' + name);
        }
        else {
            return indicator;
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/** Represents a NAV radio, subscribes to the NAV SimVars. */
class NavRadioNavSource extends NavSourceBase {
    /** @inheritdoc */
    constructor(bus, name, index) {
        super(bus, name, index);
        this.glideSlopeErrorDegrees = Subject.create(0);
        this.navCdi = Subject.create(0);
        this.navDme = Subject.create(0);
        this.navRadial = Subject.create(0);
        this.updateDistance = () => {
            this.distance.set(this.hasDme.get() ? this.navDme.get() : null);
        };
        this.updateIsLocalizer = () => {
            var _a;
            const navHasLocalizer = this.hasLocalizer.get();
            const _isLocalizerFrequency = RadioUtils.isLocalizerFrequency((_a = this.activeFrequency.get()) !== null && _a !== void 0 ? _a : 0);
            this.isLocalizer.set(navHasLocalizer || _isLocalizerFrequency);
        };
        this.updateVerticalDeviation = () => {
            this.verticalDeviation.set(this.getVerticalDeviation());
        };
        this.updateBearing = () => {
            if (!this.hasNav.get()) {
                this.bearing.set(null);
            }
            else {
                const radialDegrees = this.navRadial.get();
                const bearing = (radialDegrees + 180) % 360;
                this.bearing.set(bearing);
            }
        };
        this.updateLateralDeviation = () => {
            this.lateralDeviation.set(this.getLateralDeviation());
        };
        const navComSubscriber = this.bus.getSubscriber();
        navComSubscriber.on(`nav_signal_${index}`).whenChanged().handle(this.signalStrength.set.bind(this.signalStrength));
        navComSubscriber.on(`nav_dme_${index}`).whenChanged().handle(this.navDme.set.bind(this.navDme));
        navComSubscriber.on(`nav_has_dme_${index}`).whenChanged().handle(this.setters.get('hasDme'));
        navComSubscriber.on(`nav_ident_${index}`).whenChanged().handle(this.setters.get('ident'));
        navComSubscriber.on(`nav_localizer_${index}`).whenChanged().handle(this.setters.get('hasLocalizer'));
        navComSubscriber.on(`nav_gs_error_${index}`).whenChanged().handle(this.glideSlopeErrorDegrees.set.bind(this.glideSlopeErrorDegrees));
        navComSubscriber.on(`nav_glideslope_${index}`).whenChanged().handle(this.setters.get('hasGlideSlope'));
        navComSubscriber.on(`nav_obs_${index}`).whenChanged().handle(this.setters.get('course'));
        navComSubscriber.on(`nav_radial_${index}`).whenChanged().handle(this.navRadial.set.bind(this.navRadial));
        navComSubscriber.on(`nav_cdi_${index}`).whenChanged().handle(this.navCdi.set.bind(this.navCdi));
        navComSubscriber.on(`nav_has_nav_${index}`).whenChanged().handle(this.setters.get('hasNav'));
        navComSubscriber.on(`nav_to_from_${index}`).whenChanged().handle(this.setters.get('toFrom'));
        navComSubscriber.on(`nav_active_frequency_${index}`).whenChanged().handle(this.setters.get('activeFrequency'));
        this.hasDme.sub(this.updateDistance);
        this.navDme.sub(this.updateDistance);
        this.hasLocalizer.sub(this.updateIsLocalizer);
        this.activeFrequency.sub(this.updateIsLocalizer);
        this.hasGlideSlope.sub(this.updateVerticalDeviation);
        this.glideSlopeErrorDegrees.sub(this.updateVerticalDeviation);
        this.navRadial.sub(this.updateBearing);
        this.hasNav.sub(this.updateBearing);
        this.navCdi.sub(this.updateLateralDeviation);
        this.hasNav.sub(this.updateLateralDeviation);
    }
    /** @inheritdoc */
    getType() {
        return NavSourceType.Nav;
    }
    /** @returns Deviation is in degrees, and standard glideslope is 1.4 degrees thick,
     * so the vdev indicator will max out when 0.7 degrees off the GS */
    getVerticalDeviation() {
        if (!this.hasGlideSlope.get()) {
            return null;
        }
        else {
            return this.glideSlopeErrorDegrees.get() / 0.7;
        }
    }
    /** @returns Deviation is in degrees, and standard glideslope is 1.4 degrees thick,
     * so the vdev indicator will max out when 0.7 degrees off the GS */
    getLateralDeviation() {
        if (!this.hasNav.get()) {
            return null;
        }
        else {
            // The NAV CDI simvar holds the deviation as a range from -127 to 127
            return this.navCdi.get() / 127;
        }
    }
}

/** Represents an ADF radio, subscribes to the ADF SimVars. */
class AdfRadioSource extends NavSourceBase {
    /** @inheritdoc */
    constructor(bus, name, index) {
        super(bus, name, index);
        this.heading = Subject.create(0);
        this.adfRadial = Subject.create(0);
        this.adfSignal = Subject.create(0);
        this.updateBearing = () => {
            if (this.adfSignal.get() === 0) {
                this.bearing.set(null);
            }
            else {
                const newBearing = this.adfRadial.get() + this.heading.get();
                this.bearing.set(newBearing);
            }
        };
        const adc = this.bus.getSubscriber();
        adc.on('hdg_deg')
            .withPrecision(2)
            .handle(this.heading.set.bind(this.heading));
        const navComSubscriber = this.bus.getSubscriber();
        navComSubscriber.on(`adf_bearing_${index}`).withPrecision(2).handle(this.adfRadial.set.bind(this.adfRadial));
        navComSubscriber.on(`adf_signal_${index}`).withPrecision(0).handle(this.adfSignal.set.bind(this.adfSignal));
        navComSubscriber.on(`adf_active_frequency_${index}`).whenChanged().handle(this.activeFrequency.set.bind(this.activeFrequency));
        this.adfSignal.pipe(this.signalStrength);
        this.heading.sub(this.updateBearing);
        this.adfRadial.sub(this.updateBearing);
        this.adfSignal.sub(this.updateBearing);
    }
    /** @inheritdoc */
    getType() {
        return NavSourceType.Adf;
    }
}

/**
 * A TCAS II implementation for the Boeing airplanes.
 */
class BoeingTCAS extends Tcas {
    constructor() {
        super(...arguments);
        this.settings = TrafficUserSettings.getManager(this.bus);
        /** All RAs are inhibited when airplane is on ground, or when airplane's radio altitude < 1100ft. */
        this.isRAsInhibited = MappedSubject.create(([radarAlt, isClimbing]) => {
            return radarAlt < (isClimbing ? 900 : 1100);
        }, this.ownAirplaneSubs.radarAltitude.map(radarAlt => Math.round(radarAlt.asUnit(UnitType.FOOT))), this.ownAirplaneSubs.verticalSpeed.map(verticalSpeed => verticalSpeed.number >= 0));
    }
    /** @inheritdoc */
    init() {
        super.init();
        this.settings.whenSettingChanged('trafficOperatingMode').handle(mode => {
            switch (mode) {
                case TcasOperatingModeSetting.Standby:
                    this.setOperatingMode(TcasOperatingMode.Standby);
                    break;
                case TcasOperatingModeSetting.TAOnly:
                    this.setOperatingMode(TcasOperatingMode.TAOnly);
                    break;
                case TcasOperatingModeSetting.TA_RA:
                    if (this.isRAsInhibited.get()) {
                        this.setOperatingMode(TcasOperatingMode.TAOnly);
                    }
                    else {
                        this.setOperatingMode(TcasOperatingMode.TA_RA);
                    }
                    break;
            }
        });
        this.isRAsInhibited.sub(isInhibited => {
            if (this.settings.getSetting('trafficOperatingMode').value === TcasOperatingModeSetting.TA_RA) {
                this.setOperatingMode(isInhibited ? TcasOperatingMode.TAOnly : TcasOperatingMode.TA_RA);
            }
        });
    }
    /** @inheritdoc */
    createSensitivity() {
        return new TcasIISensitivity();
    }
    /** @inheritdoc */
    createIntruderEntry(contact) {
        return new DefaultTcasIntruder(contact);
    }
    /** @inheritdoc */
    updateSensitivity() {
        this.sensitivity.updateLevel(this.ownAirplaneSubs.altitude.get(), this.ownAirplaneSubs.radarAltitude.get());
    }
}

/**
 * A default implementation of {@link TcasRaCommandDataProvider}.
 */
class DefaultTcasRaCommandDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tcas The TCAS which from which this data provider sources resolution advisory commands.
     */
    constructor(bus, tcas) {
        this.bus = bus;
        this.tcas = tcas;
        this._raMinVs = Subject.create(null);
        /** @inheritdoc */
        this.raMinVs = this._raMinVs;
        this._raMaxVs = Subject.create(null);
        /** @inheritdoc */
        this.raMaxVs = this._raMaxVs;
        this._raFlyToMinVs = Subject.create(null);
        /** @inheritdoc */
        this.raFlyToMinVs = this._raFlyToMinVs;
        this._raFlyToMaxVs = Subject.create(null);
        /** @inheritdoc */
        this.raFlyToMaxVs = this._raFlyToMaxVs;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = false;
        this.tcasRaSubs = [];
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider has been destroyed.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultTcasRaCommandDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.isPaused = paused;
        const sub = this.bus.getSubscriber();
        const updateRaSpeeds = this.updateRaSpeeds.bind(this);
        updateRaSpeeds();
        this.tcasRaSubs.push(sub.on('tcas_ra_issued').handle(updateRaSpeeds), sub.on('tcas_ra_updated').handle(updateRaSpeeds), sub.on('tcas_ra_canceled').handle(updateRaSpeeds));
        if (paused) {
            this.pause();
        }
    }
    /**
     * Update vertical speeds commanded by TCAS resolution advisories.
     */
    updateRaSpeeds() {
        const host = this.tcas.getResolutionAdvisoryHost();
        if (host.primaryType === TcasResolutionAdvisoryType.Clear) {
            this._raMinVs.set(null);
            this._raMaxVs.set(null);
            this._raFlyToMinVs.set(null);
            this._raFlyToMaxVs.set(null);
            return;
        }
        const minVsFpm = host.minVerticalSpeed.asUnit(UnitType.FPM);
        const maxVsFpm = host.maxVerticalSpeed.asUnit(UnitType.FPM);
        if (host.secondaryType === null) {
            // Single RA
            if (BitFlags.isAll(host.primaryFlags, TcasResolutionAdvisoryFlags.UpSense)) {
                // Upward sense
                this._raMaxVs.set(null);
                this._raMinVs.set(minVsFpm > -100 && minVsFpm < 100 ? -100 : minVsFpm);
            }
            else {
                // Downward sense
                this._raMinVs.set(null);
                this._raMaxVs.set(maxVsFpm > -100 && maxVsFpm < 100 ? 100 : maxVsFpm);
            }
            if (BitFlags.isAny(host.primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
                // Corrective positive
                this._raFlyToMaxVs.set(maxVsFpm);
                this._raFlyToMinVs.set(minVsFpm);
            }
            else if (host.primaryType === TcasResolutionAdvisoryType.ReduceDescent) {
                // Corrective upward negative
                this._raFlyToMinVs.set(-100);
                this._raFlyToMaxVs.set(500);
            }
            else if (host.primaryType === TcasResolutionAdvisoryType.ReduceClimb) {
                // Corrective downward negative
                this._raFlyToMinVs.set(-500);
                this._raFlyToMaxVs.set(100);
            }
            else {
                // Preventative
                this._raFlyToMinVs.set(null);
                this._raFlyToMaxVs.set(null);
            }
        }
        else {
            // Composite RA
            const minVs = minVsFpm > -100 && minVsFpm < 100 ? -100 : minVsFpm;
            const maxVs = maxVsFpm > -100 && maxVsFpm < 100 ? 100 : maxVsFpm;
            this._raMinVs.set(minVs);
            this._raMaxVs.set(maxVs);
            if (host.primaryType === TcasResolutionAdvisoryType.ReduceDescent) {
                // Corrective upward negative primary
                this._raFlyToMinVs.set(-100);
                this._raFlyToMaxVs.set(Math.min(maxVs, 500));
            }
            else if (host.primaryType === TcasResolutionAdvisoryType.ReduceClimb) {
                // Corrective downward negative primary
                this._raFlyToMinVs.set(Math.max(minVs, -500));
                this._raFlyToMaxVs.set(100);
            }
            else {
                // Preventative primary
                this._raFlyToMinVs.set(null);
                this._raFlyToMaxVs.set(null);
            }
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultTcasRaCommandDataProvider: cannot resume a dead provider');
        }
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this.updateRaSpeeds();
        this.tcasRaSubs.forEach(sub => { sub.resume(); });
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultTcasRaCommandDataProvider: cannot pause a dead provider');
        }
        if (this.isPaused) {
            return;
        }
        this.tcasRaSubs.forEach(sub => { sub.pause(); });
        this.isPaused = true;
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        this.tcasRaSubs.forEach(sub => { sub.destroy(); });
    }
}

/**
 * A controller which manages the state of an altitude alert.
 */
class BoeingAltitudeAlertController {
    /**
     * Creates an instance of BoeingAltitudeAlertController.
     * @param bus The event bus.
     * @param performancePlan The active performance plan.
     * @param altimeterDataProvider A provider of altimeter data.
     */
    constructor(bus, performancePlan, altimeterDataProvider) {
        this.bus = bus;
        this.performancePlan = performancePlan;
        this.altimeterDataProvider = altimeterDataProvider;
        this.alerterState = Subject.create(AltAlertState.DISABLED);
        this.alertPublisher = this.bus.getPublisher();
        this.debounce = new DebounceTimer();
        this.inApproachLock = Subject.create(false);
        this.flapsPosition = Subject.create(0);
        this.isGearDown = Subject.create(false);
        this.isApproachMode = this.getIsApproachModeSubscribable();
        this.altitude = 0;
        this.targetAltitude = 0;
        this.isOnGround = true;
        const adc = this.bus.getSubscriber();
        const ap = this.bus.getSubscriber();
        const controlSurfaces = this.bus.getSubscriber();
        const consumer = this.bus.getSubscriber().on('fma_data');
        consumer.handle(newFmaState => {
            this.inApproachLock.set((newFmaState === null || newFmaState === void 0 ? void 0 : newFmaState.verticalActive) === APVerticalModes.GS || (newFmaState === null || newFmaState === void 0 ? void 0 : newFmaState.verticalActive) === APVerticalModes.GP);
        });
        adc.on('on_ground').whenChanged().handle((g) => {
            this.isOnGround = g;
            if (this.isOnGround) {
                this.alerterState.set(AltAlertState.DISABLED);
                this.updateAltitudeAlerter();
            }
        });
        this.altimeterDataProvider.isAdcDataFailed.sub(isDataFailed => {
            if (isDataFailed) {
                this.alerterState.set(AltAlertState.DISABLED);
                this.updateAltitudeAlerter();
            }
        });
        this.altimeterDataProvider.indicatedAltitude.map(SubscribableMapFunctions.withPrecision(10)).sub(this.updateAltitudeAlerter.bind(this));
        ap.on('ap_altitude_selected_3').whenChanged().handle((v) => {
            this.targetAltitude = Math.round(v);
            this.alerterState.set(AltAlertState.DISABLED);
            this.updateAltitudeAlerter();
        });
        controlSurfaces.on('gear_position').whenChanged().handle((v) => {
            this.isGearDown.set(v === 1);
        });
        controlSurfaces.on('flaps_handle_index').whenChanged().handle((v) => {
            this.flapsPosition.set(v);
        });
        this.alerterState.sub((v) => {
            this.alertPublisher.pub('altitude_alert', v, false, true);
            if (v === AltAlertState.DISABLED) {
                const armFn = (timeout) => {
                    this.debounce.schedule(() => {
                        if (this.canArm()) {
                            this.alerterState.set(AltAlertState.ARMED);
                            this.updateAltitudeAlerter();
                        }
                        else {
                            armFn(1000);
                        }
                    }, timeout);
                };
                armFn(3000);
            }
        }, true);
    }
    /**
     * A method called to update the altitude alerter
     * @param altitude The current altitude
     * @private
     */
    updateAltitudeAlerter(altitude) {
        if (altitude) {
            this.altitude = altitude;
        }
        if (!this.canArm()) {
            this.alerterState.set(AltAlertState.DISABLED);
        }
        const deltaAlt = Math.abs(this.targetAltitude - this.altitude);
        switch (this.alerterState.get()) {
            case AltAlertState.DISABLED:
                break;
            case AltAlertState.ARMED:
                if (deltaAlt < 100) {
                    this.alerterState.set(AltAlertState.CAPTURED);
                }
                else if (deltaAlt < 200) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                else if (deltaAlt < 900) {
                    this.alerterState.set(AltAlertState.WITHIN_900);
                }
                break;
            case AltAlertState.WITHIN_200:
                if (deltaAlt <= 100) {
                    this.alerterState.set(AltAlertState.CAPTURED);
                }
                else if (deltaAlt > 200) {
                    this.alerterState.set(AltAlertState.WITHIN_900);
                }
                break;
            case AltAlertState.WITHIN_900:
                if (deltaAlt <= 200) {
                    this.alerterState.set(AltAlertState.WITHIN_200);
                }
                else if (deltaAlt > 900) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                break;
            case AltAlertState.CAPTURED:
                if (deltaAlt > 200) {
                    this.alerterState.set(AltAlertState.DEVIATION_200);
                }
                break;
            case AltAlertState.DEVIATION_200:
                if (deltaAlt <= 200 || deltaAlt > 900) {
                    this.alerterState.set(AltAlertState.ARMED);
                }
                break;
        }
    }
    /**
     * A method called to determine if we can arm the alerter
     * @returns boolean
     */
    canArm() {
        return (!this.isOnGround && !this.isApproachMode.get() && !isNaN(this.targetAltitude) && !this.altimeterDataProvider.isAdcDataFailed.get());
    }
}

/** Stores wind data associated with a flightplan */
class WindPlan {
    /**
     * Constructs a new WindPlan
     * @param options Options for the WindPlanner
     * @param numberOfLegs Number of legs to initialise the plan with (will be filled with empty data)
     */
    constructor(options, numberOfLegs = 0) {
        this.options = options;
        this.climbData = [];
        this.descentData = [];
        /** Maps global flight plan leg index to wind records */
        this.legWindData = [];
        /** Maps global flight plan leg index to temparture records */
        this.legTemperatureData = [];
        if (numberOfLegs > 0) {
            this.legWindData = Array.from({ length: numberOfLegs }, () => []);
        }
    }
    /**
     * Set wind for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature !== null;
            this.refreshTemperaturePropagation(this.climbData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Deletes a climb wind record
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(altitude) {
        const deleteIndex = this.climbData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.climbData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the climb wind records for a flight plan
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures() {
        return this.climbData;
    }
    /**
     * Set wind for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfDescentAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setDescentTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature === null;
            this.refreshTemperaturePropagation(this.descentData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.descentData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Deletes a descent wind record
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWind(altitude) {
        const deleteIndex = this.descentData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.descentData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the descent wind records for a flight plan
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures() {
        return this.descentData;
    }
    /**
     * Deletes the record for a leg (when the leg is deleted from the flightplan)
     * @param globalLegIndex Index of leg in entire flight plan
     */
    deleteLeg(globalLegIndex) {
        // Does not removed propagated data from other legs... may need an option for this later with other FMS types
        if (this.legWindData[globalLegIndex]) {
            this.legWindData.splice(globalLegIndex, 1);
        }
        if (this.legTemperatureData[globalLegIndex]) {
            this.legTemperatureData.splice(globalLegIndex, 1);
        }
    }
    /**
     * Inserts a new flight plan leg and propagates data from existing legs
     * @param globalLegIndex Index of leg in entire flight plan
     */
    insertLegAndPropagate(globalLegIndex) {
        this.legWindData.splice(globalLegIndex, 0, []);
        const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : 0;
        const propagationData = this.legWindData[propagationIndex];
        if (propagationData) {
            const records = propagationData.map(({ altitude, direction, speed }) => ({ altitude, direction, speed, windPropagated: true }));
            this.legWindData.splice(globalLegIndex, 0, records);
        }
        else {
            this.legWindData.splice(globalLegIndex, 0, []);
        }
        const tempData = this.legTemperatureData[propagationIndex];
        if (tempData) {
            this.legTemperatureData.splice(globalLegIndex, 0, Object.assign(Object.assign({}, tempData), { temperaturePropagated: true }));
        }
    }
    /**
     * Check if all the available leg altitudes are already used
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed() {
        if (this.legWindData.length === 0 || this.options.numberOfLegAltitudes === undefined) {
            return false;
        }
        const windData = this.legWindData[0];
        return windData.length >= this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.legWindData[globalLegIndex]) === null || _a === void 0 ? void 0 : _a.some((record) => record.windPropagated === false)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(globalLegIndex, altitude, speed, direction) {
        var _a, _b, _c, _d;
        const windData = this.legWindData[globalLegIndex];
        if (windData === undefined) {
            return false;
        }
        /** index of existing record for this altitude (same in all legs) */
        const existingRecordIndex = (_a = windData === null || windData === void 0 ? void 0 : windData.findIndex((v) => v.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (existingRecordIndex < 0 && isFinite((_b = this.options.numberOfLegAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
            if (((_c = windData === null || windData === void 0 ? void 0 : windData.length) !== null && _c !== void 0 ? _c : 0) >= ((_d = this.options.numberOfLegAltitudes) !== null && _d !== void 0 ? _d : Infinity)) {
                return false;
            }
        }
        if (existingRecordIndex >= 0 && windData) {
            const existingRecord = windData[existingRecordIndex];
            existingRecord.altitude = altitude;
            existingRecord.speed = speed;
            existingRecord.direction = direction;
            existingRecord.windPropagated = false;
            // propagate backward if needed
            if (this.findNextNonPropagatedLeg(globalLegIndex, altitude, -1) < 0) {
                this.propagateWind(0, globalLegIndex - 1, windData[existingRecordIndex], existingRecordIndex);
            }
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLeg(globalLegIndex, altitude);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateWind(globalLegIndex + 1, propagateTo, windData[existingRecordIndex], existingRecordIndex);
        }
        else {
            const newRecord = {
                altitude,
                speed,
                direction,
                windPropagated: true,
            };
            this.legWindData.forEach((r, index) => r.push(index === globalLegIndex ? Object.assign(Object.assign({}, newRecord), { windPropagated: speed === null }) : Object.assign({}, newRecord)));
        }
        return true;
    }
    /**
     * Delete an altitude from all leg wind records
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(altitude) {
        this.legWindData.forEach((leg) => {
            const idx = leg.findIndex((r) => r.altitude === altitude);
            if (idx >= 0) {
                leg.splice(idx, 1);
            }
        });
    }
    /**
     * Delete wind at a leg at a given altitude (does not delete this altitude globally)
     * @param globalLegIndex Flight plan leg index
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(globalLegIndex, altitude) {
        var _a;
        const leg = this.legWindData[globalLegIndex];
        const recordIndex = (_a = leg === null || leg === void 0 ? void 0 : leg.findIndex((r) => r.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (recordIndex >= 0 && leg) {
            const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : globalLegIndex + 1;
            const propagationData = this.legWindData[propagationIndex][recordIndex];
            if (propagationData) {
                const record = leg[recordIndex];
                Object.assign(record, propagationData);
                record.windPropagated = true;
            }
            else {
                // we must be the only leg
                this.deleteLegAltitude(altitude);
            }
        }
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(globalLegIndex, altitude, temperature) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            const tempData = this.legTemperatureData[globalLegIndex];
            tempData.altitude = altitude;
            tempData.temperature = temperature;
            tempData.temperaturePropagated = temperature === null;
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, 1);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateTemperature(globalLegIndex + 1, propagateTo, tempData);
            // propagate backward if no non-propagated legs behind
            const prevNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, -1);
            if (prevNonPropagatedLeg < 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
        }
        else {
            const tempData = { altitude, temperature, temperaturePropagated: temperature === null };
            this.legTemperatureData[globalLegIndex] = tempData;
            // no data exists, so we can propagate to all legs
            if (globalLegIndex > 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
            if (globalLegIndex < (this.legWindData.length - 1)) {
                this.propagateTemperature(globalLegIndex + 1, this.legWindData.length - 1, tempData);
            }
        }
        return true;
    }
    /**
     * Deletes a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(globalLegIndex) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            this.legTemperatureData[globalLegIndex].temperature = null;
            // TODO propagate from other leg
        }
    }
    /**
     * Gets a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     * @returns the leg temperature record if it exists, else undefined
     */
    getLegTemperature(globalLegIndex) {
        return this.legTemperatureData[globalLegIndex];
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from
     * @param recordIndex The index of the altitude record to propagate
     */
    propagateWind(fromIndex, toIndex, fromRecord, recordIndex) {
        for (let i = fromIndex; i <= toIndex; i++) {
            const record = this.legWindData[i][recordIndex];
            if (!record.windPropagated) {
                console.warn('Overwriting non-propagated wind record with propagated record at global leg', i);
                record.windPropagated = true;
            }
            record.altitude = fromRecord.altitude;
            record.direction = fromRecord.direction;
            record.speed = fromRecord.speed;
        }
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from.
     * @throws if parameters are incompatible with options
     */
    propagateTemperature(fromIndex, toIndex, fromRecord) {
        for (let i = fromIndex; i <= toIndex; i++) {
            if (this.legTemperatureData[i] === undefined) {
                this.legTemperatureData[i] = Object.assign(Object.assign({}, fromRecord), { temperaturePropagated: true });
            }
            else {
                const record = this.legTemperatureData[i];
                if (!record.temperaturePropagated) {
                    console.warn('Overwriting non-propagated temperature record with propagated record at global leg', i);
                    record.temperaturePropagated = true;
                }
                record.altitude = fromRecord.altitude;
                record.temperature = fromRecord.temperature;
            }
        }
    }
    /**
     * Find the next leg that doesn't have a propagated wind
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLeg(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legWindData.length : i >= 0); i += direction) {
            const legData = this.legWindData[i];
            if (legData.find((w) => w.altitude === altitude && !w.windPropagated)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Find the next leg that doesn't have a propagated temperature
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLegTemperature(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legTemperatureData.length : i >= 0); i += direction) {
            const legData = this.legTemperatureData[i];
            if (!legData.temperaturePropagated) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Get the wind records for a flight plan leg
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(globalLegIndex) {
        return this.legWindData[globalLegIndex];
    }
    /**
     * Get the number of legs in the plan
     * @returns the number of legs in the plan
     */
    get legLength() {
        return this.legWindData.length;
    }
    /**
     * Copy all data from another plan into this one
     * @param fromPlan the plan to copy from
     */
    copyFrom(fromPlan) {
        // TODO make this cheaper by re-using existing objects
        this.climbData = fromPlan.climbData.map((r) => (Object.assign({}, r)));
        this.descentData = fromPlan.descentData.map((r) => (Object.assign({}, r)));
        this.legWindData = fromPlan.legWindData.map((r) => r.map((v) => (Object.assign({}, v))));
        this.legTemperatureData = fromPlan.legTemperatureData.map((r) => (Object.assign({}, r)));
    }
    /**
     * Insert a climb or descent record into the array, taking care of temperature propagation and sorting
     * @param records climb or descent records
     * @param newRecord new record to insert
     */
    insertClimbDescentRecord(records, newRecord) {
        const insertAt = Math.max(0, records.findIndex((r) => r.altitude > newRecord.altitude));
        records.splice(insertAt, 0, newRecord);
        this.refreshTemperaturePropagation(records);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Refresh propagated temperature values for climb and descent from the non-propagated records
     * @param records Climb or Descent records
     */
    refreshTemperaturePropagation(records) {
        var _a;
        const anyNonPropagated = records.some((r) => r.temperaturePropagated === false);
        if (anyNonPropagated) {
            let previousAlt = null;
            let previousTemp = null;
            for (const record of records) {
                if ((_a = record.temperaturePropagated) !== null && _a !== void 0 ? _a : true) {
                    const nextHighestNonPropagated = records.find((r) => r.altitude > record.altitude && r.temperature !== null && r.temperaturePropagated === false);
                    if (nextHighestNonPropagated !== undefined && previousTemp !== null && previousAlt !== null && nextHighestNonPropagated.altitude !== previousAlt) {
                        // we have a temp above and below, interpolate isa delta between them
                        /** proportion of the higher ISA delta to take */
                        const k = (record.altitude - previousAlt) / (nextHighestNonPropagated.altitude - previousAlt);
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + k * isaAbove + (1 - k) * isaBelow;
                    }
                    else if (nextHighestNonPropagated !== undefined) {
                        // we have a temp above but not below, use isaDelta directly
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaAbove;
                    }
                    else if (previousTemp !== null && previousAlt !== null) {
                        // we have a temp below but not above, use isaDelta directly
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaBelow;
                    }
                }
                else {
                    previousAlt = record.altitude;
                    previousTemp = record.temperature;
                }
            }
        }
        else {
            records.forEach((r) => r.temperature = this.isaTemperatureFeet(r.altitude));
        }
    }
}

/** Stores and manages wind plans */
class WindPlanner {
    /**
     * Constructs a WindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.plans = [];
        this.syncPublisher = this.bus.getPublisher();
        this.eventPublisher = this.bus.getPublisher();
        this.ignoreSync = false;
        const fpln = this.bus.getSubscriber();
        fpln.on('fplCreated').handle(this.onPlanCreated.bind(this));
        fpln.on('fplCopied').handle(this.onPlanCopied.bind(this));
        fpln.on('fplLoaded').handle(this.onPlanLoaded.bind(this));
        fpln.on('fplDeleted').handle(this.onPlanDeleted.bind(this));
        fpln.on('fplSegmentChange').handle(this.onSegmentChanged.bind(this));
        fpln.on('fplLegChange').handle(this.onLegChanged.bind(this));
        const sync = this.bus.getSubscriber();
        sync.on('windsync_climb_wind_deleted').handle(this.handleClimbWindDelete.bind(this));
        sync.on('windsync_climb_wind_set').handle(this.handleClimbWindSet.bind(this));
        sync.on('windsync_climb_temperature_set').handle(this.handleClimbTemperatureSet.bind(this));
        sync.on('windsync_descent_wind_deleted').handle(this.handleDescentWindDelete.bind(this));
        sync.on('windsync_descent_wind_set').handle(this.handleDescentWindSet.bind(this));
        sync.on('windsync_descent_temperature_set').handle(this.handleDescentTemperatureSet.bind(this));
        sync.on('windsync_leg_wind_deleted').handle(this.handleLegWindDelete.bind(this));
        sync.on('windsync_leg_altitude_deleted').handle(this.handleLegAltitudeDelete.bind(this));
        sync.on('windsync_leg_wind_set').handle(this.handleLegWindSet.bind(this));
        sync.on('windsync_leg_temperature_deleted').handle(this.handleLegTempDelete.bind(this));
        sync.on('windsync_leg_temperature_set').handle(this.handleLegTempSet.bind(this));
    }
    /**
     * Set wind for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbWindSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a climb wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleClimbWindDelete(ev);
    }
    /**
     * Handles climb wind delete events
     * @param ev the event
     */
    handleClimbWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteClimbWindAndTemperature(ev.altitude);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set temperature for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbTemperatureSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the climb wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getClimbWindsAndTemperatures();
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentWindSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a descent wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDescentWindDelete(ev);
    }
    /**
     * Handles descent wind delete events
     * @param ev the event
     */
    handleDescentWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteDescentWind(ev.altitude);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentTemperatureSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the descent wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getDescentWindsAndTemperatures();
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(planIndex, globalLegIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegWindSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegWind(ev.globalLegIndex, ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg wind record
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(planIndex, globalLegIndex, altitude) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegWindDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegWind(ev.globalLegIndex, ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Deletes all leg wind records for a given altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_altitude_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegAltitudeDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegAltitudeDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegAltitude(ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the wind records for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegWinds(globalLegIndex);
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(planIndex, globalLegIndex, altitude, temperature = null) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegTempSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegTempSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegTemperature(ev.globalLegIndex, ev.altitude, ev.temperature);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg temperature record,
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(planIndex, globalLegIndex) {
        const ev = {
            planIndex,
            globalLegIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegTempDelete(ev);
    }
    /**
     * Handles leg temperature delete events
     * @param ev the event
     */
    handleLegTempDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegTemperature(ev.globalLegIndex);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the temperature record for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns A temperature record if one exists, else undefined
     */
    getLegTemperature(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegTemperature(globalLegIndex);
    }
    /**
     * Handles flight plan creation events
     * @param data Event Data
     */
    onPlanCreated(data) {
        this.plans[data.planIndex] = new WindPlan(this.options);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handle flight plan copy events by copying related wind data
     * @param data Event Data
     */
    onPlanCopied(data) {
        const targetPlan = this.plans[data.targetPlanIndex];
        const fromPlan = this.plans[data.planIndex];
        if (!targetPlan || !fromPlan) {
            console.error('WindPlanner: failed to copy plan!');
            return;
        }
        targetPlan.copyFrom(fromPlan);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handles flight plan load events
     * @param data Event Data
     */
    onPlanLoaded(data) {
        const flightPlan = this.flightPlanner.getFlightPlan(data.planIndex);
        if (!flightPlan) {
            this.plans[data.planIndex] = undefined;
            return;
        }
        this.plans[data.planIndex] = new WindPlan(this.options, flightPlan.length);
    }
    /**
     * Handles flight plan deletion events
     * @param data Event Data
     */
    onPlanDeleted(data) {
        this.plans[data.planIndex] = undefined;
    }
    /**
     * Handles flight plan segment change events
     * @param data Event Data
     */
    onSegmentChanged(data) {
        var _a, _b;
        const windPlan = this.plans[data.planIndex];
        if (!windPlan) {
            return;
        }
        switch (data.type) {
            case SegmentEventType.Removed:
                for (let i = 0; i < ((_b = (_a = data.segment) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0); i++) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    windPlan.deleteLeg(data.segment.offset);
                }
                break;
            case SegmentEventType.Changed:
            // fall through, airway changes don't matter to us
            case SegmentEventType.Added:
            case SegmentEventType.Inserted:
            default:
                // nothing we need to do for these as they don't add or remove legs
                return;
        }
    }
    /**
     * Handles flight plan leg change events
     * @param data Event Data
     */
    onLegChanged(data) {
        const globalLegIndex = WindPlanner.getGlobalLegIndex(this.flightPlanner.getFlightPlan(data.planIndex), data.segmentIndex, data.legIndex);
        const plan = this.plans[data.planIndex];
        if (!plan) {
            console.warn('onLegChanged, but the flightplan doesn\'t exist!');
            return;
        }
        switch (data.type) {
            case LegEventType.Added:
                plan.insertLegAndPropagate(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
            case LegEventType.Removed:
                plan.deleteLeg(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
        }
    }
    /**
     * Get a flight plan or error if it doesn't exist
     * @param planIndex Flight Plan index
     * @throws if flight plan doesn't exist
     * @returns FlightPlan
     */
    getPlan(planIndex) {
        const plan = this.plans[planIndex];
        if (plan === undefined) {
            throw new Error(`WindPlanner: wind plan ${planIndex} does not exist!`);
        }
        return plan;
    }
    /**
     * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param segmentIndex The Segment Index.
     * @param segmentLegIndex The Segment Leg Index.
     * @returns The global leg index.
     */
    static getGlobalLegIndex(lateralPlan, segmentIndex, segmentLegIndex) {
        if (segmentIndex < lateralPlan.segmentCount) {
            const segment = lateralPlan.getSegment(segmentIndex);
            return segment.offset + segmentLegIndex;
        }
        return -1;
    }
    /**
     * Check if all the available leg altitudes are already used
     * @param planIndex Flight Plan index
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed(planIndex) {
        const plan = this.getPlan(planIndex);
        return plan.areAllLegAltitudesUsed();
    }
    /**
     * Get the number of leg wind altitudes permitted
     * @returns the maximum number of leg wind altitudes, or undefined if no limit
     */
    getNumberOfLegAltitudes() {
        return this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.legHasNonPropagatedWind(globalLegIndex);
    }
}

// TODO consider average wind entry instead of individual winds
/** Wind Planner that interpolates live wind data along the route for a Boeing FMS */
class InterpolatingWindPlanner extends WindPlanner {
    /**
     * Constructs an InterpolatingWindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        super(bus, flightPlanner, options);
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.vec2Cache = [Vec2Math.create(), Vec2Math.create(), Vec2Math.create()];
        this.filteredLiveWind = Vec2Math.create();
        /** sim wind direction in degrees true */
        this.liveWindDirection = ConsumerValue.create(null, 0);
        /** sim wind speed in knots */
        this.liveWindSpeed = ConsumerValue.create(null, 0);
        /** plane altitude in feet */
        this.planeAltitude = ConsumerValue.create(null, 0);
        /** plane is on the ground */
        this.onGround = ConsumerValue.create(null, true);
        /** static/outside air temperature in degrees celsius */
        this.staticAirTemperature = ConsumerValue.create(null, 0);
        this.filteredCache = [];
        const sub = this.bus.getSubscriber();
        this.liveWindDirection.setConsumer(sub.on('ambient_wind_direction').withPrecision(0));
        this.liveWindSpeed.setConsumer(sub.on('ambient_wind_velocity').withPrecision(0));
        this.planeAltitude.setConsumer(sub.on('indicated_alt').withPrecision(-2));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.staticAirTemperature.setConsumer(sub.on('ambient_temp_c').withPrecision(0));
        sub.on('simTime').atFrequency(1).handle(this.updateLiveWind.bind(this));
    }
    /** Apply an IIR filter to the live wind */
    updateLiveWind() {
        Vec2Math.setFromPolar(this.liveWindSpeed.get(), UnitType.RADIAN.convertFrom(this.liveWindDirection.get(), UnitType.DEGREE), this.vec2Cache[0]);
        Vec2Math.multScalar(this.vec2Cache[0], 0.1, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 0.9, this.filteredLiveWind);
        Vec2Math.add(this.filteredLiveWind, this.vec2Cache[0], this.filteredLiveWind);
    }
    /**
     * Transform a cartesian wind vector to polar direction/speed
     * @param vector Cartesian wind vector or null if no vector
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    windVectorToDirectionSpeed(vector, out) {
        if (vector === null) {
            return null;
        }
        out[0] = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Vec2Math.theta(vector), UnitType.DEGREE));
        out[1] = Vec2Math.abs(vector);
        return out;
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO Does the Boeing use climb and/or descent wind if no leg winds?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.tryGetLeg(globalLegIndex);
        if (!fpLeg) {
            return null;
        }
        /** Stored in this.vec2Cache[0] */
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        /** proportion of live wind to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        Vec2Math.multScalar(forecastWind, 1 - k, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
        return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedWindAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        const wind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get the wind at a given altitude on a given leg
     * @param windPlan The wind plan to use
     * @param globalLegIndex The global index of the desired leg
     * @param altitude Altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getLegWindAtAltitude(windPlan, globalLegIndex, altitude, out) {
        const legWinds = windPlan.getLegWinds(globalLegIndex);
        if (legWinds === undefined) {
            return null;
        }
        return this.getAltitudeInterpolatedWind(legWinds, altitude, out);
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(climbWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = this.vec2Cache[0][0];
        out[1] = this.vec2Cache[0][1];
        return out;
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedClimbWind(planIndex, altitude, liveWind, out) {
        const wind = this.getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get a descent wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedDescentWind(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const desWinds = windPlan.getDescentWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(desWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = UnitType.RADIAN.convertTo(Vec2Math.theta(this.vec2Cache[0]), UnitType.DEGREE);
        out[1] = Vec2Math.abs(this.vec2Cache[0]);
        return out;
    }
    /**
     * Get the wind at a given altitude from a WindRecord, interpolated when it lies between altitudes for which wind is defined
     * Caution: clobbers first 2 elements of this.vec2Cache
     * @param winds Wind records to use
     * @param altitude Desired altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getAltitudeInterpolatedWind(winds, altitude, out) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < winds.length; i++) {
            const wind = winds[i];
            if (wind.direction !== null && wind.speed !== null) {
                this.filteredCache[index++] = wind;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredWinds = this.filteredCache;
        if (filteredWinds.length < 1) {
            return null;
        }
        if (filteredWinds.length === 1 || altitude >= filteredWinds[0].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[0].speed, UnitType.RADIAN.convertFrom(filteredWinds[0].direction, UnitType.DEGREE), out);
        }
        if (altitude <= filteredWinds[filteredWinds.length - 1].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[filteredWinds.length - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[filteredWinds.length - 1].direction, UnitType.DEGREE), out);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredWinds.length; i++) {
            if (filteredWinds[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper wind to take */
            const k = (altitude - filteredWinds[i].altitude) / (filteredWinds[i - 1].altitude - filteredWinds[i].altitude);
            const windUpper = Vec2Math.setFromPolar(filteredWinds[i - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[i - 1].direction, UnitType.DEGREE), this.vec2Cache[0]);
            const windLower = Vec2Math.setFromPolar(filteredWinds[i].speed, UnitType.RADIAN.convertFrom(filteredWinds[i].direction, UnitType.DEGREE), this.vec2Cache[1]);
            Vec2Math.multScalar(windUpper, k, this.vec2Cache[0]);
            Vec2Math.multScalar(windLower, 1 - k, this.vec2Cache[1]);
            return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
        }
        return null;
    }
    /**
     * Get the ISA delta temperature interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @returns ISA temperature delta in °C or null if no data
     */
    getInterpolatedIsaDeltaAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO use climb and/or descent temp if no leg temp?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.getLeg(globalLegIndex);
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        const legTemp = windPlan.getLegTemperature(globalLegIndex);
        if (legTemp === undefined || legTemp.temperature === null) {
            return null;
        }
        /** proportion of live data to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        const isaTemp = this.isaTemperatureFeet(altitude);
        const interpolatedTemp = k * this.staticAirTemperature.get() + (1 - k) * legTemp.temperature;
        return interpolatedTemp - isaTemp;
    }
    /**
     * Get a climb ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedClimbIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(climbWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get a descent ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedDescentIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const descentWinds = windPlan.getDescentWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(descentWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get the ISA temperature delta at a given altitude from a WindAndTemperatureRecord,
     * interpolated when it lies between altitudes for which temperature is defined
     * @param temps Wind/Temperature records to use
     * @param altitude Desired altitude in feet MSL
     * @returns An ISA delta in °C or null if unavailable
     */
    getAltitudeInterpolatedIsaDelta(temps, altitude) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < temps.length; i++) {
            const temp = temps[i];
            if (temp.temperature !== null) {
                this.filteredCache[index++] = temp;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredTemps = this.filteredCache;
        if (filteredTemps.length < 1) {
            return null;
        }
        if (filteredTemps.length === 1 || altitude >= filteredTemps[0].altitude) {
            return filteredTemps[0].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        else if (altitude <= filteredTemps[filteredTemps.length - 1].altitude) {
            return filteredTemps[filteredTemps.length - 1].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredTemps.length; i++) {
            if (filteredTemps[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper temperature to take */
            const k = (altitude - filteredTemps[i].altitude) / (filteredTemps[i - 1].altitude - filteredTemps[i].altitude);
            // we have filtered out null temps above, but the linter isn't quite smart enough to figure that out
            const upperIsaDelta = filteredTemps[i - 1].temperature - this.isaTemperatureFeet(filteredTemps[i - 1].altitude);
            const lowerIsaDelta = filteredTemps[i].temperature - this.isaTemperatureFeet(filteredTemps[i].altitude);
            return k * upperIsaDelta + (1 - k) * lowerIsaDelta;
        }
        return null;
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a distance from the aircraft
     * @param distance distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportion(distance) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        if (distance < 277800) {
            return 1 - 1 / 3 * (distance / 277800) ** 2;
        }
        return 2 / 3 * (Math.E ** (-5 * ((distance - 277800) / 1852000)));
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a height from the aircraft
     * @param height vertical distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportionHeight(height) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        // 243.045 = 6076.12 feet/NM / (17500 ft / 700 NM), the latter from FMS documentation
        return this.getLiveDataProportion(Math.abs(height) * 243.045);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Calculate the wind speed for the ECON speed calculation.
     * Before takeoff, when planning the flight, this shall be taken from the wind plan.
     * Once flying at cruise flight level, ECON speed controls the AT so we want to base the calculation
     * on the actual live wind.
     * @param planIndex Flight Plan index
     * @param cruiseAltitude Planned cruise altitude
     * @param globalLegIndex Index of active leg
     * @param distanceAlongLeg Distance along the active leg
     * @param trueHeading Heading of the aircraft, degree
     * @returns Headwind component (knots)
     */
    getHeadwindForEconSpeedCalculation(planIndex, cruiseAltitude, globalLegIndex, distanceAlongLeg, trueHeading) {
        // Retrieve planned wind (first wind along leg, if unavailble climb wind).
        let planWind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, distanceAlongLeg, this.vec2Cache[2]);
        if (planWind === null) {
            planWind = this.getInterpolatedClimbWindCartesian(planIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, true, this.vec2Cache[2]);
        }
        if (planWind === null) {
            planWind = this.vec2Cache[2];
            this.vec2Cache[2][0] = 0;
            this.vec2Cache[2][1] = 0;
        }
        // Blend gradually between planned wind and live wind using 100% live wind @(plane alt = cruiseAlt) 
        // and 100% planned wind @(alt deviates 500ft or more from cruise alt):
        const planWindProportion = Math.min(1, Math.abs(cruiseAltitude - this.planeAltitude.get()) / 500);
        Vec2Math.multScalar(planWind, planWindProportion, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 1 - planWindProportion, this.vec2Cache[1]);
        Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        // Create unit vector in heading direction:
        Vec2Math.setFromPolar(1, UnitType.RADIAN.convertFrom(trueHeading, UnitType.DEGREE), this.vec2Cache[1]);
        // The dot product returns the projected length of the wind vector onto the heading (unit) vector:
        return VecNMath.dot(this.vec2Cache[0], this.vec2Cache[1]);
    }
}
InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT = (a, b) => b.altitude - a.altitude;

/**
 * A class that handles aurals coming from panel.xml.
 */
class B78XmlAuralsConfig {
    /**
     * Ctor
     * @param inst The instrument this manager is on.
     * @param logicHost The xml logic host.
     * @param bus The event bus.
     */
    constructor(inst, logicHost, bus) {
        this.soundController = new SoundServerController(bus);
        const warnFactory = new XMLWarningFactory(inst);
        const warnings = warnFactory.parseConfig(inst.xmlConfig);
        this.warningsManager = new WarningManager(warnings, logicHost, () => { }, this.onWarningSound.bind(this));
    }
    /**
     * Start or stop playing a continuour warning sound.
     * @param warning The warning.
     * @param active Whether the warning is turning on or off.
     */
    onWarningSound(warning, active) {
        if (warning.soundId) {
            if (active) {
                this.soundController.startSound(warning.soundId);
            }
            else {
                this.soundController.stop(warning.soundId);
            }
        }
    }
}

/** The state of the minimums controller. */
var MinimumsAlerterState;
(function (MinimumsAlerterState) {
    MinimumsAlerterState[MinimumsAlerterState["DISABLED"] = 0] = "DISABLED";
    MinimumsAlerterState[MinimumsAlerterState["ARMED"] = 1] = "ARMED";
    MinimumsAlerterState[MinimumsAlerterState["ALERTING"] = 2] = "ALERTING";
})(MinimumsAlerterState || (MinimumsAlerterState = {}));
/**
 * A controller for the minimums alert. Publishes the alert state for any minimums and radio minimums to the event bus
 * topics `minimums_alert` and `radio_minimums_alert`, respectively.
 */
class MinimumsAlertController {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.adcSub = this.bus.getSubscriber();
        this.radioAltSub = this.bus.getSubscriber();
        this.alertPublisher = this.bus.getPublisher();
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.bus);
        this.modeSetting = this.cockpitUserSettings.getSetting('minimumsMode');
        this.alertValue = MappedSubject.create(([mode, baroMins, radioMins]) => {
            switch (mode) {
                case MinimumsMode.BARO:
                    return baroMins;
                case MinimumsMode.RA:
                    return radioMins;
                default:
                    return null;
            }
        }, this.modeSetting, this.cockpitUserSettings.getSetting('decisionAltitudeFeet'), this.cockpitUserSettings.getSetting('decisionHeightFeet'));
        this.alerterState = Subject.create(MinimumsAlerterState.DISABLED);
        this.isOnGround = ConsumerSubject.create(this.adcSub.on('on_ground'), true);
        this.planeAltitude = ConsumerSubject.create(null, 0);
        this.bus = bus;
        const updateAlerterState = this.updateAlerterState.bind(this);
        this.modeSetting.sub(this.onModeChanged.bind(this));
        this.alertValue.sub(this.onMinimumsChanged.bind(this));
        this.planeAltitude.sub(updateAlerterState);
        this.isOnGround.sub(updateAlerterState);
        updateAlerterState();
        this.alerterState.sub(this.onAlerterStateChanged.bind(this), true);
    }
    /**
     * Called when the minimums mode changes.
     * @param mode The new minimums mode.
     */
    onModeChanged(mode) {
        this.alerterState.set(MinimumsAlerterState.DISABLED);
        switch (mode) {
            case MinimumsMode.BARO:
                this.planeAltitude.setConsumer(this.adcSub.on('indicated_alt'));
                break;
            case MinimumsMode.RA:
                this.planeAltitude.setConsumer(this.radioAltSub.on('ra_radio_alt_1'));
                break;
            default:
                this.planeAltitude.setConsumer(null);
        }
        this.updateAlerterState();
    }
    /**
     * Called when the minimums value changes.
     */
    onMinimumsChanged() {
        this.alerterState.set(MinimumsAlerterState.DISABLED);
        this.updateAlerterState();
    }
    /**
     * Called when the alerter state changes.
     * @param state The new alerter state.
     */
    onAlerterStateChanged(state) {
        this.alertPublisher.pub('minimums_alert', state === MinimumsAlerterState.ALERTING, false, true);
        this.alertPublisher.pub('radio_minimums_alert', state === MinimumsAlerterState.ALERTING && this.modeSetting.value === MinimumsMode.RA, false, true);
    }
    /**
     * Updates the alert state.
     */
    updateAlerterState() {
        const minimums = this.alertValue.get();
        if (minimums === null || this.isOnGround.get()) {
            this.alerterState.set(MinimumsAlerterState.DISABLED);
            return;
        }
        const altitude = this.planeAltitude.get();
        switch (this.alerterState.get()) {
            case MinimumsAlerterState.DISABLED:
                if (altitude >= minimums + 50) {
                    this.alerterState.set(MinimumsAlerterState.ARMED);
                }
                break;
            case MinimumsAlerterState.ARMED:
                if (altitude < minimums) {
                    this.alerterState.set(MinimumsAlerterState.ALERTING);
                }
                break;
            case MinimumsAlerterState.ALERTING:
                // Reset when:
                // - Plane altitude is above selected minimums (with buffer of 20 ft).
                // - When gear touches ground during landing phase.
                if (altitude >= minimums + 50) {
                    this.alerterState.set(MinimumsAlerterState.ARMED);
                }
                else if (altitude >= minimums + 20) {
                    this.alerterState.set(MinimumsAlerterState.DISABLED);
                }
                break;
        }
    }
}

const efisEventMap = {
    'Mins_INC': 'EFIS.MINS_INC',
    'Mins_DEC': 'EFIS.MINS_DEC',
    'Mins_Press': 'EFIS.MINS_PRESS',
    'Range_INC': 'EFIS.RANGE_INC',
    'Range_DEC': 'EFIS.RANGE_DEC',
    'AUTOPILOT_CTR': 'EFIS.ND_CTR',
    'WXR': 'EFIS.WXR',
    'TFC': 'EFIS.TFC',
    'TERR': 'EFIS.TERR',
    'MTRS': 'EFIS.MTRS',
};
/**
 * The publisher for EFIS panel events.
 */
class EfisEventPublisher extends BasePublisher {
    /**
     * Ctor
     * @param bus The event bus.
     * @param isMfd Whether this instance is on a MFD.
     * @param index The index of the instrument.
     */
    constructor(bus, isMfd, index) {
        super(bus);
        this.isMfd = isMfd;
        this.index = index;
        if (isMfd) {
            this.eventRegx = new RegExp(`AS01B_MFD_${this.index}_(.*)`);
        }
        else {
            // TODO: PFD events have no indexes. Fix Modelbehaviors
            this.eventRegx = /AS01B_PFD_(.*)/;
        }
        this.startPublish();
    }
    /**
     * Handles HEvents to be published as {@link EfisEvent}.
     * @param evt The hevent.
     * @returns True if the event was handled, false otherwise.
     */
    handleHEvent(evt) {
        const matches = evt.match(this.eventRegx);
        if (matches) {
            const efisEvent = efisEventMap[matches[1]];
            if (efisEvent) {
                this.publish(efisEvent, undefined, false, false);
                return true;
            }
        }
        return false;
    }
}

/**
 * Boeing 787 MFD side selections.
 */
var MFD_SIDE_SELECT;
(function (MFD_SIDE_SELECT) {
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["LEFT"] = 0] = "LEFT";
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["RIGHT"] = 1] = "RIGHT";
})(MFD_SIDE_SELECT || (MFD_SIDE_SELECT = {}));
/**
 * Boeing 787 transponder modes.
 */
var B78_XPDR_MODE;
(function (B78_XPDR_MODE) {
    B78_XPDR_MODE[B78_XPDR_MODE["STBY"] = 0] = "STBY";
    B78_XPDR_MODE[B78_XPDR_MODE["ON"] = 1] = "ON";
    B78_XPDR_MODE[B78_XPDR_MODE["TA_Only"] = 2] = "TA_Only";
    B78_XPDR_MODE[B78_XPDR_MODE["TA_RA"] = 3] = "TA_RA";
})(B78_XPDR_MODE || (B78_XPDR_MODE = {}));
/**
 * Boeing 787 hydraulic pump modes.
 */
var B78_HYDRAULIC_PUMP_MODE;
(function (B78_HYDRAULIC_PUMP_MODE) {
    B78_HYDRAULIC_PUMP_MODE[B78_HYDRAULIC_PUMP_MODE["OFF"] = 0] = "OFF";
    B78_HYDRAULIC_PUMP_MODE[B78_HYDRAULIC_PUMP_MODE["AUTO"] = 1] = "AUTO";
    B78_HYDRAULIC_PUMP_MODE[B78_HYDRAULIC_PUMP_MODE["ON"] = 2] = "ON";
})(B78_HYDRAULIC_PUMP_MODE || (B78_HYDRAULIC_PUMP_MODE = {}));
/**
 * Boeing 787 IRS knob states.
 */
var IrsKnobState;
(function (IrsKnobState) {
    IrsKnobState[IrsKnobState["Off"] = 0] = "Off";
    IrsKnobState[IrsKnobState["On"] = 1] = "On";
})(IrsKnobState || (IrsKnobState = {}));
/**
 * Boeing 787 AIR DATA/ATT source select knob states.
 */
var AirDataAttSourceKnobState;
(function (AirDataAttSourceKnobState) {
    AirDataAttSourceKnobState[AirDataAttSourceKnobState["Auto"] = 0] = "Auto";
    AirDataAttSourceKnobState[AirDataAttSourceKnobState["Alternate"] = 1] = "Alternate";
})(AirDataAttSourceKnobState || (AirDataAttSourceKnobState = {}));
/** Boeing 787 Alternate Mode Flap Selector states. */
var B78AlternateFlapSelectorState;
(function (B78AlternateFlapSelectorState) {
    B78AlternateFlapSelectorState[B78AlternateFlapSelectorState["Retract"] = -1] = "Retract";
    B78AlternateFlapSelectorState[B78AlternateFlapSelectorState["Off"] = 0] = "Off";
    B78AlternateFlapSelectorState[B78AlternateFlapSelectorState["Extend"] = 1] = "Extend";
})(B78AlternateFlapSelectorState || (B78AlternateFlapSelectorState = {}));
/**
 * Boeing 787 wing/engine anti-ice knob states.
 */
var AntiIceKnobState;
(function (AntiIceKnobState) {
    AntiIceKnobState[AntiIceKnobState["Off"] = 0] = "Off";
    AntiIceKnobState[AntiIceKnobState["Auto"] = 1] = "Auto";
    AntiIceKnobState[AntiIceKnobState["On"] = 2] = "On";
})(AntiIceKnobState || (AntiIceKnobState = {}));
/**
 * A publisher for Boeing 787 cockpit state data.
 */
class CockpitVarsPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of CockpitVarsPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(new Map([
            ['b78_minimums_mode', { name: 'L:XMLVAR_Mins_Selector_Baro', type: SimVarValueType.Number }],
            ['b78_fpa_mode', { name: 'L:XMLVAR_FPA_MODE_ACTIVE', type: SimVarValueType.Bool }],
            ['b78_trk_mode', { name: 'L:XMLVAR_TRK_MODE_ACTIVE', type: SimVarValueType.Bool }],
            ['b78_fpv_mode', { name: 'L:XMLVAR_FPV_MODE_ACTIVE', type: SimVarValueType.Bool }],
            ['pilot_transmitting', { name: 'PILOT TRANSMITTING', type: SimVarValueType.Bool }],
            ['b78_xpdr_mode', { name: 'L:XMLVAR_Transponder_Mode', type: SimVarValueType.Number }],
            ['b78_apu_knob_state', { name: 'L:XMLVAR_APU_StarterKnob_Pos', type: SimVarValueType.Number }],
            ['b78_hyd_pump_left', { name: 'L:XMLVAR_HYDRAULICS_DEMAND_LEFT', type: SimVarValueType.Number }],
            ['b78_hyd_pump_c1', { name: 'L:XMLVAR_HYDRAULICS_C1', type: SimVarValueType.Number }],
            ['b78_hyd_pump_c2', { name: 'L:XMLVAR_HYDRAULICS_C2', type: SimVarValueType.Number }],
            ['b78_hyd_pump_right', { name: 'L:XMLVAR_HYDRAULICS_DEMAND_RIGHT', type: SimVarValueType.Number }],
            ['b78_elec_cabin_util', { name: 'L:XMLVAR_Utility_Cabin', type: SimVarValueType.Bool }],
            ['b78_elec_ife_seats', { name: 'L:XMLVAR_Utility_Ife', type: SimVarValueType.Bool }],
            ['b78_elec_emer_lights', { name: 'L:XMLVAR_EMER_LIGHTS_ARMED', type: SimVarValueType.Number }],
            ['b78_elec_fddoor_pwr', { name: 'L:XMLVAR_FdDoor_Power', type: SimVarValueType.Bool }],
            ['b78_elec_packsL', { name: 'L:XMLVAR_Packs_L_Switch', type: SimVarValueType.Bool }],
            ['b78_elec_packsR', { name: 'L:XMLVAR_Packs_R_Switch', type: SimVarValueType.Bool }],
            ['b78_trim_airL', { name: 'L:XMLVAR_TrimAir_L', type: SimVarValueType.Bool }],
            ['b78_trim_airR', { name: 'L:XMLVAR_TrimAir_R', type: SimVarValueType.Bool }],
            ['b78_fuel_balance_button_on', { name: 'L:XMLVAR_FuelBalance_Switch_On', type: SimVarValueType.Bool }],
            ['b78_fuel_balance_inhb', { name: 'L:XMLVAR_FuelBalance_Fault', type: SimVarValueType.Bool }],
            ['b78_altn_flaps_arm', { name: 'L:XMLVAR_ALTN_FLAPS_ARMED', type: SimVarValueType.Bool }],
            ['b78_altn_flaps_selector', { name: 'L:XMLVAR_ALTN_FLAPS_SELECTOR', type: SimVarValueType.Number }],
            ['b78_fltdeck_temp_target', { name: 'L:XMLVAR_Heat_FltDeck', type: SimVarValueType.Number }],
            ['b78_cabin_master_temp_target', { name: 'L:XMLVAR_Heat_Cabin', type: SimVarValueType.Number }],
            ['b78_fwd_cargo_temp_target', { name: 'L:XMLVAR_Heat_Cargo', type: SimVarValueType.Number }],
            ['b78_recirc_upper', { name: 'L:XMLVAR_RecircUpper', type: SimVarValueType.Bool }],
            ['b78_recirc_lower', { name: 'L:XMLVAR_FansLower', type: SimVarValueType.Bool }],
            ['b78_equip_cool_fwd', { name: 'L:XMLVAR_Equip_Fwd', type: SimVarValueType.Bool }],
            ['b78_equip_cool_aft', { name: 'L:XMLVAR_Cooling_Aft', type: SimVarValueType.Bool }],
            ['mfd_side_select', { name: 'L:XMLVAR_MFD_Side_#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['mfd_nd_wx_terr_contrast_1', { name: 'L:WT_MFD_1_CONTRAST', type: SimVarValueType.Number }],
            ['mfd_nd_wx_terr_contrast_2', { name: 'L:WT_MFD_2_CONTRAST', type: SimVarValueType.Number }],
            ['pfd_minimap_wx_terr_contrast', { name: 'L:WT_PFD_1_CONTRAST', type: SimVarValueType.Number }],
            ['b78_engine_anti_ice_knob_state', { name: 'L:B787_Engine_AntiIce_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b78_wing_anti_ice_knob_state', { name: 'L:B787_Wing_AntiIce_Knob_State', type: SimVarValueType.Number }],
            ['b78_windshield_deice', { name: 'L:XMLVAR_DeiceWindshield:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['baro_ref_hpa', { name: 'L:XMLVAR_Baro_Selector_HPA_#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b78_irs_knob_state', { name: 'L:B787_IRS_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b78_air_data_att_source_knob_state', { name: 'L:B787_Air_Data_Att_Source_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b78_ext_pwr', { name: 'L:EXT_PWR_COMMANDED:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
        ]), bus);
    }
}

/* eslint-disable max-len */
/**
 * B787-9 Trent 1000-J Engine Data Utility Class.
 */
class B787EngineData {
    /**
     * Creates an instance of B787 Engine Data
     * @param bus The Event Bus.
     * @param performanceData An instance of the BoeingPerformanceDataProvider.
     */
    constructor(bus, performanceData) {
        this.performanceData = performanceData;
        this.engineCount = 2;
        // 20 is best guess, and matches engines.cfg
        this.IDLE_N1 = 20;
        // 96.5 is the highest N1 value found in perf tables.
        // (This is still a best guess as to what maximum rated thrust means, we know max rated is below redline, based on the FCOM)
        this.MAX_RATED_N1 = 96.5;
        // 101.5 from the Trent 1000 series cert docs for Trent engines (LP).
        this.RED_LINE_N1 = 101.5;
        // 58 is best guess from looking at videos.
        this.IDLE_N2 = 58;
        // 103 from the Trent 1000 series cert docs for Trent engines (IP).
        this.RED_LINE_N2 = 103;
        // 700 comes from the Trent 1000 series cert docs.
        this.START_LIMIT_EGT = 700;
        // 850 comes from Trent 1000 series cert docs, EGT Max Continuous max temp C
        this.CONTINUOUS_LIMIT_EGT = 850;
        // 920 comes from Trent 1000 series cert docs, Max over-temp C
        // (we used the highest egt limit in that table)
        this.RED_LINE_EGT = 920;
        this.mach = ConsumerValue.create(null, 0);
        this.sat = ConsumerValue.create(null, 0);
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.tprAltCorrection = new LerpLookupTable([[1, 0], [1.43, 20000], [1.38, 25000], [1.28, 30000], [1.18, 35000], [1.155, 38000], [1.09525, 40000]]);
        this.mach.setConsumer(bus.getSubscriber().on('mach_number').withPrecision(2));
        this.sat.setConsumer(bus.getSubscriber().on('ambient_temp_c').withPrecision(0));
        this.pressureAlt.setConsumer(bus.getSubscriber().on('pressure_alt').withPrecision(0));
    }
    /** @inheritdoc */
    getMaxConN1(pressureAltitude, tat) {
        return B787EngineData.max_con_n1.get(tat, pressureAltitude);
    }
    /** @inheritdoc */
    getMaxConTpr(pressureAltitude, tat) {
        return this.getTprFromN1(this.getMaxConN1(pressureAltitude, tat), tat, pressureAltitude);
    }
    /** @inheritdoc */
    getToMaxTpr(airportPressureAltitude, airportTemp) {
        return this.getTprFromN1(this.getToMaxN1(airportPressureAltitude, airportTemp), airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getToMaxN1(airportPressureAltitude, airportTemp) {
        return B787EngineData.to_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getTo1Tpr(airportPressureAltitude, airportTemp) {
        return this.getTprFromN1(this.getTo1N1(airportPressureAltitude, airportTemp), airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getTo1N1(airportPressureAltitude, airportTemp) {
        const maxTo = this.getToMaxN1(airportPressureAltitude, airportTemp);
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxTo, 0);
        // 10% derate
        const deratedThrustScalar = 0.9 * thrustScalar;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(deratedThrustScalar, 0);
    }
    /** @inheritdoc */
    getTo2Tpr(airportPressureAltitude, airportTemp) {
        return this.getTprFromN1(this.getTo2N1(airportPressureAltitude, airportTemp), airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    getTo2N1(airportPressureAltitude, airportTemp) {
        const maxTo = this.getToMaxN1(airportPressureAltitude, airportTemp);
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxTo, 0);
        // 20% derate
        const deratedThrustScalar = 0.8 * thrustScalar;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(deratedThrustScalar, 0);
    }
    /** @inheritdoc */
    getClbMaxTpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getClbMaxN1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClbMaxN1(pressureAltitude, totalAirTemp) {
        return B787EngineData.clb_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClb1Tpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getClb1N1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClb1N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 5% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxClb, mach);
        const derate = thrustScalar * 0.05 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(thrustScalar - derate, mach);
    }
    /** @inheritdoc */
    getClb2Tpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getClb2N1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getClb2N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 15% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxClb, mach);
        const derate = thrustScalar * 0.15 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(thrustScalar - derate, mach);
    }
    /** @inheritdoc */
    getGaMaxTpr(pressureAltitude, totalAirTemp) {
        return this.getTprFromN1(this.getGaMaxN1(pressureAltitude, totalAirTemp), totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getGaMaxN1(pressureAltitude, totalAirTemp) {
        return B787EngineData.ga_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getCruiseMaxN1(pressureAltitude, totalAirTemp) {
        return B787EngineData.cru_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getOptimumAltitude(aircraftWeight) {
        return Math.min(B787EngineData.alt_opt.get(aircraftWeight), 41000);
    }
    /** @inheritdoc */
    getMaximumAltitude(aircraftWeight) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(this.pressureAlt.get());
        const isaTempC = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const isaDev = this.sat.get() - isaTempC;
        return Math.min(B787EngineData.alt_max.get(aircraftWeight, isaDev), 41000);
    }
    /** @inheritdoc */
    getLongRangeCruiseMach(aircraftWeight, pressureAltitude) {
        return B787EngineData.lrc_mach.get(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    getEconCruiseMach(aircraftWeight, pressureAltitude) {
        return 0.95 * this.getLongRangeCruiseMach(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    getTprFromN1(n1, tat, pressureAltitude) {
        const isaTemp = UnitType.CELSIUS.convertTo(AeroMath.isaTemperature(pressureAltitude), UnitType.KELVIN);
        const deltaIsa = UnitType.CELSIUS.convertTo(tat, UnitType.KELVIN) - isaTemp;
        const rangeScalar = 1.33;
        const densityRatio = isaTemp / (isaTemp + deltaIsa * rangeScalar);
        const maxThrust = this.performanceData.calculateThrustFromCorrectedN1(100, this.mach.get());
        const n1Thrust = this.performanceData.calculateThrustFromCorrectedN1(n1, this.mach.get()) * densityRatio;
        const tpr = (n1Thrust / maxThrust) * 100 * 1.04 * this.tprAltCorrection.get(pressureAltitude);
        return (tpr <= 96) ? tpr : MathUtils.lerp(tpr, 96, 115, 96, 100);
    }
    /** @inheritDoc */
    getTakeoffDeratePercentage(targetN1, maxN1) {
        const targetThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(targetN1, 0);
        const maxThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxN1, 0);
        return (maxThrustScalar - targetThrustScalar) / maxThrustScalar * 100;
    }
}
B787EngineData.to_tpr_max = new LerpLookupTable([
    [50.7, 75, -2000], [50.8, 75, -1000], [50.8, 75, 0], [49.8, 75, 1000], [48.8, 75, 2000], [47.8, 75, 3000], [46.8, 75, 4000], [45.8, 75, 5000], [44.7, 75, 6000],
    [43.2, 75, 7000], [41.7, 75, 8000], [40.2, 75, 9000], [38.6, 75, 10000], [37.1, 75, 11000], [35.5, 75, 12000], [33.6, 75, 13000], [31.7, 75, 14000],
    [54.6, 70, -2000], [54.8, 70, -1000], [55, 70, 0], [54, 70, 1000], [53.1, 70, 2000], [52.2, 70, 3000], [51.3, 70, 4000], [50.3, 70, 5000], [49.3, 70, 6000],
    [47.9, 70, 7000], [46.4, 70, 8000], [44.9, 70, 9000], [43.4, 70, 10000], [42, 70, 11000], [40.4, 70, 12000], [38.5, 70, 13000], [36.6, 70, 14000],
    [58.4, 65, -2000], [58.8, 65, -1000], [59.2, 65, 0], [58.2, 65, 1000], [57.4, 65, 2000], [56.6, 65, 3000], [55.7, 65, 4000], [54.8, 65, 5000], [53.9, 65, 6000],
    [52.5, 65, 7000], [51.1, 65, 8000], [49.7, 65, 9000], [48.2, 65, 10000], [46.8, 65, 11000], [45.3, 65, 12000], [43.4, 65, 13000], [41.5, 65, 14000],
    [62.3, 60, -2000], [62.9, 60, -1000], [63.3, 60, 0], [62.4, 60, 1000], [61.7, 60, 2000], [60.9, 60, 3000], [60.2, 60, 4000], [59.3, 60, 5000], [58.5, 60, 6000],
    [57.2, 60, 7000], [55.8, 60, 8000], [54.4, 60, 9000], [53, 60, 10000], [51.6, 60, 11000], [50.2, 60, 12000], [48.3, 60, 13000], [46.4, 60, 14000],
    [65.9, 55, -2000], [66.8, 55, -1000], [67.5, 55, 0], [66.6, 55, 1000], [66, 55, 2000], [65.3, 55, 3000], [64.6, 55, 4000], [63.9, 55, 5000], [63.1, 55, 6000],
    [61.8, 55, 7000], [60.4, 55, 8000], [59.2, 55, 9000], [57.7, 55, 10000], [56.5, 55, 11000], [55.1, 55, 12000], [53.2, 55, 13000], [51.3, 55, 14000],
    [69.5, 50, -2000], [70.5, 50, -1000], [71.4, 50, 0], [70.7, 50, 1000], [70.2, 50, 2000], [69.7, 50, 3000], [69.1, 50, 4000], [68.4, 50, 5000], [67.7, 50, 6000],
    [66.4, 50, 7000], [65.1, 50, 8000], [63.9, 50, 9000], [62.5, 50, 10000], [61.3, 50, 11000], [60, 50, 12000], [58.1, 50, 13000], [56.2, 50, 14000],
    [72.8, 45, -2000], [74.1, 45, -1000], [75.4, 45, 0], [74.7, 45, 1000], [74.3, 45, 2000], [73.9, 45, 3000], [73.4, 45, 4000], [72.9, 45, 5000], [72.3, 45, 6000],
    [71.1, 45, 7000], [69.8, 45, 8000], [68.6, 45, 9000], [67.3, 45, 10000], [66.1, 45, 11000], [64.9, 45, 12000], [63, 45, 13000], [61.1, 45, 14000],
    [76.1, 40, -2000], [77.6, 40, -1000], [78.9, 40, 0], [78.5, 40, 1000], [78.4, 40, 2000], [78.1, 40, 3000], [77.7, 40, 4000], [77.3, 40, 5000], [76.8, 40, 6000],
    [75.7, 40, 7000], [74.5, 40, 8000], [73.4, 40, 9000], [72.1, 40, 10000], [71, 40, 11000], [69.8, 40, 12000], [67.9, 40, 13000], [66, 40, 14000],
    [79.6, 35, -2000], [81.2, 35, -1000], [82.7, 35, 0], [82.2, 35, 1000], [82.1, 35, 2000], [82, 35, 3000], [81.9, 35, 4000], [81.7, 35, 5000], [81.3, 35, 6000],
    [80.4, 35, 7000], [79.3, 35, 8000], [78.2, 35, 9000], [76.9, 35, 10000], [75.8, 35, 11000], [74.7, 35, 12000], [72.8, 35, 13000], [70.9, 35, 14000],
    [80.6, 30, -2000], [83.6, 30, -1000], [86.7, 30, 0], [86.3, 30, 1000], [86.2, 30, 2000], [86, 30, 3000], [85.9, 30, 4000], [85.7, 30, 5000], [85.6, 30, 6000],
    [84.9, 30, 7000], [84.1, 30, 8000], [83.1, 30, 9000], [81.9, 30, 10000], [80.8, 30, 11000], [79.6, 30, 12000], [77.7, 30, 13000], [75.8, 30, 14000],
    [80.8, 25, -2000], [83.9, 25, -1000], [87, 25, 0], [88.1, 25, 1000], [89.6, 25, 2000], [90.4, 25, 3000], [90.2, 25, 4000], [90.1, 25, 5000], [90, 25, 6000],
    [89.1, 25, 7000], [88.2, 25, 8000], [87.8, 25, 9000], [87, 25, 10000], [85.9, 25, 11000], [84.7, 25, 12000], [82.7, 25, 13000], [80.8, 25, 14000],
    [81, 20, -2000], [84.1, 20, -1000], [87.2, 20, 0], [88.3, 20, 1000], [89.9, 20, 2000], [91.4, 20, 3000], [92.8, 20, 4000], [94.3, 20, 5000], [94.1, 20, 6000],
    [93.6, 20, 7000], [92.9, 20, 8000], [92.1, 20, 9000], [90.3, 20, 10000], [89.8, 20, 11000], [89.3, 20, 12000], [87.8, 20, 13000], [85.9, 20, 14000],
    [81.2, 15, -2000], [84.3, 15, -1000], [87.4, 15, 0], [88.6, 15, 1000], [90.1, 15, 2000], [91.6, 15, 3000], [93.1, 15, 4000], [94.5, 15, 5000], [95.7, 15, 6000],
    [96.6, 15, 7000], [96.9, 15, 8000], [96.3, 15, 9000], [94.8, 15, 10000], [93.5, 15, 11000], [92.6, 15, 12000], [91.4, 15, 13000], [90.1, 15, 14000],
    [81.4, 10, -2000], [84.5, 10, -1000], [87.6, 10, 0], [88.8, 10, 1000], [90.3, 10, 2000], [91.9, 10, 3000], [93.3, 10, 4000], [94.8, 10, 5000], [96, 10, 6000],
    [96.9, 10, 7000], [97.8, 10, 8000], [98.6, 10, 9000], [98.6, 10, 10000], [97.4, 10, 11000], [96.1, 10, 12000], [94.7, 10, 13000], [93.4, 10, 14000],
    [81.6, 5, -2000], [84.8, 5, -1000], [87.9, 5, 0], [89, 5, 1000], [90.6, 5, 2000], [92.1, 5, 3000], [93.6, 5, 4000], [95, 5, 5000], [96.2, 5, 6000], [97.1, 5, 7000],
    [98, 5, 8000], [98.8, 5, 9000], [98.9, 5, 10000], [99.8, 5, 11000], [99.8, 5, 12000], [98.4, 5, 13000], [97, 5, 14000],
    [81.8, 0, -2000], [85, 0, -1000], [88.1, 0, 0], [89.3, 0, 1000], [90.8, 0, 2000], [92.4, 0, 3000], [93.8, 0, 4000], [95.3, 0, 5000], [96.5, 0, 6000], [97.4, 0, 7000],
    [98.3, 0, 8000], [99.1, 0, 9000], [99.1, 0, 10000], [100.1, 0, 11000], [102.8, 0, 12000], [102.2, 0, 13000], [100.8, 0, 14000],
    [82.3, -10, -2000], [85.4, -10, -1000], [88.6, -10, 0], [89.7, -10, 1000], [91.3, -10, 2000], [92.8, -10, 3000], [94.3, -10, 4000], [95.8, -10, 5000],
    [97, -10, 6000], [97.9, -10, 7000], [98.8, -10, 8000], [99.6, -10, 9000], [99.7, -10, 10000], [100.6, -10, 11000], [103.3, -10, 12000], [103.3, -10, 13000],
    [103.2, -10, 14000], [82.7, -20, -2000], [85.9, -20, -1000], [89, -20, 0], [90.2, -20, 1000], [91.7, -20, 2000], [93.3, -20, 3000], [94.8, -20, 4000], [96.3, -20, 5000],
    [97.5, -20, 6000], [98.4, -20, 7000], [99.3, -20, 8000], [100.1, -20, 9000], [100.2, -20, 10000], [101.1, -20, 11000], [103.9, -20, 12000], [103.8, -20, 13000],
    [103.7, -20, 14000], [83.1, -30, -2000], [86.3, -30, -1000], [89.5, -30, 0], [90.7, -30, 1000], [92.2, -30, 2000], [93.8, -30, 3000], [95.3, -30, 4000], [96.8, -30, 5000],
    [98, -30, 6000], [98.9, -30, 7000], [99.8, -30, 8000], [100.7, -30, 9000], [100.7, -30, 10000], [101.7, -30, 11000], [104.4, -30, 12000], [104.3, -30, 13000],
    [104.3, -30, 14000], [83.5, -40, -2000], [86.7, -40, -1000], [89.9, -40, 0], [91.1, -40, 1000], [92.7, -40, 2000], [94.3, -40, 3000], [95.8, -40, 4000], [97.3, -40, 5000],
    [98.5, -40, 6000], [99.4, -40, 7000], [100.4, -40, 8000], [101.2, -40, 9000], [101.2, -40, 10000], [102.2, -40, 11000], [104.9, -40, 12000], [104.9, -40, 13000],
    [104.8, -40, 14000], [84, -50, -2000], [87.2, -50, -1000], [90.4, -50, 0], [91.6, -50, 1000], [93.2, -50, 2000], [94.8, -50, 3000], [96.3, -50, 4000], [97.8, -50, 5000],
    [99, -50, 6000], [100, -50, 7000], [100.9, -50, 8000], [101.7, -50, 9000], [101.8, -50, 10000], [102.7, -50, 11000], [105.5, -50, 12000], [105.4, -50, 13000],
    [105.4, -50, 14000]
]);
B787EngineData.to_n1_max = new LerpLookupTable([
    [87, 55, -2000], [87.4, 55, -1000], [87.8, 55, 0], [87.4, 55, 1000], [87, 55, 2000], [86.7, 55, 3000], [86.3, 55, 4000], [85.9, 55, 5000], [85.4, 55, 6000], [84.7, 55, 7000],
    [83.9, 55, 8000], [83.2, 55, 9000], [82.3, 55, 10000], [81.6, 55, 11000], [80.8, 55, 12000], [79.5, 55, 13000], [78.2, 55, 14000],
    [88.2, 50, -2000], [88.7, 50, -1000], [89.1, 50, 0], [88.8, 50, 1000], [88.6, 50, 2000], [88.3, 50, 3000], [88, 50, 4000], [87.7, 50, 5000], [87.3, 50, 6000], [86.6, 50, 7000],
    [86, 50, 8000], [85.3, 50, 9000], [84.5, 50, 10000], [83.8, 50, 11000], [83.1, 50, 12000], [82, 50, 13000], [80.8, 50, 14000],
    [89, 45, -2000], [89.6, 45, -1000], [90.2, 45, 0], [89.9, 45, 1000], [89.7, 45, 2000], [89.5, 45, 3000], [89.3, 45, 4000], [89.1, 45, 5000], [88.8, 45, 6000], [88.3, 45, 7000],
    [87.7, 45, 8000], [87.1, 45, 9000], [86.5, 45, 10000], [85.8, 45, 11000], [85.2, 45, 12000], [84.1, 45, 13000], [83.1, 45, 14000],
    [89.8, 40, -2000], [90.4, 40, -1000], [91, 40, 0], [90.9, 40, 1000], [90.8, 40, 2000], [90.7, 40, 3000], [90.5, 40, 4000], [90.4, 40, 5000], [90.2, 40, 6000], [89.7, 40, 7000],
    [89.1, 40, 8000], [88.6, 40, 9000], [88.1, 40, 10000], [87.6, 40, 11000], [87.1, 40, 12000], [86.1, 40, 13000], [85.1, 40, 14000],
    [90.6, 35, -2000], [91.3, 35, -1000], [92, 35, 0], [91.8, 35, 1000], [91.8, 35, 2000], [91.7, 35, 3000], [91.7, 35, 4000], [91.6, 35, 5000], [91.4, 35, 6000], [91, 35, 7000],
    [90.5, 35, 8000], [90.1, 35, 9000], [89.5, 35, 10000], [89, 35, 11000], [88.5, 35, 12000], [87.7, 35, 13000], [86.9, 35, 14000],
    [90.3, 30, -2000], [91.7, 30, -1000], [93, 30, 0], [92.8, 30, 1000], [92.8, 30, 2000], [92.7, 30, 3000], [92.7, 30, 4000], [92.6, 30, 5000], [92.6, 30, 6000], [92.3, 30, 7000],
    [91.9, 30, 8000], [91.5, 30, 9000], [91, 30, 10000], [90.5, 30, 11000], [90, 30, 12000], [89.1, 30, 13000], [88.3, 30, 14000],
    [89.6, 25, -2000], [91, 25, -1000], [92.4, 25, 0], [92.8, 25, 1000], [93.5, 25, 2000], [93.9, 25, 3000], [93.8, 25, 4000], [93.7, 25, 5000], [93.7, 25, 6000], [93.3, 25, 7000],
    [92.9, 25, 8000], [92.8, 25, 9000], [92.4, 25, 10000], [91.9, 25, 11000], [91.4, 25, 12000], [90.6, 25, 13000], [89.8, 25, 14000],
    [89, 20, -2000], [90.3, 20, -1000], [91.7, 20, 0], [92.2, 20, 1000], [92.8, 20, 2000], [93.5, 20, 3000], [94.2, 20, 4000], [94.9, 20, 5000], [94.8, 20, 6000], [94.6, 20, 7000],
    [94.3, 20, 8000], [93.9, 20, 9000], [93.1, 20, 10000], [92.9, 20, 11000], [92.7, 20, 12000], [92, 20, 13000], [91.2, 20, 14000],
    [88.3, 15, -2000], [89.7, 15, -1000], [91, 15, 0], [91.5, 15, 1000], [92.1, 15, 2000], [92.8, 15, 3000], [93.5, 15, 4000], [94.2, 15, 5000], [94.8, 15, 6000], [95.3, 15, 7000],
    [95.4, 15, 8000], [95.1, 15, 9000], [94.3, 15, 10000], [93.7, 15, 11000], [93.4, 15, 12000], [92.8, 15, 13000], [92.2, 15, 14000],
    [87.6, 10, -2000], [89, 10, -1000], [90.3, 10, 0], [90.8, 10, 1000], [91.4, 10, 2000], [92.1, 10, 3000], [92.8, 10, 4000], [93.5, 10, 5000], [94.1, 10, 6000], [94.6, 10, 7000],
    [95.1, 10, 8000], [95.5, 10, 9000], [95.5, 10, 10000], [94.9, 10, 11000], [94.2, 10, 12000], [93.5, 10, 13000], [92.9, 10, 14000],
    [86.9, 5, -2000], [88.3, 5, -1000], [89.6, 5, 0], [90.1, 5, 1000], [90.7, 5, 2000], [91.4, 5, 3000], [92.1, 5, 4000], [92.7, 5, 5000], [93.4, 5, 6000], [93.9, 5, 7000],
    [94.4, 5, 8000], [94.8, 5, 9000], [94.8, 5, 10000], [95.3, 5, 11000], [95.4, 5, 12000], [94.6, 5, 13000], [93.9, 5, 14000],
    [86.2, 0, -2000], [87.6, 0, -1000], [88.9, 0, 0], [89.4, 0, 1000], [90, 0, 2000], [90.7, 0, 3000], [91.4, 0, 4000], [92, 0, 5000], [92.7, 0, 6000], [93.2, 0, 7000],
    [93.6, 0, 8000], [94.1, 0, 9000], [94.1, 0, 10000], [94.6, 0, 11000], [96.1, 0, 12000], [95.8, 0, 13000], [95.1, 0, 14000],
    [84.8, -10, -2000], [86.1, -10, -1000], [87.4, -10, 0], [87.9, -10, 1000], [88.6, -10, 2000], [89.3, -10, 3000], [89.9, -10, 4000], [90.6, -10, 5000], [91.2, -10, 6000],
    [91.7, -10, 7000], [92.2, -10, 8000], [92.6, -10, 9000], [92.6, -10, 10000], [93.2, -10, 11000], [94.7, -10, 12000], [94.7, -10, 13000], [94.7, -10, 14000],
    [83.4, -20, -2000], [84.7, -20, -1000], [85.9, -20, 0], [86.4, -20, 1000], [87.1, -20, 2000], [87.7, -20, 3000], [88.4, -20, 4000], [89.1, -20, 5000], [89.7, -20, 6000],
    [90.2, -20, 7000], [90.7, -20, 8000], [91.1, -20, 9000], [91.1, -20, 10000], [91.7, -20, 11000], [93.1, -20, 12000], [93.1, -20, 13000], [93.1, -20, 14000],
    [81.9, -30, -2000], [83.1, -30, -1000], [84.4, -30, 0], [84.9, -30, 1000], [85.5, -30, 2000], [86.2, -30, 3000], [86.8, -30, 4000], [87.6, -30, 5000], [88.2, -30, 6000],
    [88.7, -30, 7000], [89.1, -30, 8000], [89.5, -30, 9000], [89.6, -30, 10000], [90.1, -30, 11000], [91.6, -30, 12000], [91.6, -30, 13000], [91.6, -30, 14000],
    [80.3, -40, -2000], [81.6, -40, -1000], [82.8, -40, 0], [83.3, -40, 1000], [83.9, -40, 2000], [84.6, -40, 3000], [85.3, -40, 4000], [86, -40, 5000], [86.6, -40, 6000],
    [87.1, -40, 7000], [87.5, -40, 8000], [88, -40, 9000], [88, -40, 10000], [88.5, -40, 11000], [90, -40, 12000], [89.9, -40, 13000], [89.9, -40, 14000],
    [78.8, -50, -2000], [80, -50, -1000], [81.2, -50, 0], [81.7, -50, 1000], [82.3, -50, 2000], [83, -50, 3000], [83.7, -50, 4000], [84.4, -50, 5000], [85, -50, 6000],
    [85.4, -50, 7000], [85.9, -50, 8000], [86.3, -50, 9000], [86.4, -50, 10000], [86.9, -50, 11000], [88.3, -50, 12000], [88.3, -50, 13000], [88.3, -50, 14000]
]);
B787EngineData.to_tpr_1 = new LerpLookupTable([
    [46.5, 75, -2000], [46.6, 75, -1000], [46.6, 75, 0], [45.7, 75, 1000], [45, 75, 2000], [45, 75, 3000], [45, 75, 4000], [45, 75, 5000], [44.7, 75, 6000], [43.2, 75, 7000],
    [41.7, 75, 8000], [40.2, 75, 9000], [38.6, 75, 10000], [37.1, 75, 11000], [35.5, 75, 12000], [33.6, 75, 13000], [31.7, 75, 14000],
    [50, 70, -2000], [50.2, 70, -1000], [50.4, 70, 0], [49.5, 70, 1000], [48.7, 70, 2000], [47.9, 70, 3000], [47, 70, 4000], [46.2, 70, 5000], [45.3, 70, 6000], [45, 70, 7000],
    [45, 70, 8000], [44.9, 70, 9000], [43.4, 70, 10000], [42, 70, 11000], [40.4, 70, 12000], [38.5, 70, 13000], [36.6, 70, 14000],
    [53.5, 65, -2000], [53.8, 65, -1000], [54.1, 65, 0], [53.3, 65, 1000], [52.6, 65, 2000], [51.8, 65, 3000], [51.1, 65, 4000], [50.2, 65, 5000], [49.4, 65, 6000],
    [48.1, 65, 7000], [46.9, 65, 8000], [45.6, 65, 9000], [45, 65, 10000], [45, 65, 11000], [45, 65, 12000], [43.4, 65, 13000], [41.5, 65, 14000],
    [57, 60, -2000], [57.5, 60, -1000], [57.9, 60, 0], [57.1, 60, 1000], [56.4, 60, 2000], [55.7, 60, 3000], [55, 60, 4000], [54.3, 60, 5000], [53.5, 60, 6000], [52.3, 60, 7000],
    [51.1, 60, 8000], [49.9, 60, 9000], [48.6, 60, 10000], [47.4, 60, 11000], [46.1, 60, 12000], [45, 60, 13000], [45, 60, 14000],
    [60.2, 55, -2000], [61, 55, -1000], [61.6, 55, 0], [60.8, 55, 1000], [60.3, 55, 2000], [59.7, 55, 3000], [59, 55, 4000], [58.4, 55, 5000], [57.7, 55, 6000], [56.5, 55, 7000],
    [55.3, 55, 8000], [54.1, 55, 9000], [52.9, 55, 10000], [51.7, 55, 11000], [50.5, 55, 12000], [48.8, 55, 13000], [47, 55, 14000],
    [63.4, 50, -2000], [64.3, 50, -1000], [65.1, 50, 0], [64.4, 50, 1000], [64, 50, 2000], [63.5, 50, 3000], [63, 50, 4000], [62.4, 50, 5000], [61.8, 50, 6000], [60.7, 50, 7000],
    [59.5, 50, 8000], [58.4, 50, 9000], [57.2, 50, 10000], [56, 50, 11000], [54.9, 50, 12000], [53.2, 50, 13000], [51.4, 50, 14000],
    [66.2, 45, -2000], [67.4, 45, -1000], [68.5, 45, 0], [68, 45, 1000], [67.6, 45, 2000], [67.2, 45, 3000], [66.8, 45, 4000], [66.4, 45, 5000], [65.8, 45, 6000], [64.8, 45, 7000],
    [63.6, 45, 8000], [62.6, 45, 9000], [61.4, 45, 10000], [60.4, 45, 11000], [59.3, 45, 12000], [57.6, 45, 13000], [55.8, 45, 14000],
    [69.1, 40, -2000], [70.4, 40, -1000], [71.5, 40, 0], [71.2, 40, 1000], [71.1, 40, 2000], [70.9, 40, 3000], [70.6, 40, 4000], [70.2, 40, 5000], [69.8, 40, 6000],
    [68.8, 40, 7000], [67.8, 40, 8000], [66.8, 40, 9000], [65.6, 40, 10000], [64.7, 40, 11000], [63.6, 40, 12000], [61.9, 40, 13000], [60.2, 40, 14000],
    [72.2, 35, -2000], [73.6, 35, -1000], [74.7, 35, 0], [74.4, 35, 1000], [74.3, 35, 2000], [74.1, 35, 3000], [74.1, 35, 4000], [73.9, 35, 5000], [73.6, 35, 6000],
    [72.8, 35, 7000], [71.9, 35, 8000], [71, 35, 9000], [69.8, 35, 10000], [68.9, 35, 11000], [67.9, 35, 12000], [66.2, 35, 13000], [64.6, 35, 14000],
    [73, 30, -2000], [75.6, 30, -1000], [78.1, 30, 0], [77.8, 30, 1000], [77.6, 30, 2000], [77.5, 30, 3000], [77.4, 30, 4000], [77.3, 30, 5000], [77.2, 30, 6000], [76.6, 30, 7000],
    [75.9, 30, 8000], [75.1, 30, 9000], [74.1, 30, 10000], [73.2, 30, 11000], [72.2, 30, 12000], [70.5, 30, 13000], [68.9, 30, 14000],
    [73.2, 25, -2000], [75.7, 25, -1000], [78.3, 25, 0], [79.2, 25, 1000], [80.5, 25, 2000], [81, 25, 3000], [80.9, 25, 4000], [80.8, 25, 5000], [80.7, 25, 6000], [80, 25, 7000],
    [79.3, 25, 8000], [78.9, 25, 9000], [78.3, 25, 10000], [77.4, 25, 11000], [76.4, 25, 12000], [74.8, 25, 13000], [73.1, 25, 14000],
    [73.3, 20, -2000], [75.9, 20, -1000], [78.5, 20, 0], [79.4, 20, 1000], [80.6, 20, 2000], [81.8, 20, 3000], [82.8, 20, 4000], [83.8, 20, 5000], [83.7, 20, 6000],
    [83.3, 20, 7000], [82.8, 20, 8000], [82.3, 20, 9000], [81, 20, 10000], [80.6, 20, 11000], [80.2, 20, 12000], [79, 20, 13000], [77.4, 20, 14000],
    [73.5, 15, -2000], [76.1, 15, -1000], [78.7, 15, 0], [79.6, 15, 1000], [80.8, 15, 2000], [81.9, 15, 3000], [83, 15, 4000], [84, 15, 5000], [84.8, 15, 6000], [85.4, 15, 7000],
    [85.6, 15, 8000], [85.2, 15, 9000], [84.2, 15, 10000], [83.3, 15, 11000], [82.6, 15, 12000], [81.7, 15, 13000], [80.9, 15, 14000],
    [73.7, 10, -2000], [76.3, 10, -1000], [78.8, 10, 0], [79.8, 10, 1000], [81, 10, 2000], [82.1, 10, 3000], [83.1, 10, 4000], [84.2, 10, 5000], [85, 10, 6000], [85.6, 10, 7000],
    [86.2, 10, 8000], [86.7, 10, 9000], [86.8, 10, 10000], [85.9, 10, 11000], [85, 10, 12000], [84.1, 10, 13000], [83.2, 10, 14000],
    [73.9, 5, -2000], [76.5, 5, -1000], [79, 5, 0], [80, 5, 1000], [81.2, 5, 2000], [82.3, 5, 3000], [83.3, 5, 4000], [84.3, 5, 5000], [85.1, 5, 6000], [85.8, 5, 7000],
    [86.4, 5, 8000], [86.9, 5, 9000], [86.9, 5, 10000], [87.5, 5, 11000], [87.6, 5, 12000], [86.6, 5, 13000], [85.7, 5, 14000],
    [74, 0, -2000], [76.7, 0, -1000], [79.2, 0, 0], [80.2, 0, 1000], [81.3, 0, 2000], [82.5, 0, 3000], [83.5, 0, 4000], [84.5, 0, 5000], [85.3, 0, 6000], [85.9, 0, 7000],
    [86.5, 0, 8000], [87.1, 0, 9000], [87.1, 0, 10000], [87.7, 0, 11000], [89.4, 0, 12000], [89, 0, 13000], [88.2, 0, 14000],
    [74.4, -10, -2000], [77, -10, -1000], [79.6, -10, 0], [80.5, -10, 1000], [81.7, -10, 2000], [82.8, -10, 3000], [83.8, -10, 4000], [84.8, -10, 5000], [85.7, -10, 6000],
    [86.3, -10, 7000], [86.9, -10, 8000], [87.4, -10, 9000], [87.4, -10, 10000], [88, -10, 11000], [89.7, -10, 12000], [89.7, -10, 13000], [89.6, -10, 14000],
    [74.8, -20, -2000], [77.4, -20, -1000], [80, -20, 0], [80.9, -20, 1000], [82, -20, 2000], [83.1, -20, 3000], [84.2, -20, 4000], [85.2, -20, 5000], [86, -20, 6000],
    [86.6, -20, 7000], [87.2, -20, 8000], [87.8, -20, 9000], [87.8, -20, 10000], [88.4, -20, 11000], [90, -20, 12000], [90, -20, 13000], [90, -20, 14000],
    [75.1, -30, -2000], [77.8, -30, -1000], [80.3, -30, 0], [81.2, -30, 1000], [82.4, -30, 2000], [83.5, -30, 3000], [84.5, -30, 4000], [85.5, -30, 5000], [86.3, -30, 6000],
    [87, -30, 7000], [87.6, -30, 8000], [88.1, -30, 9000], [88.1, -30, 10000], [88.7, -30, 11000], [90.4, -30, 12000], [90.3, -30, 13000], [90.3, -30, 14000],
    [75.5, -40, -2000], [78.1, -40, -1000], [80.7, -40, 0], [81.6, -40, 1000], [82.7, -40, 2000], [83.8, -40, 3000], [84.8, -40, 4000], [85.8, -40, 5000], [86.7, -40, 6000],
    [87.3, -40, 7000], [87.9, -40, 8000], [88.4, -40, 9000], [88.4, -40, 10000], [89, -40, 11000], [90.7, -40, 12000], [90.7, -40, 13000], [90.6, -40, 14000],
    [75.8, -50, -2000], [78.5, -50, -1000], [81.1, -50, 0], [81.9, -50, 1000], [83, -50, 2000], [84.2, -50, 3000], [85.2, -50, 4000], [86.2, -50, 5000], [87, -50, 6000],
    [87.6, -50, 7000], [88.2, -50, 8000], [88.7, -50, 9000], [88.8, -50, 10000], [89.3, -50, 11000], [91.1, -50, 12000], [91.1, -50, 13000], [91, -50, 14000]
]);
B787EngineData.to_tpr_2 = new LerpLookupTable([
    [45, 75, -2000], [45, 75, -1000], [45, 75, 0], [45, 75, 1000], [45, 75, 2000], [45, 75, 3000], [45, 75, 4000], [45, 75, 5000], [44.7, 75, 6000], [43.2, 75, 7000],
    [41.7, 75, 8000], [40.2, 75, 9000], [38.6, 75, 10000], [37.1, 75, 11000], [35.5, 75, 12000], [33.6, 75, 13000], [31.7, 75, 14000],
    [45.4, 70, -2000], [45.7, 70, -1000], [45.8, 70, 0], [45, 70, 1000], [45, 70, 2000], [45, 70, 3000], [45, 70, 4000], [45, 70, 5000], [45, 70, 6000],
    [45, 70, 7000], [45, 70, 8000], [44.9, 70, 9000], [43.4, 70, 10000], [42, 70, 11000], [40.4, 70, 12000], [38.5, 70, 13000], [36.6, 70, 14000],
    [48.5, 65, -2000], [48.9, 65, -1000], [49.1, 65, 0], [48.3, 65, 1000], [47.7, 65, 2000], [47, 65, 3000], [46.4, 65, 4000], [45.6, 65, 5000], [45, 65, 6000],
    [45, 65, 7000], [45, 65, 8000], [45, 65, 9000], [45, 65, 10000], [45, 65, 11000], [45, 65, 12000], [43.4, 65, 13000], [41.5, 65, 14000],
    [51.6, 60, -2000], [52.1, 60, -1000], [52.4, 60, 0], [51.7, 60, 1000], [51.1, 60, 2000], [50.5, 60, 3000], [49.9, 60, 4000], [49.3, 60, 5000], [48.6, 60, 6000],
    [47.5, 60, 7000], [46.4, 60, 8000], [45.3, 60, 9000], [45, 60, 10000], [45, 60, 11000], [45, 60, 12000], [45, 60, 13000], [45, 60, 14000],
    [54.5, 55, -2000], [55.2, 55, -1000], [55.7, 55, 0], [55.1, 55, 1000], [54.5, 55, 2000], [54, 55, 3000], [53.5, 55, 4000], [52.9, 55, 5000], [52.2, 55, 6000],
    [51.2, 55, 7000], [50.1, 55, 8000], [49.1, 55, 9000], [48, 55, 10000], [47, 55, 11000], [45.9, 55, 12000], [45, 55, 13000], [45, 55, 14000],
    [57.3, 50, -2000], [58.1, 50, -1000], [58.8, 50, 0], [58.3, 50, 1000], [57.9, 50, 2000], [57.4, 50, 3000], [57, 50, 4000], [56.4, 50, 5000], [55.9, 50, 6000],
    [54.9, 50, 7000], [53.9, 50, 8000], [52.9, 50, 9000], [51.8, 50, 10000], [50.8, 50, 11000], [49.8, 50, 12000], [48.3, 50, 13000], [46.7, 50, 14000],
    [59.8, 45, -2000], [60.9, 45, -1000], [61.8, 45, 0], [61.4, 45, 1000], [61.1, 45, 2000], [60.7, 45, 3000], [60.4, 45, 4000], [60, 45, 5000], [59.5, 45, 6000],
    [58.5, 45, 7000], [57.6, 45, 8000], [56.6, 45, 9000], [55.6, 45, 10000], [54.7, 45, 11000], [53.7, 45, 12000], [52.1, 45, 13000], [50.6, 45, 14000],
    [62.4, 40, -2000], [63.5, 40, -1000], [64.5, 40, 0], [64.2, 40, 1000], [64.1, 40, 2000], [63.9, 40, 3000], [63.6, 40, 4000], [63.3, 40, 5000], [63, 40, 6000],
    [62.1, 40, 7000], [61.2, 40, 8000], [60.3, 40, 9000], [59.3, 40, 10000], [58.5, 40, 11000], [57.5, 40, 12000], [56, 40, 13000], [54.5, 40, 14000],
    [65, 35, -2000], [66.2, 35, -1000], [67.2, 35, 0], [66.9, 35, 1000], [66.9, 35, 2000], [66.7, 35, 3000], [66.7, 35, 4000], [66.5, 35, 5000], [66.3, 35, 6000],
    [65.6, 35, 7000], [64.8, 35, 8000], [64, 35, 9000], [63, 35, 10000], [62.2, 35, 11000], [61.3, 35, 12000], [59.8, 35, 13000], [58.4, 35, 14000],
    [65.7, 30, -2000], [68, 30, -1000], [70.1, 30, 0], [69.8, 30, 1000], [69.7, 30, 2000], [69.7, 30, 3000], [69.6, 30, 4000], [69.4, 30, 5000], [69.4, 30, 6000],
    [68.8, 30, 7000], [68.3, 30, 8000], [67.6, 30, 9000], [66.7, 30, 10000], [65.9, 30, 11000], [65, 30, 12000], [63.6, 30, 13000], [62.1, 30, 14000],
    [65.9, 25, -2000], [68.1, 25, -1000], [70.3, 25, 0], [71.1, 25, 1000], [72.1, 25, 2000], [72.6, 25, 3000], [72.5, 25, 4000], [72.4, 25, 5000], [72.3, 25, 6000],
    [71.7, 25, 7000], [71.2, 25, 8000], [70.8, 25, 9000], [70.3, 25, 10000], [69.5, 25, 11000], [68.7, 25, 12000], [67.3, 25, 13000], [65.9, 25, 14000],
    [66, 20, -2000], [68.3, 20, -1000], [70.4, 20, 0], [71.2, 20, 1000], [72.3, 20, 2000], [73.2, 20, 3000], [74, 20, 4000], [74.9, 20, 5000], [74.8, 20, 6000],
    [74.4, 20, 7000], [74.1, 20, 8000], [73.6, 20, 9000], [72.6, 20, 10000], [72.2, 20, 11000], [71.9, 20, 12000], [70.9, 20, 13000], [69.5, 20, 14000],
    [66.2, 15, -2000], [68.4, 15, -1000], [70.6, 15, 0], [71.4, 15, 1000], [72.4, 15, 2000], [73.3, 15, 3000], [74.2, 15, 4000], [75, 15, 5000], [75.7, 15, 6000],
    [76.2, 15, 7000], [76.3, 15, 8000], [76, 15, 9000], [75.2, 15, 10000], [74.4, 15, 11000], [73.9, 15, 12000], [73.2, 15, 13000], [72.5, 15, 14000],
    [66.3, 10, -2000], [68.6, 10, -1000], [70.8, 10, 0], [71.5, 10, 1000], [72.6, 10, 2000], [73.5, 10, 3000], [74.3, 10, 4000], [75.2, 10, 5000], [75.8, 10, 6000],
    [76.3, 10, 7000], [76.8, 10, 8000], [77.2, 10, 9000], [77.2, 10, 10000], [76.6, 10, 11000], [75.9, 10, 12000], [75.1, 10, 13000], [74.4, 10, 14000],
    [66.5, 5, -2000], [68.8, 5, -1000], [70.9, 5, 0], [71.7, 5, 1000], [72.7, 5, 2000], [73.6, 5, 3000], [74.5, 5, 4000], [75.3, 5, 5000], [75.9, 5, 6000],
    [76.4, 5, 7000], [76.9, 5, 8000], [77.3, 5, 9000], [77.4, 5, 10000], [77.9, 5, 11000], [77.9, 5, 12000], [77.1, 5, 13000], [76.4, 5, 14000],
    [66.6, 0, -2000], [68.9, 0, -1000], [71.1, 0, 0], [71.9, 0, 1000], [72.8, 0, 2000], [73.8, 0, 3000], [74.6, 0, 4000], [75.4, 0, 5000], [76.1, 0, 6000],
    [76.6, 0, 7000], [77.1, 0, 8000], [77.5, 0, 9000], [77.5, 0, 10000], [78, 0, 11000], [79.3, 0, 12000], [79, 0, 13000], [78.3, 0, 14000],
    [67, -10, -2000], [69.2, -10, -1000], [71.4, -10, 0], [72.2, -10, 1000], [73.1, -10, 2000], [74, -10, 3000], [74.9, -10, 4000], [75.7, -10, 5000], [76.4, -10, 6000],
    [76.8, -10, 7000], [77.3, -10, 8000], [77.8, -10, 9000], [77.8, -10, 10000], [78.3, -10, 11000], [79.6, -10, 12000], [79.5, -10, 13000], [79.5, -10, 14000],
    [67.3, -20, -2000], [69.5, -20, -1000], [71.7, -20, 0], [72.5, -20, 1000], [73.4, -20, 2000], [74.3, -20, 3000], [75.2, -20, 4000], [76, -20, 5000], [76.6, -20, 6000],
    [77.1, -20, 7000], [77.6, -20, 8000], [78, -20, 9000], [78.1, -20, 10000], [78.5, -20, 11000], [79.8, -20, 12000], [79.8, -20, 13000], [79.8, -20, 14000],
    [67.6, -30, -2000], [69.8, -30, -1000], [72, -30, 0], [72.8, -30, 1000], [73.7, -30, 2000], [74.6, -30, 3000], [75.4, -30, 4000], [76.2, -30, 5000], [76.9, -30, 6000],
    [77.4, -30, 7000], [77.9, -30, 8000], [78.3, -30, 9000], [78.3, -30, 10000], [78.8, -30, 11000], [80.1, -30, 12000], [80.1, -30, 13000], [80, -30, 14000],
    [67.9, -40, -2000], [70.1, -40, -1000], [72.3, -40, 0], [73, -40, 1000], [73.9, -40, 2000], [74.9, -40, 3000], [75.7, -40, 4000], [76.5, -40, 5000], [77.2, -40, 6000],
    [77.7, -40, 7000], [78.1, -40, 8000], [78.5, -40, 9000], [78.6, -40, 10000], [79, -40, 11000], [80.3, -40, 12000], [80.3, -40, 13000], [80.3, -40, 14000],
    [68.2, -50, -2000], [70.4, -50, -1000], [72.6, -50, 0], [73.3, -50, 1000], [74.2, -50, 2000], [75.2, -50, 3000], [76, -50, 4000], [76.8, -50, 5000], [77.4, -50, 6000],
    [77.9, -50, 7000], [78.4, -50, 8000], [78.8, -50, 9000], [78.8, -50, 10000], [79.3, -50, 11000], [80.6, -50, 12000], [80.6, -50, 13000], [80.6, -50, 14000]
]);
B787EngineData.ga_tpr_max = new LerpLookupTable([
    [63.8, 60, -2000], [64.6, 60, -1000], [65.1, 60, 0], [64.3, 60, 1000], [63.7, 60, 2000], [63, 60, 3000], [62.3, 60, 4000], [61.6, 60, 5000], [60.8, 60, 6000],
    [59.5, 60, 7000], [58.2, 60, 8000], [57, 60, 9000], [55.8, 60, 10000], [54.5, 60, 11000], [53.1, 60, 12000], [51.3, 60, 13000], [49.5, 60, 14000],
    [67.1, 55, -2000], [68.1, 55, -1000], [68.9, 55, 0], [68.3, 55, 1000], [67.8, 55, 2000], [67.2, 55, 3000], [66.6, 55, 4000], [65.9, 55, 5000], [65.2, 55, 6000],
    [63.9, 55, 7000], [62.7, 55, 8000], [61.6, 55, 9000], [60.4, 55, 10000], [59.1, 55, 11000], [57.8, 55, 12000], [56, 55, 13000], [54.2, 55, 14000],
    [70.6, 50, -2000], [71.6, 50, -1000], [72.7, 50, 0], [72.1, 50, 1000], [71.8, 50, 2000], [71.3, 50, 3000], [70.8, 50, 4000], [70.3, 50, 5000], [69.6, 50, 6000],
    [68.4, 50, 7000], [67.2, 50, 8000], [66.2, 50, 9000], [65, 50, 10000], [63.8, 50, 11000], [62.5, 50, 12000], [60.7, 50, 13000], [58.9, 50, 14000],
    [74, 45, -2000], [75.3, 45, -1000], [76.4, 45, 0], [76, 45, 1000], [75.7, 45, 2000], [75.4, 45, 3000], [75, 45, 4000], [74.6, 45, 5000], [74, 45, 6000],
    [72.9, 45, 7000], [71.8, 45, 8000], [70.7, 45, 9000], [69.6, 45, 10000], [68.5, 45, 11000], [67.3, 45, 12000], [65.5, 45, 13000], [63.7, 45, 14000],
    [77.4, 40, -2000], [78.8, 40, -1000], [80.1, 40, 0], [79.7, 40, 1000], [79.6, 40, 2000], [79.4, 40, 3000], [79.2, 40, 4000], [78.8, 40, 5000], [78.4, 40, 6000],
    [77.7, 40, 7000], [76.6, 40, 8000], [75.4, 40, 9000], [74.2, 40, 10000], [73.1, 40, 11000], [72, 40, 12000], [70.2, 40, 13000], [68.4, 40, 14000],
    [79.1, 35, -2000], [81.9, 35, -1000], [83.9, 35, 0], [83.5, 35, 1000], [83.4, 35, 2000], [83.4, 35, 3000], [83.2, 35, 4000], [83, 35, 5000], [82.8, 35, 6000],
    [82.5, 35, 7000], [81.7, 35, 8000], [80.6, 35, 9000], [79.1, 35, 10000], [78, 35, 11000], [76.7, 35, 12000], [74.9, 35, 13000], [73.1, 35, 14000],
    [79.3, 30, -2000], [82.1, 30, -1000], [85, 30, 0], [86.2, 30, 1000], [87.6, 30, 2000], [87.5, 30, 3000], [87.4, 30, 4000], [87.3, 30, 5000], [87.2, 30, 6000],
    [86.3, 30, 7000], [85.8, 30, 8000], [85.5, 30, 9000], [84.1, 30, 10000], [83.1, 30, 11000], [81.9, 30, 12000], [79.9, 30, 13000], [78, 30, 14000],
    [79.5, 25, -2000], [82.4, 25, -1000], [85.2, 25, 0], [86.4, 25, 1000], [88, 25, 2000], [89.5, 25, 3000], [91.1, 25, 4000], [91.7, 25, 5000], [91.6, 25, 6000],
    [90.9, 25, 7000], [90, 25, 8000], [89, 25, 9000], [88.2, 25, 10000], [87.5, 25, 11000], [87.1, 25, 12000], [85.1, 25, 13000], [83.2, 25, 14000],
    [79.7, 20, -2000], [82.6, 20, -1000], [85.5, 20, 0], [86.6, 20, 1000], [88.2, 20, 2000], [89.7, 20, 3000], [91.4, 20, 4000], [93, 20, 5000], [94.5, 20, 6000],
    [95.1, 20, 7000], [94.4, 20, 8000], [93.8, 20, 9000], [93.1, 20, 10000], [91.4, 20, 11000], [90.3, 20, 12000], [89.2, 20, 13000], [88, 20, 14000],
    [79.9, 15, -2000], [82.8, 15, -1000], [85.7, 15, 0], [86.9, 15, 1000], [88.4, 15, 2000], [90, 15, 3000], [91.6, 15, 4000], [93.3, 15, 5000], [94.8, 15, 6000],
    [95.6, 15, 7000], [96.4, 15, 8000], [97.1, 15, 9000], [96.5, 15, 10000], [95.4, 15, 11000], [94, 15, 12000], [92.6, 15, 13000], [91.3, 15, 14000],
    [80.1, 10, -2000], [83, 10, -1000], [85.9, 10, 0], [87.1, 10, 1000], [88.7, 10, 2000], [90.2, 10, 3000], [91.9, 10, 4000], [93.5, 10, 5000], [95, 10, 6000],
    [95.8, 10, 7000], [96.6, 10, 8000], [97.3, 10, 9000], [97.4, 10, 10000], [98.1, 10, 11000], [97.4, 10, 12000], [96.2, 10, 13000], [94.8, 10, 14000],
    [80.3, 5, -2000], [83.2, 5, -1000], [86.1, 5, 0], [87.3, 5, 1000], [88.9, 5, 2000], [90.4, 5, 3000], [92.1, 5, 4000], [93.8, 5, 5000], [95.3, 5, 6000],
    [96.1, 5, 7000], [96.9, 5, 8000], [97.6, 5, 9000], [97.7, 5, 10000], [98.6, 5, 11000], [101.1, 5, 12000], [99.7, 5, 13000], [98.5, 5, 14000],
    [80.5, 0, -2000], [83.4, 0, -1000], [86.3, 0, 0], [87.5, 0, 1000], [89.1, 0, 2000], [90.7, 0, 3000], [92.3, 0, 4000], [94, 0, 5000], [95.5, 0, 6000],
    [96.3, 0, 7000], [97.1, 0, 8000], [97.8, 0, 9000], [97.9, 0, 10000], [98.8, 0, 11000], [101.6, 0, 12000], [101.5, 0, 13000], [101.5, 0, 14000],
    [80.9, -10, -2000], [83.9, -10, -1000], [86.8, -10, 0], [88, -10, 1000], [89.6, -10, 2000], [91.1, -10, 3000], [92.8, -10, 4000], [94.5, -10, 5000],
    [96, -10, 6000], [96.8, -10, 7000], [97.6, -10, 8000], [98.4, -10, 9000], [98.4, -10, 10000], [99.4, -10, 11000], [102.1, -10, 12000], [102.1, -10, 13000], [102.1, -10, 14000],
    [81.3, -20, -2000], [84.3, -20, -1000], [87.2, -20, 0], [88.4, -20, 1000], [90, -20, 2000], [91.6, -20, 3000], [93.3, -20, 4000], [95, -20, 5000],
    [96.5, -20, 6000], [97.3, -20, 7000], [98.1, -20, 8000], [98.9, -20, 9000], [98.9, -20, 10000], [99.9, -20, 11000], [102.6, -20, 12000], [102.6, -20, 13000],
    [102.6, -20, 14000],
    [81.7, -30, -2000], [84.7, -30, -1000], [87.7, -30, 0], [88.9, -30, 1000], [90.5, -30, 2000], [92.1, -30, 3000], [93.8, -30, 4000], [95.4, -30, 5000],
    [97, -30, 6000], [97.8, -30, 7000], [98.6, -30, 8000], [99.4, -30, 9000], [99.4, -30, 10000], [100.4, -30, 11000], [103.1, -30, 12000], [103.1, -30, 13000],
    [103.1, -30, 14000],
    [82.2, -40, -2000], [85.1, -40, -1000], [88.1, -40, 0], [89.3, -40, 1000], [90.9, -40, 2000], [92.5, -40, 3000], [94.2, -40, 4000], [95.9, -40, 5000],
    [97.5, -40, 6000], [98.3, -40, 7000], [99.1, -40, 8000], [99.9, -40, 9000], [100, -40, 10000], [100.9, -40, 11000], [103.7, -40, 12000], [103.7, -40, 13000],
    [103.6, -40, 14000],
    [82.6, -50, -2000], [85.6, -50, -1000], [88.6, -50, 0], [89.8, -50, 1000], [91.4, -50, 2000], [93, -50, 3000], [94.7, -50, 4000], [96.4, -50, 5000],
    [98, -50, 6000], [98.8, -50, 7000], [99.6, -50, 8000], [100.4, -50, 9000], [100.5, -50, 10000], [101.4, -50, 11000], [104.2, -50, 12000],
    [104.2, -50, 13000], [104.2, -50, 14000]
]);
B787EngineData.ga_n1_max = new LerpLookupTable([
    [86.6, 60, -2000], [87.1, 60, -1000], [87.4, 60, 0], [86.9, 60, 1000], [86.5, 60, 2000], [86.2, 60, 3000], [85.8, 60, 4000], [85.4, 60, 5000], [84.9, 60, 6000],
    [84.1, 60, 7000], [83.4, 60, 8000], [82.7, 60, 9000], [81.9, 60, 10000], [81, 60, 11000], [80.1, 60, 12000], [78.9, 60, 13000], [77.7, 60, 14000],
    [87.7, 55, -2000], [88.3, 55, -1000], [88.7, 55, 0], [88.3, 55, 1000], [88.1, 55, 2000], [87.8, 55, 3000], [87.5, 55, 4000], [87.1, 55, 5000], [86.7, 55, 6000], [86, 55, 7000],
    [85.4, 55, 8000], [84.7, 55, 9000], [84, 55, 10000], [83.3, 55, 11000], [82.5, 55, 12000], [81.4, 55, 13000], [80.3, 55, 14000],
    [88.8, 50, -2000], [89.3, 50, -1000], [89.8, 50, 0], [89.5, 50, 1000], [89.4, 50, 2000], [89.2, 50, 3000], [89, 50, 4000], [88.7, 50, 5000], [88.4, 50, 6000], [87.7, 50, 7000],
    [87.1, 50, 8000], [86.6, 50, 9000], [86, 50, 10000], [85.3, 50, 11000], [84.6, 50, 12000], [83.6, 50, 13000], [82.5, 50, 14000],
    [89.6, 45, -2000], [90.2, 45, -1000], [90.7, 45, 0], [90.5, 45, 1000], [90.4, 45, 2000], [90.3, 45, 3000], [90.1, 45, 4000], [89.9, 45, 5000], [89.7, 45, 6000],
    [89.2, 45, 7000], [88.7, 45, 8000], [88.2, 45, 9000], [87.7, 45, 10000], [87.1, 45, 11000], [86.5, 45, 12000], [85.6, 45, 13000], [84.6, 45, 14000],
    [90.4, 40, -2000], [91, 40, -1000], [91.6, 40, 0], [91.4, 40, 1000], [91.4, 40, 2000], [91.3, 40, 3000], [91.2, 40, 4000], [91.1, 40, 5000], [90.9, 40, 6000], [90.6, 40, 7000],
    [90.1, 40, 8000], [89.6, 40, 9000], [89.1, 40, 10000], [88.6, 40, 11000], [88.1, 40, 12000], [87.3, 40, 13000], [86.4, 40, 14000],
    [90.4, 35, -2000], [91.7, 35, -1000], [92.6, 35, 0], [92.4, 35, 1000], [92.4, 35, 2000], [92.3, 35, 3000], [92.3, 35, 4000], [92.2, 35, 5000], [92.1, 35, 6000],
    [91.9, 35, 7000], [91.6, 35, 8000], [91.1, 35, 9000], [90.5, 35, 10000], [90, 35, 11000], [89.4, 35, 12000], [88.6, 35, 13000], [87.9, 35, 14000],
    [89.8, 30, -2000], [91, 30, -1000], [92.3, 30, 0], [92.8, 30, 1000], [93.4, 30, 2000], [93.4, 30, 3000], [93.3, 30, 4000], [93.3, 30, 5000], [93.2, 30, 6000], [92.8, 30, 7000],
    [92.6, 30, 8000], [92.5, 30, 9000], [91.9, 30, 10000], [91.4, 30, 11000], [90.9, 30, 12000], [90.1, 30, 13000], [89.2, 30, 14000],
    [89.1, 25, -2000], [90.4, 25, -1000], [91.6, 25, 0], [92.1, 25, 1000], [92.8, 25, 2000], [93.4, 25, 3000], [94.2, 25, 4000], [94.5, 25, 5000], [94.4, 25, 6000],
    [94.1, 25, 7000], [93.7, 25, 8000], [93.2, 25, 9000], [92.9, 25, 10000], [92.6, 25, 11000], [92.4, 25, 12000], [91.6, 25, 13000], [90.7, 25, 14000],
    [88.5, 20, -2000], [89.7, 20, -1000], [90.9, 20, 0], [91.5, 20, 1000], [92.1, 20, 2000], [92.8, 20, 3000], [93.5, 20, 4000], [94.3, 20, 5000], [95, 20, 6000], [95.3, 20, 7000],
    [95, 20, 8000], [94.7, 20, 9000], [94.3, 20, 10000], [93.5, 20, 11000], [93, 20, 12000], [92.5, 20, 13000], [92, 20, 14000],
    [87.8, 15, -2000], [89, 15, -1000], [90.3, 15, 0], [90.8, 15, 1000], [91.4, 15, 2000], [92.1, 15, 3000], [92.8, 15, 4000], [93.6, 15, 5000], [94.3, 15, 6000], [94.8, 15, 7000],
    [95.2, 15, 8000], [95.6, 15, 9000], [95.3, 15, 10000], [94.6, 15, 11000], [94, 15, 12000], [93.3, 15, 13000], [92.7, 15, 14000],
    [87.1, 10, -2000], [88.3, 10, -1000], [89.6, 10, 0], [90.1, 10, 1000], [90.7, 10, 2000], [91.4, 10, 3000], [92.1, 10, 4000], [92.9, 10, 5000], [93.6, 10, 6000],
    [94.1, 10, 7000], [94.5, 10, 8000], [94.9, 10, 9000], [95, 10, 10000], [95.3, 10, 11000], [95, 10, 12000], [94.3, 10, 13000], [93.5, 10, 14000],
    [86.4, 5, -2000], [87.7, 5, -1000], [88.9, 5, 0], [89.4, 5, 1000], [90, 5, 2000], [90.7, 5, 3000], [91.4, 5, 4000], [92.2, 5, 5000], [92.9, 5, 6000], [93.4, 5, 7000],
    [93.8, 5, 8000], [94.2, 5, 9000], [94.3, 5, 10000], [94.8, 5, 11000], [96.2, 5, 12000], [95.4, 5, 13000], [94.7, 5, 14000],
    [85.7, 0, -2000], [87, 0, -1000], [88.2, 0, 0], [88.6, 0, 1000], [89.3, 0, 2000], [89.9, 0, 3000], [90.7, 0, 4000], [91.5, 0, 5000], [92.2, 0, 6000], [92.7, 0, 7000],
    [93.1, 0, 8000], [93.5, 0, 9000], [93.6, 0, 10000], [94.1, 0, 11000], [95.7, 0, 12000], [95.7, 0, 13000], [95.6, 0, 14000],
    [84.3, -10, -2000], [85.5, -10, -1000], [86.7, -10, 0], [87.2, -10, 1000], [87.8, -10, 2000], [88.5, -10, 3000], [89.3, -10, 4000], [90, -10, 5000], [90.8, -10, 6000],
    [91.2, -10, 7000], [91.7, -10, 8000], [92.1, -10, 9000], [92.1, -10, 10000], [92.6, -10, 11000], [94.2, -10, 12000], [94.2, -10, 13000], [94.2, -10, 14000],
    [82.9, -20, -2000], [84.1, -20, -1000], [85.2, -20, 0], [85.7, -20, 1000], [86.3, -20, 2000], [87, -20, 3000], [87.8, -20, 4000], [88.5, -20, 5000], [89.3, -20, 6000],
    [89.8, -20, 7000], [90.2, -20, 8000], [90.6, -20, 9000], [90.6, -20, 10000], [91.1, -20, 11000], [92.7, -20, 12000], [92.7, -20, 13000], [92.7, -20, 14000],
    [81.4, -30, -2000], [82.5, -30, -1000], [83.7, -30, 0], [84.2, -30, 1000], [84.8, -30, 2000], [85.5, -30, 3000], [86.2, -30, 4000], [87, -30, 5000], [87.8, -30, 6000],
    [88.2, -30, 7000], [88.7, -30, 8000], [89, -30, 9000], [89.1, -30, 10000], [89.6, -30, 11000], [91.2, -30, 12000], [91.2, -30, 13000], [91.2, -30, 14000],
    [79.8, -40, -2000], [81, -40, -1000], [82.1, -40, 0], [82.6, -40, 1000], [83.2, -40, 2000], [83.9, -40, 3000], [84.6, -40, 4000], [85.4, -40, 5000], [86.2, -40, 6000],
    [86.6, -40, 7000], [87.1, -40, 8000], [87.5, -40, 9000], [87.5, -40, 10000], [88, -40, 11000], [89.6, -40, 12000], [89.6, -40, 13000], [89.6, -40, 14000],
    [78.3, -50, -2000], [79.4, -50, -1000], [80.5, -50, 0], [80.9, -50, 1000], [81.6, -50, 2000], [82.3, -50, 3000], [83, -50, 4000], [83.8, -50, 5000], [84.6, -50, 6000],
    [85, -50, 7000], [85.4, -50, 8000], [85.8, -50, 9000], [85.9, -50, 10000], [86.4, -50, 11000], [87.9, -50, 12000], [87.9, -50, 13000], [87.9, -50, 14000]
]);
B787EngineData.clb_tpr_max = new LerpLookupTable([
    [51.1, 60, 0], [51.7, 60, 5000], [53.7, 60, 10000], [59.9, 60, 15000], [61.9, 60, 20000], [64.6, 60, 25000], [67.4, 60, 30000], [74.1, 60, 35000], [71.9, 60, 40000],
    [70.9, 60, 43000], [58.2, 50, 0], [58.3, 50, 5000], [56.9, 50, 10000], [59.9, 50, 15000], [61.9, 50, 20000], [64.6, 50, 25000], [67.4, 50, 30000], [74.1, 50, 35000],
    [71.9, 50, 40000], [70.9, 50, 43000], [66.3, 40, 0], [66.5, 40, 5000], [64.6, 40, 10000], [66.1, 40, 15000], [63.2, 40, 20000], [64.6, 40, 25000], [67.4, 40, 30000],
    [74.1, 40, 35000], [71.9, 40, 40000], [70.9, 40, 43000], [67.8, 30, 0], [74.9, 30, 5000], [74.4, 30, 10000], [75.4, 30, 15000], [72.1, 30, 20000], [70.2, 30, 25000],
    [68.6, 30, 30000], [74.1, 30, 35000], [71.9, 30, 40000], [70.9, 30, 43000], [68.1, 20, 0], [75.3, 20, 5000], [80.2, 20, 10000], [85.3, 20, 15000], [82.6, 20, 20000],
    [80.5, 20, 25000], [78.4, 20, 30000], [76.6, 20, 35000], [72.4, 20, 40000], [71.4, 20, 43000], [68.3, 15, 0], [75.5, 15, 5000], [80.4, 15, 10000], [87.4, 15, 15000],
    [89.2, 15, 20000], [86.1, 15, 25000], [84.2, 15, 30000], [80.7, 15, 35000], [76.8, 15, 40000], [75.9, 15, 43000], [68.5, 10, 0], [75.7, 10, 5000], [80.6, 10, 10000],
    [87.6, 10, 15000], [92.8, 10, 20000], [91.5, 10, 25000], [89.9, 10, 30000], [85.2, 10, 35000], [81.1, 10, 40000], [80.4, 10, 43000], [68.7, 5, 0], [75.9, 5, 5000],
    [80.8, 5, 10000], [87.8, 5, 15000], [93.8, 5, 20000], [95.5, 5, 25000], [95.3, 5, 30000], [90.4, 5, 35000], [86.8, 5, 40000], [86.4, 5, 43000],
    [68.8, 0, 0], [76, 0, 5000], [81, 0, 10000], [88, 0, 15000], [94, 0, 20000], [97.2, 0, 25000], [99.6, 0, 30000], [95.8, 0, 35000], [92.8, 0, 40000], [92.6, 0, 43000],
    [69, -5, 0], [76.2, -5, 5000], [81.2, -5, 10000], [88.2, -5, 15000], [94.2, -5, 20000], [97.4, -5, 25000], [101.8, -5, 30000], [102.3, -5, 35000], [98.7, -5, 40000],
    [98.7, -5, 43000], [69.2, -10, 0], [76.4, -10, 5000], [81.4, -10, 10000], [88.5, -10, 15000], [94.4, -10, 20000], [97.6, -10, 25000], [102, -10, 30000], [106.3, -10, 35000],
    [103.9, -10, 40000], [104, -10, 43000], [69.3, -15, 0], [76.6, -15, 5000], [81.6, -15, 10000], [88.7, -15, 15000], [94.7, -15, 20000], [97.9, -15, 25000], [102.2, -15, 30000],
    [107.5, -15, 35000], [107, -15, 40000], [107.1, -15, 43000], [69.5, -20, 0], [76.8, -20, 5000], [81.8, -20, 10000], [88.9, -20, 15000], [94.9, -20, 20000], [98.1, -20, 25000],
    [102.5, -20, 30000], [107.7, -20, 35000], [107.2, -20, 40000], [107.3, -20, 43000], [69.7, -25, 0], [77, -25, 5000], [82, -25, 10000], [89.1, -25, 15000], [95.1, -25, 20000],
    [98.3, -25, 25000], [102.7, -25, 30000], [108, -25, 35000], [107.5, -25, 40000], [107.6, -25, 43000], [69.9, -30, 0], [77.2, -30, 5000], [82.2, -30, 10000], [89.3, -30, 15000],
    [95.4, -30, 20000], [98.6, -30, 25000], [103, -30, 30000], [108.2, -30, 35000], [107.7, -30, 40000], [107.8, -30, 43000], [70, -35, 0], [77.4, -35, 5000], [82.4, -35, 10000],
    [89.5, -35, 15000], [95.6, -35, 20000], [98.8, -35, 25000], [103.2, -35, 30000], [108.5, -35, 35000], [108, -35, 40000], [108.1, -35, 43000], [70.2, -40, 0], [77.6, -40, 5000],
    [82.6, -40, 10000], [89.7, -40, 15000], [95.8, -40, 20000], [99, -40, 25000], [103.4, -40, 30000], [108.7, -40, 35000], [108.2, -40, 40000], [108.3, -40, 43000]
]);
B787EngineData.clb_n1_max = new LerpLookupTable([
    [79.9, 60, 0], [80.6, 60, 5000], [82.3, 60, 10000], [86.5, 60, 15000], [87.8, 60, 20000], [89.4, 60, 25000], [91.2, 60, 30000], [94.5, 60, 35000], [93.5, 60, 40000], [93.1, 60, 43000],
    [83.2, 50, 0], [83.5, 50, 5000], [83, 50, 10000], [85.2, 50, 15000], [86.5, 50, 20000], [88.1, 50, 25000], [89.8, 50, 30000], [93, 50, 35000], [92.1, 50, 40000], [91.7, 50, 43000],
    [86.2, 40, 0], [86.5, 40, 5000], [85.9, 40, 10000], [87, 40, 15000], [85.8, 40, 20000], [86.7, 40, 25000], [88.4, 40, 30000], [91.6, 40, 35000], [90.7, 40, 40000], [90.2, 40, 43000],
    [85.5, 30, 0], [88.9, 30, 5000], [89, 30, 10000], [89.8, 30, 15000], [88.5, 30, 20000], [87.9, 30, 25000], [87.5, 30, 30000], [90.1, 30, 35000], [89.2, 30, 40000], [88.8, 30, 43000],
    [84.2, 20, 0], [87.6, 20, 5000], [89.9, 20, 10000], [92.4, 20, 15000], [91.3, 20, 20000], [90.7, 20, 25000], [90.1, 20, 30000], [89.6, 20, 35000], [87.9, 20, 40000], [87.5, 20, 43000],
    [83.6, 15, 0], [86.9, 15, 5000], [89.3, 15, 10000], [92.5, 15, 15000], [93.2, 15, 20000], [92.2, 15, 25000], [91.7, 15, 30000], [90.4, 15, 35000], [88.9, 15, 40000], [88.6, 15, 43000],
    [83, 10, 0], [86.2, 10, 5000], [88.6, 10, 10000], [91.8, 10, 15000], [94.1, 10, 20000], [93.6, 10, 25000], [93.2, 10, 30000], [91.5, 10, 35000], [89.8, 10, 40000], [89.6, 10, 43000],
    [82.3, 5, 0], [85.6, 5, 5000], [87.9, 5, 10000], [91, 5, 15000], [93.7, 5, 20000], [94.7, 5, 25000], [94.9, 5, 30000], [92.8, 5, 35000], [91.3, 5, 40000], [91.1, 5, 43000],
    [81.6, 0, 0], [84.9, 0, 5000], [87.2, 0, 10000], [90.3, 0, 15000], [93, 0, 20000], [94.7, 0, 25000], [96.3, 0, 30000], [94.5, 0, 35000], [93.1, 0, 40000], [93, 0, 43000],
    [81, -5, 0], [84.2, -5, 5000], [86.4, -5, 10000], [89.6, -5, 15000], [92.2, -5, 20000], [94, -5, 25000], [96.5, -5, 30000], [96.9, -5, 35000], [95, -5, 40000], [95.1, -5, 43000],
    [80.3, -10, 0], [83.4, -10, 5000], [85.7, -10, 10000], [88.8, -10, 15000], [91.5, -10, 20000], [93.2, -10, 25000], [95.8, -10, 30000], [98.2, -10, 35000], [96.9, -10, 40000], [96.9, -10, 43000],
    [79.6, -15, 0], [82.7, -15, 5000], [85, -15, 10000], [88, -15, 15000], [90.7, -15, 20000], [92.5, -15, 25000], [95, -15, 30000], [97.8, -15, 35000], [97.6, -15, 40000], [97.6, -15, 43000],
    [78.9, -20, 0], [82, -20, 5000], [84.2, -20, 10000], [87.3, -20, 15000], [89.9, -20, 20000], [91.7, -20, 25000], [94.2, -20, 30000], [97, -20, 35000], [96.7, -20, 40000], [96.8, -20, 43000],
    [78.2, -25, 0], [81.2, -25, 5000], [83.5, -25, 10000], [86.5, -25, 15000], [89.2, -25, 20000], [90.9, -25, 25000], [93.4, -25, 30000], [96.1, -25, 35000], [95.9, -25, 40000], [95.9, -25, 43000],
    [77.5, -30, 0], [80.5, -30, 5000], [82.7, -30, 10000], [85.7, -30, 15000], [88.4, -30, 20000], [90.1, -30, 25000], [92.6, -30, 30000], [95.3, -30, 35000], [95.1, -30, 40000], [95.1, -30, 43000],
    [76.7, -35, 0], [79.7, -35, 5000], [81.9, -35, 10000], [84.9, -35, 15000], [87.6, -35, 20000], [89.3, -35, 25000], [91.7, -35, 30000], [94.4, -35, 35000], [94.2, -35, 40000], [94.2, -35, 43000],
    [76, -40, 0], [79, -40, 5000], [81.1, -40, 10000], [84.1, -40, 15000], [86.8, -40, 20000], [88.4, -40, 25000], [90.9, -40, 30000], [93.5, -40, 35000], [93.3, -40, 40000], [93.4, -40, 43000],
]);
B787EngineData.cru_n1_max = new LerpLookupTable([
    [87.4, 25, 25000], [87.1, 25, 27000], [87.1, 25, 29000], [87.1, 25, 31000], [87.2, 25, 33000], [87.6, 25, 35000], [87.4, 25, 37000],
    [86.9, 25, 39000], [86.6, 25, 41000], [86.3, 25, 43000], [88.7, 20, 25000], [88.4, 20, 27000], [88.3, 20, 29000], [88.2, 20, 31000],
    [88.1, 20, 33000], [87.8, 20, 35000], [86.9, 20, 37000], [86.4, 20, 39000], [86.1, 20, 41000], [85.8, 20, 43000], [89.9, 15, 25000],
    [89.5, 15, 27000], [89.5, 15, 29000], [89.4, 15, 31000], [89, 15, 33000], [88.6, 15, 35000], [87.7, 15, 37000], [87.3, 15, 39000],
    [87, 15, 41000], [86.8, 15, 43000], [91, 10, 25000], [90.6, 10, 27000], [90.7, 10, 29000], [90.6, 10, 31000], [90.1, 10, 33000], [89.3, 10, 35000],
    [88.4, 10, 37000], [88, 10, 39000], [87.9, 10, 41000], [87.7, 10, 43000], [91.5, 5, 25000], [91.5, 5, 27000], [91.6, 5, 29000], [91.8, 5, 31000],
    [91.2, 5, 33000], [90.3, 5, 35000], [89.4, 5, 37000], [89.1, 5, 39000], [89, 5, 41000], [88.9, 5, 43000], [91.3, 0, 25000], [91.7, 0, 27000],
    [92.1, 0, 29000], [92.8, 0, 31000], [92.7, 0, 33000], [91.3, 0, 35000], [90.4, 0, 37000], [90.3, 0, 39000], [90.3, 0, 41000], [90.2, 0, 43000],
    [90.5, -5, 25000], [91, -5, 27000], [91.8, -5, 29000], [93.1, -5, 31000], [93.7, -5, 33000], [93, -5, 35000], [91.5, -5, 37000], [91.5, -5, 39000],
    [91.6, -5, 41000], [91.6, -5, 43000], [89.7, -10, 25000], [90.2, -10, 27000], [91, -10, 29000], [92.4, -10, 31000], [93.5, -10, 33000], [93.8, -10, 35000],
    [92.7, -10, 37000], [92.8, -10, 39000], [92.8, -10, 41000], [92.8, -10, 43000], [89, -15, 25000], [89.4, -15, 27000], [90.3, -15, 29000], [91.6, -15, 31000],
    [92.7, -15, 33000], [93.4, -15, 35000], [93.2, -15, 37000], [93.2, -15, 39000], [93.2, -15, 41000], [93.2, -15, 43000], [88.2, -20, 25000],
    [88.7, -20, 27000], [89.5, -20, 29000], [90.8, -20, 31000], [91.9, -20, 33000], [92.6, -20, 35000], [92.4, -20, 37000], [92.4, -20, 39000],
    [92.4, -20, 41000], [92.4, -20, 43000], [87.4, -25, 25000], [87.9, -25, 27000], [88.7, -25, 29000], [90, -25, 31000], [91.1, -25, 33000], [91.8, -25, 35000],
    [91.6, -25, 37000], [91.6, -25, 39000], [91.6, -25, 41000], [91.6, -25, 43000], [86.6, -30, 25000], [87.1, -30, 27000], [87.9, -30, 29000],
    [89.2, -30, 31000], [90.3, -30, 33000], [90.9, -30, 35000], [90.7, -30, 37000], [90.7, -30, 39000], [90.8, -30, 41000], [90.8, -30, 43000],
    [85.8, -35, 25000], [86.2, -35, 27000], [87.1, -35, 29000], [88.4, -35, 31000], [89.4, -35, 33000], [90.1, -35, 35000], [89.9, -35, 37000],
    [89.9, -35, 39000], [89.9, -35, 41000], [89.9, -35, 43000]
]);
B787EngineData.max_con_n1 = new LerpLookupTable([
    [89.3, 30, 5000], [90, 30, 10000], [90.6, 30, 12000], [90.2, 30, 14000], [89.8, 30, 16000], [90, 30, 18000], [90.6, 30, 20000], [90.1, 30, 22000],
    [89.8, 30, 24000], [89.7, 30, 25000], [89.7, 30, 27000], [89.7, 30, 29000], [89.3, 30, 31000], [88.5, 30, 33000], [87.6, 30, 35000], [86.4, 30, 37000],
    [88.7, 25, 5000], [90.9, 25, 10000], [91.6, 25, 12000], [91.4, 25, 14000], [90.9, 25, 16000], [90.8, 25, 18000], [91.5, 25, 20000], [91.1, 25, 22000],
    [90.9, 25, 24000], [90.9, 25, 25000], [91.1, 25, 27000], [91.1, 25, 29000], [90.7, 25, 31000], [89.9, 25, 33000], [89.1, 25, 35000], [87.9, 25, 37000],
    [88, 20, 5000], [90.6, 20, 10000], [92.3, 20, 12000], [92.1, 20, 14000], [92.2, 20, 16000], [92.2, 20, 18000], [92.5, 20, 20000], [92.1, 20, 22000],
    [91.9, 20, 24000], [91.9, 20, 25000], [92.2, 20, 27000], [92.4, 20, 29000], [92, 20, 31000], [91.2, 20, 33000], [90.5, 20, 35000], [89.1, 20, 37000],
    [87.3, 15, 5000], [89.9, 15, 10000], [91.6, 15, 12000], [91.9, 15, 14000], [92.4, 15, 16000], [93.1, 15, 18000], [93.6, 15, 20000], [93.4, 15, 22000],
    [93.1, 15, 24000], [93, 15, 25000], [93.3, 15, 27000], [93.5, 15, 29000], [93.2, 15, 31000], [92.3, 15, 33000], [91.6, 15, 35000], [90.1, 15, 37000],
    [86.7, 10, 5000], [89.2, 10, 10000], [90.9, 10, 12000], [91.1, 10, 14000], [91.7, 10, 16000], [93, 10, 18000], [95.1, 10, 20000], [94.7, 10, 22000],
    [94.7, 10, 24000], [95, 10, 25000], [95, 10, 27000], [94.9, 10, 29000], [94.5, 10, 31000], [93.3, 10, 33000], [92.6, 10, 35000], [91.1, 10, 37000],
    [86, 5, 5000], [88.5, 5, 10000], [90.2, 5, 12000], [90.4, 5, 14000], [91, 5, 16000], [92.2, 5, 18000], [94.3, 5, 20000], [94.8, 5, 22000], [95.3, 5, 24000],
    [95.6, 5, 25000], [96.3, 5, 27000], [96.5, 5, 29000], [96, 5, 31000], [94.7, 5, 33000], [93.8, 5, 35000], [92.1, 5, 37000],
    [85.3, 0, 5000], [87.8, 0, 10000], [89.4, 0, 12000], [89.7, 0, 14000], [90.3, 0, 16000], [91.5, 0, 18000], [93.6, 0, 20000], [94.1, 0, 22000],
    [94.6, 0, 24000], [95.1, 0, 25000], [96.3, 0, 27000], [97.3, 0, 29000], [97.2, 0, 31000], [96.1, 0, 33000], [95.3, 0, 35000], [93.3, 0, 37000],
    [84.5, -5, 5000], [87.1, -5, 10000], [88.7, -5, 12000], [88.9, -5, 14000], [89.5, -5, 16000], [90.8, -5, 18000], [92.9, -5, 20000], [93.3, -5, 22000],
    [93.8, -5, 24000], [94.3, -5, 25000], [95.5, -5, 27000], [96.5, -5, 29000], [97.1, -5, 31000], [96.8, -5, 33000], [96.6, -5, 35000], [94.6, -5, 37000],
    [83.8, -10, 5000], [86.3, -10, 10000], [88, -10, 12000], [88.2, -10, 14000], [88.8, -10, 16000], [90, -10, 18000], [92.1, -10, 20000], [92.6, -10, 22000],
    [93.1, -10, 24000], [93.5, -10, 25000], [94.8, -10, 27000], [95.7, -10, 29000], [96.3, -10, 31000], [96, -10, 33000], [95.9, -10, 35000], [93.8, -10, 37000],
    [83.1, -15, 5000], [85.6, -15, 10000], [87.2, -15, 12000], [87.4, -15, 14000], [88, -15, 16000], [89.3, -15, 18000], [91.4, -15, 20000], [91.8, -15, 22000],
    [92.3, -15, 24000], [92.8, -15, 25000], [94, -15, 27000], [95, -15, 29000], [95.6, -15, 31000], [95.2, -15, 33000], [95.1, -15, 35000], [93, -15, 37000],
    [82.4, -20, 5000], [84.9, -20, 10000], [86.4, -20, 12000], [86.7, -20, 14000], [87.2, -20, 16000], [88.5, -20, 18000], [90.6, -20, 20000], [91, -20, 22000],
    [91.5, -20, 24000], [92, -20, 25000], [93.2, -20, 27000], [94.2, -20, 29000], [94.7, -20, 31000], [94.4, -20, 33000], [94.3, -20, 35000], [92.2, -20, 37000],
    [81.6, -25, 5000], [84.1, -25, 10000], [85.7, -25, 12000], [85.9, -25, 14000], [86.4, -25, 16000], [87.7, -25, 18000], [89.8, -25, 20000], [90.2, -25, 22000],
    [90.7, -25, 24000], [91.2, -25, 25000], [92.4, -25, 27000], [93.4, -25, 29000], [93.9, -25, 31000], [93.6, -25, 33000], [93.5, -25, 35000], [91.4, -25, 37000],
    [80.9, -30, 5000], [83.3, -30, 10000], [84.9, -30, 12000], [85.1, -30, 14000], [85.6, -30, 16000], [86.9, -30, 18000], [89, -30, 20000], [89.4, -30, 22000],
    [89.9, -30, 24000], [90.4, -30, 25000], [91.6, -30, 27000], [92.5, -30, 29000], [93.1, -30, 31000], [92.8, -30, 33000], [92.7, -30, 35000], [90.6, -30, 37000],
    [80.1, -35, 5000], [82.5, -35, 10000], [84.1, -35, 12000], [84.3, -35, 14000], [84.8, -35, 16000], [86.1, -35, 18000], [88.2, -35, 20000], [88.6, -35, 22000],
    [89.1, -35, 24000], [89.5, -35, 25000], [90.8, -35, 27000], [91.7, -35, 29000], [92.3, -35, 31000], [92, -35, 33000], [91.8, -35, 35000], [89.8, -35, 37000],
    [79.3, -40, 5000], [81.7, -40, 10000], [83.3, -40, 12000], [83.5, -40, 14000], [84, -40, 16000], [85.3, -40, 18000], [87.4, -40, 20000], [87.8, -40, 22000],
    [88.3, -40, 24000], [88.7, -40, 25000], [89.9, -40, 27000], [90.8, -40, 29000], [91.4, -40, 31000], [91.1, -40, 33000], [91, -40, 35000], [88.9, -40, 37000]
]);
B787EngineData.lrc_mach = new LerpLookupTable([
    // New data, this is for the 787-10 from the respective FCOM.
    // At weight 617294/280t:
    [0.825, 617294.3, 25000], [0.855, 617294.3, 27000], [0.858, 617294.3, 29000], [0.854, 617294.3, 31000], [0.847, 617294.3, 33000],
    [.843, 617294.3, 35000], [.833, 617294.3, 37000], [.815, 617294.3, 39000], [.801, 617294.3, 41000], [.789, 617294.3, 43000],
    // At weight 573201/260t:
    [0.789, 573201.2, 25000], [0.832, 573201.2, 27000], [0.857, 573201.2, 29000], [0.857, 573201.2, 31000], [0.853, 573201.2, 33000],
    [0.845, 573201.2, 35000], [.833, 573201.2, 37000], [.815, 573201.2, 39000], [.801, 573201.2, 41000], [.789, 573201.2, 43000],
    // At weight 529108/240t:
    [0.758, 529108.8, 25000], [0.792, 529108.8, 27000], [0.836, 529108.8, 29000], [0.858, 529108.8, 31000], [0.857, 529108.8, 33000],
    [0.852, 529108.8, 35000], [0.843, 529108.8, 37000], [0.837, 529108.8, 39000], [0.829, 529108.8, 41000], [0.814, 529108.8, 43000],
    // At weight 485016/220t:
    [0.731, 485016.4, 25000], [0.759, 485016.4, 27000], [0.794, 485016.4, 29000], [0.838, 485016.4, 31000], [0.858, 485016.4, 33000],
    [0.856, 485016.4, 35000], [0.851, 485016.4, 37000], [0.844, 485016.4, 39000], [0.834, 485016.4, 41000], [0.824, 485016.4, 43000],
    // At weight 440924/200t:
    [0.704, 440924, 25000], [0.729, 440924, 27000], [0.757, 440924, 29000], [0.792, 440924, 31000], [0.837, 440924, 33000],
    [0.858, 440924, 35000], [0.856, 440924, 37000], [0.851, 440924, 39000], [0.842, 440924, 41000], [0.835, 440924, 43000],
    // At weight 396831/180t:
    [0.676, 396831.6, 25000], [0.700, 396831.6, 27000], [0.725, 396831.6, 29000], [0.752, 396831.6, 31000], [0.786, 396831.6, 33000],
    [0.832, 396831.6, 35000], [0.858, 396831.6, 37000], [0.857, 396831.6, 39000], [0.852, 396831.6, 41000], [.845, 396831.6, 43000],
    // At weight 352739/160t:
    [0.644, 352739.2, 25000], [0.668, 352739.2, 27000], [0.692, 352739.2, 29000], [0.717, 352739.2, 31000], [0.744, 352739.2, 33000],
    [0.775, 352739.2, 35000], [0.820, 352739.2, 37000], [0.855, 352739.2, 39000], [0.857, 352739.2, 41000], [0.854, 352739.2, 43000],
    // At weight 308646/140t:
    [0.612, 308646.8, 25000], [0.633, 308646.8, 27000], [0.656, 308646.8, 29000], [0.681, 308646.8, 31000], [0.706, 308646.8, 33000],
    [0.733, 308646.8, 35000], [0.763, 308646.8, 37000], [0.802, 308646.8, 39000], [0.847, 308646.8, 41000], [0.853, 308646.8, 43000],
    // At weight 264554/120t:
    [0.581, 264554.4, 25000], [0.598, 264554.4, 27000], [0.618, 264554.4, 29000], [0.639, 264554.4, 31000], [0.664, 264554.4, 33000],
    [0.690, 264554.4, 35000], [0.716, 264554.4, 37000], [0.744, 264554.4, 39000], [0.775, 264554.4, 41000], [0.818, 264554.4, 43000]
]);
/** Output: Opt Altitude in Ft; Term 1: Weight in LBS */
B787EngineData.alt_opt = new LerpLookupTable([
    [31800, 573201.2],
    [32600, 551155],
    [33500, 529108.8],
    [34400, 507062.6],
    [35300, 485016.4],
    [36300, 462970.2],
    [37300, 440924],
    [38400, 418877.8],
    [39500, 396831.6],
    [40700, 374785.4],
    [41900, 352739.2],
    [43100, 330693],
    [43100, 308646.8],
    [43100, 286600.6],
    [43100, 264554.4]
]);
/** Output: Max Altitude in Ft; Term 1: Weight in LBS; Term 2: ISA Tem Deviation in C */
B787EngineData.alt_max = new LerpLookupTable([
    [34700, 573201.2, -100], [34700, 573201.2, 10], [34400, 573201.2, 15], [32700, 573201.2, 20],
    [35600, 551155, -100], [35600, 551155, 10], [35300, 551155, 15], [33800, 551155, 20],
    [36400, 529108.8, -100], [36400, 529108.8, 10], [36000, 529108.8, 15], [34800, 529108.8, 20],
    [37300, 507062.6, -100], [37300, 507062.6, 10], [36800, 507062.6, 15], [35800, 507062.6, 20],
    [38200, 485016.4, -100], [38200, 485016.4, 10], [37700, 485016.4, 15], [36500, 485016.4, 20],
    [39200, 462970.2, -100], [39200, 462970.2, 10], [38700, 462970.2, 15], [37500, 462970.2, 20],
    [40200, 440924, -100], [40200, 440924, 10], [39600, 440924, 15], [38400, 440924, 20],
    [41300, 418877.8, -100], [41300, 418877.8, 10], [40600, 418877.8, 15], [39300, 418877.8, 20],
    [42300, 396831.6, -100], [42300, 396831.6, 10], [41600, 396831.6, 15], [40200, 396831.6, 20],
    [43100, 374785.4, -100], [43100, 374785.4, 10], [42700, 374785.4, 15], [41100, 374785.4, 20],
    [43100, 352739.2, -100], [43100, 352739.2, 10], [43100, 352739.2, 15], [42100, 352739.2, 20],
    [43100, 330693, -100], [43100, 330693, 10], [43100, 330693, 15], [43100, 330693, 20],
    [43100, 308646.8, -100], [43100, 308646.8, 10], [43100, 308646.8, 15], [43100, 308646.8, 20],
    [43100, 286600.6, -100], [43100, 286600.6, 10], [43100, 286600.6, 15], [43100, 286600.6, 20],
    [43100, 264554.4, -100], [43100, 264554.4, 10], [43100, 264554.4, 15], [43100, 264554.4, 20]
]);
B787EngineData.n1_tpr_lookup = new LerpLookupTable([
    [1.015, -30, -2000, 90], [1.06, -30, 0, 90], [1.105, -30, 5000, 90], [1.124, -30, 10000, 90], [1.129, -30, 11000, 90], [1.14, -30, 12000, 90], [1.139, -30, 13000, 90],
    [1.139, -30, 14000, 90], [1.079, -30, 20000, 90], [1.094, -30, 25000, 90], [1.112, -30, 30000, 90], [1.135, -30, 35000, 90], [1.132, -30, 40000, 90], [1.134, -30, 43000, 90],
    [1.015, -30, -2000, 65], [1.06, -30, 0, 65], [1.105, -30, 5000, 65], [1.124, -30, 10000, 65], [1.129, -30, 11000, 65], [1.14, -30, 12000, 65], [1.139, -30, 13000, 65],
    [1.139, -30, 14000, 65], [1.079, -30, 20000, 65], [1.094, -30, 25000, 65], [1.112, -30, 30000, 65], [1.135, -30, 35000, 65], [1.132, -30, 40000, 65], [1.134, -30, 43000, 65],
    [0.338, -30, -2000, 25], [0.353, -30, 0, 25], [0.368, -30, 5000, 25], [0.375, -30, 10000, 25], [0.376, -30, 11000, 25], [0.38, -30, 12000, 25], [0.38, -30, 13000, 25],
    [0.38, -30, 14000, 25], [0.36, -30, 20000, 25], [0.365, -30, 25000, 25], [0.371, -30, 30000, 25], [0.378, -30, 35000, 25], [0.377, -30, 40000, 25], [0.378, -30, 43000, 25],
    [0.238, -30, -2000, 0], [0.253, -30, 0, 0], [0.268, -30, 5000, 0], [0.275, -30, 10000, 0], [0.276, -30, 11000, 0], [0.28, -30, 12000, 0], [0.28, -30, 13000, 0],
    [0.28, -30, 14000, 0], [0.26, -30, 20000, 0], [0.265, -30, 25000, 0], [0.271, -30, 30000, 0], [0.278, -30, 35000, 0], [0.277, -30, 40000, 0], [0.278, -30, 43000, 0],
    [0.971, -10, -2000, 90], [1.014, -10, 0, 90], [1.057, -10, 5000, 90], [1.077, -10, 10000, 90], [1.079, -10, 11000, 90], [1.091, -10, 12000, 90], [1.091, -10, 13000, 90],
    [1.09, -10, 14000, 90], [1.032, -10, 20000, 90], [1.047, -10, 25000, 90], [1.065, -10, 30000, 90], [1.082, -10, 35000, 90], [1.072, -10, 40000, 90], [1.073, -10, 43000, 90],
    [0.971, -10, -2000, 65], [1.014, -10, 0, 65], [1.057, -10, 5000, 65], [1.077, -10, 10000, 65], [1.079, -10, 11000, 65], [1.091, -10, 12000, 65], [1.091, -10, 13000, 65],
    [1.09, -10, 14000, 65], [1.032, -10, 20000, 65], [1.047, -10, 25000, 65], [1.065, -10, 30000, 65], [1.082, -10, 35000, 65], [1.072, -10, 40000, 65], [1.073, -10, 43000, 65],
    [0.324, -10, -2000, 25], [0.338, -10, 0, 25], [0.352, -10, 5000, 25], [0.359, -10, 10000, 25], [0.36, -10, 11000, 25], [0.364, -10, 12000, 25], [0.364, -10, 13000, 25],
    [0.363, -10, 14000, 25], [0.344, -10, 20000, 25], [0.349, -10, 25000, 25], [0.355, -10, 30000, 25], [0.361, -10, 35000, 25], [0.357, -10, 40000, 25], [0.358, -10, 43000, 25],
    [0.224, -10, -2000, 0], [0.238, -10, 0, 0], [0.252, -10, 5000, 0], [0.259, -10, 10000, 0], [0.26, -10, 11000, 0], [0.264, -10, 12000, 0], [0.264, -10, 13000, 0],
    [0.263, -10, 14000, 0], [0.244, -10, 20000, 0], [0.249, -10, 25000, 0], [0.255, -10, 30000, 0], [0.261, -10, 35000, 0], [0.257, -10, 40000, 0], [0.258, -10, 43000, 0],
    [0.949, 0, -2000, 90], [0.991, 0, 0, 90], [1.036, 0, 5000, 90], [1.053, 0, 10000, 90], [1.058, 0, 11000, 90], [1.07, 0, 12000, 90], [1.067, 0, 13000, 90], [1.06, 0, 14000, 90],
    [1.011, 0, 20000, 90], [1.026, 0, 25000, 90], [1.034, 0, 30000, 90], [1.014, 0, 35000, 90], [0.997, 0, 40000, 90], [0.996, 0, 43000, 90],
    [0.949, 0, -2000, 65], [0.991, 0, 0, 65], [1.036, 0, 5000, 65], [1.053, 0, 10000, 65], [1.058, 0, 11000, 65], [1.07, 0, 12000, 65], [1.067, 0, 13000, 65],
    [1.06, 0, 14000, 65], [1.011, 0, 20000, 65], [1.026, 0, 25000, 65], [1.034, 0, 30000, 65], [1.014, 0, 35000, 65], [0.997, 0, 40000, 65], [0.996, 0, 43000, 65],
    [0.316, 0, -2000, 25], [0.33, 0, 0, 25], [0.345, 0, 5000, 25], [0.351, 0, 10000, 25], [0.353, 0, 11000, 25], [0.357, 0, 12000, 25], [0.356, 0, 13000, 25],
    [0.353, 0, 14000, 25], [0.337, 0, 20000, 25], [0.342, 0, 25000, 25], [0.345, 0, 30000, 25], [0.338, 0, 35000, 25], [0.332, 0, 40000, 25], [0.332, 0, 43000, 25],
    [0.216, 0, -2000, 0], [0.23, 0, 0, 0], [0.245, 0, 5000, 0], [0.251, 0, 10000, 0], [0.253, 0, 11000, 0], [0.257, 0, 12000, 0], [0.256, 0, 13000, 0], [0.253, 0, 14000, 0],
    [0.237, 0, 20000, 0], [0.242, 0, 25000, 0], [0.245, 0, 30000, 0], [0.238, 0, 35000, 0], [0.232, 0, 40000, 0], [0.232, 0, 43000, 0],
    [0.92, 15, -2000, 90], [0.96, 15, 0, 90], [1.003, 15, 5000, 90], [1.005, 15, 10000, 90], [0.998, 15, 11000, 90], [0.991, 15, 12000, 90], [0.985, 15, 13000, 90],
    [0.977, 15, 14000, 90], [0.957, 15, 20000, 90], [0.934, 15, 25000, 90], [0.918, 15, 30000, 90], [0.893, 15, 35000, 90], [0.864, 15, 40000, 90], [0.857, 15, 43000, 90],
    [0.92, 15, -2000, 65], [0.96, 15, 0, 65], [1.003, 15, 5000, 65], [1.005, 15, 10000, 65], [0.998, 15, 11000, 65], [0.991, 15, 12000, 65], [0.985, 15, 13000, 65],
    [0.977, 15, 14000, 65], [0.957, 15, 20000, 65], [0.934, 15, 25000, 65], [0.918, 15, 30000, 65], [0.893, 15, 35000, 65], [0.864, 15, 40000, 65], [0.857, 15, 43000, 65],
    [0.307, 15, -2000, 25], [0.32, 15, 0, 25], [0.334, 15, 5000, 25], [0.335, 15, 10000, 25], [0.333, 15, 11000, 25], [0.33, 15, 12000, 25], [0.328, 15, 13000, 25],
    [0.326, 15, 14000, 25], [0.319, 15, 20000, 25], [0.311, 15, 25000, 25], [0.306, 15, 30000, 25], [0.298, 15, 35000, 25], [0.288, 15, 40000, 25], [0.286, 15, 43000, 25],
    [0.207, 15, -2000, 0], [0.22, 15, 0, 0], [0.234, 15, 5000, 0], [0.235, 15, 10000, 0], [0.233, 15, 11000, 0], [0.23, 15, 12000, 0], [0.228, 15, 13000, 0],
    [0.226, 15, 14000, 0], [0.219, 15, 20000, 0], [0.211, 15, 25000, 0], [0.206, 15, 30000, 0], [0.198, 15, 35000, 0], [0.188, 15, 40000, 0], [0.186, 15, 43000, 0],
    [0.893, 30, -2000, 90], [0.932, 30, 0, 90], [0.925, 30, 5000, 90], [0.9, 30, 10000, 90], [0.893, 30, 11000, 90], [0.884, 30, 12000, 90], [0.872, 30, 13000, 90],
    [0.858, 30, 14000, 90], [0.815, 30, 20000, 90], [0.799, 30, 25000, 90], [0.784, 30, 30000, 90], [0.822, 30, 35000, 90], [0.806, 30, 40000, 90], [0.798, 30, 43000, 90],
    [0.893, 30, -2000, 65], [0.932, 30, 0, 65], [0.925, 30, 5000, 65], [0.9, 30, 10000, 65], [0.893, 30, 11000, 65], [0.884, 30, 12000, 65], [0.872, 30, 13000, 65],
    [0.858, 30, 14000, 65], [0.815, 30, 20000, 65], [0.799, 30, 25000, 65], [0.784, 30, 30000, 65], [0.822, 30, 35000, 65], [0.806, 30, 40000, 65], [0.798, 30, 43000, 65],
    [0.298, 30, -2000, 25], [0.311, 30, 0, 25], [0.308, 30, 5000, 25], [0.3, 30, 10000, 25], [0.298, 30, 11000, 25], [0.295, 30, 12000, 25], [0.291, 30, 13000, 25],
    [0.286, 30, 14000, 25], [0.272, 30, 20000, 25], [0.266, 30, 25000, 25], [0.261, 30, 30000, 25], [0.274, 30, 35000, 25], [0.269, 30, 40000, 25], [0.266, 30, 43000, 25],
    [0.198, 30, -2000, 0], [0.211, 30, 0, 0], [0.208, 30, 5000, 0], [0.2, 30, 10000, 0], [0.198, 30, 11000, 0], [0.195, 30, 12000, 0], [0.191, 30, 13000, 0],
    [0.186, 30, 14000, 0], [0.172, 30, 20000, 0], [0.166, 30, 25000, 0], [0.161, 30, 30000, 0], [0.174, 30, 35000, 0], [0.169, 30, 40000, 0], [0.166, 30, 43000, 0]
]);

/** B787 Performance Math Utility Class. */
class B787PerformanceMath extends BoeingPerformanceDataProvider {
    /** @inheritDoc */
    get operatingEmptyWeight() {
        return 298700; // 135,488 kg
    }
    /** @inheritDoc */
    get maxZeroFuelWeight() {
        return 425000; // 192,777 kg
    }
    /** @inheritDoc */
    get maxGrossWeight() {
        return 557000; // 252,651 kg
    }
    /** @inheritDoc */
    get maxReserveFuel() {
        return Number.MAX_SAFE_INTEGER; // TODO Replace with actual value
    }
    /** @inheritDoc */
    get fuelFreezeTemp() {
        return -37;
    }
    /** @inheritDoc */
    get minCenterOfGravity() {
        return 6;
    }
    /** @inheritDoc */
    get maxCenterOfGravity() {
        return 39.5;
    }
    /** @inheritdoc */
    getAircraftFlightModel() {
        return {
            wing_span: 197,
            wing_area: 4058,
            //From the lift_coef_aoa_table: the value at aoa_0.
            cl_cd: [[0.317, 0.028], [0.5282, 0.0447], [0.5714, 0.526], [0.6147, 0.0620], [0.6580, 0.0729],
                [0.6801, 0.0788], [0.6952, 0.0830], [0.7173, 0.0898], [0.7109, 0.1041], [0.7284, 0.1280]],
            induced_drag_scalar: 1.3,
            oswald_efficiency_factor: 0.73,
            inlet_area: 68.4,
            low_idle_n1: 20,
            mach_influence_on_n1: 10,
            static_thrust: 76100,
            ThrustSpecificFuelConsumption: 0.265,
            /** Output: Thrust scalar; Term 1: CN1; Term 2: Mach */
            n1_and_mach_on_thrust_table: new LerpLookupTable([
                // updated 5/19/23 MBN
                [0, 0, 0], [0, 0, 0.4], [0, 0, 0.8], [0, 0, 0.9],
                [0.0705, 20, 0], [0, 20, 0.4], [0.0705, 20, 0.8], [0.0705, 20, 0.9],
                [0.087562, 26, 0], [0, 26, 0.4], [0.221344, 26, 0.8], [0.225566, 26, 0.9],
                [0.265, 50, 0], [0.29, 50, 0.4], [0.344558, 50, 0.8], [0.340335, 50, 0.9],
                [0.43, 65, 0], [0.44, 65, 0.4], [0.479558, 65, 0.8], [0.479558, 65, 0.9],
                [0.68, 80, 0], [0.715, 80, 0.4], [0.75, 80, 0.8], [0.76, 80, 0.9],
                [0.82, 85, 0], [0.86, 85, 0.4], [0.9, 85, 0.8], [0.91, 85, 0.9],
                [0.98, 90, 0], [1.02, 90, 0.4], [1.06, 90, 0.8], [1.11, 90, 0.9],
                [1.1, 95, 0], [1.165, 95, 0.4], [1.23, 95, 0.8], [1.24, 95, 0.9],
                [1.18, 100, 0], [1.25, 100, 0.4], [1.32, 100, 0.8], [1.32, 100, 0.9],
                [1.25, 105, 0], [1.335, 105, 0.4], [1.42, 105, 0.8], [1.42, 105, 0.9],
                [1.3, 110, 0], [1.395, 110, 0.4], [1.49, 110, 0.8], [1.49, 110, 0.9]
            ]),
            /** Output: CN1; Term 1: Thrust Scalar; Term 2: Mach */
            thrust_and_mach_on_n1_table: new LerpLookupTable([
                // updated 5/19/23 MBN
                [0, 0, 0], [0, 0, 0.4], [0, 0, 0.8], [0, 0, 0.9],
                [20, 0.0705, 0], [20, 0, 0.4], [20, 0.0705, 0.8], [20, 0.0705, 0.9],
                [26, 0.087562, 0], [26, 0, 0.4], [26, 0.221344, 0.8], [26, 0.225566, 0.9],
                [50, 0.265, 0], [50, 0.29, 0.4], [50, 0.344558, 0.8], [50, 0.340335, 0.9],
                [65, 0.43, 0], [65, 0.44, 0.4], [65, 0.479558, 0.8], [65, 0.479558, 0.9],
                [80, 0.68, 0], [80, 0.715, 0.4], [80, 0.75, 0.8], [80, 0.76, 0.9],
                [85, 0.82, 0], [85, 0.86, 0.4], [85, 0.9, 0.8], [85, 0.91, 0.9],
                [90, 0.98, 0], [90, 1.02, 0.4], [90, 1.06, 0.8], [90, 1.11, 0.9],
                [95, 1.1, 0], [95, 1.165, 0.4], [95, 1.23, 0.8], [95, 1.24, 0.9],
                [100, 1.18, 0], [100, 1.25, 0.4], [100, 1.32, 0.8], [100, 1.32, 0.9],
                [105, 1.25, 0], [105, 1.335, 0.4], [105, 1.42, 0.8], [105, 1.42, 0.9],
                [110, 1.3, 0], [110, 1.395, 0.4], [110, 1.49, 0.8], [110, 1.49, 0.9]
            ]),
            corrected_airflow_table: new LerpLookupTable([
                // updated 2/22/23 CWB
                [0, 0, 0], [0, 0, 0.9],
                [0.1, 20, 0], [5, 20, 0.9],
                [1, 40, 0], [7.3, 40, 0.9],
                [3, 60, 0], [8.75, 60, 0.9],
                [4, 70, 0], [9.7, 70, 0.9],
                [5, 75, 0], [10.5, 75, 0.9],
                [8, 80, 0], [12, 80, 0.9],
                [11.5, 85, 0], [14.75, 85, 0.9],
                [15, 90, 0], [18, 90, 0.9],
                [17, 95, 0], [21, 95, 0.9],
                [19, 100, 0], [23, 100, 0.9],
                [21, 105, 0], [24.75, 105, 0.9],
                [23, 110, 0], [26.25, 110, 0.9]
            ])
        };
    }
}

/* eslint-disable max-len */
/** Boeing Speed Data */
class B787SpeedData {
    /**
     * Construct an instance of the 787 speed provider
     * @param bus Event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.pressureAlt.setConsumer(this.bus.getSubscriber().on('pressure_alt'));
    }
    /** @inheritdoc */
    getFlapManeuverSpeed(flapPos, weight, pressureAlt) {
        return B787SpeedData.flap_maneuver_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVrefSpeed(flapPos, weight, pressureAlt) {
        if (flapPos === 20) {
            // We don't have pressure alt corrected data for 10k... do a dirty and use the difference between maneuver speeds
            const vRef14k = B787SpeedData.vref14k.get(weight, flapPos);
            const maneuver14k = this.getFlapManeuverSpeed(flapPos, weight, 14000);
            const maneuver = this.getFlapManeuverSpeed(flapPos, weight, pressureAlt);
            return vRef14k + (maneuver - maneuver14k);
        }
        if (flapPos === 25 || flapPos === 30) {
            // the flap maneuver speeds for 25 and 30 are vref, and corrected for pressure alt
            return this.getFlapManeuverSpeed(flapPos, weight, pressureAlt);
        }
        throw new Error('20, 25, 30 are the only valid 787 VREF flap positions');
    }
    /** @inheritdoc */
    getHoldingSpeed(flapPos, weight, pressureAlt) {
        return B787SpeedData.holding_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVmo(pressureAlt) {
        // The 787's official Type Certificate Data Sheet contains these speed limits: VMO/MMO 350KEAS / 360KIAS / 0.90M
        return Math.min(360, BoeingAeroMath.easToCas(B787SpeedData.vmo, pressureAlt !== null && pressureAlt !== void 0 ? pressureAlt : this.pressureAlt.get()));
    }
    /** @inheritdoc */
    getMmo() {
        return B787SpeedData.mmo;
    }
    /** @inheritdoc */
    getGearLimitSpeed() {
        return B787SpeedData.vle;
    }
}
/** Maximum Speed Limit Mach Number */
B787SpeedData.mmo = 0.9;
/** Maximum Speed Limit KEAS */
B787SpeedData.vmo = 350;
/** Landing Gear Placard Speed KIAS */
B787SpeedData.vle = 270;
/** Flap Maneuver Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B787SpeedData.flap_maneuver_speeds = new LerpLookupTable([
    [258, 573202, 0, 0], [238, 573202, 1, 0], [208, 573202, 5, 0], [198, 573202, 10, 0], [193, 573202, 15, 0], [193, 573202, 17, 0], [193, 573202, 18, 0], [187, 573202, 20, 0], [179, 573202, 25, 0], [174, 573202, 30, 0],
    [258, 551156, 0, 0], [238, 551156, 1, 0], [208, 551156, 5, 0], [198, 551156, 10, 0], [193, 551156, 15, 0], [193, 551156, 17, 0], [193, 551156, 18, 0], [185, 551156, 20, 0], [175, 551156, 25, 0], [170, 551156, 30, 0],
    [258, 529110, 0, 0], [237, 529110, 1, 0], [208, 529110, 5, 0], [195, 529110, 10, 0], [190, 529110, 15, 0], [190, 529110, 17, 0], [190, 529110, 18, 0], [182, 529110, 20, 0], [172, 529110, 25, 0], [167, 529110, 30, 0],
    [253, 507064, 0, 0], [233, 507064, 1, 0], [206, 507064, 5, 0], [192, 507064, 10, 0], [187, 507064, 15, 0], [187, 507064, 17, 0], [187, 507064, 18, 0], [178, 507064, 20, 0], [168, 507064, 25, 0], [163, 507064, 30, 0],
    [246, 485017, 0, 0], [227, 485017, 1, 0], [203, 485017, 5, 0], [188, 485017, 10, 0], [183, 485017, 15, 0], [183, 485017, 17, 0], [183, 485017, 18, 0], [174, 485017, 20, 0], [164, 485017, 25, 0], [159, 485017, 30, 0],
    [238, 462971, 0, 0], [222, 462971, 1, 0], [199, 462971, 5, 0], [184, 462971, 10, 0], [179, 462971, 15, 0], [179, 462971, 17, 0], [179, 462971, 18, 0], [171, 462971, 20, 0], [160, 462971, 25, 0], [155, 462971, 30, 0],
    [234, 440925, 0, 0], [217, 440925, 1, 0], [195, 440925, 5, 0], [180, 440925, 10, 0], [175, 440925, 15, 0], [175, 440925, 17, 0], [175, 440925, 18, 0], [167, 440925, 20, 0], [157, 440925, 25, 0], [152, 440925, 30, 0],
    [233, 418879, 0, 0], [211, 418879, 1, 0], [191, 418879, 5, 0], [176, 418879, 10, 0], [171, 418879, 15, 0], [171, 418879, 17, 0], [171, 418879, 18, 0], [165, 418879, 20, 0], [155, 418879, 25, 0], [150, 418879, 30, 0],
    [227, 396832, 0, 0], [206, 396832, 1, 0], [187, 396832, 5, 0], [172, 396832, 10, 0], [167, 396832, 15, 0], [167, 396832, 17, 0], [167, 396832, 18, 0], [161, 396832, 20, 0], [150, 396832, 25, 0], [146, 396832, 30, 0],
    [223, 374786, 0, 0], [200, 374786, 1, 0], [183, 374786, 5, 0], [168, 374786, 10, 0], [163, 374786, 15, 0], [163, 374786, 17, 0], [163, 374786, 18, 0], [157, 374786, 20, 0], [146, 374786, 25, 0], [141, 374786, 30, 0],
    [218, 352740, 0, 0], [194, 352740, 1, 0], [179, 352740, 5, 0], [164, 352740, 10, 0], [158, 352740, 15, 0], [158, 352740, 17, 0], [158, 352740, 18, 0], [152, 352740, 20, 0], [141, 352740, 25, 0], [137, 352740, 30, 0],
    [214, 330694, 0, 0], [189, 330694, 1, 0], [174, 330694, 5, 0], [159, 330694, 10, 0], [154, 330694, 15, 0], [154, 330694, 17, 0], [154, 330694, 18, 0], [148, 330694, 20, 0], [137, 330694, 25, 0], [132, 330694, 30, 0],
    [209, 308647, 0, 0], [184, 308647, 1, 0], [170, 308647, 5, 0], [154, 308647, 10, 0], [149, 308647, 15, 0], [149, 308647, 17, 0], [149, 308647, 18, 0], [143, 308647, 20, 0], [132, 308647, 25, 0], [128, 308647, 30, 0],
    [206, 286601, 0, 0], [180, 286601, 1, 0], [166, 286601, 5, 0], [150, 286601, 10, 0], [145, 286601, 15, 0], [145, 286601, 17, 0], [145, 286601, 18, 0], [139, 286601, 20, 0], [127, 286601, 25, 0], [124, 286601, 30, 0],
    [202, 264555, 0, 0], [177, 264555, 1, 0], [162, 264555, 5, 0], [147, 264555, 10, 0], [142, 264555, 15, 0], [142, 264555, 17, 0], [142, 264555, 18, 0], [135, 264555, 20, 0], [122, 264555, 25, 0], [121, 264555, 30, 0],
    [258, 573202, 0, 10000], [238, 573202, 1, 10000], [208, 573202, 5, 10000], [200, 573202, 10, 10000], [194, 573202, 15, 10000], [194, 573202, 17, 10000], [194, 573202, 18, 10000], [188, 573202, 20, 10000], [182, 573202, 25, 10000], [175, 573202, 30, 10000],
    [258, 551156, 0, 10000], [238, 551156, 1, 10000], [208, 551156, 5, 10000], [200, 551156, 10, 10000], [194, 551156, 15, 10000], [194, 551156, 17, 10000], [194, 551156, 18, 10000], [187, 551156, 20, 10000], [178, 551156, 25, 10000], [172, 551156, 30, 10000],
    [258, 529110, 0, 10000], [238, 529110, 1, 10000], [208, 529110, 5, 10000], [197, 529110, 10, 10000], [192, 529110, 15, 10000], [192, 529110, 17, 10000], [192, 529110, 18, 10000], [183, 529110, 20, 10000], [174, 529110, 25, 10000], [168, 529110, 30, 10000],
    [253, 507064, 0, 10000], [234, 507064, 1, 10000], [207, 507064, 5, 10000], [193, 507064, 10, 10000], [188, 507064, 15, 10000], [188, 507064, 17, 10000], [188, 507064, 18, 10000], [179, 507064, 20, 10000], [170, 507064, 25, 10000], [164, 507064, 30, 10000],
    [246, 485017, 0, 10000], [229, 485017, 1, 10000], [204, 485017, 5, 10000], [189, 485017, 10, 10000], [184, 485017, 15, 10000], [184, 485017, 17, 10000], [184, 485017, 18, 10000], [176, 485017, 20, 10000], [166, 485017, 25, 10000], [161, 485017, 30, 10000],
    [238, 462971, 0, 10000], [224, 462971, 1, 10000], [200, 462971, 5, 10000], [185, 462971, 10, 10000], [180, 462971, 15, 10000], [180, 462971, 17, 10000], [180, 462971, 18, 10000], [172, 462971, 20, 10000], [162, 462971, 25, 10000], [157, 462971, 30, 10000],
    [234, 440925, 0, 10000], [218, 440925, 1, 10000], [196, 440925, 5, 10000], [181, 440925, 10, 10000], [176, 440925, 15, 10000], [176, 440925, 17, 10000], [176, 440925, 18, 10000], [169, 440925, 20, 10000], [159, 440925, 25, 10000], [153, 440925, 30, 10000],
    [233, 418879, 0, 10000], [213, 418879, 1, 10000], [192, 418879, 5, 10000], [177, 418879, 10, 10000], [172, 418879, 15, 10000], [172, 418879, 17, 10000], [172, 418879, 18, 10000], [166, 418879, 20, 10000], [156, 418879, 25, 10000], [151, 418879, 30, 10000],
    [228, 396832, 0, 10000], [207, 396832, 1, 10000], [188, 396832, 5, 10000], [173, 396832, 10, 10000], [168, 396832, 15, 10000], [168, 396832, 17, 10000], [168, 396832, 18, 10000], [162, 396832, 20, 10000], [152, 396832, 25, 10000], [147, 396832, 30, 10000],
    [224, 374786, 0, 10000], [201, 374786, 1, 10000], [184, 374786, 5, 10000], [169, 374786, 10, 10000], [164, 374786, 15, 10000], [164, 374786, 17, 10000], [164, 374786, 18, 10000], [158, 374786, 20, 10000], [147, 374786, 25, 10000], [142, 374786, 30, 10000],
    [219, 352740, 0, 10000], [195, 352740, 1, 10000], [179, 352740, 5, 10000], [164, 352740, 10, 10000], [159, 352740, 15, 10000], [159, 352740, 17, 10000], [159, 352740, 18, 10000], [153, 352740, 20, 10000], [142, 352740, 25, 10000], [138, 352740, 30, 10000],
    [215, 330694, 0, 10000], [189, 330694, 1, 10000], [175, 330694, 5, 10000], [160, 330694, 10, 10000], [155, 330694, 15, 10000], [155, 330694, 17, 10000], [155, 330694, 18, 10000], [148, 330694, 20, 10000], [137, 330694, 25, 10000], [133, 330694, 30, 10000],
    [210, 308647, 0, 10000], [184, 308647, 1, 10000], [170, 308647, 5, 10000], [155, 308647, 10, 10000], [150, 308647, 15, 10000], [150, 308647, 17, 10000], [150, 308647, 18, 10000], [144, 308647, 20, 10000], [132, 308647, 25, 10000], [128, 308647, 30, 10000],
    [206, 286601, 0, 10000], [180, 286601, 1, 10000], [166, 286601, 5, 10000], [151, 286601, 10, 10000], [146, 286601, 15, 10000], [146, 286601, 17, 10000], [146, 286601, 18, 10000], [139, 286601, 20, 10000], [127, 286601, 25, 10000], [124, 286601, 30, 10000],
    [202, 264555, 0, 10000], [177, 264555, 1, 10000], [163, 264555, 5, 10000], [147, 264555, 10, 10000], [142, 264555, 15, 10000], [142, 264555, 17, 10000], [142, 264555, 18, 10000], [135, 264555, 20, 10000], [122, 264555, 25, 10000], [121, 264555, 30, 10000],
    [260, 573202, 0, 20000], [239, 573202, 1, 20000], [209, 573202, 5, 20000], [202, 573202, 10, 20000], [194, 573202, 15, 20000], [194, 573202, 17, 20000], [194, 573202, 18, 20000], [189, 573202, 20, 20000], [185, 573202, 25, 20000], [177, 573202, 30, 20000],
    [259, 551156, 0, 20000], [239, 551156, 1, 20000], [209, 551156, 5, 20000], [202, 551156, 10, 20000], [194, 551156, 15, 20000], [194, 551156, 17, 20000], [194, 551156, 18, 20000], [189, 551156, 20, 20000], [181, 551156, 25, 20000], [174, 551156, 30, 20000],
    [259, 529110, 0, 20000], [239, 529110, 1, 20000], [209, 529110, 5, 20000], [199, 529110, 10, 20000], [193, 529110, 15, 20000], [193, 529110, 17, 20000], [193, 529110, 18, 20000], [185, 529110, 20, 20000], [177, 529110, 25, 20000], [170, 529110, 30, 20000],
    [254, 507064, 0, 20000], [237, 507064, 1, 20000], [209, 507064, 5, 20000], [195, 507064, 10, 20000], [190, 507064, 15, 20000], [190, 507064, 17, 20000], [190, 507064, 18, 20000], [181, 507064, 20, 20000], [173, 507064, 25, 20000], [166, 507064, 30, 20000],
    [247, 485017, 0, 20000], [232, 485017, 1, 20000], [206, 485017, 5, 20000], [191, 485017, 10, 20000], [186, 485017, 15, 20000], [186, 485017, 17, 20000], [186, 485017, 18, 20000], [177, 485017, 20, 20000], [169, 485017, 25, 20000], [162, 485017, 30, 20000],
    [239, 462971, 0, 20000], [227, 462971, 1, 20000], [202, 462971, 5, 20000], [187, 462971, 10, 20000], [182, 462971, 15, 20000], [182, 462971, 17, 20000], [182, 462971, 18, 20000], [174, 462971, 20, 20000], [165, 462971, 25, 20000], [158, 462971, 30, 20000],
    [234, 440925, 0, 20000], [221, 440925, 1, 20000], [198, 440925, 5, 20000], [183, 440925, 10, 20000], [178, 440925, 15, 20000], [178, 440925, 17, 20000], [178, 440925, 18, 20000], [170, 440925, 20, 20000], [161, 440925, 25, 20000], [155, 440925, 30, 20000],
    [234, 418879, 0, 20000], [215, 418879, 1, 20000], [194, 418879, 5, 20000], [179, 418879, 10, 20000], [174, 418879, 15, 20000], [174, 418879, 17, 20000], [174, 418879, 18, 20000], [168, 418879, 20, 20000], [159, 418879, 25, 20000], [152, 418879, 30, 20000],
    [229, 396832, 0, 20000], [209, 396832, 1, 20000], [190, 396832, 5, 20000], [175, 396832, 10, 20000], [170, 396832, 15, 20000], [170, 396832, 17, 20000], [170, 396832, 18, 20000], [164, 396832, 20, 20000], [154, 396832, 25, 20000], [148, 396832, 30, 20000],
    [225, 374786, 0, 20000], [203, 374786, 1, 20000], [185, 374786, 5, 20000], [170, 374786, 10, 20000], [165, 374786, 15, 20000], [165, 374786, 17, 20000], [165, 374786, 18, 20000], [159, 374786, 20, 20000], [149, 374786, 25, 20000], [144, 374786, 30, 20000],
    [220, 352740, 0, 20000], [196, 352740, 1, 20000], [181, 352740, 5, 20000], [166, 352740, 10, 20000], [161, 352740, 15, 20000], [161, 352740, 17, 20000], [161, 352740, 18, 20000], [155, 352740, 20, 20000], [144, 352740, 25, 20000], [139, 352740, 30, 20000],
    [216, 330694, 0, 20000], [191, 330694, 1, 20000], [176, 330694, 5, 20000], [161, 330694, 10, 20000], [156, 330694, 15, 20000], [156, 330694, 17, 20000], [156, 330694, 18, 20000], [150, 330694, 20, 20000], [139, 330694, 25, 20000], [134, 330694, 30, 20000],
    [211, 308647, 0, 20000], [186, 308647, 1, 20000], [171, 308647, 5, 20000], [156, 308647, 10, 20000], [151, 308647, 15, 20000], [151, 308647, 17, 20000], [151, 308647, 18, 20000], [145, 308647, 20, 20000], [134, 308647, 25, 20000], [129, 308647, 30, 20000],
    [207, 286601, 0, 20000], [181, 286601, 1, 20000], [167, 286601, 5, 20000], [152, 286601, 10, 20000], [146, 286601, 15, 20000], [146, 286601, 17, 20000], [146, 286601, 18, 20000], [140, 286601, 20, 20000], [128, 286601, 25, 20000], [125, 286601, 30, 20000],
    [203, 264555, 0, 20000], [177, 264555, 1, 20000], [163, 264555, 5, 20000], [148, 264555, 10, 20000], [143, 264555, 15, 20000], [143, 264555, 17, 20000], [143, 264555, 18, 20000], [136, 264555, 20, 20000], [123, 264555, 25, 20000], [122, 264555, 30, 20000],
]);
/** Holding Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B787SpeedData.holding_speeds = new LerpLookupTable([
    [258, 617295, 0, 1500], [258, 617295, 0, 5000], [258, 617295, 0, 10000], [260, 617295, 0, 15000], [277, 617295, 0, 20000], [290, 617295, 0, 25000], [294, 617295, 0, 30000],
    [258, 573202, 0, 1500], [258, 573202, 0, 5000], [258, 573202, 0, 10000], [259, 573202, 0, 15000], [260, 573202, 0, 20000], [279, 573202, 0, 25000], [282, 573202, 0, 30000], [287, 573202, 0, 35000],
    [258, 529110, 0, 1500], [258, 529110, 0, 5000], [258, 529110, 0, 10000], [258, 529110, 0, 15000], [259, 529110, 0, 20000], [263, 529110, 0, 25000], [270, 529110, 0, 30000], [275, 529110, 0, 35000],
    [246, 485017, 0, 1500], [246, 485017, 0, 5000], [246, 485017, 0, 10000], [246, 485017, 0, 15000], [247, 485017, 0, 20000], [247, 485017, 0, 25000], [258, 485017, 0, 30000], [262, 485017, 0, 35000],
    [234, 440925, 0, 1500], [234, 440925, 0, 5000], [234, 440925, 0, 10000], [234, 440925, 0, 15000], [234, 440925, 0, 20000], [234, 440925, 0, 25000], [244, 440925, 0, 30000], [248, 440925, 0, 35000], [253, 440925, 0, 40000],
    [227, 396832, 0, 1500], [227, 396832, 0, 5000], [228, 396832, 0, 10000], [229, 396832, 0, 15000], [229, 396832, 0, 20000], [230, 396832, 0, 25000], [230, 396832, 0, 30000], [235, 396832, 0, 35000], [238, 396832, 0, 40000], [239, 396832, 0, 41000],
    [218, 352740, 0, 1500], [219, 352740, 0, 5000], [219, 352740, 0, 10000], [220, 352740, 0, 15000], [220, 352740, 0, 20000], [221, 352740, 0, 25000], [221, 352740, 0, 30000], [221, 352740, 0, 35000], [223, 352740, 0, 40000], [224, 352740, 0, 41000],
    [209, 308647, 0, 1500], [210, 308647, 0, 5000], [210, 308647, 0, 10000], [210, 308647, 0, 15000], [211, 308647, 0, 20000], [211, 308647, 0, 25000], [211, 308647, 0, 30000], [211, 308647, 0, 35000], [211, 308647, 0, 40000], [211, 308647, 0, 41000],
    [202, 264555, 0, 1500], [202, 264555, 0, 5000], [202, 264555, 0, 10000], [203, 264555, 0, 15000], [203, 264555, 0, 20000], [203, 264555, 0, 25000], [203, 264555, 0, 30000], [203, 264555, 0, 35000], [203, 264555, 0, 40000], [203, 264555, 0, 41000],
    [238, 617295, 1, 500], [238, 617295, 1, 5000], [238, 617295, 1, 10000], [238, 617295, 1, 15000], [239, 617295, 1, 20000],
    [238, 573202, 1, 238], [238, 573202, 1, 238], [238, 573202, 1, 238], [238, 573202, 1, 238], [239, 573202, 1, 239],
    [237, 529110, 1, 238], [237, 529110, 1, 238], [238, 529110, 1, 238], [238, 529110, 1, 238], [239, 529110, 1, 239],
    [228, 485017, 1, 237], [228, 485017, 1, 237], [229, 485017, 1, 238], [230, 485017, 1, 238], [232, 485017, 1, 239],
    [217, 440925, 1, 228], [217, 440925, 1, 228], [218, 440925, 1, 229], [219, 440925, 1, 230], [221, 440925, 1, 232],
    [206, 396832, 1, 217], [206, 396832, 1, 217], [207, 396832, 1, 218], [208, 396832, 1, 219], [209, 396832, 1, 221],
    [194, 352740, 1, 206], [194, 352740, 1, 206], [195, 352740, 1, 207], [195, 352740, 1, 208], [196, 352740, 1, 209],
    [184, 308647, 1, 194], [184, 308647, 1, 194], [184, 308647, 1, 195], [185, 308647, 1, 195], [186, 308647, 1, 196],
    [177, 264555, 1, 184], [177, 264555, 1, 184], [177, 264555, 1, 184], [177, 264555, 1, 185], [177, 264555, 1, 186],
]);
/** Vref data for Zp=14000 ft, speed [kcas], weight [lb], flap position => lookup key = (weight, flap) */
B787SpeedData.vref14k = new LerpLookupTable([
    [176, 573202, 30], [183, 573202, 25], [183, 573202, 20],
    [172, 551156, 30], [79, 551156, 25], [179, 551156, 20],
    [169, 529110, 30], [175, 529110, 25], [175, 529110, 20],
    [165, 507064, 30], [171, 507064, 25], [171, 507064, 20],
    [161, 485017, 30], [167, 485017, 25], [167, 485017, 20],
    [157, 462971, 30], [163, 462971, 25], [163, 462971, 20],
    [154, 440925, 30], [160, 440925, 25], [160, 440925, 20],
    [152, 418879, 30], [157, 418879, 25], [157, 418879, 20],
    [147, 396832, 30], [153, 396832, 25], [153, 396832, 20],
    [143, 374786, 30], [148, 374786, 25], [148, 374786, 20],
    [138, 352740, 30], [143, 352740, 25], [143, 352740, 20],
    [134, 330694, 30], [138, 330694, 25], [138, 330694, 20],
    [129, 308647, 30], [133, 308647, 25], [133, 308647, 20],
    [125, 286601, 30], [128, 286601, 25], [128, 286601, 20],
    [121, 264555, 30], [122, 264555, 25], [122, 264555, 20],
]);

/**
 * A Boeing 787 air data reference system (ADRS).
 */
class B787Adrs {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param sourceSelectSide The system source select side that determines which AIR DATA/ATT selector knob controls
     * this system's selection logic.
     */
    constructor(bus, sourceSelectSide) {
        this.bus = bus;
        this.sourceSelectSide = sourceSelectSide;
        // index 1: primary ADCs (1-3 combined)
        // index 2: backup airspeed system
        // index 3: backup altitude system
        // index 4: ISFD air data system
        this.airspeedCandidates = SetSubject.create([1, 2, 4]);
        this.altitudeCandidates = SetSubject.create([1, 3, 4]);
        this.airspeedSelector = new AdcSystemSelector(1, this.bus, this.airspeedCandidates, [1, 2, 4], 'airspeed-only');
        this.altitudeSelector = new AdcSystemSelector(2, this.bus, this.altitudeCandidates, [1, 3, 4], 'altitude-only');
        this.isInit = false;
    }
    /**
     * Initializes this system. Once initialized, this system will automatically select the best ADCs for airspeed and
     * altitude data among its candidates.
     */
    init() {
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.bus.getSubscriber()
            .on(`b78_air_data_att_source_knob_state_${this.sourceSelectSide === 'right' ? 2 : 1}`)
            .handle(state => {
            if (state === AirDataAttSourceKnobState.Alternate) {
                this.airspeedCandidates.toggle(1, false);
                this.altitudeCandidates.toggle(1, false);
            }
            else {
                this.airspeedCandidates.toggle(1, true);
                this.altitudeCandidates.toggle(1, true);
            }
        });
        this.airspeedSelector.init();
        this.altitudeSelector.init();
    }
}

/**
 * A Boeing 787 backup airspeed system. Provides backup airspeed data from angle-of-attack and inertial inputs.
 */
class B787BackupAirspeedSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of B787BackupAirspeedSystem.
     * @param index The index of the system.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this system derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, airspeedIndicatorIndex, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.airspeedIndicatorIndex = airspeedIndicatorIndex;
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_ias_${this.index}`]: `ias_${this.airspeedIndicatorIndex}`,
            [`adc_tas_${this.index}`]: `tas_${this.airspeedIndicatorIndex}`,
            [`adc_mach_to_kias_factor_${this.index}`]: `mach_to_kias_factor_${this.airspeedIndicatorIndex}`,
            [`adc_mach_number_${this.index}`]: 'mach_number'
        };
        this.invalidDataTopics = {
            [`adc_indicated_alt_${this.index}`]: 0,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: 1013.2,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: 16212,
            [`adc_altimeter_baro_is_std_${this.index}`]: false,
            [`adc_pressure_alt_${this.index}`]: 0,
            [`adc_vertical_speed_${this.index}`]: 0,
            [`adc_ambient_density_${this.index}`]: 0,
            [`adc_ambient_temp_c_${this.index}`]: 0,
            [`adc_ambient_pressure_inhg_${this.index}`]: 0,
            [`adc_isa_temp_c_${this.index}`]: 0,
            [`adc_ram_air_temp_c_${this.index}`]: 0
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.isInertialDataValid = ConsumerSubject.create(null, true);
        this.aoaSystemState1 = ConsumerSubject.create(null, undefined);
        this.aoaSystemState2 = ConsumerSubject.create(null, undefined);
        this.scheduleUpdateFailedState = () => { this.needUpdateFailedState = true; };
        this.needUpdateFailedState = true;
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, true, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, false, false, false);
        const sub = bus.getSubscriber();
        this.isInertialDataValid.setConsumer(sub.on('irs_selector_inertial_data_valid_1'));
        this.aoaSystemState1.setConsumer(sub.on('aoa_state_1'));
        this.aoaSystemState2.setConsumer(sub.on('aoa_state_2'));
        this.isInertialDataValid.sub(this.scheduleUpdateFailedState);
        this.aoaSystemState1.sub(this.scheduleUpdateFailedState);
        this.aoaSystemState2.sub(this.scheduleUpdateFailedState);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing airspeed data on the event bus.
     */
    startDataPublish() {
        // Publish default values for all non-airspeed topics.
        for (const topic in this.invalidDataTopics) {
            this.publisher.pub(topic, this.invalidDataTopics[topic], false, true);
        }
        for (const topic in this.dataSourceTopicMap) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.needUpdateFailedState = true;
            }
            else {
                this.setState(AvionicsSystemState.Off);
                this.needUpdateFailedState = false;
            }
        }
        else {
            this.needUpdateFailedState = false;
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(this.scheduleUpdateFailedState, this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.speedDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.speedDataValidTopic, false, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        var _a, _b;
        super.onUpdate();
        if (this.isPowerValid && this.needUpdateFailedState) {
            const aoaSystemState1 = (_a = this.aoaSystemState1.get()) === null || _a === void 0 ? void 0 : _a.current;
            const aoaSystemState2 = (_b = this.aoaSystemState2.get()) === null || _b === void 0 ? void 0 : _b.current;
            if (((aoaSystemState1 === undefined || aoaSystemState1 === AvionicsSystemState.On)
                || (aoaSystemState2 === undefined || aoaSystemState2 === AvionicsSystemState.On))
                && this.isInertialDataValid.get()) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Failed);
            }
            this.needUpdateFailedState = false;
        }
    }
}

/**
 * A Boeing 787 backup altitude system. Provides backup altitude data from GPS inputs.
 */
class B787BackupAltitudeSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of B787BackupAltitudeSystem.
     * @param index The index of the system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_vertical_speed_${this.index}`]: 'vertical_speed'
        };
        this.altitudeTopics = [
            `adc_indicated_alt_${this.index}`,
            `adc_pressure_alt_${this.index}`
        ];
        this.invalidDataTopics = {
            [`adc_ias_${this.index}`]: 0,
            [`adc_tas_${this.index}`]: 0,
            [`adc_mach_to_kias_factor_${this.index}`]: UnitType.MPS.convertTo(AeroMath.SOUND_SPEED_SEA_LEVEL_ISA, UnitType.KNOT),
            [`adc_mach_number_${this.index}`]: 0,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: 29.92,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: 1013.2,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: 16212,
            [`adc_altimeter_baro_is_std_${this.index}`]: false,
            [`adc_ambient_density_${this.index}`]: 0,
            [`adc_ambient_temp_c_${this.index}`]: 0,
            [`adc_ambient_pressure_inhg_${this.index}`]: 0,
            [`adc_isa_temp_c_${this.index}`]: 0,
            [`adc_ram_air_temp_c_${this.index}`]: 0
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.gpsReceiverSystemState1 = ConsumerSubject.create(null, undefined);
        this.gpsReceiverSystemState2 = ConsumerSubject.create(null, undefined);
        this.scheduleUpdateFailedState = () => { this.needUpdateFailedState = true; };
        this.needUpdateFailedState = true;
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, false, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, true, false, false);
        const sub = bus.getSubscriber();
        this.gpsReceiverSystemState1.setConsumer(sub.on('gps_rec_state_1'));
        this.gpsReceiverSystemState2.setConsumer(sub.on('gps_rec_state_2'));
        this.gpsReceiverSystemState1.sub(this.scheduleUpdateFailedState);
        this.gpsReceiverSystemState2.sub(this.scheduleUpdateFailedState);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing altitude data on the event bus.
     */
    startDataPublish() {
        // Publish default values for all non-altitude topics.
        for (const topic in this.invalidDataTopics) {
            this.publisher.pub(topic, this.invalidDataTopics[topic], false, true);
        }
        for (const topic in this.dataSourceTopicMap) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        for (const topic of this.altitudeTopics) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap || this.altitudeTopics.includes(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        if (topic in this.dataSourceTopicMap) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, true);
            }, paused));
        }
        else {
            this.dataSubs.push(this.dataSourceSubscriber.on('gps-position').handle(lla => {
                this.publisher.pub(topic, UnitType.METER.convertTo(lla.alt, UnitType.FOOT), false, true);
            }, paused));
        }
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.needUpdateFailedState = true;
            }
            else {
                this.setState(AvionicsSystemState.Off);
                this.needUpdateFailedState = false;
            }
        }
        else {
            this.needUpdateFailedState = false;
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(this.scheduleUpdateFailedState, this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.altitudeDataValidTopic, false, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        var _a, _b;
        super.onUpdate();
        if (this.isPowerValid && this.needUpdateFailedState) {
            const gpsReceiverSystemState1 = (_a = this.gpsReceiverSystemState1.get()) === null || _a === void 0 ? void 0 : _a.current;
            const gpsReceiverSystemState2 = (_b = this.gpsReceiverSystemState2.get()) === null || _b === void 0 ? void 0 : _b.current;
            if ((gpsReceiverSystemState1 === undefined || gpsReceiverSystemState1 === AvionicsSystemState.On)
                || (gpsReceiverSystemState2 === undefined || gpsReceiverSystemState2 === AvionicsSystemState.On)) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Failed);
            }
            this.needUpdateFailedState = false;
        }
    }
}

/**
 * A TCAS II implementation for the B787.
 */
class B787TCAS extends BoeingTCAS {
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * A common instrument for the B787-10 displays.
 */
class WTB78xFsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        this.instrument = instrument;
        this.config = config;
        this.isInstrumentPowered = false;
        this.isPowerValid = false;
        this.isPowered = undefined;
        this.bus = new EventBus();
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.hEventPublisher = new HEventPublisher(this.bus);
        this.flightPathCalculator = new FlightPathCalculator(this.facLoader, {
            defaultClimbRate: 2000,
            defaultSpeed: 180,
            bankAngle: BoeingFlightPathUtils.flightPathBankAngleTable,
            holdBankAngle: null,
            courseReversalBankAngle: null,
            turnAnticipationBankAngle: null,
            maxBankAngle: 25,
            airplaneSpeedMode: FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
        }, this.bus);
        this.flightPlanner = FlightPlanner.getPlanner(this.bus, this.flightPathCalculator, BoeingFmsUtils.buildBoeingLegName);
        this.perfPlanRepository = new PerformancePlanRepository(this.flightPlanner, this.bus);
        this.activeRoutePerformancePlan = this.perfPlanRepository.getActivePlan();
        this.performanceMath = new B787PerformanceMath();
        this.pathPerformanceProvider = new DefaultBoeingPathPerformanceProvider(this.performanceMath);
        this.engineDataProvider = new B787EngineData(this.bus, this.performanceMath);
        /** Handles wind and temperature entries and propagation for climb, cruise, and descent */
        this.windPlanner = new InterpolatingWindPlanner(this.bus, this.flightPlanner, {
            numberOfClimbAltitudes: 9,
            numberOfDescentAltitudes: 9,
            numberOfLegAltitudes: 4,
        });
        this.verticalPathCalculator = new BoeingPathCalculator(this.bus, this.flightPlanner, BoeingFms.ACT_RTE_PLAN_INDEX, this.pathPerformanceProvider, this.engineDataProvider, this.perfPlanRepository, this.windPlanner, this.getVerticalPathCalculatorOptions());
        this.activeRoutePredictor = new BoeingFlightPlanPredictionsProvider(this.bus, 1, BoeingFms.ACT_RTE_PLAN_INDEX, 1000, this.flightPlanner, this.windPlanner, this.verticalPathCalculator, this.perfPlanRepository, this.pathPerformanceProvider, this.facLoader);
        this.backplane = new InstrumentBackplane();
        this.clock = new Clock(this.bus);
        this.baseInstrumentPublisher = new BaseInstrumentPublisher(this.instrument, this.bus);
        this.ambientPublisher = new AmbientPublisher(this.bus);
        this.gnssPublisher = new GNSSPublisher(this.bus);
        this.adcPublisher = new AdcPublisher(this.bus);
        this.ahrsPublisher = new AhrsPublisher(this.bus);
        this.boeingApPublisher = new BoeingAPSimVarPublisher(this.bus);
        this.lNavPublisher = new LNavSimVarPublisher(this.bus);
        this.lNavDataPublisher = new BoeingLNavDataSimVarPublisher(this.bus);
        this.vNavPublisher = new VNavSimVarPublisher(this.bus);
        this.boeingVNavPublisher = new BoeingVNavSimVarPublisher(this.bus);
        this.navComSimVarPublisher = new NavComSimVarPublisher(this.bus);
        this.cockpitVarsPublisher = new CockpitVarsPublisher(this.bus);
        this.electricalPublisher = new ElectricalPublisher(this.bus);
        this.eisPublisher = new EISPublisher(this.bus);
        this.trafficInstrument = new TrafficInstrument(this.bus, { realTimeUpdateFreq: 2, simTimeUpdateFreq: 1, contactDeprecateTime: 10 });
        this.weightAndBalancePublisher = new WeightBalanceSimvarPublisher(this.bus);
        this.fuelSystemPublisher = new FuelSystemSimVarPublisher(this.bus);
        this.tcas = new B787TCAS(this.bus, this.trafficInstrument, 40, 2, 1);
        this.gameUnitsPublisher = new BoeingGameUnitsPublisher(this.bus);
        this.xpdrInstrument = new XPDRInstrument(this.bus);
        this.brakesPublisher = new BrakeSimvarPublisher(this.bus);
        this.speedData = new B787SpeedData(this.bus);
        this.timerPublisher = new FlightTimerPublisher(this.bus, 2);
        this.aiPilotPublisher = new AiPilotPublisher(this.bus);
        this.fmsOperatingPhasePublisher = new FmsOperatingPhasePublisher(this.bus);
        this.irsSystemGroupStatusPublisher = new IrsSystemGroupStatusPublisher(this.bus, 2);
        // TODO check placard speeds are correct for -10 (from flight_model.cfg)
        // -9 is 260, 240, 230, *220*, *215*, 215, 210, 190, 180
        this.flapConfig = {
            flap_positions: [
                { label: 0, flapAngle: 0, slatAngle: 0, speedLimit: Infinity },
                { label: 1, flapAngle: 0, slatAngle: 15, speedLimit: 260 },
                { label: 5, flapAngle: 5, slatAngle: 15.572958, speedLimit: 240 },
                { label: 10, flapAngle: 10, slatAngle: 16.145916, speedLimit: 230 },
                { label: 15, flapAngle: 15, slatAngle: 16.718873, speedLimit: 225 },
                { label: 17, flapAngle: 17, slatAngle: 17.291831, speedLimit: 220 },
                { label: 18, flapAngle: 18, slatAngle: 17.864789, speedLimit: 215 },
                { label: 20, flapAngle: 20, slatAngle: 18.437747, speedLimit: 210 },
                { label: 25, flapAngle: 20, slatAngle: 31, speedLimit: 190 },
                { label: 30, flapAngle: 30, slatAngle: 31.572958, speedLimit: 180 },
            ],
            speed_data: this.speedData,
        };
        this.flapComputer = new FlapComputer(this.bus, this.flapConfig);
        /** Videos show the radio altimeter at about [-8, -4] on the ground,
         * the RADIO HEIGHT simvar is about +15 feet, so we use offset of -21. */
        this.radioAltimeterOffset = -21;
        this.apInstrument = new AutopilotInstrument(this.bus);
        this.apRadioNavInstrument = new APRadioNavInstrument(this.bus);
        this.systems = [];
        this.sourceSelectSide = this.getSourceSelectSide();
        this.adrs = new B787Adrs(this.bus, this.sourceSelectSide);
        this.irsSystemSelector = new IrsSystemSelector(1, this.bus, [1, 2], [1, 2]);
        /** Whether this instrument has started updating. */
        this.haveUpdatesStarted = false;
        this.backplane.addInstrument(InstrumentBackplaneNames.Clock, this.clock);
        this.backplane.addInstrument(InstrumentBackplaneNames.Autopilot, this.apInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.AutopilotRadioNav, this.apRadioNavInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Traffic, this.trafficInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Xpdr, this.xpdrInstrument);
        this.backplane.addPublisher(InstrumentBackplaneNames.Base, this.baseInstrumentPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ambient, this.ambientPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Brakes, this.brakesPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.HEvents, this.hEventPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Adc, this.adcPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ahrs, this.ahrsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Gnss, this.gnssPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingAutopilot, this.boeingApPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNav, this.lNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNavData, this.lNavDataPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.VNav, this.vNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingVNav, this.boeingVNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.NavCom, this.navComSimVarPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.CockpitVars, this.cockpitVarsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Electrical, this.electricalPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Eis, this.eisPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.WeightAndBalance, this.weightAndBalancePublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Units, this.gameUnitsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.FuelSystem, this.fuelSystemPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Timer, this.timerPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ai, this.aiPilotPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.FmsOperatingPhase, this.fmsOperatingPhasePublisher);
        this.tcas.init();
        // force enable animations
        document.documentElement.classList.add('animationsEnabled');
        // Wait until game has entered briefing or in-game mode before initializing the avionics status client. This
        // ensures that we do not publish any statuses based on erroneous power states.
        Wait.awaitSubscribable(GameStateProvider.get(), gameState => gameState === GameState.briefing || gameState === GameState.ingame, true).then(async () => {
            this.isPowerValid = true;
            // Wait until updates have started before initializing the power state because instrument power is not
            // initialized until the first update.
            await Wait.awaitCondition(() => this.haveUpdatesStarted);
            if (this.isPowered === undefined) {
                this.isPowered = this.isInstrumentPowered;
                this.onPowerChanged(this.isPowered, undefined);
            }
        });
    }
    /**
     * Gets configuration options for the vertical path calculator.
     * @returns Configuration options for the vertical path calculator.
     */
    getVerticalPathCalculatorOptions() {
        return undefined;
    }
    /**
     * Whether to locally calculate predictions
     *
     * @returns a boolean
     */
    getLocallyCalculatePredictions() {
        return false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSoundEnd(soundEventId) {
        // noop
    }
    /** @inheritdoc */
    Update() {
        this.haveUpdatesStarted = true;
        this.backplane.onUpdate();
        this.updateSystems();
    }
    /**
     * Updates this instrument's systems.
     */
    updateSystems() {
        for (let i = 0; i < this.systems.length; i++) {
            this.systems[i].onUpdate();
        }
    }
    /**
     * Creates this instrument's avionics systems. This method should be called after `this.iauIndex` has been defined.
     */
    createSystems() {
        // TODO the B787 doesn't have a magnetometer
        const magnetometers = [new MagnetometerSystem(1, this.bus, 'elec_master_battery')];
        // In reality, there are three independent ADCs (pitot-static systems with their own air data modules). However,
        // since we are not fully modeling the electrical system and the sim doesn't model independent ADC failures for
        // other reasons, we will combine all three ADCs into one system (index 1).
        const adcSystems = [
            new AdcSystem(1, this.bus, 1, 1, 'elec_circuit_on_96'),
            new B787BackupAirspeedSystem(2, this.bus, 1, 'elec_circuit_on_95'),
            new B787BackupAltitudeSystem(3, this.bus, 'elec_circuit_on_95'),
            new AdcSystem(4, this.bus, 2, 2, 'elec_circuit_on_99'), // ISFD air data
        ];
        const raSystems = this.config.sensors.radarAltimeterDefinitions.slice(1, this.config.sensors.radarAltimeterCount + 1).map((def, index) => {
            return new RASystem(index + 1, this.bus, this.radioAltimeterOffset, def.electricity);
        });
        const gpsSystems = [1, 2].map(index => new GpsReceiverSystem(index, this.bus, new GPSSatComputer(index, this.bus, 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/Data/gps_ephemeris.json', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/Data/gps_sbas.json', 5000, [], this.instrument.instrumentIndex === 3 ? 'primary' : 'replica')));
        const irsAlignTimeSetting = BoeingMsfsUserSettings.getManager(this.bus).getSetting('boeingMsfsIrsAlignTime');
        const irsAttitudeAndRealignDuration = irsAlignTimeSetting.map(setting => setting === BoeingIrsAlignTimeMode.Instant ? 0 : undefined);
        const irsFullAlignDuration = irsAlignTimeSetting.map(setting => {
            switch (setting) {
                case BoeingIrsAlignTimeMode.Instant:
                    return 0;
                case BoeingIrsAlignTimeMode.Realistic:
                    return undefined;
                default:
                    return 60000;
            }
        });
        const irsSystems = [1, 2].map(index => {
            const modeSetting = ConsumerSubject.create(this.bus.getSubscriber().on(`b78_irs_knob_state_${index}`), IrsKnobState.On)
                .map(state => state === IrsKnobState.Off ? IrsSystemOperatingModeSetting.Off : IrsSystemOperatingModeSetting.Navigation);
            return new IrsSystem(index, this.bus, 1, 1, true, modeSetting, `elec_circuit_on_${96 + index}`, [1, 2], irsAttitudeAndRealignDuration, irsFullAlignDuration, irsAttitudeAndRealignDuration);
        });
        this.gpsReceiverSelector = new GpsReceiverSelector(this.bus, Array.from({ length: this.config.sensors.gpsCount }, (v, index) => index + 1), 1 // Math.min(this.iauIndex, this.config.sensors.gpsCount)
        );
        this.gpsReceiverSelector.init();
        // One FMS geo-positioning system for each PFD (technically IAU)
        const fmsPosSystems = [0].map(index => {
            return new FmsPositionSystem(index + 1, this.bus, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.gpsReceiverSelector.selectedIndex, 1, // pfdSettingManager.getSetting('pfdAdcIndex'),
            1);
        });
        this.systems.push(...magnetometers, ...adcSystems, ...raSystems, ...gpsSystems, ...irsSystems, ...fmsPosSystems, new AoaSystem(1, this.bus, 'elec_master_battery'), new MarkerBeaconSystem(1, this.bus, 'elec_master_battery'));
        this.adrs.init();
        this.irsSystemSelector.init();
        this.activeRoutePredictor.init(this.getLocallyCalculatePredictions());
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        this.hEventPublisher.dispatchHEvent(args[0]);
    }
    /**
     * Attempt to run onFlightStart in case the instrument was reloaded.
     */
    tryRunOnFlightStart() {
        // Only try to start if ingame during the constructor.
        // If not ingame, then user will get a briefing and will eventually trigger onFlightStart.
        if (GameStateProvider.get().get() === GameState.ingame) {
            this.onFlightStart();
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        SimVar.SetSimVarValue('L:WT_Flight_Started', SimVarValueType.Bool, true);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onGameStateChanged(oldState, newState) {
        // TODO
    }
    /**
     * A callback which is executed when this instrument transitions from a power-off to power-on state.
     */
    onPowerOn() {
        this.isInstrumentPowered = true;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = true;
            if (old !== true) {
                this.onPowerChanged(true, old);
            }
        }
    }
    /**
     * A callback which is executed when this instrument transitions from a power-on to power-off state.
     */
    onPowerOff() {
        this.isInstrumentPowered = false;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = false;
            if (old !== false) {
                this.onPowerChanged(false, old);
            }
        }
    }
    /**
     * Responds to when this instrument's power state changes.
     * @param current The current power state.
     * @param previous The previous power state, or `undefined` if the previous state was invalid.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPowerChanged(current, previous) {
        //
    }
}

/**
 * A controller that listens to H Events sent for Minimums Indications.
 * Sends Key Events to MinimumsManager.
 */
class B787MinimumsStateController extends BoeingMinimumsStateController {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        super(bus, ConsumerSubject.create(bus.getSubscriber().on('b78_minimums_mode').whenChanged(), MinimumsMode.OFF));
    }
}

/** B787 cdu common constants and functions. */
class B787CduCommon {
}
B787CduCommon.flightNumberMinLength = 1;
B787CduCommon.flightNumberMaxLength = 10;

/**
 * Setting modes for date/time format.
 */
var DateTimeFormatSettingMode;
(function (DateTimeFormatSettingMode) {
    DateTimeFormatSettingMode["UTC"] = "UTC";
    DateTimeFormatSettingMode["Local24"] = "Local24";
    DateTimeFormatSettingMode["Local12"] = "Local12";
})(DateTimeFormatSettingMode || (DateTimeFormatSettingMode = {}));
/**
 * Utility class for retrieving date/time user setting managers.
 */
class DateTimeUserSettings {
    /**
     * Retrieves a manager for date/time user settings.
     * @param bus The event bus.
     * @returns A manager for date/time user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = DateTimeUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (DateTimeUserSettings.INSTANCE = new DefaultUserSettingManager(bus, [
            {
                name: 'dateTimeFormat',
                defaultValue: DateTimeFormatSettingMode.UTC
            },
            {
                name: 'dateTimeLocalOffset',
                defaultValue: 0
            }
        ]));
    }
}

/**
 * Date display formats.
 */
var DateDisplayFormat;
(function (DateDisplayFormat) {
    /** UTC time. */
    DateDisplayFormat[DateDisplayFormat["UTC"] = 0] = "UTC";
    /** Local time in 24-hour format. */
    DateDisplayFormat[DateDisplayFormat["Local24"] = 1] = "Local24";
    /** Local time in 12-hour format. */
    DateDisplayFormat[DateDisplayFormat["Local12"] = 2] = "Local12";
})(DateDisplayFormat || (DateDisplayFormat = {}));
/**
 * Displays date in DD MMM YY format.
 */
class DateDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.timeSeconds = typeof this.props.time === 'object'
            ? (this.timeSub = this.props.time.map(DateDisplay.SECOND_PRECISION_MAP))
            : Subject.create(DateDisplay.SECOND_PRECISION_MAP(this.props.time));
        this.localOffset = typeof this.props.localOffset === 'object'
            ? this.props.localOffset
            : Subject.create(this.props.localOffset);
        this.date = new Date();
        this.dateText = Subject.create('');
        this.monthText = Subject.create('');
        this.yearText = Subject.create('');
        this.updateHandler = this.updateDisplayedTime.bind(this);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.localOffsetSub = this.localOffset.sub(this.updateHandler);
        this.timeSeconds.sub(this.updateHandler, true);
    }
    /**
     * Updates the displayed time.
     */
    updateDisplayedTime() {
        const utcTime = this.timeSeconds.get();
        if (isNaN(utcTime)) {
            this.dateText.set('__');
            this.monthText.set('___');
            this.yearText.set('__');
        }
        else {
            const displayTime = utcTime + this.localOffset.get();
            this.date.setTime(displayTime);
            this.dateText.set(this.date.getUTCDate().toString());
            this.monthText.set(` ${DateDisplay.MONTH_NAMES[this.date.getUTCMonth()]} `);
            this.yearText.set(this.date.getUTCFullYear().toString().substring(2, 4));
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        return (FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : 'date-display' },
            FSComponent.buildComponent("span", { class: 'time-date' }, this.dateText),
            FSComponent.buildComponent("span", { class: 'time-month' }, this.monthText),
            FSComponent.buildComponent("span", { class: 'time-year' }, this.yearText)));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.timeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.formatSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.localOffsetSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}
DateDisplay.SECOND_PRECISION_MAP = SubscribableMapFunctions.withPrecision(1000);
DateDisplay.MONTH_NAMES = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];

/** Time display formats. */
var TimeDisplayFormat;
(function (TimeDisplayFormat) {
    /** UTC time. */
    TimeDisplayFormat[TimeDisplayFormat["UTC"] = 0] = "UTC";
    /** Local time in 24-hour format. */
    TimeDisplayFormat[TimeDisplayFormat["Local24"] = 1] = "Local24";
    /** Local time in 12-hour format. */
    TimeDisplayFormat[TimeDisplayFormat["Local12"] = 2] = "Local12";
})(TimeDisplayFormat || (TimeDisplayFormat = {}));
/** Displays time in HH:MM:SS format. */
class TimeDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.date = new Date();
        this.hourText = Subject.create('');
        this.minText = Subject.create('');
        this.secText = Subject.create('');
        this.suffixText = Subject.create('');
    }
    /** @inheritdoc */
    onAfterRender() {
        this.formatSub = this.props.format.sub(this.updateDisplayedTime.bind(this), true);
        this.localOffsetSub = this.props.localOffset.sub(this.updateDisplayedTime.bind(this), true);
        this.timeSub = this.props.time.sub(this.updateDisplayedTime.bind(this), true);
    }
    /**
     * Updates the displayed time.
     */
    updateDisplayedTime() {
        const utcTime = this.props.time.get();
        const format = this.props.format.get();
        const localOffset = this.props.localOffset.get();
        let isAm = true;
        if (isNaN(utcTime)) {
            this.hourText.set('__');
            this.minText.set('__');
            this.secText.set('__');
        }
        else {
            const offset = format === TimeDisplayFormat.UTC ? 0 : localOffset;
            const displayTime = utcTime + offset;
            this.date.setTime(displayTime);
            const hour = this.date.getUTCHours();
            isAm = hour < 12;
            const displayHour = format === TimeDisplayFormat.Local12
                ? 12 - (12 - (hour % 12)) % 12 // Need to display hours 0 and 12 as '12'
                : hour % 24;
            this.hourText.set(displayHour.toString().padStart(2, '0'));
            this.minText.set(this.date.getUTCMinutes().toString().padStart(2, '0'));
            this.secText.set(this.date.getUTCSeconds().toString().padStart(2, '0'));
        }
        this.suffixText.set(this.getSuffix(format, isAm));
    }
    /**
     * Gets the suffix to append to the time display.
     * @param format The format of the time display.
     * @param isAm Whether or not the current time is AM or PM.
     * @returns The time display suffix.
     */
    getSuffix(format, isAm) {
        if (format === TimeDisplayFormat.UTC) {
            return 'z';
        }
        else if (format === TimeDisplayFormat.Local24) {
            return 'LCL';
        }
        else {
            return isAm ? 'AM' : 'PM';
        }
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { style: 'white-space: nowrap;' },
            FSComponent.buildComponent("span", { class: 'time-hour' }, this.hourText),
            FSComponent.buildComponent("span", { class: 'time-min' },
                ":",
                this.minText),
            FSComponent.buildComponent("span", { class: 'time-sec' },
                ":",
                this.secText),
            FSComponent.buildComponent("span", { class: 'time-suffix' }, this.suffixText)));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b, _c;
        (_a = this.timeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.formatSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.localOffsetSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}

var ChronographStates;
(function (ChronographStates) {
    ChronographStates[ChronographStates["HIDDEN"] = 0] = "HIDDEN";
    ChronographStates[ChronographStates["STARTED"] = 1] = "STARTED";
    ChronographStates[ChronographStates["STOPPED"] = 2] = "STOPPED";
})(ChronographStates || (ChronographStates = {}));
var FlightDataBlockTimer;
(function (FlightDataBlockTimer) {
    FlightDataBlockTimer[FlightDataBlockTimer["DEFAULT_TIMER_INDEX"] = 1] = "DEFAULT_TIMER_INDEX";
    FlightDataBlockTimer[FlightDataBlockTimer["ELAPSED_TIMER_INDEX"] = 2] = "ELAPSED_TIMER_INDEX";
})(FlightDataBlockTimer || (FlightDataBlockTimer = {}));
/** The FlightDataBlock component. */
class FlightDataBlock extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.chronoClockRef = FSComponent.createRef();
        this.chronoClockHandRef = FSComponent.createRef();
        this.comFreqRef = FSComponent.createRef();
        this.micSourceRef = FSComponent.createRef();
        this.datetimeSettingManager = DateTimeUserSettings.getManager(this.props.bus);
        this.timerPublisher = this.props.bus.getPublisher();
        this.timerSubscriber = this.props.bus.getSubscriber();
        this.comSimVarSubscriber = this.props.bus.getSubscriber();
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.props.bus);
        this.isTransmitting = ConsumerSubject.create(this.props.bus.getSubscriber().on('pilot_transmitting').whenChanged(), false);
        this.xpdrCodeSubject = ComputedSubject.create(0, (v) => `${MathUtils.round(v)}`.padStart(4, '0'));
        this.timeSubject = ConsumerSubject.create(this.props.bus.getSubscriber().on('simTime').whenChangedBy(1000), 0);
        this.timeDisplayFormatSubject = Subject.create(TimeDisplayFormat.UTC);
        this.timeDisplayLocalOffsetSubject = Subject.create(0);
        /* Chronograph digital display */
        this.chronoState = Subject.create(ChronographStates.HIDDEN);
        this.chronoDigitalDisplay = ComputedSubject.create(0, (v) => FlightDataBlock.ELAPSED_TIME_FORMATTER_CAP_MINUTE(v));
        /*----------------------------*/
        /* Elapsed flying time digital display */
        this.elapsedTimeDigitalDisplay = ComputedSubject.create(0, (v) => FlightDataBlock.ELAPSED_TIME_FORMATTER_CAP_HOUR(v));
        /*------------------------------------*/
        this.comActiveFreqDisplaySubject = Subject.create('---');
        this.comActiveFreqSubject = ConsumerSubject.create(this.comSimVarSubscriber.on('com_active_frequency_1').whenChanged().withPrecision(3), 0);
        this.com1Subject = ConsumerSubject.create(this.comSimVarSubscriber.on('com_transmit_1').whenChanged(), false);
        this.com2Subject = ConsumerSubject.create(this.comSimVarSubscriber.on('com_transmit_2').whenChanged(), false);
        this.comMicSourceSubject = MappedSubject.create(([com1, com2]) => {
            if (com1) {
                return 'VHF L';
            }
            if (com2) {
                return 'VHF C';
            }
            return 'VHF R';
        }, this.com1Subject, this.com2Subject);
        this.flightNumber = Subject.create('-'.repeat(B787CduCommon.flightNumberMaxLength));
        this.tailId = SimVar.GetSimVarValue('ATC ID', SimVarValueType.String);
        this.subscriptions = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        this.subscriptions = [
            this.cockpitUserSettings.whenSettingChanged('fltNumber').handle(this.onFlightNumberChanged.bind(this)),
            this.props.bus.getSubscriber().on('xpdr_code_1').whenChanged().handle(this.onXpdrCodeChanged.bind(this)),
            this.comSimVarSubscriber.on('com_receive_1').whenChanged().handle(this.onComDataLinked.bind(this)),
            this.timerSubscriber.on(`timer_value_ms_${FlightDataBlockTimer.DEFAULT_TIMER_INDEX}`).handle(this.rotateChrNeedle.bind(this)),
            this.timerSubscriber.on(`timer_value_ms_${FlightDataBlockTimer.ELAPSED_TIMER_INDEX}`).whenChangedBy(1000).handle(this.updateElapsedTimeDigitalDisplay.bind(this)),
            this.props.bus.getSubscriber().on('hEvent').handle((hEvent) => {
                if (hEvent === 'AS01B_PFD_BTN_Clock') {
                    switch (this.chronoState.get()) {
                        case ChronographStates.HIDDEN:
                            this.chronoState.set(ChronographStates.STARTED);
                            break;
                        case ChronographStates.STARTED:
                            this.chronoState.set(ChronographStates.STOPPED);
                            break;
                        case ChronographStates.STOPPED:
                            this.chronoState.set(ChronographStates.HIDDEN);
                            break;
                        default:
                            console.error('Invalid PFD Chrono clock state: ', this.chronoState.get());
                            break;
                    }
                }
            }),
            this.datetimeSettingManager.whenSettingChanged('dateTimeFormat').handle(this.onDateTimeFormatSettingChanged.bind(this)),
            this.datetimeSettingManager.whenSettingChanged('dateTimeLocalOffset').handle(this.onDateTimeLocalOffsetChanged.bind(this)),
            this.chronoState.sub((v) => {
                this.timerPublisher.pub(`timer_set_initial_value_${FlightDataBlockTimer.DEFAULT_TIMER_INDEX}`, -1, true, false);
                if (v === ChronographStates.STARTED) {
                    this.timerPublisher.pub(`timer_set_mode_${FlightDataBlockTimer.DEFAULT_TIMER_INDEX}`, FlightTimerMode.CountingUp, true, false);
                    this.timerPublisher.pub(`timer_start_${FlightDataBlockTimer.DEFAULT_TIMER_INDEX}`, undefined, true, false);
                }
                else if (v === ChronographStates.STOPPED) {
                    this.timerPublisher.pub(`timer_stop_${FlightDataBlockTimer.DEFAULT_TIMER_INDEX}`, undefined, true, false);
                }
                else {
                    this.timerPublisher.pub(`timer_reset_${FlightDataBlockTimer.DEFAULT_TIMER_INDEX}`, undefined, true, false);
                }
                this.chronoClockRef.instance.classList.toggle('hidden', v === ChronographStates.HIDDEN);
            }, true),
            this.isTransmitting.sub(v => {
                this.micSourceRef.instance.classList.toggle('active', v);
            }),
        ];
        this.subscriptions.push(this.comMicSourceSubject.sub((v) => {
            switch (v) {
                case 'VHF L':
                    this.comActiveFreqSubject.setConsumer(this.comSimVarSubscriber.on('com_active_frequency_1').whenChanged().withPrecision(3));
                    break;
                case 'VHF C':
                    this.comActiveFreqSubject.setConsumer(this.comSimVarSubscriber.on('com_active_frequency_2').whenChanged().withPrecision(3));
                    break;
                case 'VHF R':
                    this.comActiveFreqSubject.setConsumer(this.comSimVarSubscriber.on('com_active_frequency_3').whenChanged().withPrecision(3));
                    break;
            }
        }, true));
        this.subscriptions.push(this.comActiveFreqSubject.sub(this.onActiveFreqChanged.bind(this), true));
    }
    /** @inheritdoc */
    onResume() {
        var _a, _b;
        (_a = this.timerSubscription) === null || _a === void 0 ? void 0 : _a.resume(true);
        (_b = this.isTransmitting) === null || _b === void 0 ? void 0 : _b.resume();
        this.timeSubject.resume();
    }
    /** @inheritdoc */
    onPause() {
        var _a, _b;
        (_a = this.timerSubscription) === null || _a === void 0 ? void 0 : _a.pause();
        (_b = this.isTransmitting) === null || _b === void 0 ? void 0 : _b.pause();
        this.timeSubject.pause();
    }
    /**
     * Update the xpdrStringSubject when xpdr code simvar changes.
     * @param code The new xpdr code.
     */
    onXpdrCodeChanged(code) {
        this.xpdrCodeSubject.set(code);
    }
    /**
     * Update the comActiveFreqSubject when active com frequency simvar changes.
     * @param freq The new active com frequency.
     */
    onActiveFreqChanged(freq) {
        this.comActiveFreqDisplaySubject.set(freq.toString());
    }
    /**
     * Toggle color of comFreqRef based on com datalink activity.
     * @param isDataLinked Whether com is transmitting/receiving datalink information.
     */
    onComDataLinked(isDataLinked) {
        this.comFreqRef.instance.classList.toggle('datalink', isDataLinked === true);
    }
    /**
     * Update timeDisplayFormatSubject when dateTimeFormat setting changes.
     * @param mode New DateTimeFormatSettingMode.
     */
    onDateTimeFormatSettingChanged(mode) {
        this.timeDisplayFormatSubject.set(FlightDataBlock.FORMAT_SETTING_MAP[mode]);
    }
    /**
     * Update timeDisplayLocalOffsetSubject when dateTimeLocalOffset setting changes.
     * @param offset Local offset in miliseconds.
     */
    onDateTimeLocalOffsetChanged(offset) {
        this.timeDisplayLocalOffsetSubject.set(offset);
    }
    /**
     * Update flightNumber subject when the fltNumber in the CockpitUserSettings changes
     * @param fltNumber the new flight number
     */
    onFlightNumberChanged(fltNumber) {
        this.flightNumber.set(fltNumber || '-'.repeat(B787CduCommon.flightNumberMaxLength));
    }
    /**
     * Rotates the CHR needle SVG around the chronograph.
     * Needle completes a 360-degree rotation per minute.
     * @param timeMs Timer time in ms.
     */
    rotateChrNeedle(timeMs) {
        const chrHandDegree = (timeMs / 1000) * 6;
        this.chronoClockHandRef.instance.style.transform = `rotate3d(0,0,1, ${chrHandDegree}deg)`;
        this.chronoDigitalDisplay.set(timeMs);
    }
    /**
     * Update the digital display of the elapsed flying time.
     * @param timeMs Timer time in ms.
     */
    updateElapsedTimeDigitalDisplay(timeMs) {
        this.elapsedTimeDigitalDisplay.set(timeMs);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "flight-data-block-container" },
            FSComponent.buildComponent("div", { class: "flight-datablock-upper-section" },
                FSComponent.buildComponent("div", { class: "flight-datablock-indications" },
                    FSComponent.buildComponent("div", { class: "flight-datablock-row" },
                        FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "FLT #"),
                        FSComponent.buildComponent("div", { class: "flight-datablock-flight-number" }, this.flightNumber)),
                    FSComponent.buildComponent("div", { class: "flight-datablock-row", ref: this.comFreqRef },
                        FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "MIC"),
                        FSComponent.buildComponent("div", { class: "flight-datablock-mic-source", ref: this.micSourceRef },
                            FSComponent.buildComponent("span", null, this.comActiveFreqDisplaySubject),
                            FSComponent.buildComponent("span", { class: "flight-datablock-mic-source-type" }, this.comMicSourceSubject))),
                    FSComponent.buildComponent("div", { class: "flight-datablock-row" },
                        FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "XPDR"),
                        FSComponent.buildComponent("div", null, this.xpdrCodeSubject)),
                    FSComponent.buildComponent("div", { class: "flight-datablock-row" },
                        FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "SELCAL"),
                        FSComponent.buildComponent("div", null, BoeingMsfsUserSettings.getManager(this.props.bus).getSetting('boeingMsfsSelcal'))),
                    FSComponent.buildComponent("div", { class: "flight-datablock-row" },
                        FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "TAIL #"),
                        FSComponent.buildComponent("div", null, this.tailId))),
                FSComponent.buildComponent("div", { class: "flight-datablock-clock hidden", ref: this.chronoClockRef },
                    FSComponent.buildComponent("div", { class: "flight-datablock-clockface" },
                        FSComponent.buildComponent("div", { class: "clockface-ticks" }),
                        FSComponent.buildComponent("div", { class: "clockface-ticks marks2" }),
                        FSComponent.buildComponent("div", { class: "clockface-ticks marks3" }),
                        FSComponent.buildComponent("div", { class: "clockface-ticks marks4" }),
                        FSComponent.buildComponent("div", { class: "clockface-ticks marks5" }),
                        FSComponent.buildComponent("div", { class: "clockface-ticks marks6" }),
                        FSComponent.buildComponent("div", { class: "clockface-tick-marks-mask" }),
                        FSComponent.buildComponent("div", { class: "flight-datablock-clock-second-hand", ref: this.chronoClockHandRef }),
                        FSComponent.buildComponent("div", { class: "flight-datablock-clock-circle" })),
                    FSComponent.buildComponent("div", null, this.chronoDigitalDisplay))),
            FSComponent.buildComponent("div", { class: "flight-datablock-lower-section" },
                FSComponent.buildComponent("div", { class: "flight-datablock-time" },
                    FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "UTC TIME"),
                    FSComponent.buildComponent("div", { class: "flight-datablock-value" },
                        FSComponent.buildComponent(TimeDisplay, { time: this.timeSubject, format: this.timeDisplayFormatSubject, localOffset: this.timeDisplayLocalOffsetSubject }))),
                FSComponent.buildComponent("div", { class: "flight-datablock-time" },
                    FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "DATE"),
                    FSComponent.buildComponent(DateDisplay, { time: this.timeSubject, localOffset: this.timeDisplayLocalOffsetSubject.get() })),
                FSComponent.buildComponent("div", { class: "flight-datablock-time" },
                    FSComponent.buildComponent("div", { class: "flight-datablock-label" }, "ELAPSED TIME"),
                    FSComponent.buildComponent("div", { class: "flight-datablock-value" }, this.elapsedTimeDigitalDisplay)))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.subscriptions.forEach((sub) => sub.destroy());
        (_a = this.timerSubscription) === null || _a === void 0 ? void 0 : _a.destroy();
        this.timeSubject.destroy();
        this.isTransmitting.destroy();
    }
}
FlightDataBlock.FORMAT_SETTING_MAP = {
    [DateTimeFormatSettingMode.Local12]: TimeDisplayFormat.Local12,
    [DateTimeFormatSettingMode.Local24]: TimeDisplayFormat.Local24,
    [DateTimeFormatSettingMode.UTC]: TimeDisplayFormat.UTC
};
FlightDataBlock.ELAPSED_TIME_FORMATTER_CAP_MINUTE = DurationFormatter.create('{mm}:{ss}', UnitType.MILLISECOND, 100, '--:--');
FlightDataBlock.ELAPSED_TIME_FORMATTER_CAP_HOUR = DurationFormatter.create('{hh}:{mm}', UnitType.MILLISECOND, 100, '--:--');

/** The LeftSectionContainer component. */
class LeftSectionContainer extends DisplayComponent {
    /** @inheritdoc */
    onAfterRender() {
        // TODO do stuff
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", null,
            FSComponent.buildComponent(FlightDataBlock, { bus: this.props.bus })));
    }
}

var _a;
/** Collection of common data used by the map system. */
class MapSystemCommon {
}
_a = MapSystemCommon;
MapSystemCommon.canvasScale = XBOX() ? 0.5 : 1;
// 787 is using MAX displays, so not scaling needed
/** The number to scale elements designed for MAX displays by so it will be the correct size for the older square Boeing displays. */
MapSystemCommon.maxToOldBoeingScale = 1;
MapSystemCommon.labelFontSize = 28 * _a.canvasScale;
MapSystemCommon.fontOutlineWidth = 1 * _a.canvasScale;
MapSystemCommon.labelLineHeight = 25 * _a.canvasScale;
MapSystemCommon.strokeWidth = 4 * _a.canvasScale;
MapSystemCommon.arrowStrokeWidth = 3 * _a.canvasScale;
MapSystemCommon.outlineWidth = 1 * _a.canvasScale;
MapSystemCommon.smallLabelOffsetPx = 11 * _a.canvasScale;
MapSystemCommon.smallLabelOffset = new Float64Array([_a.smallLabelOffsetPx, _a.smallLabelOffsetPx]);
MapSystemCommon.bigLabelOffsetPx = 18 * _a.canvasScale;
MapSystemCommon.bigLabelOffset = new Float64Array([_a.bigLabelOffsetPx, _a.bigLabelOffsetPx]);
MapSystemCommon.mapIconSize = 50 * _a.canvasScale;
MapSystemCommon.mapStyles = {
    canvasScale: MapSystemCommon.canvasScale,
    labelFontSize: MapSystemCommon.labelFontSize,
    fontOutlineWidth: MapSystemCommon.fontOutlineWidth,
    labelLineHeight: MapSystemCommon.labelLineHeight,
    strokeWidth: MapSystemCommon.strokeWidth,
    arrowStrokeWidth: MapSystemCommon.arrowStrokeWidth,
    outlineWidth: MapSystemCommon.outlineWidth,
    smallLabelOffsetPx: MapSystemCommon.smallLabelOffsetPx,
    smallLabelOffset: MapSystemCommon.smallLabelOffset,
    bigLabelOffsetPx: MapSystemCommon.bigLabelOffsetPx,
    bigLabelOffset: MapSystemCommon.bigLabelOffset,
    mapIconSize: MapSystemCommon.mapIconSize,
    maxToOldBoeingScale: MapSystemCommon.maxToOldBoeingScale,
};
MapSystemCommon.mapCompassMaskHeight = 660 * _a.canvasScale;
MapSystemCommon.minimapCompassMaskHeight = 430 * _a.canvasScale;
MapSystemCommon.rangeTickWidth = 20 * _a.canvasScale;
MapSystemCommon.minimapHeightUnscaled = 505;
MapSystemCommon.minimapCompassRadiusUnscaled = 332;
MapSystemCommon.mapCompassRadiusUnscaled = 970;
MapSystemCommon.mapCtrCompassRadiusUnscaled = 328;
MapSystemCommon.planHalfCompassRadiusUnscaled = 400;
MapSystemCommon.planFullCompassRadiusUnscaled = 490;
MapSystemCommon.minimapCompassRadius = _a.minimapCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.mapCompassRadius = _a.mapCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.mapCtrCompassRadius = _a.mapCtrCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.planHalfCompassRadius = _a.planHalfCompassRadiusUnscaled * _a.canvasScale;
MapSystemCommon.planFullCompassRadius = _a.planFullCompassRadiusUnscaled * _a.canvasScale;

/** Provides data for ND. */
class B787NdDataProvider extends BoeingNdDataProvider {
    /** @inheritdoc */
    constructor(bus, navIndicators, settings) {
        super(bus, navIndicators, settings, BoeingMsfsUserSettings.getManager(bus));
        this.boeingType = '787';
        this.canvasScale = MapSystemCommon.canvasScale;
        this.cockpitVarEvents = this.bus.getSubscriber();
        this.b78_trk_mode = ConsumerSubject.create(this.cockpitVarEvents.on('b78_trk_mode').whenChanged(), false);
        settings.getSetting('vorLeftEnabled').map(x => x ? 'VOR' : 'OFF').pipe(this._navAidLeftState);
        settings.getSetting('vorRightEnabled').map(x => x ? 'VOR' : 'OFF').pipe(this._navAidRightState);
        this.b78_trk_mode.map(x => x ? 'track' : 'heading').pipe(this._selHdgOrTrk);
    }
}

/** Provides data for mini-map Info. */
class B787MiniMapDataProvider extends B787NdDataProvider {
    /** @inheritdoc */
    constructor(bus, navIndicators, mfdSettings, pfdSettings) {
        super(bus, navIndicators, mfdSettings);
        this.pfdSettings = pfdSettings;
        this.mapRange = Subject.create(20);
        this.halfRangeNumber = Subject.create('10');
        this.hideWindVector = Subject.create(false);
        this.isWxrSupported = Subject.create(true);
        this.isTerrSupported = this.isWxrSupported;
        this.isTfcSupported = this.isWxrSupported;
        this.isVorSupported = this.isWxrSupported;
        this.isAdfSupported = this.isWxrSupported;
        this.isNavPerfSupported = this.isWxrSupported;
        this.terrWxContrast = this.pfdSettings.getSetting('terrWxContrast');
        this.showWxr = MappedSubject.create(([isWxrEnabled, isWxrSupported]) => isWxrEnabled && isWxrSupported, this.isWxrEnabled, this.isWxrSupported);
        this.showTerr = MappedSubject.create(([isTerrEnabled, isTerrSupported]) => isTerrEnabled && isTerrSupported, this.isTerrEnabled, this.isTerrSupported);
        this.showTfc = MappedSubject.create(([isTfcEnabled, isTfcSupported]) => isTfcEnabled && isTfcSupported, this.isTfcEnabled, this.isTfcSupported);
        this._navAidLeftState = Subject.create('ADF');
        this.navAidLeftState = this._navAidLeftState;
        this._navAidRightState = Subject.create('ADF');
        this.navAidRightState = this._navAidRightState;
        this.adfPointerLeftIsVisible = this.navIndicators.get('adfLeft').bearing.map(x => x !== null);
        this.adfPointerRightIsVisible = this.navIndicators.get('adfRight').bearing.map(x => x !== null);
    }
}

const mapSettings = [
    {
        name: 'mapFormatPFD',
        defaultValue: 'MINI'
    },
    {
        name: 'mapFormatMFD_1',
        defaultValue: 'MAP'
    },
    {
        name: 'mapFormatMFD_2',
        defaultValue: 'MAP'
    },
    {
        name: 'mapRangePFD_1',
        defaultValue: 20
    },
    {
        name: 'mapRangeMFD_1',
        defaultValue: 10
    },
    {
        name: 'mapRangeMFD_2',
        defaultValue: 10
    },
    {
        name: 'tfcEnabledPFD',
        defaultValue: false
    },
    {
        name: 'tfcEnabledMFD_1',
        defaultValue: false
    },
    {
        name: 'tfcEnabledMFD_2',
        defaultValue: false
    },
    {
        name: 'terrWxStatePFD',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxStateMFD_1',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxStateMFD_2',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxContrastMFD_1',
        defaultValue: 1,
    },
    {
        name: 'terrWxContrastMFD_2',
        defaultValue: 1,
    },
    {
        name: 'terrWxContrastPFD',
        defaultValue: 1,
    },
    {
        name: 'mapWaypointsDisplayPFD',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapWaypointsDisplayMFD_1',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapWaypointsDisplayMFD_2',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'vorLeftEnabledMFD_1',
        defaultValue: true
    },
    {
        name: 'vorLeftEnabledMFD_2',
        defaultValue: true
    },
    {
        name: 'vorRightEnabledMFD_1',
        defaultValue: true
    },
    {
        name: 'vorRightEnabledMFD_2',
        defaultValue: true
    }
];
const mapSettingsPfdAliased = [
    {
        name: 'mapFormat',
        defaultValue: 'MINI'
    },
    {
        name: 'mapRange',
        defaultValue: 20
    },
    {
        name: 'tfcEnabled',
        defaultValue: false
    },
    {
        name: 'terrWxState',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxContrast',
        defaultValue: 1,
    },
    {
        name: 'mapWaypointsDisplay',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
];
const mapSettingsMfdAliased = [
    {
        name: 'mapFormat',
        defaultValue: 'MAP'
    },
    {
        name: 'mapRange',
        defaultValue: 10
    },
    {
        name: 'tfcEnabled',
        defaultValue: false
    },
    {
        name: 'terrWxState',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxContrast',
        defaultValue: 1,
    },
    {
        name: 'mapWaypointsDisplay',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'vorLeftEnabled',
        defaultValue: true
    },
    {
        name: 'vorRightEnabled',
        defaultValue: true
    }
];
/** Utility class for retrieving map user setting managers. */
class MapUserSettings {
    /**
     * Retrieves a setting manager with all map user settings.
     * @param bus The event bus.
     * @returns A setting manager with all map user settings.
     */
    static getMasterManager(bus) {
        var _a;
        return (_a = MapUserSettings.INSTANCE_MASTER) !== null && _a !== void 0 ? _a : (MapUserSettings.INSTANCE_MASTER = new DefaultUserSettingManager(bus, mapSettings));
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Retrieves a setting manager with aliased map user settings specific to the PFD or MFD.
     * @param bus The event bus.
     * @param pfdOrMfd Whether to get the PFD or MFD setting manager.
     * @param index The map side index.
     * @returns A setting manager with aliased map user settings specific to the PFD or MFD.
     */
    static getAliasedManager(bus, pfdOrMfd, index) {
        return (pfdOrMfd === 'PFD' ? MapUserSettings.getPfdManager(bus) : MapUserSettings.getMfdManager(bus, index));
    }
    /**
     * Retrieves a setting manager with aliased PFD map user settings.
     * @param bus The event bus.
     * @returns A setting manager with aliased PFD map user settings.
     */
    static getPfdManager(bus) {
        if (MapUserSettings.INSTANCE_PFD === undefined) {
            MapUserSettings.INSTANCE_PFD = new AliasedUserSettingManager(bus, mapSettingsPfdAliased);
            MapUserSettings.INSTANCE_PFD.useAliases(MapUserSettings.getMasterManager(bus), {
                mapFormat: 'mapFormatPFD',
                tfcEnabled: 'tfcEnabledPFD',
                terrWxState: 'terrWxStatePFD',
                terrWxContrast: 'terrWxContrastPFD',
                mapWaypointsDisplay: 'mapWaypointsDisplayPFD',
                mapRange: 'mapRangePFD_1',
            });
        }
        return MapUserSettings.INSTANCE_PFD;
    }
    /**
     * Retrieves a setting manager with aliased MFD map user settings.
     * @param bus The event bus.
     * @param index The MFD side index.
     * @returns A setting manager with aliased MFD map user settings.
     */
    static getMfdManager(bus, index) {
        if (MapUserSettings.INSTANCES_MFD[index] === undefined) {
            MapUserSettings.INSTANCES_MFD[index] = new AliasedUserSettingManager(bus, mapSettingsMfdAliased);
            MapUserSettings.INSTANCES_MFD[index].useAliases(MapUserSettings.getMasterManager(bus), {
                mapFormat: `mapFormatMFD_${index}`,
                tfcEnabled: `tfcEnabledMFD_${index}`,
                terrWxState: `terrWxStateMFD_${index}`,
                terrWxContrast: `terrWxContrastMFD_${index}`,
                mapWaypointsDisplay: `mapWaypointsDisplayMFD_${index}`,
                mapRange: `mapRangeMFD_${index}`,
                vorLeftEnabled: `vorLeftEnabledMFD_${index}`,
                vorRightEnabled: `vorRightEnabledMFD_${index}`
            });
        }
        return MapUserSettings.INSTANCES_MFD[index];
    }
}
MapUserSettings.INSTANCES_MFD = [];
MapUserSettings.mapFormatsAll = ['MAP', 'MAPCTR', 'PLAN', 'MINI'];
MapUserSettings.mapFormatsPFD = ['MINI'];
MapUserSettings.mapFormatsMFD = ['MAP', 'MAPCTR', 'PLAN'];
MapUserSettings.terrWxStates = ['OFF', 'TERR', 'WX'];
MapUserSettings.mapRanges = [0.5, 1, 2, 5, 10, 20, 40, 80, 160, 320, 640, 1280];

/** A controller which handles map traffic settings. */
class B787MapTrafficController extends BoeingMapTrafficController {
}

ImageCache.addToCache('AIRPORT', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/airport_c.png');
ImageCache.addToCache('INTERSECTION', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/intersection.png');
ImageCache.addToCache('NDB', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/ndb.png');
ImageCache.addToCache('VOR', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/vor.png');
ImageCache.addToCache('DME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/dme.png');
ImageCache.addToCache('VORDME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/vordme.png');
ImageCache.addToCache('VORTAC', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/vortac.png');
ImageCache.addToCache('TACAN', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/tacan.png');
ImageCache.addToCache('STA_VOR', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/sta_vor.png');
ImageCache.addToCache('STA_DME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/sta_dme.png');
ImageCache.addToCache('STA_NDB', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/sta_ndb.png');
ImageCache.addToCache('STA_VORDME', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/sta_vordme.png');
ImageCache.addToCache('STA_VORTAC', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/sta_vortac.png');
ImageCache.addToCache('STA_TACAN', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/sta_tacan.png');
ImageCache.addToCache('FLIGHTPLAN', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/flightplan.png');
ImageCache.addToCache('FLIGHTPLAN_M', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/flightplan_m.png');
ImageCache.addToCache('FLIGHTPLAN_C', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/flightplan_c.png');
ImageCache.addToCache('FLIGHTPLAN_CIRCLE_WHITE', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/flightplan_circle_white.png');
ImageCache.addToCache('FLIGHTPLAN_CIRCLE_MAGENTA', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/flightplan_circle_magenta.png');
ImageCache.addToCache('TOD', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/tod.png');
/** The map builder for the B787. */
class B787MapBuilder {
    /**
     * Creates a new B787MapBuilder.
     * @param boeingMapBuilder Boeing map builder instance.
     * @param ndDataProvider The nd data provider.
     * @param bus The event bus.
     * @param flightPlanner The flight planner.
     */
    constructor(boeingMapBuilder, ndDataProvider, bus, flightPlanner) {
        this.boeingMapBuilder = boeingMapBuilder;
        this.ndDataProvider = ndDataProvider;
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.mapSystemConfig = new MapSystemConfig(MapSystemCommon.mapStyles);
        /**
         * Add the flight plans.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withFlightPlans = (builder) => {
            return builder
                .with(this.boeingMapBuilder.withFlightPlans, this.mapSystemConfig);
        };
        /**
         * Add the map select waypoint layer.
         * @param builder The map system builder.
         * @param offScaleTcasAlertLevel The offScaleTcasAlertLevel subject.
         * @returns The map system builder, after it has been configured.
         */
        this.withTraffic = (builder, offScaleTcasAlertLevel) => {
            return this.boeingMapBuilder.withTraffic(builder, this.mapSystemConfig, true, (context) => new B787MapTrafficController(context, this.ndDataProvider, UnitType.FOOT.createNumber(9900)), offScaleTcasAlertLevel);
        };
        /**
         * Add the altitude arc.
         * @param builder The map system builder.
         * @param arcRadius The radius of the arc, in pixels.
         * @param arcAngularWidth The angular width of the arc, in degrees.
         * @returns The map system builder, after it has been configured.
         */
        this.withAltitudeArc = (builder, arcRadius, arcAngularWidth) => {
            return this.boeingMapBuilder.withAltitudeArc(builder, {
                arcRadius: arcRadius,
                arcAngularWidth: arcAngularWidth,
                strokeStyle: BoeingColors.green,
                strokeWidth: MapSystemCommon.strokeWidth,
                outlineWidth: MapSystemCommon.outlineWidth,
            });
        };
        /**
         * Add the altitude arc.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withBoeingMapStyles = (builder) => {
            return builder
                .withModule(BoeingMapKeys.MapStyles, () => new BoeingMapStylesModule(MapSystemCommon.mapStyles));
        };
        /**
         * Add the nearest waypoints layer.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withNearestWaypoints = (builder) => {
            return builder
                .with(this.boeingMapBuilder.withNearestWaypoints, this.mapSystemConfig);
        };
        /**
         * The map builder for the airplane icon.
         * @param builder The map system builder.
         * @returns The map system builder, after it has been configured.
         */
        this.withAirplaneIcon = (builder) => {
            return this.boeingMapBuilder.withAirplaneIcon(builder, {
                fontSize: 28,
                height: 32,
                padding: 4,
                top: 50,
            }, 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/ownship_tri.svg', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB787_10/Assets/icons/ownship_outline.svg');
        };
    }
}

/**
 * A map system controller that controls the display settings of the various format
 * and terrain/wxr combinations.
 */
class B787MiniMapFormatController extends BoeingMapFormatController {
    /**
     * Creates an instance of the MapFormatController.
     * @param context The map system context to use with this controller.
     * @param pfdIndex The index of the pfd this map is on.
     */
    constructor(context, pfdIndex) {
        const mfdSettings = MapUserSettings.getAliasedManager(context.bus, 'MFD', pfdIndex);
        super(context, MapSystemCommon.canvasScale, Subject.create(B787MiniMapFormatController.MAP_CONFIG), mfdSettings.getSetting('terrWxState'));
    }
}
B787MiniMapFormatController.MAP_CONFIG = Object.assign({ compassType: 'arc', targetProjectedOffsetUnscaledY: 110.5, compassRadiusUnscaled: MapSystemCommon.minimapCompassRadiusUnscaled, mapHeightUnscaled: MapSystemCommon.minimapHeightUnscaled, layerKeys: [BoeingMapKeys.CompassArcLowerLayer, BoeingMapKeys.CompassArcUpperLayer, ...BoeingMapCommon.COMPASS_FORMAT_COMMON_LAYER_KEYS] }, BoeingMapCommon.COMPASS_DEFAULT_CONFIG);

/** Map compass overlay components which go below the flight plan rotue lines. */
class MiniMapCompassLowerLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.ndMapCompassRotatingSvgRef = FSComponent.createRef();
        this.ndMapTrackRotatingSvgRef = FSComponent.createRef();
        this.compassSvgSize = this.props.compassSvgSize;
        this.compassRadius = this.props.compassRadius;
        this.trackLineTranslateY = -this.compassRadius / 2;
        this.classList = SetSubject.create([
            'mini-map-overlay',
            'map-rotating-overlay',
            'map-compass-overlay'
        ]);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.props.ndDataProvider.compassRotationAnimated.sub(rot => {
            this.ndMapCompassRotatingSvgRef.instance.style.transform = `rotate3d(0, 0, 1, ${rot * -1}deg)`;
        });
        this.props.ndDataProvider.currentTrackRotation.sub(rot => {
            this.ndMapTrackRotatingSvgRef.instance.style.transform = `rotate3d(0, 0, 1, ${rot * -1}deg) translateY(${this.trackLineTranslateY}px)`;
        }, true);
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.classList.toggle('hidden', !isVisible);
    }
    /** @inheritdoc */
    render() {
        const rangeTickWidth = MapSystemCommon.rangeTickWidth;
        const trackLineSvgWidth = rangeTickWidth * 2;
        const trackLineSvgPaddingY = 10 * MapSystemCommon.canvasScale;
        const trackLineSvgHeight = this.compassRadius + trackLineSvgPaddingY;
        const trackLinePath = `M 0 0 l 0 ${this.props.compassRadius}`;
        const rangeTicksPath = `M ${-rangeTickWidth / 2} ${this.props.compassRadius / 2} l ${rangeTickWidth} 0`;
        return (FSComponent.buildComponent("div", { class: this.classList },
            FSComponent.buildComponent(MapCompassOffset, { compassSvgSize: this.props.compassSvgSize, targetProjectedOffsetY: this.props.ndDataProvider.targetProjectedOffsetY },
                FSComponent.buildComponent(MapCompassArcMask, { isEnabled: true, maskHeightPx: MapSystemCommon.minimapCompassMaskHeight, innerHeightPx: this.props.compassSvgSize },
                    FSComponent.buildComponent("svg", { ref: this.ndMapCompassRotatingSvgRef, class: "compass-circle-ticks", viewBox: `0 0 ${this.compassSvgSize} ${this.compassSvgSize}`, width: this.compassSvgSize, height: this.compassSvgSize, style: "position: absolute;" },
                        FSComponent.buildComponent(CompassRoseTicks, { svgViewBoxSize: this.compassSvgSize, ticksRadius: this.compassRadius, shortTickLength: 11 * MapSystemCommon.canvasScale, longTickLength: 22 * MapSystemCommon.canvasScale, tickDirection: 'Inwards', withCircle: false, degreesPerTick: 5 }),
                        FSComponent.buildComponent(CompassRoseNumbers, { svgViewBoxSize: this.compassSvgSize, numbersRadius: this.compassRadius - (50 * MapSystemCommon.canvasScale), fontSize: (30 * MapSystemCommon.canvasScale) + 'px', strokeWidth: 3 * MapSystemCommon.canvasScale }))),
                FSComponent.buildComponent("svg", { ref: this.ndMapTrackRotatingSvgRef, class: "track-line-ticks-svg", viewBox: `${-trackLineSvgWidth / 2} ${-trackLineSvgPaddingY / 2} ${trackLineSvgWidth} ${trackLineSvgHeight}`, width: trackLineSvgWidth, height: trackLineSvgHeight, style: 'position: absolute' },
                    FSComponent.buildComponent(OutlinedElement, { tag: "path", class: "track-line", outlineClass: "nd-path-shadow", d: trackLinePath }),
                    FSComponent.buildComponent(OutlinedElement, { tag: "path", className: "track-line-with-ticks", outlineClass: "nd-path-shadow", d: `${trackLinePath} ${rangeTicksPath}` }))),
            FSComponent.buildComponent("div", { class: "half-range-number" }, "10")));
    }
}

/** Map compass overlay components. */
class MiniMapCompassUpperLayer extends MapLayer {
    constructor() {
        super(...arguments);
        this.compassSvgSize = this.props.compassSvgSize;
        this.compassRadius = this.props.compassRadius;
        this.containerRef = FSComponent.createRef();
        this.classList = SetSubject.create([
            'mini-map-overlay',
            'map-rotating-overlay',
            'map-compass-overlay'
        ]);
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
        this.containerRef.instance.classList.toggle('hidden', !isVisible);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.classList, ref: this.containerRef },
            FSComponent.buildComponent("div", { class: "mini-map-mask" },
                FSComponent.buildComponent("div", { class: "top-mask" }),
                FSComponent.buildComponent("div", { class: "left-mask" }),
                FSComponent.buildComponent("div", { class: "right-mask" }),
                FSComponent.buildComponent("div", { class: "bottom-mask" })),
            FSComponent.buildComponent(MapCompassOffset, { compassSvgSize: this.props.compassSvgSize, targetProjectedOffsetY: this.props.ndDataProvider.targetProjectedOffsetY },
                FSComponent.buildComponent(TcasRing, { compassRadius: this.props.compassRadius, ndDataProvider: this.props.ndDataProvider, fixedRange: 20 }),
                FSComponent.buildComponent(MapCompassArcMask, { isEnabled: true, maskHeightPx: MapSystemCommon.minimapCompassMaskHeight, innerHeightPx: this.props.compassSvgSize },
                    FSComponent.buildComponent(BearingPointer, { type: "ADF", leftOrRight: "left", color: "var(--boeing-colors-cyan)", isVisible: this.props.ndDataProvider.adfPointerLeftIsVisible, rotation: this.props.ndDataProvider.adfLeftRotationAnimated, compassRadiusUnscaled: this.props.compassRadius / MapSystemCommon.canvasScale, heightUnscaled: this.compassSvgSize / MapSystemCommon.canvasScale, canvasScale: MapSystemCommon.canvasScale }),
                    FSComponent.buildComponent(BearingPointer, { type: "ADF", leftOrRight: "right", color: "var(--boeing-colors-cyan)", isVisible: this.props.ndDataProvider.adfPointerRightIsVisible, rotation: this.props.ndDataProvider.adfRightRotationAnimated, compassRadiusUnscaled: this.props.compassRadius / MapSystemCommon.canvasScale, heightUnscaled: this.compassSvgSize / MapSystemCommon.canvasScale, canvasScale: MapSystemCommon.canvasScale })),
                FSComponent.buildComponent(SelectedHeadingLine, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.compassRadius }),
                FSComponent.buildComponent(SelectedTrackLine, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.compassRadius }),
                FSComponent.buildComponent(MapCompassArcMask, { isEnabled: true, maskHeightPx: MapSystemCommon.minimapCompassMaskHeight, innerHeightPx: this.props.compassSvgSize },
                    FSComponent.buildComponent(SelectedHeadingBug, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius }),
                    FSComponent.buildComponent(SelectedTrackBug, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius }),
                    FSComponent.buildComponent(CurrentHeadingTriangle, { ndDataProvider: this.props.ndDataProvider, compassRadius: this.props.compassRadius })))));
    }
}

/** The MiniMap component. */
class MiniMap extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
        super(props);
        this.mapSystemContainerRef = FSComponent.createRef();
        this.containerHeight = MapSystemCommon.minimapHeightUnscaled;
        this.compassSvgSize = 800 * MapSystemCommon.canvasScale;
        this.mapSystemWidth = (MapSystemCommon.minimapCompassRadius * 2) + (40 * MapSystemCommon.canvasScale);
        this.mapSystemHeight = this.containerHeight * MapSystemCommon.canvasScale;
        this.mapSystem = this.buildMapSystem().build('map-system' + (MapSystemCommon.canvasScale === 0.5 ? ' map-system-canvas-half-scale' : ''));
        this.props.miniMapDataProvider.initMapProjection(this.mapSystem.context.projection);
    }
    /** @inheritdoc */
    onAfterRender() {
        const translate = (MapSystemCommon.canvasScale === 1 ? 0 : (MapSystemCommon.canvasScale * 50)) + '%';
        this.mapSystemContainerRef.instance.style.setProperty('--nd-canvas-transform', `scale(${1 / MapSystemCommon.canvasScale}) translate(${translate}, ${translate})`);
        this.mapSystemContainerRef.instance.style.setProperty('--nd-canvas-scale', MapSystemCommon.canvasScale.toString());
    }
    /**
     * Builds the map system for the navigation map.
     * @returns The configured map system builder.
     */
    buildMapSystem() {
        const boeingMapBuilder = new BoeingMapBuilder(this.props.bus, this.props.miniMapDataProvider, 'PFD', this.props.facLoader, this.props.flightPlanner, this.props.activeRoutePredictor, this.props.perfPlanRepository, this.props.tcas);
        const b787MapBuilder = new B787MapBuilder(boeingMapBuilder, this.props.miniMapDataProvider, this.props.bus, this.props.flightPlanner);
        return MapSystemBuilder.create(this.props.bus)
            .withBing(`b78-map-pfd-${this.props.pfdIndex}`, 0, undefined, undefined, 'bing-map', this.props.miniMapDataProvider.terrWxContrast)
            .with(b787MapBuilder.withBoeingMapStyles)
            .with(boeingMapBuilder.withTerrainColors)
            .withModule(BoeingMapKeys.NdDataProvider, () => this.props.miniMapDataProvider)
            .withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule())
            .withController(MapSystemKeys.AutopilotProps, context => new BoeingMapAutopilotPropsController(context))
            // TODO non plan waypoints and navaids go below the compass lower layer
            .withLayer(BoeingMapKeys.CompassArcLowerLayer, context => FSComponent.buildComponent(MiniMapCompassLowerLayer, { model: context.model, mapProjection: context.projection, ndDataProvider: this.props.miniMapDataProvider, compassSvgSize: this.compassSvgSize, compassRadius: MapSystemCommon.minimapCompassRadius }))
            .with(boeingMapBuilder.withPlanAirportsRunways)
            .with(b787MapBuilder.withNearestWaypoints)
            .with(b787MapBuilder.withFlightPlans)
            .with(boeingMapBuilder.withTopOfDescent)
            .with(boeingMapBuilder.positionTrendVector, { minRangeVisible: 10, strokeWidth: MapSystemCommon.strokeWidth, outlineWidth: MapSystemCommon.outlineWidth })
            .with(b787MapBuilder.withAltitudeArc, 200 * MapSystemCommon.canvasScale, 65)
            .withLayer(BoeingMapKeys.CompassArcUpperLayer, context => FSComponent.buildComponent(MiniMapCompassUpperLayer, { model: context.model, mapProjection: context.projection, ndDataProvider: this.props.miniMapDataProvider, compassSvgSize: this.compassSvgSize, compassRadius: MapSystemCommon.minimapCompassRadius }))
            .with(b787MapBuilder.withAirplaneIcon)
            .withFollowAirplane()
            .withRotation()
            .withController(BoeingMapKeys.MapFormatController, context => new B787MiniMapFormatController(context, this.props.pfdIndex))
            .withController(BoeingMapKeys.RangeController, context => new MapRangeController(context, Subject.create(20)))
            .with(boeingMapBuilder.withWaypointDisplayController)
            .with(b787MapBuilder.withTraffic, this.props.offScaleTcasAlertLevel)
            .withProjectedSize(new Float64Array([this.mapSystemWidth, this.mapSystemHeight]))
            .withClockUpdate(30);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { ref: this.mapSystemContainerRef, class: {
                'mini-map': true,
                'map-requires-alignment': true,
                'map-system-container': true,
                'inertial-heading-data-invalid': this.props.miniMapDataProvider.isInertialHeadingDataValid.map(x => !x),
            }, style: `width: ${this.mapSystemWidth / MapSystemCommon.canvasScale}px; height: ${this.mapSystemHeight / MapSystemCommon.canvasScale}px;` }, this.mapSystem.map));
    }
}

/** The SelHdgTrk component. */
class SelHdgTrk extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.mode = this.props.ndDataProvider.selHdgOrTrk.map(x => x === 'heading' ? 'HDG' : 'TRK');
        this.selectedHeading = ConsumerSubject.create(this.props.bus.getSubscriber().on('ap_heading_selected'), 0);
        this.displayValue = this.selectedHeading.map(value => {
            value = Math.round(value) % 360;
            value = value === 0 ? 360 : value;
            return value.toFixed(0).padStart(3, '0');
        });
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'sel-hdg-trk': true,
                'hidden': this.props.ndDataProvider.isInertialHeadingDataValid.map(x => !x),
            } },
            FSComponent.buildComponent("span", { class: "sel" }, "SEL"),
            FSComponent.buildComponent("span", { class: "mode" }, this.mode),
            FSComponent.buildComponent("span", { class: "value" }, this.displayValue)));
    }
}

/** The MiniMapInformation component. */
class MiniMapInformation extends DisplayComponent {
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "mini-map-info" },
            FSComponent.buildComponent(SpeedWindRangeInfoBlock, { bus: this.props.bus, showRange: false, ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(TimeToAlign, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(ActiveWaypointDataBlock, { bus: this.props.bus, activeRoutePredictor: this.props.activeRoutePredictor, distancePad: 5, flightPlanner: this.props.flightPlanner }),
            FSComponent.buildComponent(SelHdgTrk, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent(TcasAdvisoryStatus, { bus: this.props.bus, tcasOffScaleStatus: this.props.offScaleTcasAlertLevel, ndDataProvider: this.props.ndDataProvider }),
            FSComponent.buildComponent("div", { class: "mini-map-info-lower-section" },
                FSComponent.buildComponent(WxTerrTfcDataBlock, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider, showMapSymbolsBlock: false }),
                FSComponent.buildComponent(AdfDisplay, { bus: this.props.bus, ndDataProvider: this.props.ndDataProvider }))));
    }
}

/** The LowerSectionContainer component. */
class LowerSectionContainer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.mfdSettings = MapUserSettings.getAliasedManager(this.props.bus, 'MFD', this.props.pfdIndex);
        this.pfdSettings = MapUserSettings.getAliasedManager(this.props.bus, 'PFD', this.props.pfdIndex);
        this.miniMapDataProvider = new B787MiniMapDataProvider(this.props.bus, this.props.navIndicators, this.mfdSettings, this.pfdSettings);
        this.offScaleTcasAlertLevel = Subject.create(TcasAlertLevel.None);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "lower-section-container" },
            FSComponent.buildComponent(MiniMap, { bus: this.props.bus, pfdIndex: this.props.pfdIndex, facLoader: this.props.facLoader, tcas: this.props.tcas, activeRoutePredictor: this.props.activeRoutePredictor, flightPlanner: this.props.flightPlanner, miniMapDataProvider: this.miniMapDataProvider, perfPlanRepository: this.props.perfPlanRepository, offScaleTcasAlertLevel: this.offScaleTcasAlertLevel }),
            FSComponent.buildComponent(MiniMapInformation, { bus: this.props.bus, activeRoutePredictor: this.props.activeRoutePredictor, ndDataProvider: this.miniMapDataProvider, flightPlanner: this.props.flightPlanner, offScaleTcasAlertLevel: this.offScaleTcasAlertLevel }),
            FSComponent.buildComponent(MapFailureFlags, { ndDataProvider: this.miniMapDataProvider })));
    }
}

/* eslint-disable jsdoc/require-jsdoc,@typescript-eslint/no-unused-vars */
/** The PfdReferenceOverlay component. */
class PfdReferenceOverlay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.referencePhotoOverlayRef = FSComponent.createRef();
        this.imgSrc = Subject.create('');
        this.overlayEnabled = false;
        this.enableOverlay = () => {
            this.referencePhotoOverlayRef.instance.style.display = 'block';
            this.overlayEnabled = true;
        };
        this.hideOverlay = () => {
            this.referencePhotoOverlayRef.instance.style.display = 'none';
            this.overlayEnabled = false;
        };
    }
    /** @inheritdoc */
    onAfterRender() {
        this.setupReferenceOverlayToggle();
    }
    addDebugButton(name, image) {
        g_modDebugMgr.AddDebugButton(name, () => {
            if (this.overlayEnabled) {
                if (this.imgSrc.get() === image) {
                    this.hideOverlay();
                }
                else {
                    this.imgSrc.set(image);
                }
            }
            else {
                this.enableOverlay();
                this.imgSrc.set(image);
            }
        });
    }
    /** Adds a debug button to toggle the reference photo overlay. */
    setupReferenceOverlayToggle() {
        if (typeof g_modDebugMgr !== 'undefined') {
            g_modDebugMgr.AddDebugButton('Disable PFD Overlay', this.hideOverlay);
            for (const [name, uri] of PfdReferenceOverlay.IMAGES) {
                this.addDebugButton(name, PfdReferenceOverlay.IMAGE_PREFIX + uri);
            }
        }
    }
    /** @inheritdoc */
    render() {
        const display = 'display: none;';
        // const display = 'display: unset;';
        return (FSComponent.buildComponent("div", { class: "reference-photo-overlay", ref: this.referencePhotoOverlayRef, style: display + 'position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 10000; opacity: 0.5; pointer-events: none;' },
            FSComponent.buildComponent("img", { alt: "", src: this.imgSrc })));
    }
}
PfdReferenceOverlay.IMAGE_PREFIX = '/Pages/VCockpit/Instruments/Airliners/WTB787_10/PFD/Components/PfdReferenceOverlay/';
/** Pairs of name and image URI */
PfdReferenceOverlay.IMAGES = [
    ['PFD Overlay 1', 'pfd-1.png'],
];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A provider of Boeing 787 flap speed bug data.
 */
class B787FlapSpeedBugDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param speedProvider A speed provider.
     * @param adcIndex The index of the ADC that is the source of this provider's pressure altitude data.
     */
    constructor(bus, speedProvider, adcIndex) {
        this.bus = bus;
        this.speedProvider = speedProvider;
        this.flapPositions = [0, 1, 5, 10, 15, 17, 18, 20];
        this._data = new Map(Array.from(this.flapPositions, position => {
            return [
                position,
                {
                    position,
                    maneuverIas: Subject.create(null),
                    lastPressureAlt: undefined,
                    lastWeight: undefined
                }
            ];
        }));
        /** @inheritdoc */
        this.data = this._data;
        this.isOnGround = ConsumerValue.create(null, false).pause();
        this.pressureAltitude = ConsumerValue.create(null, 0).pause();
        this.grossWeight = ConsumerValue.create(null, 0);
        this.flapsHandleIndex = ConsumerValue.create(null, 0).pause();
        this.simRate = ConsumerValue.create(null, 1);
        this.pauseable = [
            this.pressureAltitude,
            this.isOnGround,
            this.flapsHandleIndex,
            this.grossWeight,
            this.simRate
        ];
        this.lastUpdateTime = undefined;
        this.isAltBelow20k = false;
        this.nominalFlapsHandleIndex = 0;
        this.flapsHandleIndexDelay = 0;
        this.flapsHandleArmedIndex = undefined;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('B787FlapSpeedBugDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.adcIndexSub = this.adcIndex.sub(index => {
            this.pressureAltitude.setConsumer(sub.on(`adc_pressure_alt_${index}`));
        }, true);
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.flapsHandleIndex.setConsumer(sub.on('flaps_handle_index'));
        this.grossWeight.setConsumer(sub.on('total_weight'));
        this.simRate.setConsumer(sub.on('simRate'));
        this.updateSub = sub.on('realTime').handle(this.update.bind(this), true);
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('B787FlapSpeedBugDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
        this.updateSub.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('B787FlapSpeedBugDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
        this.updateSub.pause();
        this.lastUpdateTime = undefined;
        this.flapsHandleArmedIndex = undefined;
        this.flapsHandleIndexDelay = 0;
    }
    /**
     * Executes this data provider's periodic updates.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        var _a;
        const dt = Math.max(time - ((_a = this.lastUpdateTime) !== null && _a !== void 0 ? _a : time), 0) * this.simRate.get();
        this.lastUpdateTime = time;
        this.updateNominalFlapsHandleIndex(dt);
        const pressureAlt = MathUtils.round(this.pressureAltitude.get(), 10);
        const weight = MathUtils.round(this.grossWeight.get(), 100);
        // Calculate visibilities for all the bugs.
        this.isAltBelow20k = pressureAlt < (this.isAltBelow20k ? 20100 : 19900);
        // FUP -> visible if handle up or 1
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex <= 1) {
            this.updateFlapManeuveringSpeed(this._data.get(0), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(0));
        }
        // F1 ->  visible if handle 1 or 5
        if (this.isAltBelow20k && (this.nominalFlapsHandleIndex === 1 || this.nominalFlapsHandleIndex === 2)) {
            this.updateFlapManeuveringSpeed(this._data.get(1), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(1));
        }
        // F5 ->  visible if handle in 5, 10, 15, 17, 18, 20
        if (this.isAltBelow20k && (this.nominalFlapsHandleIndex >= 2 && this.nominalFlapsHandleIndex <= 7)) {
            this.updateFlapManeuveringSpeed(this._data.get(5), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(5));
        }
        // F10 -> visible if handle 10
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex === 3) {
            this.updateFlapManeuveringSpeed(this._data.get(10), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(10));
        }
        // F15 -> visible if handle 15
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex === 4) {
            this.updateFlapManeuveringSpeed(this._data.get(15), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(15));
        }
        // F17 -> visible if handle 17
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex === 5) {
            this.updateFlapManeuveringSpeed(this._data.get(17), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(17));
        }
        // F18 -> visible if handle 18
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex === 6) {
            this.updateFlapManeuveringSpeed(this._data.get(18), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(18));
        }
        // F20 -> visible if handle 20
        if (this.isAltBelow20k && this.nominalFlapsHandleIndex === 7) {
            this.updateFlapManeuveringSpeed(this._data.get(20), pressureAlt, weight);
        }
        else {
            this.hideFlapSpeedBug(this._data.get(20));
        }
    }
    /**
     * Updates the nominal flaps handle index, which is the flaps handle index after applying a 1 second delay.
     * @param dt The amount of time elapsed since the last update, in milliseconds.
     */
    updateNominalFlapsHandleIndex(dt) {
        const currentIndex = this.flapsHandleIndex.get();
        if (currentIndex === this.nominalFlapsHandleIndex) {
            this.flapsHandleArmedIndex = undefined;
            return;
        }
        if (this.flapsHandleArmedIndex !== currentIndex) {
            this.flapsHandleIndexDelay = 1000;
            this.flapsHandleArmedIndex = currentIndex;
            return;
        }
        this.flapsHandleIndexDelay -= dt;
        if (this.flapsHandleIndexDelay <= 0) {
            this.nominalFlapsHandleIndex = this.flapsHandleArmedIndex;
            this.flapsHandleArmedIndex = undefined;
        }
    }
    /**
     * Updates one of this data provider's flap maneuvering speeds.
     * @param data The data for the flap speed bug to update.
     * @param pressureAlt The current pressure altitude, in feet.
     * @param weight The current airplane weight, in pounds.
     */
    updateFlapManeuveringSpeed(data, pressureAlt, weight) {
        if (pressureAlt === data.lastPressureAlt && weight === data.lastWeight) {
            return;
        }
        data.lastPressureAlt = pressureAlt;
        data.lastWeight = weight;
        data.maneuverIas.set(Math.floor(this.speedProvider.getFlapManeuverSpeed(data.position, weight, pressureAlt)));
    }
    /**
     * Sets one of this data provider's flap speed bugs to be hidden.
     * @param data The data for the flap speed bug to hide.
     */
    hideFlapSpeedBug(data) {
        data.lastPressureAlt = undefined;
        data.lastWeight = undefined;
        data.maneuverIas.set(null);
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        (_a = this.adcIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.updateSub) === null || _b === void 0 ? void 0 : _b.destroy();
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/** Class to manage the altitude alerter on the PFD Altimeter */
class B787AltitudeAlertController extends BoeingAltitudeAlertController {
    /** @inheritdoc */
    getIsApproachModeSubscribable() {
        return MappedSubject.create(([gearDown, flapPosition, approachFlapsSpeed, inApproachLock]) => {
            var _a;
            // if no landing flaps are selected, check for flaps full
            const landingFlaps = approachFlapsSpeed ? (_a = approachFlapsSpeed[0]) !== null && _a !== void 0 ? _a : 30 : 30;
            let isLandingFlapsSet;
            switch (landingFlaps) {
                case 20:
                    isLandingFlapsSet = flapPosition === 7;
                    break;
                case 25:
                    isLandingFlapsSet = flapPosition === 8;
                    break;
                case 30:
                default:
                    isLandingFlapsSet = flapPosition === 9;
            }
            return inApproachLock || (gearDown && isLandingFlapsSet);
        }, this.isGearDown, this.flapsPosition, this.performancePlan.approachFlapSpeed, this.inApproachLock);
    }
}

/**
 * A provider of Boeing 787 minimums data.
 */
class B787MinimumsDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.bus);
        /** @inheritdoc */
        this.minimumsMode = this.cockpitUserSettings.getSetting('minimumsMode');
        /** @inheritdoc */
        this.baroMinimums = MappedSubject.create(([mode, minimums]) => mode === MinimumsMode.BARO ? minimums : null, this.minimumsMode, this.cockpitUserSettings.getSetting('decisionAltitudeFeet'));
        /** @inheritdoc */
        this.radioMinimums = MappedSubject.create(([mode, minimums]) => mode === MinimumsMode.RA ? minimums : null, this.minimumsMode, this.cockpitUserSettings.getSetting('decisionHeightFeet'));
        this.minimumsAlertState = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isBaroMinimumsAlertActive = MappedSubject.create(([mode, alertState]) => mode === MinimumsMode.BARO && alertState, this.minimumsMode, this.minimumsAlertState);
        this._isRadioMinimumsAlertActive = ConsumerSubject.create(null, false).pause();
        /** @inheritdoc */
        this.isRadioMinimumsAlertActive = this._isRadioMinimumsAlertActive;
        this.pauseable = [
            this.baroMinimums,
            this.radioMinimums,
            this.minimumsAlertState,
            this.isBaroMinimumsAlertActive,
            this._isRadioMinimumsAlertActive
        ];
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('B787MinimumsDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.minimumsAlertState.setConsumer(sub.on('minimums_alert'));
        this._isRadioMinimumsAlertActive.setConsumer(sub.on('radio_minimums_alert'));
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('B787MinimumsDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const subject of this.pauseable) {
            subject.resume();
        }
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('B787MinimumsDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const subject of this.pauseable) {
            subject.pause();
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        for (const subject of this.pauseable) {
            subject.destroy();
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Boeing 787 air data reference system (ADRS) airspeed data modes.
 */
var B787AdrsAirspeedDataMode;
(function (B787AdrsAirspeedDataMode) {
    /** ADRS is providing voted airspeed data sourced from the left, right, and/or center pitot/static systems. */
    B787AdrsAirspeedDataMode["Voted"] = "Voted";
    /** ADRS is providing backup airspeed data sourced from angle-of-attack and inertial inputs. */
    B787AdrsAirspeedDataMode["Aoa"] = "Aoa";
    /** ADRS is providing backup airspeed data sourced from the center pitot/static system and the ISFD. */
    B787AdrsAirspeedDataMode["Isfd"] = "Isfd";
})(B787AdrsAirspeedDataMode || (B787AdrsAirspeedDataMode = {}));
/**
 * Boeing 787 air data reference system (ADRS) altitude data modes.
 */
var B787AdrsAltitudeDataMode;
(function (B787AdrsAltitudeDataMode) {
    /** ADRS is providing voted altitude data sourced from the left, right, and/or center pitot/static systems. */
    B787AdrsAltitudeDataMode["Voted"] = "Voted";
    /** ADRS is providing backup altitude data sourced from GPS altitude. */
    B787AdrsAltitudeDataMode["Gps"] = "Gps";
    /** ADRS is providing backup altitude data sourced from the center pitot/static system and the ISFD. */
    B787AdrsAltitudeDataMode["Isfd"] = "Isfd";
})(B787AdrsAltitudeDataMode || (B787AdrsAltitudeDataMode = {}));
/**
 * A default implementation of {@link B787AdrsDataProvider}.
 */
class DefaultB787AdrsDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.airspeedSelectIndex = ConsumerSubject.create(null, -1).pause();
        this.altitudeSelectIndex = ConsumerSubject.create(null, -1).pause();
        /** @inheritdoc */
        this.airspeedDataMode = this.airspeedSelectIndex.map(index => {
            switch (index) {
                case 1:
                    return B787AdrsAirspeedDataMode.Voted;
                case 2:
                    return B787AdrsAirspeedDataMode.Aoa;
                default:
                    return B787AdrsAirspeedDataMode.Isfd;
            }
        });
        /** @inheritdoc */
        this.altitudeDataMode = this.altitudeSelectIndex.map(index => {
            switch (index) {
                case 1:
                    return B787AdrsAltitudeDataMode.Voted;
                case 3:
                    return B787AdrsAltitudeDataMode.Gps;
                default:
                    return B787AdrsAltitudeDataMode.Isfd;
            }
        });
        this._isAirspeedDataValid = ConsumerSubject.create(null, true).pause();
        /** @inheritdoc */
        this.isAirspeedDataValid = this._isAirspeedDataValid;
        this._isAltitudeDataValid = ConsumerSubject.create(null, true).pause();
        /** @inheritdoc */
        this.isAltitudeDataValid = this._isAltitudeDataValid;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = true;
        this.pauseable = [
            this.airspeedSelectIndex,
            this.altitudeSelectIndex,
            this._isAirspeedDataValid,
            this._isAltitudeDataValid
        ];
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultB787AdrsDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        this.airspeedSelectIndex.setConsumer(sub.on('adc_selector_selected_index_1'));
        this.altitudeSelectIndex.setConsumer(sub.on('adc_selector_selected_index_2'));
        this._isAirspeedDataValid.setConsumer(sub.on('adc_selector_speed_data_valid_1'));
        this._isAltitudeDataValid.setConsumer(sub.on('adc_selector_altitude_data_valid_2'));
        if (!paused) {
            this.resume();
        }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('DefaultB787AdrsDataProvider: cannot resume a dead provider');
        }
        if (!this.isInit || !this.isPaused) {
            return;
        }
        this.isPaused = false;
        for (const pauseable of this.pauseable) {
            pauseable.resume();
        }
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('DefaultB787AdrsDataProvider: cannot pause a dead provider');
        }
        if (!this.isInit || this.isPaused) {
            return;
        }
        this.isPaused = true;
        for (const pauseable of this.pauseable) {
            pauseable.pause();
        }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        for (const pauseable of this.pauseable) {
            pauseable.destroy();
        }
    }
}

/*
  Possible values
  - A/P (green) - means autopilot engaged
  - FLT DIR (green) - means flight director on
  - LAND 3 (green) - means fail operational autoland
  - LAND 2 (green with white triangles either side) - means fail passive autoland
  - NO AUTOLAND (amber) - means autoland degraded in operation, or not available below 300 feet AGL

  All changes are boxed for 10 seconds (amber box for NO AUTOLAND)
*/
var AfdsStates;
(function (AfdsStates) {
    AfdsStates["None"] = "";
    AfdsStates["FlightDirector"] = "FLT DIR";
    AfdsStates["Autopilot"] = "A/P";
    /** arrows either side */
    AfdsStates["Land2"] = "LAND 2";
    AfdsStates["Land3"] = "LAND 3";
    /** amber */
    AfdsStates["NoAutoland"] = "NO AUTOLAND";
})(AfdsStates || (AfdsStates = {}));
/**
 * The Boeing 787 Autopilot Flight Director System status display.
 */
class AfdsStatus extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.statusCssClass = SetSubject.create(['afds-status']);
        this.arrowCssClass = SetSubject.create(['afds-status-arrow', 'hidden']);
        this.alertTimer = new DebounceTimer();
        this.autopilotMaster = ConsumerSubject.create(null, false);
        this.flightDirector = ConsumerSubject.create(null, false);
        this.radioAlt = ConsumerSubject.create(null, 0);
        this.radioAltHealthy = Subject.create(false);
        this.approachActive = ConsumerSubject.create(null, false);
        this.autolandCapability = ConsumerSubject.create(null, AutolandCapability.None);
        this.afdsActiveMode = MappedSubject.create(([autopilotMaster, flightDirector, radioAlt, radioAltHealthy, approachActive, autolandCapability]) => this.determineState(autopilotMaster, flightDirector, radioAlt, radioAltHealthy, approachActive, autolandCapability), this.autopilotMaster, this.flightDirector, this.radioAlt, this.radioAltHealthy, this.approachActive, this.autolandCapability);
        this.afdsActiveModeSub = this.afdsActiveMode.sub(() => this.onStatusChanged());
    }
    /** @inheritdoc */
    onAfterRender() {
        const ap = this.props.bus.getSubscriber();
        this.autopilotMaster.setConsumer(ap.on('ap_master_status'));
        // TODO FD2? PFDs common for now..
        this.flightDirector.setConsumer(ap.on('ap_boeing_flight_director_is_active_1'));
        this.approachActive.setConsumer(ap.on('ap_glideslope_hold'));
        const ra = this.props.bus.getSubscriber();
        this.radioAlt.setConsumer(ra.on('ra_radio_alt_1').atFrequency(1));
        ra.on('ra_state_1').handle((state) => this.radioAltHealthy.set(state.current === AvionicsSystemState.On));
        const control = this.props.bus.getSubscriber();
        this.autolandCapability.setConsumer(control.on('autoland_capability'));
    }
    /**
     * Determine current AFDS state
     * @param autopilotMaster Is AP engaged
     * @param flightDirector Is FD engaged
     * @param radioAlt Current radio altitude
     * @param radioAltHealthy Is the RA healthy?
     * @param approachActive are the LOC + GS modes active?
     * @param autolandCapability current FMC autoland capability
     * @returns Current AFDS State
     */
    determineState(autopilotMaster, flightDirector, radioAlt, radioAltHealthy, approachActive, autolandCapability) {
        const ra = radioAltHealthy ? radioAlt : Infinity;
        if (autopilotMaster) {
            if (approachActive) {
                if (autolandCapability === AutolandCapability.FailOperational) {
                    return AfdsStates.Land3;
                }
                else if (autolandCapability === AutolandCapability.FailPassive) {
                    return AfdsStates.Land2;
                }
                else if (ra < 300) {
                    return AfdsStates.NoAutoland;
                }
            }
            return AfdsStates.Autopilot;
        }
        else if (flightDirector) {
            return AfdsStates.FlightDirector;
        }
        return AfdsStates.None;
    }
    /** Update the display when status changes */
    onStatusChanged() {
        if (this.afdsActiveMode.get() === AfdsStates.None) {
            this.removeBox();
        }
        else {
            this.addBox();
        }
        // set the colour and/or arrows
        if (this.afdsActiveMode.get() === AfdsStates.NoAutoland) {
            this.statusCssClass.add('afds-status-failed');
        }
        else {
            this.statusCssClass.delete('afds-status-failed');
        }
        if (this.afdsActiveMode.get() === AfdsStates.Land2) {
            this.arrowCssClass.delete('hidden');
        }
        else {
            this.arrowCssClass.add('hidden');
        }
    }
    /** box the status for 10 seconds */
    addBox() {
        // schedule clears/overwrites pending timers
        this.alertTimer.schedule(() => {
            this.statusCssClass.delete('afds-status-alert');
        }, AfdsStatus.ALERT_DURATION);
        this.statusCssClass.add('afds-status-alert');
    }
    /** remove the box around the status */
    removeBox() {
        this.statusCssClass.delete('afds-status-alert');
        this.alertTimer.clear();
    }
    /** @inheritdoc */
    render() {
        if (typeof this.props.class === 'object') {
            this.cssClassSub = FSComponent.bindCssClassSet(this.statusCssClass, this.props.class, AfdsStatus.RESERVED_CSS_CLASSES);
        }
        else if (this.props.class) {
            for (const cssClass of FSComponent.parseCssClassesFromString(this.props.class, cssClassToAdd => !AfdsStatus.RESERVED_CSS_CLASSES.includes(cssClassToAdd))) {
                this.statusCssClass.add(cssClass);
            }
        }
        return (FSComponent.buildComponent("div", { class: this.statusCssClass },
            FSComponent.buildComponent("svg", { viewBox: "0 0 24 30", class: this.arrowCssClass },
                FSComponent.buildComponent("path", { d: "M 22 15 l -20 -12 l 0 24 z" })),
            FSComponent.buildComponent("div", { class: 'afds-status-active' }, this.afdsActiveMode),
            FSComponent.buildComponent("svg", { viewBox: "0 0 24 30", class: this.arrowCssClass },
                FSComponent.buildComponent("path", { d: "M 2 15 l 20 -12 l 0 24 z" }))));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        this.afdsActiveModeSub.destroy();
        (_a = this.cssClassSub) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}
/** duration for status change boxing */
AfdsStatus.ALERT_DURATION = 10000; // milliseconds
AfdsStatus.RESERVED_CSS_CLASSES = ['afds-status', 'afds-status-alert', 'afds-status-failed'];

/**
 * The Boeing 787 PFD Autopilot Flight Director System status display.
 */
class PfdAfdsStatus extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(AfdsStatus, { ref: this.ref, bus: this.props.bus }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}

/**
 * A PFD airspeed indicator.
 */
class PfdAirspeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-airspeed-container': true,
                'translucent-box': true,
                'att-failed-gray-box': true,
                'outlined-box': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent(AirspeedIndicator, { ref: this.ref, dataProvider: this.props.dataProvider, flapRetractionDataProvider: this.props.flapRetractionDataProvider, flapSpeedBugDataProvider: this.props.flapSpeedBugDataProvider, vnavSpeedBandDataProvider: this.props.vnavSpeedBandDataProvider, performancePlan: this.props.performancePlan, vSpeedSettings: this.props.vSpeedSettings, showManeuverSpeedBands: this.props.showManeuverSpeedBands, windowHeight: 684, v1BugPositionClamp: 28, vrefBugPositionClamp: 634 })));
    }
}

/**
 * A PFD selected airspeed display box.
 */
class PfdAirspeedSelectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(AirspeedSelectBox, { ref: this.ref, dataProvider: this.props.dataProvider }));
    }
}

/**
 * A PFD mach digital readout display.
 */
class PfdMachReadout extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(GsMachReadout, { ref: this.ref, airspeedIndicatorDataProvider: this.props.airspeedIndicatorDataProvider, showMach: this.props.showMach }));
    }
}

/**
 * A PFD "NO VSPD" failure flag.
 */
class PfdNoVSpdFlag extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(NoVSpdFlag, { ref: this.ref, bus: this.props.bus, isAirspeedDataFailed: this.props.isAirspeedDataFailed }));
    }
}

/**
 * A PFD altimeter.
 */
class PfdAltimeter extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.hidden.sub(hidden => {
            if (hidden) {
                this.ref.instance.pause();
            }
            else {
                this.ref.instance.resume();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-altimeter-container': true,
                'translucent-box': true,
                'att-failed-gray-box': true,
                'outlined-box': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent(Altimeter, { ref: this.ref, dataProvider: this.props.dataProvider, minimumsDataProvider: this.props.minimumsDataProvider, showMetric: this.props.showMetric, isQfe: this.props.isQfe, windowHeight: 684, supportTrendVector: true })));
    }
}

/**
 * A PFD altimeter barometric settings display.
 */
class PfdAltimeterBaroDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.hidden.sub(hidden => {
            if (hidden) {
                this.ref.instance.pause();
            }
            else {
                this.ref.instance.resume();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'pfd-alt-baro-container': true, 'hidden': this.hidden } },
            FSComponent.buildComponent(AltimeterBaroDisplay, { ref: this.ref, dataProvider: this.props.dataProvider, showMetric: this.props.showMetric })));
    }
}

/**
 * A PFD altitude preselect display.
 */
class PfdAltPreselectBox extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(AltPreselectBox, { ref: this.ref, selectedAltitude: this.props.dataProvider.selectedAltitude, altitudeAlertState: this.props.dataProvider.altitudeAlertState, showMetric: this.props.showMetric }));
    }
}

/**
 * A PFD approach reference display.
 */
class PfdApproachReference extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(ApproachReference, { ref: this.ref, dataProvider: this.props.dataProvider }));
    }
}

/**
 * A PFD lateral deviation indicator.
 */
class PfdLateralDeviationIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.isNpScaleVisible = MappedSubject.create(SubscribableMapFunctions.or(), this.props.dataProvider.isLateralNavSourceNp, this.props.dataProvider.isApLateralTogaActive);
        this.isNpDeviationVisible = this.props.dataProvider.npDeviation.map(deviation => deviation !== null);
        this.isFacScaleVisible = this.props.dataProvider.facDeviation.map(deviation => deviation !== null);
        this.isLsScaleVisible = this.props.dataProvider.locDeviation.map(deviation => deviation !== null);
        this.isLocCaptured = MappedSubject.create(([isLocActive, locDeviation]) => isLocActive && locDeviation !== null && Math.abs(locDeviation) < 0.5, this.props.dataProvider.isApLocActive, this.props.dataProvider.locDeviation);
        this.locCaptureExpandedLsScale = Subject.create(false);
        this.locCaptureExpandedLsScaleTimer = new DebounceTimer();
        this.expandedLsScale = MappedSubject.create(SubscribableMapFunctions.or(), this.locCaptureExpandedLsScale, this.props.dataProvider.isApTakeoffLocActive);
    }
    /** @inheritdoc */
    onAfterRender() {
        const activateLocCaptureExpandedLsScale = this.locCaptureExpandedLsScale.set.bind(this.locCaptureExpandedLsScale, true);
        this.isLocCaptured.sub((captured) => {
            if (captured) {
                this.locCaptureExpandedLsScaleTimer.schedule(activateLocCaptureExpandedLsScale, PfdLateralDeviationIndicator.LOC_CAPTURE_EXPANDED_LS_SCALE_DELAY);
            }
            else {
                this.locCaptureExpandedLsScaleTimer.clear();
                this.locCaptureExpandedLsScale.set(false);
            }
        }, true);
        if (this.props.expandedLocScale) {
            this.expandedLsScalePipe = this.expandedLsScale.pipe(this.props.expandedLocScale);
        }
        this.ref.instance.wake();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "lateral-deviation-box" },
            FSComponent.buildComponent(DeviationIndicator, { ref: this.ref, rnp: this.props.dataProvider.rnp, anp: this.props.dataProvider.anp, npDeviation: this.props.dataProvider.npDeviation, isUnableRnpAlertActive: this.props.dataProvider.isUnableRnp, isNpDeviationAlertActive: this.props.dataProvider.isNpDeviationExcessive, npDeviationVisible: this.isNpDeviationVisible, npScaleVisible: this.isNpScaleVisible, ianDeviation: this.props.dataProvider.facDeviation, isIanDeviationAlertActive: this.props.dataProvider.isFacDeviationExcessive, ianDeviationVisible: this.isFacScaleVisible, ianScaleVisible: this.isFacScaleVisible, lsDeviation: this.props.dataProvider.locDeviation, lsScaleVisible: this.isLsScaleVisible, isLsDeviationAlertActive: this.props.dataProvider.isLocDeviationExcessive, isLsPointerFlashing: this.props.isLocPointerFlashing, expandedLsScale: this.expandedLsScale })));
    }
    /** @inheritdoc */
    destroy() {
        var _a, _b;
        (_a = this.ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isNpScaleVisible.destroy();
        this.isNpDeviationVisible.destroy();
        this.isLsScaleVisible.destroy();
        this.isLocCaptured.destroy();
        this.locCaptureExpandedLsScaleTimer.clear();
        this.expandedLsScale.destroy();
        (_b = this.expandedLsScalePipe) === null || _b === void 0 ? void 0 : _b.destroy();
        super.destroy();
    }
}
PfdLateralDeviationIndicator.LOC_CAPTURE_EXPANDED_LS_SCALE_DELAY = 10000; // ms

/**
 * A PFD vertical deviation indicator.
 */
class PfdVerticalDeviationIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.isNpScaleVisible = MappedSubject.create(SubscribableMapFunctions.or(), this.props.dataProvider.isVerticalNavSourceNp, this.props.dataProvider.isApLateralTogaActive);
        this.isNpDeviationVisible = MappedSubject.create(([isVerticalPathAvailable, isVerticalNavSourceNp, npDeviation]) => {
            return isVerticalNavSourceNp && npDeviation !== null && isVerticalPathAvailable;
        }, this.props.dataProvider.isVerticalPathAvailable, this.props.dataProvider.isVerticalNavSourceNp, this.props.dataProvider.npDeviation);
        this.isGpScaleVisible = this.props.dataProvider.gpDeviation.map(deviation => deviation !== null);
        this.isLsScaleVisible = this.props.dataProvider.gsDeviation.map(deviation => deviation !== null);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.wake();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: "vertical-deviation-box" },
            FSComponent.buildComponent(DeviationIndicator, { ref: this.ref, rnp: this.props.dataProvider.rnp, anp: this.props.dataProvider.anp, npDeviation: this.props.dataProvider.npDeviation, isUnableRnpAlertActive: this.props.dataProvider.isUnableRnp, isNpDeviationAlertActive: this.props.dataProvider.isNpDeviationExcessive, npDeviationVisible: this.isNpDeviationVisible, npScaleVisible: this.isNpScaleVisible, ianDeviation: this.props.dataProvider.gpDeviation, isIanDeviationAlertActive: this.props.dataProvider.isGpDeviationExcessive, ianDeviationVisible: this.isGpScaleVisible, ianScaleVisible: this.isGpScaleVisible, lsDeviation: this.props.dataProvider.gsDeviation, lsScaleVisible: this.isLsScaleVisible, isLsDeviationAlertActive: this.props.dataProvider.isGsDeviationExcessive })));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isNpScaleVisible.destroy();
        this.isNpDeviationVisible.destroy();
        this.isGpScaleVisible.destroy();
        this.isLsScaleVisible.destroy();
        super.destroy();
    }
}

/** The RisingRunwayIndicator component. */
class RisingRunwayIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.raHeight = ConsumerSubject.create(null, 0);
        this.isHidden = MappedSubject.create(([radioAltitude, locDeviation]) => radioAltitude >= 2500 || locDeviation === null, this.raHeight, this.props.lateralDeviationDataProvider.locDeviation);
        this.transform = CssTransformSubject.create(CssTransformBuilder.translate3d('px'));
        this.positionSubs = [];
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.raHeight.setConsumer(sub.on('ra_radio_alt_1').whenChangedBy(10));
        const positionHandler = this.moveRisingRunwaySymbol.bind(this);
        this.positionSubs.push(this.raHeight.sub(positionHandler), this.props.lateralDeviationDataProvider.locDeviation.sub(positionHandler), this.props.expandedLocScale.sub(positionHandler));
        this.isHidden.sub(isHidden => {
            if (isHidden) {
                for (const positionSub of this.positionSubs) {
                    positionSub.pause();
                }
            }
            else {
                for (const positionSub of this.positionSubs) {
                    positionSub.resume();
                }
                this.moveRisingRunwaySymbol();
            }
        }, true);
    }
    /**
     * Method to move the rising runway within the surrounding div:
     */
    moveRisingRunwaySymbol() {
        var _a;
        // The symbol moves vertically according to the radio altitude over ground (<200) and laterally with the LOC deviation indicator:
        const raHeight = this.raHeight.get();
        const locDeviation = (_a = this.props.lateralDeviationDataProvider.locDeviation.get()) !== null && _a !== void 0 ? _a : 0;
        const verticalDeviationInPixel = raHeight != null ? (raHeight > 200 ? 259 : raHeight * 259 / 200) : 259;
        const locDeviationInPixel = locDeviation * (this.props.expandedLocScale.get() ? 210.36 : 70.12); // Reduced gives 3x the resolution
        // Now move the symbol:
        this.transform.transform.set(locDeviationInPixel, verticalDeviationInPixel, 0, 0.1, 0.1);
        this.transform.resolve();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'rising-runway-box': true, 'hidden': this.isHidden } },
            FSComponent.buildComponent("div", { class: "rising-runway-symbol", style: { 'transform': this.transform } },
                FSComponent.buildComponent("svg", { "stroke-linejoin": "round", fill: "none" },
                    FSComponent.buildComponent("path", { d: "M 15 3 l 200 0 l 10 29 l -220 0 z M 115 3 l 0 29", "stroke-width": "6", stroke: "var(--boeing-colors-black)" }),
                    FSComponent.buildComponent("path", { d: "M 15 3 l 200 0 l 10 29 l -220 0 z M 115 3 l 0 29", "stroke-width": "4", stroke: "var(--boeing-colors-green)" })),
                FSComponent.buildComponent("svg", { class: { 'rising-runway-alert': this.props.isLocPointerFlashing }, style: "height:400px", "stroke-linejoin": "round", fill: "none" },
                    FSComponent.buildComponent("path", { d: "M 111 34.5 l 0 400 M 119 34.5 l 0 400", "stroke-width": "6", stroke: "var(--boeing-colors-black)" }),
                    FSComponent.buildComponent("path", { d: "M 111 34.5 l 0 400 M 119 34.5 l 0 400", "stroke-width": "4", stroke: "var(--boeing-colors-magenta)" })))));
    }
}

/** The Marker Beacon Display Component. */
class MarkerBeacon extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.markerBeaconRef = FSComponent.createRef();
        this.textSub = ComputedSubject.create(MarkerBeaconState.Inactive, (state) => MarkerBeacon.TEXT[state]);
        /**
         * Handle a marker beacon state change event.
         * @param state is the marker beacon state.
         */
        this.onMarkerBeacon = (state) => {
            this.textSub.set(state);
            switch (state) {
                case MarkerBeaconState.Inactive:
                    this.markerBeaconRef.instance.classList.remove('outer-animation', 'middle-animation', 'inner-animation');
                    break;
                case MarkerBeaconState.Outer:
                    this.markerBeaconRef.instance.classList.remove('middle-animation', 'inner-animation');
                    this.markerBeaconRef.instance.classList.add('outer-animation');
                    break;
                case MarkerBeaconState.Middle:
                    this.markerBeaconRef.instance.classList.remove('outer-animation', 'inner-animation');
                    this.markerBeaconRef.instance.classList.add('middle-animation');
                    break;
                case MarkerBeaconState.Inner:
                    this.markerBeaconRef.instance.classList.remove('outer-animation', 'middle-animation');
                    this.markerBeaconRef.instance.classList.add('inner-animation');
                    break;
            }
        };
    }
    /** A callback called after the component renders. */
    onAfterRender() {
        this.props.dataProvider.markerBeaconState.sub(this.onMarkerBeacon.bind(this));
    }
    /**
     * Renders the component.
     * @returns The component VNode.
     */
    render() {
        return (FSComponent.buildComponent("div", { class: "marker-beacon-box", ref: this.markerBeaconRef }, this.textSub));
    }
}
MarkerBeacon.TEXT = {
    [MarkerBeaconState.Inactive]: '',
    [MarkerBeaconState.Outer]: 'OM',
    [MarkerBeaconState.Middle]: 'MM',
    [MarkerBeaconState.Inner]: 'IM',
};

/** The MinimumsIndicator component. */
class MinimumsIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.cockpitUserSettings = CockpitUserSettings.getManager(this.props.bus);
        this.modeSetting = this.cockpitUserSettings.getSetting('minimumsMode');
        this.baroMinimumsSetting = this.cockpitUserSettings.getSetting('decisionAltitudeFeet');
        this.radioMinimumsSetting = this.cockpitUserSettings.getSetting('decisionHeightFeet');
        this.minimumsLabel = this.modeSetting.map(mode => {
            switch (mode) {
                case MinimumsMode.BARO:
                    return 'BARO';
                case MinimumsMode.RA:
                    return 'RADIO';
                default:
                    return '';
            }
        });
        this.minimumsValue = MappedSubject.create(([mode, baroMins, radioMins]) => {
            switch (mode) {
                case MinimumsMode.BARO:
                    return baroMins.toFixed(0);
                case MinimumsMode.RA:
                    return radioMins.toFixed(0);
                default:
                    return '';
            }
        }, this.modeSetting, this.baroMinimumsSetting, this.radioMinimumsSetting);
        this.isAlertActive = ConsumerSubject.create(null, false);
        this.isFlashing = Subject.create(false);
        this.flashTimer = new DebounceTimer();
        this.isHidden = MappedSubject.create(([show, mode]) => !show || mode === MinimumsMode.OFF, this.props.show, this.modeSetting);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.isAlertActive.setConsumer(this.props.bus.getSubscriber().on('minimums_alert'));
        const deactivateFlashing = this.isFlashing.set.bind(this.isFlashing, false);
        this.isAlertActive.sub(isActive => {
            if (isActive) {
                this.isFlashing.set(true);
                this.flashTimer.schedule(deactivateFlashing, MinimumsIndicator.FLASH_DURATION);
            }
            else {
                this.flashTimer.clear();
                deactivateFlashing();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'minimums-indicator': true,
                'hidden': this.isHidden,
                'minimums-indicator-alert': this.isAlertActive,
                'minimums-indicator-flash': this.isFlashing
            } },
            FSComponent.buildComponent("div", { class: "minimums-indicator-text" },
                FSComponent.buildComponent("div", { class: "minimums-indicator-text-label" }, this.minimumsLabel),
                FSComponent.buildComponent("div", { class: "minimums-indicator-text-value" }, this.minimumsValue))));
    }
    /** @inheritdoc */
    destroy() {
        this.minimumsValue.destroy();
        this.minimumsLabel.destroy();
        this.isAlertActive.destroy();
        this.isHidden.destroy();
        this.flashTimer.clear();
        super.destroy();
    }
}
MinimumsIndicator.FLASH_DURATION = 3000; // milliseconds

/**
 * A PFD navigation source display.
 */
class PfdNavigationSourceDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.resume();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(NavigationSourceDisplay, { ref: this.ref, lateralDeviationDataProvider: this.props.lateralDeviationDataProvider, verticalDeviationDataProvider: this.props.verticalDeviationDataProvider, isVerticalTogaNp: false }));
    }
}

/** The Altimeter component. */
class RadioAltimeter extends DisplayComponent {
    constructor() {
        super(...arguments);
        /** above this height the RA is not displayed */
        this.RADIO_ALT_MAX = 2500;
        /** below this height the RA value is quantised in twos, above this it's tens */
        this.RADIO_ALT_TENS_THRESHOLD = 100;
        /** below this height the RA value is quantised in tens, above it's twenties */
        this.RADIO_ALT_TWENTIES_THRESHOLD = 500;
        /** the value will be boxed for this time [ms] on first appearing */
        this.RADIO_ALT_ALERT_TIME = 10000;
        this.quantisedRadioAltitude = ComputedSubject.create(0, (ra) => {
            if (ra >= this.RADIO_ALT_TWENTIES_THRESHOLD) {
                return MathUtils.ceil(ra, 20);
            }
            else if (ra >= this.RADIO_ALT_TENS_THRESHOLD) {
                return MathUtils.ceil(ra, 10);
            }
            return MathUtils.ceil(ra, 2);
        });
        this.radioAltitudeText = Subject.create('0');
        this.radioAltClasses = SetSubject.create(['radio-alt', 'black-box', 'hidden']);
        this.radioAltVisible = Subject.create(false);
        this.alertTimer = new DebounceTimer();
    }
    /** @inheritdoc */
    onAfterRender() {
        const raSystem = this.props.bus.getSubscriber();
        this.radioAltVisible.sub(this.onRAVisibilityChanged.bind(this));
        this.quantisedRadioAltitude.sub(this.onRaHeightChanged.bind(this));
        this.rawRadioAltitude = raSystem.on('ra_radio_alt_1').handle(this.quantisedRadioAltitude.set.bind(this.quantisedRadioAltitude));
        raSystem.on('ra_state_1').whenChanged().handle(this.onRaStateChanged.bind(this));
        const controlSub = this.props.bus.getSubscriber();
        controlSub.on('radio_minimums_alert').handle(this.onRadioMinimumsAlertChanged.bind(this));
    }
    /**
     * Handle changes in RA height
     * @param ra current height
     */
    onRaHeightChanged(ra) {
        const visible = ra <= this.RADIO_ALT_MAX;
        this.radioAltVisible.set(visible);
        if (visible) {
            this.radioAltitudeText.set(ra.toFixed(0));
        }
    }
    /**
     * Handle changes in RA system state
     * @param state Current state
     */
    onRaStateChanged(state) {
        var _a, _b;
        const failed = state.current !== AvionicsSystemState.On;
        if (failed) {
            (_a = this.rawRadioAltitude) === null || _a === void 0 ? void 0 : _a.pause();
            this.radioAltitudeText.set('RA');
            this.radioAltVisible.set(true);
        }
        else {
            this.radioAltClasses.delete('radio-alt-failed');
            this.onRaHeightChanged(this.quantisedRadioAltitude.get());
            (_b = this.rawRadioAltitude) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
        this.radioAltClasses.toggle('radio-alt-failed', failed);
    }
    /**
     * Handles changes in RA component visibility
     * @param visible Whether RA value should be visible
     */
    onRAVisibilityChanged(visible) {
        if (visible) {
            this.radioAltClasses.delete('hidden');
            // box it for 10 seconds
            this.radioAltClasses.add('radio-alt-alert');
            this.alertTimer.schedule(() => this.radioAltClasses.delete('radio-alt-alert'), this.RADIO_ALT_ALERT_TIME);
        }
        else {
            this.radioAltClasses.add('hidden');
        }
    }
    /**
     * Handle changes in RA minima alert state
     * @param alert below radio minima
     */
    onRadioMinimumsAlertChanged(alert) {
        this.radioAltClasses.toggle('radio-alt-below-minima', alert);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: this.radioAltClasses }, this.radioAltitudeText));
    }
}

/**
 * A PFD vertical speed indicator.
 */
class PfdVerticalSpeedIndicator extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.hidden = this.props.show.map(SubscribableMapFunctions.not());
    }
    /** @inheritdoc */
    onAfterRender() {
        this.hidden.sub(hidden => {
            if (hidden) {
                this.ref.instance.pause();
            }
            else {
                this.ref.instance.resume();
            }
        }, true);
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: {
                'pfd-vertical-speed-container': true,
                'hidden': this.hidden
            } },
            FSComponent.buildComponent("svg", { class: 'pfd-vertical-speed-background' },
                FSComponent.buildComponent("path", { d: 'M 0 0 l 42 0 l 42 110 l 0 258 l -42 110 l -42 0 l 0 -155 l 25 -15 l 0 -138 l -25 -15 z' })),
            FSComponent.buildComponent(VerticalSpeedIndicator, { ref: this.ref, dataProvider: this.props.dataProvider, scaleWidth: 54, scaleHeight: 438, scaleTickOffset: -7, scaleTickLength: 8, scaleZeroTickLength: 25, pointerOriginOffset: 49 })));
    }
}

/**
 * A Boeing 787 FMA showing the autothrust, lateral and vertical modes.
 */
class Fma extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.apFmalastData = {
            verticalActive: APVerticalModes.NONE,
            verticalArmed: APVerticalModes.NONE,
            verticalDegraded: false,
            lateralActive: APLateralModes.NONE,
            lateralArmed: APLateralModes.NONE,
            lateralDegraded: false,
        };
        this.subscriptions = [];
        this.atFmalastData = {
            status: BoeingAutothrottleStatus.Off,
            armedMode: BoeingAutothrottleModes.NONE,
            activeMode: BoeingAutothrottleModes.NONE,
            isActiveModeFail: false,
            targetIas: null,
            targetMach: null
        };
        this.lateralSlotActiveText = Subject.create('');
        this.isLateralDegraded = Subject.create(false);
        this.verticalSlotActiveText = Subject.create('');
        this.isVerticalDegraded = Subject.create(false);
        this.autothrottleSlotActiveText = Subject.create('');
        this.isAutothrottleDegraded = Subject.create(false);
        this.lateralArmedText = Subject.create('');
        this.verticalArmedText = Subject.create('');
    }
    /** @inheritdoc */
    onAfterRender() {
        const sub = this.props.bus.getSubscriber();
        this.subscriptions.push(sub.on('fma_data').handle((data) => {
            this.updateFromFmaData(data, this.apFmalastData);
            Object.assign(this.apFmalastData, data);
        }));
        this.subscriptions.push(sub.on('boeing_at_fma_data').handle((data) => {
            this.updateFromAutoThrottleFmaData(data, this.atFmalastData);
            Object.assign(this.atFmalastData, data);
        }));
    }
    /**
     * Updates this FMA from a specific set of data.
     * @param data The FMA data from which to update.
     * @param lastData The previous FMA data.
     */
    updateFromFmaData(data, lastData) {
        this.isAutothrottleDegraded.set(false);
        if (data.lateralActive !== (lastData === null || lastData === void 0 ? void 0 : lastData.lateralActive)) {
            this.lateralSlotActiveText.set(this.getLateralActiveString(data.lateralActive));
        }
        this.isLateralDegraded.set(data.lateralDegraded && this.lateralSlotActiveText.get().length > 0);
        if (data.verticalActive !== (lastData === null || lastData === void 0 ? void 0 : lastData.verticalActive)) {
            this.verticalSlotActiveText.set(this.getVerticalActiveString(data.verticalActive));
        }
        this.isVerticalDegraded.set(data.verticalDegraded && this.verticalSlotActiveText.get().length > 0);
        this.lateralArmedText.set(this.getLateralArmedString(data.lateralArmed));
        this.verticalArmedText.set(this.getVerticalArmedString(data.verticalArmed));
    }
    /**
     * Updates this FMA from a specific set of data.
     * @param data The FMA data from which to update.
     * @param lastData The previous FMA data.
     */
    updateFromAutoThrottleFmaData(data, lastData) {
        if (data.status === BoeingAutothrottleStatus.On) {
            if (data.activeMode !== (lastData === null || lastData === void 0 ? void 0 : lastData.activeMode)) {
                this.autothrottleSlotActiveText.set(this.getAutothrottleActiveString(data.activeMode));
            }
        }
        else {
            this.autothrottleSlotActiveText.set('');
        }
    }
    /**
     * Gets the display text for an active autopilot vertical mode given a specific altitude capture mode.
     * @param mode An active autopilot vertical mode.
     * @returns The display text for the specified active autopilot vertical mode and altitude capture mode.
     */
    getVerticalActiveString(mode) {
        switch (mode) {
            case APVerticalModes.TO:
            case APVerticalModes.GA:
                return 'TO/GA';
            case BoeingVNavModes.ALT:
                return 'VNAV ALT';
            case BoeingVNavModes.PATH_IDLE:
            case BoeingVNavModes.PATH_DESCENT:
            case BoeingVNavModes.PATH_LEVEL:
            case APVerticalModes.PATH:
                return 'VNAV PTH';
            case BoeingVNavModes.SPD_CLIMB:
            case BoeingVNavModes.SPD_DESCENT:
            case BoeingVNavModes.THR_DESCENT:
                return 'VNAV SPD';
            case APVerticalModes.VS:
                return 'V/S';
            case APVerticalModes.FPA:
                return 'FPA';
            case APVerticalModes.FLC:
                return 'FLCH SPD';
            case APVerticalModes.CAP:
            case APVerticalModes.ALT:
                return 'ALT';
            case APVerticalModes.GS:
                return 'G/S';
            case APVerticalModes.GP:
                return 'G/P';
            case APVerticalModes.FLARE:
                return 'FLARE';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an armed autopilot vertical mode given a specific active vertical mode, armed altitude
     * capture mode, and VNAV path mode.
     * @param mode An armed autopilot vertical mode.
     * @returns The display text for the specified armed autopilot vertical mode, active vertical mode, armed altitude
     * capture mode, and VNAV path mode.
     */
    getVerticalArmedString(mode) {
        switch (mode) {
            case BoeingVNavModes.ARMED:
                return 'VNAV';
            case APVerticalModes.FLARE:
                return 'FLARE';
            case APVerticalModes.GS:
                return 'G/S';
            case APVerticalModes.GP:
                return 'G/P';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an active autopilot lateral mode.
     * @param mode An active autopilot lateral mode.
     * @returns The display text for the specified active autopilot lateral mode.
     */
    getLateralActiveString(mode) {
        switch (mode) {
            case APLateralModes.NAV:
            case APLateralModes.GPSS:
                return 'LNAV';
            case APLateralModes.HEADING:
                return 'HDG SEL';
            case APLateralModes.HEADING_HOLD:
                return 'HDG HOLD';
            case APLateralModes.TRACK:
                return 'TRK SEL';
            case APLateralModes.TRACK_HOLD:
                return 'TRK HOLD';
            case APLateralModes.LOC:
                return 'LOC';
            case APLateralModes.FMS_LOC:
                return 'FAC';
            case APLateralModes.TO_LOC:
                return 'HUD TO/GA';
            case APLateralModes.BC:
                return 'B/CRS';
            case APLateralModes.TO:
            case APLateralModes.GA:
                return 'TO/GA';
            /*case APLateralModes.HUDTOGA:
              return 'HUD TO/GA'; */
            case APLateralModes.ROLLOUT:
                return 'ROLLOUT';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an armed autopilot lateral mode.
     * @param mode An armed autopilot lateral mode.
     * @returns The display text for the specified armed autopilot lateral mode.
     */
    getLateralArmedString(mode) {
        switch (mode) {
            case APLateralModes.NAV:
            case APLateralModes.GPSS:
                return 'LNAV';
            case APLateralModes.LOC:
                return 'LOC';
            case APLateralModes.FMS_LOC:
                return 'FAC';
            case APLateralModes.BC:
                return 'B/CRS';
            case APLateralModes.ROLLOUT:
                return 'ROLLOUT';
            default:
                return '';
        }
    }
    /**
     * Gets the display text for an active autothrottle mode.
     * @param mode An active autothrottle mode.
     * @returns The display text for the specified active autothrottle mode.
     */
    getAutothrottleActiveString(mode) {
        switch (mode) {
            case BoeingAutothrottleModes.SPD:
                return 'SPD';
            case BoeingAutothrottleModes.TAKEOFF_HOLD:
            case BoeingAutothrottleModes.DESCENT_HOLD:
            case BoeingAutothrottleModes.HOLD_FAIL:
                return 'HOLD';
            case BoeingAutothrottleModes.GA_THR:
            case BoeingAutothrottleModes.DESCENT_THR:
                return 'THR';
            case BoeingAutothrottleModes.CLIMB:
            case BoeingAutothrottleModes.CON:
            case BoeingAutothrottleModes.GA:
            case BoeingAutothrottleModes.TO:
                return 'THR REF';
            case BoeingAutothrottleModes.IDLE:
            case BoeingAutothrottleModes.RETARD:
                return 'IDLE';
            case BoeingAutothrottleModes.NONE:
                return '';
        }
    }
    /** @inheritdoc */
    render() {
        var _a;
        let cssClass;
        if (typeof this.props.class === 'object') {
            cssClass = SetSubject.create(['fma']);
            this.subscriptions.push(FSComponent.bindCssClassSet(cssClass, this.props.class, ['fma']));
        }
        else {
            cssClass = `fma ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ''}`;
        }
        return (FSComponent.buildComponent("div", { class: cssClass },
            FSComponent.buildComponent(FmaModeSlot, { active: this.autothrottleSlotActiveText, isFailed: this.isAutothrottleDegraded, class: 'fma-active fma-autothrottle-active' }),
            FSComponent.buildComponent("svg", { class: "fma-splitter fma-splitter-left" },
                FSComponent.buildComponent("line", { x1: "50%", x2: "50%", y1: "0", y2: "100%", class: "fma-splitter-line-shadow" }),
                FSComponent.buildComponent("line", { x1: "50%", x2: "50%", y1: "0", y2: "100%", class: "fma-splitter-line" })),
            FSComponent.buildComponent(FmaModeSlot, { active: this.lateralSlotActiveText, isFailed: this.isLateralDegraded, class: 'fma-active fma-lateral-active' }),
            FSComponent.buildComponent("svg", { class: "fma-splitter fma-splitter-right" },
                FSComponent.buildComponent("line", { x1: "50%", x2: "50%", y1: "0", y2: "100%", class: "fma-splitter-line-shadow" }),
                FSComponent.buildComponent("line", { x1: "50%", x2: "50%", y1: "0", y2: "100%", class: "fma-splitter-line" })),
            FSComponent.buildComponent(FmaModeSlot, { active: this.verticalSlotActiveText, isFailed: this.isVerticalDegraded, class: 'fma-active fma-vertical-active' }),
            FSComponent.buildComponent("div", { class: 'fma-armed' }),
            FSComponent.buildComponent("div", { class: 'fma-armed fma-lateral-armed' }, this.lateralArmedText),
            FSComponent.buildComponent("div", { class: 'fma-armed fma-vertical-armed' }, this.verticalArmedText)));
    }
    /** @inheritDoc */
    destroy() {
        for (const it of this.subscriptions) {
            it.destroy();
        }
        super.destroy();
    }
}

/**
 * A Boeing 787 PFD FMA.
 */
class PfdFma extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.fmaRef = FSComponent.createRef();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent("div", { class: 'translucent-box att-failed-gray-box fma-background' }),
            FSComponent.buildComponent(Fma, { ref: this.fmaRef, bus: this.props.bus })));
    }
    /** @inheritDoc */
    destroy() {
        var _a;
        (_a = this.fmaRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        super.destroy();
    }
}

/**
 * A Boeing 787 PFD horizon display.
 */
class B787PfdHorizonDisplay extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.ref = FSComponent.createRef();
        this.isFpaModeActive = ConsumerSubject.create(null, false);
        this.isFpvSelected = ConsumerSubject.create(null, false);
        this.showFpv = MappedSubject.create(SubscribableMapFunctions.or(), this.isFpaModeActive, this.isFpvSelected);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.ref.instance.wake();
        const sub = this.props.bus.getSubscriber();
        this.isFpaModeActive.setConsumer(sub.on('b78_fpa_mode'));
        this.isFpvSelected.setConsumer(sub.on('b78_fpv_mode'));
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent(PfdHorizonDisplay, { ref: this.ref, bus: this.props.bus, adcAirspeedSelectorIndex: 1, adcAltitudeSelectorIndex: 2, irsSelectorIndex: 1, aoaDataProvider: this.props.aoaDataProvider, tcasRaCommandDataProvider: this.props.tcasRaCommandDataProvider, updateFreq: B787PfdHorizonDisplay.UPDATE_FREQ, projectedSize: B787PfdHorizonDisplay.PROJECTED_SIZE, fov: B787PfdHorizonDisplay.FOV, fovEndpoints: B787PfdHorizonDisplay.FOV_ENDPOINTS, projectedOffset: B787PfdHorizonDisplay.PROJECTED_OFFSET, artificialHorizonOptions: B787PfdHorizonDisplay.ARTIFICIAL_HORIZON_OPTIONS, horizonLineConformalBounds: B787PfdHorizonDisplay.HORIZON_LINE_CONFORMAL_BOUNDS, pitchLadderOptions: B787PfdHorizonDisplay.PITCH_LADDER_OPTIONS, pitchLadderClipBounds: B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS, horizonLineSupportHeadingLabels: true, horizonLineOptions: B787PfdHorizonDisplay.HORIZON_LINE_OPTIONS, tcasRaPitchCueOptions: B787PfdHorizonDisplay.TCAS_RA_PITCH_CUE_OPTIONS, tcasRaPitchCueConformalBounds: B787PfdHorizonDisplay.TCAS_RA_PITCH_CUE_CONFORMAL_BOUNDS, bankIndicatorOptions: B787PfdHorizonDisplay.BANK_INDICATOR_OPTIONS, fdConformalBounds: B787PfdHorizonDisplay.FD_CONFORMAL_BOUNDS, showFpv: this.showFpv, fpvConformalBounds: B787PfdHorizonDisplay.FPV_CONFORMAL_BOUNDS, showSelectedFpa: true, selectedFpaClipBounds: B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS, pitchLimitOptions: B787PfdHorizonDisplay.PITCH_LIMIT_OPTIONS, pitchLimitConformalBounds: B787PfdHorizonDisplay.PITCH_LIMIT_CONFORMAL_BOUNDS, showFdFailureFlagWhenAttFail: true }));
    }
    /** @inheritdoc */
    destroy() {
        var _a;
        (_a = this.ref.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isFpaModeActive.destroy();
        this.isFpvSelected.destroy();
        super.destroy();
    }
}
B787PfdHorizonDisplay.UPDATE_FREQ = 30;
B787PfdHorizonDisplay.PROJECTED_SIZE = Vec2Math.create(1279, 919);
B787PfdHorizonDisplay.PROJECTED_OFFSET = Vec2Math.create(0, 4);
B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS = VecNMath.create(4, 409, 272, 869, 702);
B787PfdHorizonDisplay.FOV = 20;
B787PfdHorizonDisplay.FOV_ENDPOINTS = VecNMath.create(4, 0.5 + B787PfdHorizonDisplay.PROJECTED_OFFSET[0] / B787PfdHorizonDisplay.PROJECTED_SIZE[0], 0.5 + B787PfdHorizonDisplay.PROJECTED_OFFSET[1] / B787PfdHorizonDisplay.PROJECTED_SIZE[1], 0.5 + B787PfdHorizonDisplay.PROJECTED_OFFSET[0] / B787PfdHorizonDisplay.PROJECTED_SIZE[0], B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1] / B787PfdHorizonDisplay.PROJECTED_SIZE[1]);
B787PfdHorizonDisplay.ARTIFICIAL_HORIZON_OPTIONS = {
    groundColor: '#aa6d2a',
    skyColor: '#006efb'
};
B787PfdHorizonDisplay.HORIZON_LINE_CONFORMAL_BOUNDS = VecNMath.create(4, 100, 100, 1179, 819);
B787PfdHorizonDisplay.PITCH_LADDER_OPTIONS = {
    majorLineIncrement: 10,
    mediumLineFactor: 2,
    minorLineFactor: 2,
    majorLineLength: 200,
    mediumLineLength: 100,
    minorLineLength: 50,
    majorLineShowLabel: true,
    labelMargin: 20,
    labelOffsetY: 2
};
B787PfdHorizonDisplay.HORIZON_LINE_OPTIONS = {
    length: 460,
    headingMajorTickLength: 10,
    headingMinorTickLength: 7,
    headingTickWidth: 3,
    headingLabelFont: 'B787',
    headingLabelFontSize: 22,
    headingLabelOffset: 6
};
// TODO: No idea whether this is correct due to lack of references.
B787PfdHorizonDisplay.TCAS_RA_PITCH_CUE_CONFORMAL_BOUNDS = VecNMath.create(4, -(B787PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[1] - B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]), -(B787PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[1] - B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]), (B787PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[1] - B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]), (B787PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[1] - B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1]));
B787PfdHorizonDisplay.TCAS_RA_PITCH_CUE_OPTIONS = {
    noflyCueHeight: 850,
    noflyCueClosedWidth: 76,
    noflyCueOpenWidth: 572,
    cueStrokeWidth: 5,
    cueOutlineWidth: 1
};
B787PfdHorizonDisplay.BANK_INDICATOR_OPTIONS = {
    radius: 231,
    majorTickLength: 38,
    mediumTickLength: 25,
    minorTickLength: 16,
    pointerSize: Vec2Math.create(38, 25),
    pointerOffset: 2,
    slipSkidIndicatorOffset: 0,
    slipSkidIndicatorHeight: 8
};
B787PfdHorizonDisplay.FD_CONFORMAL_BOUNDS = VecNMath.create(4, B787PfdHorizonDisplay.PROJECTED_SIZE[0] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[0] - 141, B787PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[1] - 141, B787PfdHorizonDisplay.PROJECTED_SIZE[0] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[0] + 141, B787PfdHorizonDisplay.PROJECTED_SIZE[1] / 2 + B787PfdHorizonDisplay.PROJECTED_OFFSET[1] + 141);
B787PfdHorizonDisplay.FPV_CONFORMAL_BOUNDS = VecNMath.create(4, B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[0] + 53, B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1] + 29, B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[2] - 53, B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[3] - 17);
B787PfdHorizonDisplay.PITCH_LIMIT_OPTIONS = {
    maxPitch: 30
};
B787PfdHorizonDisplay.PITCH_LIMIT_CONFORMAL_BOUNDS = Vec2Math.create(B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[1] + 22, B787PfdHorizonDisplay.PITCH_LADDER_BOUNDS[3] - 16);

/**
 * The UpperSectionContainer component.
 */
class UpperSectionContainer extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.adrsDataProvider = new DefaultB787AdrsDataProvider(this.props.bus);
        this.airspeedIndicatorDataProvider = new DefaultAirspeedIndicatorDataProvider(this.props.bus, 1, undefined, true);
        this.flapSpeedBugDataProvider = new B787FlapSpeedBugDataProvider(this.props.bus, this.props.speedProvider, 1);
        this.vnavSpeedBandDataProvider = new DefaultVNavSpeedBandDataProvider(this.props.bus);
        this.verticalSpeedDataProvider = new DefaultVerticalSpeedDataProvider(this.props.bus, 2, true);
        this.altimeterDataProvider = new DefaultAltimeterDataProvider(this.props.bus, this.props.performancePlan, 2, 21, true);
        this.baroDataProvider = new DefaultBaroDataProvider(this.props.bus, this.props.performancePlan, 1);
        this.markerBeaconDataProvider = new MarkerBeaconDataProvider(this.props.bus, 1);
        this.lateralDeviationDataProvider = new DefaultLateralDeviationDataProvider(this.props.bus, this.props.navIndicators.get('ils'), 1);
        this.verticalDeviationDataProvider = new DefaultVerticalDeviationDataProvider(this.props.bus, this.props.navIndicators.get('ils'), 1);
        this.approachReferenceDataProvider = new DefaultApproachReferenceDataProvider(this.props.bus, this.props.navIndicators.get('ils'));
        this.minimumsDataProvider = new B787MinimumsDataProvider(this.props.bus);
        this.flapRetractionDataProvider = new DefaultFlapRetractionDataProvider(this.props.bus);
        this.tcasRaCommandDataProvider = new DefaultTcasRaCommandDataProvider(this.props.bus, this.props.tcas);
        this.altitudeAlertController = new B787AltitudeAlertController(this.props.bus, this.props.performancePlan, this.altimeterDataProvider);
        this.altitudeAlerts = new AltitudeCrewAlerts(this.props.bus);
        this.isAttitudeDataValid = ConsumerSubject.create(this.props.bus.getSubscriber().on('irs_selector_attitude_data_valid_1'), false);
        this.isAirspeedDataVoted = this.adrsDataProvider.airspeedDataMode.map(mode => mode === B787AdrsAirspeedDataMode.Voted);
        this.showMetricAltitude = CockpitUserSettings.getManager(this.props.bus).getSetting('metricAltitudeDisplay');
        this.showBaroDisplay = MappedSubject.create(([altitudeMode, isDataFailed]) => altitudeMode === B787AdrsAltitudeDataMode.Voted && !isDataFailed, this.adrsDataProvider.altitudeDataMode, this.baroDataProvider.isDataFailed);
        this.useBaroHpa = ConsumerSubject.create(this.props.bus.getSubscriber().on('baro_ref_hpa_1'), false);
        this.isLocDeviationPointerFlashing = Subject.create(false);
        this.expandedLocDeviationScale = Subject.create(false);
        this.aoaSpdFlagHidden = this.adrsDataProvider.airspeedDataMode.map(mode => mode !== B787AdrsAirspeedDataMode.Aoa);
        this.isfdSpdFlagHidden = this.adrsDataProvider.airspeedDataMode.map(mode => mode !== B787AdrsAirspeedDataMode.Isfd);
        this.gpsAltFlagHidden = this.adrsDataProvider.altitudeDataMode.map(mode => mode !== B787AdrsAltitudeDataMode.Gps);
        this.isfdAltFlagHidden = this.adrsDataProvider.altitudeDataMode.map(mode => mode !== B787AdrsAltitudeDataMode.Isfd);
    }
    /** @inheritdoc */
    onAfterRender() {
        this.adrsDataProvider.init();
        this.airspeedIndicatorDataProvider.init();
        this.flapSpeedBugDataProvider.init();
        this.vnavSpeedBandDataProvider.init();
        this.verticalSpeedDataProvider.init();
        this.altimeterDataProvider.init();
        this.baroDataProvider.init();
        this.markerBeaconDataProvider.init();
        this.lateralDeviationDataProvider.init();
        this.verticalDeviationDataProvider.init();
        this.approachReferenceDataProvider.init();
        this.minimumsDataProvider.init();
        this.flapRetractionDataProvider.init();
        this.tcasRaCommandDataProvider.init();
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: { 'upper-section-container': true, 'upper-section-container-att-failed': this.isAttitudeDataValid.map(SubscribableMapFunctions.not()) } },
            FSComponent.buildComponent("div", { class: "horizon-container" },
                FSComponent.buildComponent(B787PfdHorizonDisplay, { bus: this.props.bus, aoaDataProvider: this.props.aoaDataProvider, tcasRaCommandDataProvider: this.tcasRaCommandDataProvider })),
            FSComponent.buildComponent("div", { class: "flight-instrument-box" },
                FSComponent.buildComponent(MarkerBeacon, { bus: this.props.bus, dataProvider: this.markerBeaconDataProvider }),
                FSComponent.buildComponent(PfdAirspeedIndicator, { show: this.adrsDataProvider.isAirspeedDataValid, dataProvider: this.airspeedIndicatorDataProvider, flapRetractionDataProvider: this.flapRetractionDataProvider, flapSpeedBugDataProvider: this.flapSpeedBugDataProvider, vnavSpeedBandDataProvider: this.vnavSpeedBandDataProvider, performancePlan: this.props.performancePlan, vSpeedSettings: VSpeedUserSettings.getManager(this.props.bus), showManeuverSpeedBands: this.isAirspeedDataVoted }),
                FSComponent.buildComponent(PfdAirspeedSelectBox, { dataProvider: this.airspeedIndicatorDataProvider }),
                FSComponent.buildComponent(PfdMachReadout, { airspeedIndicatorDataProvider: this.airspeedIndicatorDataProvider, showMach: this.isAirspeedDataVoted }),
                FSComponent.buildComponent(PfdVerticalSpeedIndicator, { show: this.adrsDataProvider.isAltitudeDataValid, dataProvider: this.verticalSpeedDataProvider }),
                FSComponent.buildComponent(PfdAltimeter, { show: this.adrsDataProvider.isAltitudeDataValid, dataProvider: this.altimeterDataProvider, minimumsDataProvider: this.minimumsDataProvider, showMetric: this.showMetricAltitude, isQfe: this.baroDataProvider.isQfe }),
                FSComponent.buildComponent(PfdAltimeterBaroDisplay, { show: this.showBaroDisplay, dataProvider: this.baroDataProvider, showMetric: this.useBaroHpa }),
                FSComponent.buildComponent(PfdAltPreselectBox, { dataProvider: this.altimeterDataProvider, showMetric: this.showMetricAltitude }),
                FSComponent.buildComponent(MinimumsIndicator, { bus: this.props.bus, show: Subject.create(true) }),
                FSComponent.buildComponent(RisingRunwayIndicator, { bus: this.props.bus, lateralDeviationDataProvider: this.lateralDeviationDataProvider, isLocPointerFlashing: this.isLocDeviationPointerFlashing, expandedLocScale: this.expandedLocDeviationScale }),
                FSComponent.buildComponent(RadioAltimeter, { bus: this.props.bus }),
                FSComponent.buildComponent(PfdLateralDeviationIndicator, { dataProvider: this.lateralDeviationDataProvider, isLocPointerFlashing: this.isLocDeviationPointerFlashing, expandedLocScale: this.expandedLocDeviationScale }),
                FSComponent.buildComponent(PfdVerticalDeviationIndicator, { dataProvider: this.verticalDeviationDataProvider }),
                FSComponent.buildComponent(PfdNavigationSourceDisplay, { lateralDeviationDataProvider: this.lateralDeviationDataProvider, verticalDeviationDataProvider: this.verticalDeviationDataProvider }),
                FSComponent.buildComponent(PfdApproachReference, { dataProvider: this.approachReferenceDataProvider }),
                FSComponent.buildComponent(PfdNoVSpdFlag, { bus: this.props.bus, isAirspeedDataFailed: this.airspeedIndicatorDataProvider.isAdcDataFailed }),
                this.renderFailureFlag('AOA SPD', this.aoaSpdFlagHidden, 'pfd-failure-flag-message pfd-aoa-spd-flag'),
                this.renderFailureFlag('ISFD SPD', this.isfdSpdFlagHidden, 'pfd-failure-flag-message pfd-isfd-spd-flag'),
                this.renderFailureFlag('GPS ALT', this.gpsAltFlagHidden, 'pfd-failure-flag-message pfd-gps-alt-flag'),
                this.renderFailureFlag('ISFD ALT', this.isfdAltFlagHidden, 'pfd-failure-flag-message pfd-isfd-alt-flag'),
                this.renderFailureFlag('S\nP\nD', this.adrsDataProvider.isAirspeedDataValid, 'pfd-failure-flag-boxed pfd-failure-flag-vert pfd-spd-flag'),
                this.renderFailureFlag('A\nL\nT', this.adrsDataProvider.isAltitudeDataValid, 'pfd-failure-flag-boxed pfd-failure-flag-vert pfd-alt-flag'),
                this.renderFailureFlag('V\nE\nR\nT', this.adrsDataProvider.isAltitudeDataValid, 'pfd-failure-flag-boxed pfd-failure-flag-vert pfd-vert-flag')),
            FSComponent.buildComponent("div", { class: "fma-box" },
                FSComponent.buildComponent(PfdFma, { bus: this.props.bus })),
            FSComponent.buildComponent("div", { class: "afds-status-box" },
                FSComponent.buildComponent(PfdAfdsStatus, { bus: this.props.bus }))));
    }
    /**
     * Renders a generic failure flag.
     * @param text The text of the flag.
     * @param hidden Whether to hide the flag.
     * @param cssClass CSS class(es) to apply to the flag's root element.
     * @returns The specified failure flag, as a VNode.
     */
    renderFailureFlag(text, hidden, cssClass) {
        const cssClassRecord = {
            'pfd-failure-flag': true,
            'hidden': hidden
        };
        if (cssClass) {
            FSComponent.addCssClassesToRecord(cssClassRecord, cssClass, false);
        }
        return (FSComponent.buildComponent("div", { class: cssClassRecord }, text));
    }
}

/**
 * Handles baro knob H events for a PFD to change the preselected baro setting for the PFD's altimeter.
 */
class PfdBaroHEventHandler {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param altimeterIndex The index of the sim altimeter controlled by this handler.
     */
    constructor(bus, altimeterIndex) {
        this.bus = bus;
        this.altimeterIndex = altimeterIndex;
        this.stdSimVar = `L:XMLVAR_Baro${this.altimeterIndex}_ForcedToSTD`;
        this.preslectSimVar = `L:XMLVAR_Baro${this.altimeterIndex}_SavedPressure`;
        this.isAlive = true;
        this.isInit = false;
    }
    /**
     * Initializes this handler. Once this handler is initialized, it will change the baro setting for this handler's
     * PFD's altimeter in response to baro knob input events.
     * @throws Error if this handler has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('BaroHEventHandler: cannot initialize a dead handler');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.hEventSub = this.bus.getSubscriber().on('hEvent').handle(hEvent => {
            switch (hEvent) {
                case 'AP_BARO_Up':
                    this.changeBaroPreselect(1);
                    break;
                case 'AP_BARO_Down':
                    this.changeBaroPreselect(-1);
                    break;
            }
        });
    }
    /**
     * Increments or decrements the preselected baro setting if STD mode is active.
     * @param direction The direction to change the preselected baro setting.
     */
    changeBaroPreselect(direction) {
        const isStd = SimVar.GetSimVarValue(this.stdSimVar, SimVarValueType.Bool) !== 0;
        if (isStd) {
            const currentVal = SimVar.GetSimVarValue(this.preslectSimVar, SimVarValueType.Number);
            const newVal = MathUtils.clamp(currentVal + PfdBaroHEventHandler.INCREMENT_RAW * direction, PfdBaroHEventHandler.MIN_RAW, PfdBaroHEventHandler.MAX_RAW);
            SimVar.SetSimVarValue(this.preslectSimVar, SimVarValueType.Number, newVal);
        }
    }
    /**
     * Destroys this handler.
     */
    destroy() {
        var _a;
        this.isAlive = false;
        (_a = this.hEventSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}
PfdBaroHEventHandler.INCREMENT_RAW = 5;
PfdBaroHEventHandler.MIN_RAW = 15169;
PfdBaroHEventHandler.MAX_RAW = 17344;

/**
 * A Boeing 787-10 PFD instrument.
 * Primary Flight Display showing the the basic flight instruments.
 */
class WTB78xPfdInstrument extends WTB78xFsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        super(instrument, config);
        this.minimumsStateController = new B787MinimumsStateController(this.bus);
        this.minimumsManager = new MinimumsManager(this.bus);
        this.minimumsPublisher = new MinimumsSimVarPublisher(this.bus);
        this.minimumsAlertController = new MinimumsAlertController(this.bus);
        this.baroHEventHandler = new PfdBaroHEventHandler(this.bus, 1);
        /** @inheritdoc */
        this.iauIndex = this.instrument.instrumentIndex;
        // TODO: Support switching between IAU and ADC indices with a switch.
        this.iauAdcIndex = this.instrument.instrumentIndex;
        // FIXME: Provide appropriate way to source AOA Index used for DefaultAoaProvider.
        this.aoaIndex = 1;
        this.createSystems();
        // initialize onInGame callback
        const instrSub = this.bus.getSubscriber();
        const onInGameSub = instrSub.on('vc_game_state').whenChanged().handle(state => {
            if (state === GameState.ingame) {
                this.onInGame();
                onInGameSub.destroy();
            }
        }, true);
        onInGameSub.resume(true);
        this.backplane.addPublisher(InstrumentBackplaneNames.Minimums, this.minimumsPublisher);
        this.controlSurfacesPublisher = new ControlSurfacesPublisher(this.bus, 3);
        this.backplane.addPublisher(InstrumentBackplaneNames.ControlSurfaces, this.controlSurfacesPublisher);
        this.speedLimitPublisher = new SpeedLimitPublisher(this.bus, this.speedData, 1, 1);
        this.backplane.addPublisher(InstrumentBackplaneNames.SpeedLimit, this.speedLimitPublisher);
        this.efisEventPublisher = new EfisEventPublisher(this.bus, false, 1);
        this.navSources = new NavSources(new NavRadioNavSource(this.bus, 'NAV1', 1), new NavRadioNavSource(this.bus, 'NAV2', 2), new AdfRadioSource(this.bus, 'ADF1', 1), new AdfRadioSource(this.bus, 'ADF2', 2), new NavRadioNavSource(this.bus, 'ILS1', 3));
        this.backplane.addInstrument('navSources', this.navSources);
        this.flightTimerInstrument = new FlightTimerInstrument(this.bus, 2);
        this.backplane.addInstrument('flightTimer', this.flightTimerInstrument);
        this.navIndicators = new NavIndicators(new Map([
            ['adfLeft', new NavIndicator(this.navSources, 'ADF1')],
            ['adfRight', new NavIndicator(this.navSources, 'ADF2')],
            ['vorLeft', new NavIndicator(this.navSources, 'NAV1')],
            ['vorRight', new NavIndicator(this.navSources, 'NAV2')],
            ['ils', new NavIndicator(this.navSources, 'ILS1')],
        ]));
        this.backplane.addInstrument('navIndicators', this.navIndicators);
        this.doInit();
        this.xmlLogicHost = new CompositeLogicXMLHost(true);
        this.auralsConfig = new B78XmlAuralsConfig(this.instrument, this.xmlLogicHost, this.bus);
        this.aoaDataProvider = new DefaultAoaDataProvider(this.bus, this.aoaIndex, this.iauAdcIndex);
        this.aoaDataProvider.init();
        // TODO: Maybe move this into a dedicated controller so it doesn't get lost.
        this.bus.getSubscriber().on('speedlimit_max_ias').withPrecision(1).handle(ias => {
            SimVar.SetGameVarValue('AIRCRAFT_MAXSPEED_OVERRIDE', SimVarValueType.Knots, ias - 5); // offset by 5kts to even out MSFS buffer (5kts)
        });
        FSComponent.render(FSComponent.buildComponent(UpperSectionContainer, { bus: this.bus, performancePlan: this.activeRoutePerformancePlan, navIndicators: this.navIndicators, speedProvider: this.speedData, aoaDataProvider: this.aoaDataProvider, tcas: this.tcas }), document.getElementById('UpperSection'));
        FSComponent.render(FSComponent.buildComponent(LowerSectionContainer, { bus: this.bus, pfdIndex: this.iauIndex, facLoader: this.facLoader, tcas: this.tcas, activeRoutePredictor: this.activeRoutePredictor, flightPlanner: this.flightPlanner, navIndicators: this.navIndicators, perfPlanRepository: this.perfPlanRepository }), document.getElementById('LowerSection'));
        FSComponent.render(FSComponent.buildComponent(LeftSectionContainer, { bus: this.bus }), document.getElementById('LeftSection'));
    }
    /** @inheritdoc */
    getSourceSelectSide() {
        return this.instrument.instrumentIndex === 2 ? 'right' : 'left';
    }
    /**
     * Performs initialization tasks.
     */
    async doInit() {
        this.backplane.init();
        this.baroHEventHandler.init();
        // TODO: Find a better place to stick this logic.
        const metricDisplay = CockpitUserSettings.getManager(this.bus).getSetting('metricAltitudeDisplay');
        this.bus.getSubscriber().on('EFIS.MTRS').handle(() => {
            metricDisplay.set(!metricDisplay.value);
        });
        // Make sure to init plan and await it before rendering anything, to avoid plan doesn't exist errors
        await this.initFlightPlan();
        FSComponent.render(this.renderComponents(), document.getElementById('Electricity'));
        this.tryRunOnFlightStart();
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        if (!this.efisEventPublisher.handleHEvent(args[0])) {
            super.onInteractionEvent(args);
        }
    }
    /**
     * Callback for when the game state transitions to either briefing or in-game.
     * This can be used as a "last chance" hook to initialize things that need to wait
     * until a plane has loaded and everything is in a stable state.
     */
    onInGame() {
        this.xmlLogicHost.setIsPaused(false);
    }
    /**
     * Renders this instrument's components.
     * @returns This instrument's rendered components, as a VNode.
     */
    renderComponents() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.instrument.instrumentIndex === 1;
        return (FSComponent.buildComponent(FSComponent.Fragment, null,
            FSComponent.buildComponent(PfdReferenceOverlay, null)));
    }
    /** Makes sure that we have the flight plan, requesting sync if needed. */
    async initFlightPlan() {
        // Wait for MFD 3 to init the plan
        await Wait.awaitDelay(2000);
        // Request sync from MFD 3
        this.flightPlanner.requestSync();
        // Wait for sync
        await Wait.awaitDelay(500);
    }
    /** @inheritdoc */
    Update() {
        super.Update();
        this.xmlLogicHost.update(this.instrument.deltaTime);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A Boeing 787-10 PFD BaseInstrument.
 */
class WTB78x_PFD extends FsBaseInstrument {
    /** @inheritdoc */
    get isInteractive() {
        return true; // Enabling touch for all instruments for development.
    }
    /** @inheritdoc */
    constructInstrument() {
        return new WTB78xPfdInstrument(this, new AvionicsConfig(this, this.xmlConfig));
    }
    /** @inheritdoc */
    get templateID() {
        return 'WTB78x_PFD';
    }
    /** @inheritdoc */
    onPowerOn() {
        super.onPowerOn();
        this.fsInstrument.onPowerOn();
    }
    /** @inheritdoc */
    onShutDown() {
        super.onShutDown();
        this.fsInstrument.onPowerOff();
    }
}
registerInstrument('wtb78x-pfd', WTB78x_PFD);
